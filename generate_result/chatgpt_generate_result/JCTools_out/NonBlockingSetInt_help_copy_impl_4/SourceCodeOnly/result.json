{
    "project_name": "JCTools",
    "file_name": "NonBlockingSetInt.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
    "execute_path": "JCTools",
    "package": "org.jctools.maps",
    "docstring": null,
    "source_code": "// Help copy this one word.  State Machine.\n// (1) If not \"made immutable\" in the old array, set the sign bit to make\n//     it immutable.\n// (2) If non-zero in old array & zero in new, CAS new from 0 to copy-of-old\n// (3) If non-zero in old array & non-zero in new, CAS old to zero\n// (4) Zero in old, new is valid\n// At this point, old should be immutable-zero & new has a copy of bits\nprivate NBSI help_copy_impl( int i ) {\n  // Handle every 64th bit via using a nested array\n  NBSI old = this;          // The bit array being copied from\n  NBSI nnn = _new;          // The bit array being copied to\n  if( nnn == null ) return this; // Promoted already\n  int j = i;                // The bit index being added\n  while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n    old = old._nbsi64;      // Recurse\n    nnn = nnn._nbsi64;      // Recurse\n    j = j>>6;               // Strip off low 6 bits (all set)\n  }\n\n  // Transit from state 1: word is not immutable yet\n  // Immutable is in bit 63, the sign bit.\n  long bits = old._bits[j>>6];\n  while( bits >= 0 ) {      // Still in state (1)?\n    long oldbits = bits;\n    bits |= mask(63);       // Target state of bits: sign-bit means immutable\n    if( old.CAS( j>>6, oldbits, bits ) ) {\n      if( oldbits == 0 ) _copyDone.addAndGet(1);\n      break;                // Success - old array word is now immutable\n    }\n    bits = old._bits[j>>6]; // Retry if CAS failed\n  }\n\n  // Transit from state 2: non-zero in old and zero in new\n  if( bits != mask(63) ) {  // Non-zero in old?\n    long new_bits = nnn._bits[j>>6];\n    if( new_bits == 0 ) {   // New array is still zero\n      new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n      // One-shot CAS attempt, no loop, from 0 to non-zero.\n      // If it fails, somebody else did the copy for us\n      if( !nnn.CAS( j>>6, 0, new_bits ) )\n        new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n      assert new_bits != 0;\n    }\n\n    // Transit from state 3: non-zero in old and non-zero in new\n    // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n    if( old.CAS( j>>6, bits, mask(63) ) )\n      _copyDone.addAndGet(1); // One more word finished copying\n  }\n\n  // Now in state 4: zero (and immutable) in old\n\n  // Return the self bitvector for 'fluid' programming style\n  return this;\n}\n",
    "class_name": "NonBlockingSetInt",
    "method_name": "help_copy_impl",
    "arguments": [
        "int i"
    ],
    "generate_test": [
        "@Test\npublic void help_copy_implTest() {\n    // Setup\n    NonBlockingSetIntTest testObj = new NonBlockingSetIntTest();\n    // Write other setup and assertions\n    // ...\n    // Execution\n    NBSI result = testObj.help_copy_impl(3);\n    // Assertions\n    // ...\n    // Completion\n    // Output the whole test case\n    assert(result != null);\n}",
        "@Test\npublic void help_copy_implTest() {\n    // Create the NBSI objects old and nnn\n    NBSI old = new NBSI();\n    NBSI nnn = new NBSI();\n    \n    // Perform the help_copy_impl method\n    NBSI result = help_copy_impl(5);\n    \n    // Assert that the result is not null\n    assertNotNull(result);\n}",
        "@Test\npublic void help_copy_implTest() {\n    NonBlockingSetIntTest nbsi = new NonBlockingSetIntTest();\n    // Add test cases for help_copy_impl method\n    // assert statements for different scenarios\n    // test for state 1\n    // test for state 2\n    // test for state 3\n    // test for state 4\n}",
        "@Test\npublic void help_copy_implTest() {\n    // Create and initialize the object \n    NBSI nbsi = new NBSI();\n    // Perform the help_copy_impl method\n    NBSI result = nbsi.help_copy_impl(0);\n    // Assert the result\n    assertNotNull(result);\n}",
        "@Test\npublic void help_copy_implTest() {\n  // Add test cases here\n  // Make assertions using assertEquals or assertTrue\n  // Example:\n  // assertEquals(expectedValue, actualValue);\n}",
        "    NonBlockingSetIntTest test = new NonBlockingSetIntTest();\n    // Write your individual test cases for help_copy_impl method\n    test.help_copy_implTest();",
        "@Test\npublic void help_copy_implTest() {\n    // Initialize NBSI objects\n    NBSI old = new NBSI();\n    NBSI nnn = new NBSI();\n    \n    // Set up the test case\n    \n    // Test state 1: word is not immutable yet\n    long bits = old._bits[0];\n    while( bits >= 0 ) {\n        long oldbits = bits;\n        bits |= mask(63);\n        if( old.CAS( 0, oldbits, bits ) ) {\n            if( oldbits == 0 ) _copyDone.addAndGet(1);\n            break;\n        }\n        bits = old._bits[0];\n    }\n    \n    // Test state 2: non-zero in old and zero in new\n    if( bits != mask(63) ) {\n        long new_bits = nnn._bits[0];\n        if( new_bits == 0 ) {\n            new_bits = bits & ~mask(63);\n            if( !nnn.CAS( 0, 0, new_bits ) )\n                new_bits = nnn._bits[0];\n            assert new_bits != 0;\n        }\n        \n        // Transit from state 3: non-zero in old and non-zero in new\n        if( old.CAS( 0, bits, mask(63) ) )\n            _copyDone.addAndGet(1);\n    }\n}",
        "@Test\npublic void help_copy_implTest() {\n    // Creating a new instance of NBSI\n    NBSI nbsi = new NBSI();\n    // Running the help_copy_impl method and asserting the returned value is not null\n    assertNotNull(nbsi.help_copy_impl(3));\n}",
        "@Test\npublic void help_copy_implTest() {\n    NBSI old = new NBSI();\n    NBSI nnn = new NBSI();\n    assertEquals(old, old.help_copy_impl(0));\n    assertEquals(old, nnn.help_copy_impl(1));\n}",
        "@Test\npublic void help_copy_implTest() {\n    // Write the test case for help_copy_impl method here\n    // Use assertions to verify the expected behavior of the method\n    // Ensure to cover different scenarios and edge cases\n}"
    ]
}