{
    "project_name": "Java",
    "file_name": "MColoring.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": null,
    "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
    "class_name": "MColoring",
    "method_name": "possiblePaint",
    "arguments": [
        "ArrayList<Node> nodes",
        "int n",
        "int m"
    ],
    "generate_test": [
        "Node node1 = new Node(1);\nNode node2 = new Node(2);\nNode node3 = new Node(3);\nnode1.addEdge(2);\nnode1.addEdge(3);\nnode2.addEdge(1);\nnode3.addEdge(1);\nArrayList<Node> nodes = new ArrayList<>();\nnodes.add(node1);\nnodes.add(node2);\nnodes.add(node3);\nint n = 3;\nint m = 2;\nint expectedResult = 1;\nint result = possiblePaint(nodes, n, m);\nassertEquals(expectedResult, result);",
        "\n@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<Node>();\n    nodes.add(new Node(1, 1, new ArrayList<Integer>(Arrays.asList(2))));\n    nodes.add(new Node(2, 1, new ArrayList<Integer>(Arrays.asList(1, 3))));\n    nodes.add(new Node(3, 1, new ArrayList<Integer>(Arrays.asList(2))));\n    int n = 3;\n    int m = 2;\n    int result = Main.possiblePaint(nodes, n, m);\n    assertEquals(1, result);\n}\n",
        "@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    Node node1 = new Node(1, new ArrayList<>(Arrays.asList(2, 3)), 1);\n    Node node2 = new Node(2, new ArrayList<>(Arrays.asList(1, 3)), 1);\n    Node node3 = new Node(3, new ArrayList<>(Arrays.asList(1, 2)), 2);\n    nodes.add(node1);\n    nodes.add(node2);\n    nodes.add(node3);\n    int n = 3;\n    int m = 2;\n    \n    int actual = possiblePaint(nodes, n, m);\n    assertEquals(1, actual);\n}",
        "@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<Node>();\n    // Add nodes and edges here\n    int n = 5;\n    int m = 3;\n    int expected = 1;\n    int actual = Node.possiblePaint(nodes, n, m);\n    assertEquals(expected, actual);\n}",
        "@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    Node node1 = new Node(1, 1, new ArrayList<>(Arrays.asList(2)));\n    Node node2 = new Node(2, 1, new ArrayList<>(Arrays.asList(1)));\n    nodes.add(node1);\n    nodes.add(node2);\n    \n    int n = 2;\n    int m = 2;\n    \n    int result = Node.possiblePaint(nodes, n, m);\n    \n    assertEquals(1, result);\n}",
        "int result = Node.possiblePaint(nodes, n, m);\nassertEquals(1, result);",
        "int result = possiblePaint(nodes, 5, 3);\nassertEquals(1, result);",
        "@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    Node node1 = new Node();\n    Node node2 = new Node();\n    // Add edges to nodes\n    ArrayList<Integer> edges1 = new ArrayList<>();\n    edges1.add(2);\n    ArrayList<Integer> edges2 = new ArrayList<>();\n    edges2.add(1);\n    node1.setEdges(edges1);\n    node2.setEdges(edges2);\n    // Set initial color to both nodes\n    node1.setColor(1);\n    node2.setColor(1);\n    // Add nodes to the arraylist\n    nodes.add(node1);\n    nodes.add(node2);\n    int n = 2;\n    int m = 2;\n    assertEquals(1, possiblePaint(nodes, n, m));\n}\n",
        "@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    int n = 5;\n    int m = 3;\n    assertEquals(1, possiblePaint(nodes, n, m));\n}",
        "public void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    Node node1 = new Node(1, 1, new ArrayList<>(Arrays.asList(2, 3)));\n    Node node2 = new Node(2, 1, new ArrayList<>(Arrays.asList(1, 3)));\n    Node node3 = new Node(3, 1, new ArrayList<>(Arrays.asList(1, 2)));\n    nodes.add(node1);\n    nodes.add(node2);\n    nodes.add(node3);\n    int output = Node.possiblePaint(nodes, 3, 2);\n    assertEquals(1, output);\n}"
    ]
}