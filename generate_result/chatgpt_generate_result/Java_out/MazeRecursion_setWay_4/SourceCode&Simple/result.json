{
    "project_name": "Java",
    "file_name": "MazeRecursion.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
    "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
    "class_name": "MazeRecursion",
    "method_name": "setWay",
    "arguments": [
        "int[][] map",
        "int i",
        "int j"
    ],
    "generate_test": [
        "@Test\npublic void setWayTest() {\n    int[][] map = {{1, 1, 1, 1, 1, 1, 1},\n                   {1, 0, 0, 0, 0, 0, 1},\n                   {1, 0, 0, 0, 0, 0, 1},\n                   {1, 1, 1, 1, 1, 1, 1}};\n\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n}",
        "@Test\npublic void setWayTest() {\n    int[][] maze = {{1, 1, 1, 1, 1, 1, 1},\n                    {1, 0, 0, 0, 0, 0, 1},\n                    {1, 1, 1, 0, 1, 1, 1},\n                    {1, 0, 0, 0, 0, 0, 1},\n                    {1, 1, 1, 1, 1, 1, 1}};\n    \n    assertTrue(MazeRecursion.setWay(maze, 1, 1));\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = {\n        {1, 1, 1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0, 0, 1},\n        {1, 0, 1, 0, 1, 0, 1, 1},\n        {1, 1, 0, 0, 1, 1, 0, 1},\n        {1, 1, 1, 0, 1, 1, 0, 1},\n        {1, 1, 1, 0, 0, 0, 0, 1},\n        {1, 1, 1, 1, 1, 1, 1, 1}\n    };\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n}\n",
        "@Test\npublic void setWayTest() {\n    int[][] map = {{1,1,1,1,1,1,1},\n                   {1,0,0,0,0,0,1},\n                   {1,0,0,0,0,0,1},\n                   {1,1,1,1,1,1,1}};\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = {\n        {1, 1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0, 1},\n        {1, 1, 1, 1, 1, 0, 1},\n        {1, 0, 0, 0, 1, 0, 1},\n        {1, 0, 1, 0, 0, 0, 1},\n        {1, 0, 0, 0, 1, 0, 1},\n        {1, 1, 1, 1, 1, 1, 1}\n    };\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = {{1, 1, 1, 1, 1, 1, 1},\n                   {1, 0, 0, 0, 0, 0, 1},\n                   {1, 1, 1, 1, 1, 0, 1},\n                   {1, 0, 0, 0, 0, 0, 1},\n                   {1, 1, 1, 1, 1, 1, 1}};\n\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n    // Add your assertion for the expected output after calling setWay method\n}\n",
        "@Test\npublic void setWayTest() {\n    int[][] map = {\n        {1, 1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 1, 0, 1},\n        {1, 1, 1, 0, 1, 0, 1},\n        {1, 0, 0, 0, 0, 1, 1},\n        {1, 1, 1, 1, 1, 1, 1}\n    };\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = {\n        {1, 1, 1, 1, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0, 1},\n        {1, 1, 1, 0, 1, 1, 1},\n        {1, 1, 1, 0, 1, 1, 1},\n        {1, 0, 0, 0, 0, 0, 1},\n        {1, 1, 1, 1, 1, 0, 1},\n        {1, 1, 1, 1, 1, 0, 1}\n    };\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = {\n        {1, 1, 1, 1, 1, 1, 1, 1},\n        {1, 0, 1, 0, 0, 0, 0, 1},\n        {1, 0, 1, 1, 1, 1, 0, 1},\n        {1, 0, 0, 0, 0, 1, 0, 1},\n        {1, 1, 1, 1, 0, 1, 1, 1},\n        {1, 1, 0, 0, 0, 0, 0, 1},\n        {1, 1, 1, 1, 1, 1, 1, 1}\n    };\n    assertTrue(MazeRecursion.setWay(map, 1, 1)); // Assuming start point is (1, 1)\n}",
        "@Test\npublic void setWayTest() {\n    int[][] map = {{1, 1, 1, 1, 1, 1, 1},\n                   {1, 0, 0, 0, 0, 0, 1},\n                   {1, 0, 0, 0, 0, 0, 0},\n                   {1, 1, 1, 1, 1, 1, 1}};\n    assertTrue(MazeRecursion.setWay(map, 1, 1));\n}"
    ]
}