{
    "project_name": "zxing",
    "file_name": "Decoder.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.decoder",
    "docstring": "/**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */",
    "source_code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
    "class_name": "Decoder",
    "method_name": "getEncodedData",
    "arguments": [
        "boolean[] correctedBits"
    ],
    "generate_test": [
        "@Test\npublic void getEncodedDataTest() throws FormatException {\n    boolean[] exampleBits = {true, false, true, false, true, false, false, true};\n    String result = getEncodedData(exampleBits);\n    assertEquals(\"ExpectedEncodedString\", result);\n}",
        "@Test\npublic void getEncodedDataTest() {\n  boolean[] correctedBits = new boolean[] {true, false, true, true, false, true, false, false};\n  try {\n    String result = getEncodedData(correctedBits);\n    assertEquals(\"ExpectedResult\", result);\n  } catch (FormatException e) {\n    fail(\"Format Exception occurred\");\n  }\n}",
        "@Test\npublic void getEncodedDataTest() {\n    boolean[] correctedBits = {true, false, true, false, true, false, true, false, true, false};\n    assertEquals(\"HELLO\", getEncodedData(correctedBits));\n}",
        "@Test\npublic void getEncodedDataTest() {\n    boolean[] correctedBits = {true, false, true, false, true, false, true, true, false, true};\n    try {\n        String output = Decoder.getEncodedData(correctedBits);\n        assertEquals(\"ExpectedOutput\", output);\n    } catch (FormatException e) {\n        fail(\"Format exception thrown\");\n    }\n}",
        "@Test\npublic void getEncodedDataTest() {\n    boolean[] correctedBits = {true, false, true, false, true, false, true, false};  // replace with actual correctedBits array\n    try {\n        String result = Decoder.getEncodedData(correctedBits);\n        assertEquals(\"ExpectedResultStringHere\", result);\n    } catch (FormatException e) {\n        fail(\"Unexpected FormatException\");\n    }\n}",
        "@Test\npublic void getEncodedDataTest() {\n    boolean[] testCorrectedBits = new boolean[10];\n    try {\n       String result = getEncodedData(testCorrectedBits);\n       assertEquals(\"ExpectedResult\", result);\n    } catch (FormatException fe) {\n       fail(\"FormatException thrown\");\n    }\n}",
        "@Test\npublic void getEncodedDataTest() {\n    boolean[] correctedBits = {true, false, true, false, true, false, true, false};\n    String expected = \"SUTD\";\n    String actual = getEncodedData(correctedBits);\n    assertEquals(expected, actual);\n}",
        "\n@Test\npublic void getEncodedDataTest() {\n    boolean[] testBits = {false, true, true, false, true, false, false};\n    String expectedOutput = \"<expectedOutput>\";\n    String actualOutput = getEncodedData(testBits);\n    assertEquals(expectedOutput, actualOutput);\n}",
        "@Test\npublic void getEncodedDataTest() {\n  boolean[] correctedBits = {true, false, true, true, false};\n  String result = getEncodedData(correctedBits);\n  assertEquals(\"ExpectedResult\", result);\n}",
        "@Test\npublic void getEncodedDataTest() {\n    boolean[] correctedBits = new boolean[10];\n    try {\n        String result = Decoder.getEncodedData(correctedBits);\n        assertNotNull(result);\n    } catch (FormatException e) {\n        fail(\"Error in getting encoded data: \" + e.getMessage());\n    }\n}"
    ]
}