{
    "project_name": "JCTools",
    "file_name": "BaseLinkedQueue.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/queues/BaseLinkedQueue.java",
    "execute_path": "JCTools",
    "package": "org.jctools.queues",
    "docstring": "/**\n     * {@inheritDoc} <br>\n     * <p>\n     * IMPLEMENTATION NOTES:<br>\n     * This is an O(n) operation as we run through all the nodes and count them.<br>\n     * The accuracy of the value returned by this method is subject to races with producer/consumer threads. In\n     * particular when racing with the consumer thread this method may under estimate the size.<br>\n     *\n     * @see java.util.Queue#size()\n     */",
    "source_code": "\n@Override\npublic final int size()\n{\n    // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n    // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n    LinkedQueueNode<E> chaserNode = lvConsumerNode();\n    LinkedQueueNode<E> producerNode = lvProducerNode();\n    int size = 0;\n    // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n    while (chaserNode != producerNode && // don't go passed producer node\n        chaserNode != null && // stop at last node\n        size < Integer.MAX_VALUE) // stop at max int\n    {\n        LinkedQueueNode<E> next;\n        next = chaserNode.lvNext();\n        // check if this node has been consumed, if so return what we have\n        if (next == chaserNode)\n        {\n            return size;\n        }\n        chaserNode = next;\n        size++;\n    }\n    return size;\n}\n",
    "class_name": "BaseLinkedQueuePad0",
    "method_name": "size",
    "arguments": [],
    "generate_test": [
        "package org.jctools.queues;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.*;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.stream.IntStream;\n\n/**\n * @author Tolstopyatov Vsevolod\n */\npublic class BaseLinkedQueuePad0Test {\n    private static final int TEST_SIZE = 1024; // must be even number\n    private BlockingQueue<Integer> queue;\n\n    @BeforeEach\n    public void setup() {\n        queue = new LinkedBlockingDeque<>();\n    }\n\n    @Test\n    public void sizeTest() {\n        assertEquals(0, queue.size());\n\n        for (int i = 0; i < TEST_SIZE; i++) {\n            assertEquals(i, queue.size());\n            queue.add(i);\n        }\n\n        assertEquals(TEST_SIZE, queue.size());\n    }\n\n    @Test\n    public void drainToArrayTest() {\n        // given\n        int expectedSize = TEST_SIZE;\n        IntStream intStream = IntStream.rangeClosed(0, expectedSize);\n\n        // when\n        List<Integer> list = queue.addAll(intStream.iterator());\n\n        // then\n        assertEquals(expectedSize, list.size());\n    }\n}",
        "package org.jctools.queues;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseLinkedQueuePad0Test {\n    private final int SIZE = 1024;\n    private final int ITERATIONS = 1_000_000;\n\n    @Test\n    public void sizeTest() {\n        MpscUnboundedXaddQueue queue = new MpscUnboundedXaddQueue(SIZE);\n        for (int i = 0; i < ITERATIONS; i++) {\n            assertEquals(i, queue.size());\n            queue.offer(i); }\n    }\n}",
        "package org.jctools.queues;\n\nimport java.util.Queue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.IntStream;\n\nimport org.junit.jupiter.api.Test;\n\nclass BaseLinkedQueuePad0Test {\n    @Test\n    void sizeTest() {\n        BaseLinkedQueue q = new BaseLinkedQueue(16);\n        assertEquals(q.size(), 16);\n    }\n}\n",
        "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseLinkedQueuePad0Test {\n    private final BaseLinkedQueue<String> queue = new BaseLinkedQueue<>(\"test-queue\");\n\n    @Test\n    public void sizeTest() {\n        assertEquals(0, queue.size());\n        String item1 = \"item1\";\n        queue.add(item1);\n        assertEquals(1, queue.size());\n        String item2 = \"item2\";\n        queue.add(item2);\n        assertEquals(2, queue.size());\n    }\n}",
        "package org.jctools.queues;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    public void sizeTest() {\n        final int SIZE = 64;\n        for (int i = 1; i <= SIZE; i++) {\n            Mpsc01Test(SIZE);\n            <FILL>\n        }\n        System.out.println(\"passed\");\n    }\n}",
        "package org.jctools.queues;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    public void sizeTest() {\n        assertEquals(0, <FILL>);\n    }\n}",
        "import org.junit.jupiter.api.Test;\n\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    public void sizeTest() {\n        // Initially empty queue\n        LinkedQueue<Integer> queue = new LinkedQueuePad0();\n        assertEquals(0, queue.size());\n        assertTrue(queue.isEmpty());\n        assertFalse(queue.isFull());\n\n        // Add an element and check size again\n        queue.offer(1);\n        assertEquals(1, queue.size());\n        assertFalse(queue.isEmpty());\n        assertFalse(queue.isFull());\n\n        // Add a bunch more elements and check size\n        for (int i = 2; i < 4; ++i) {\n            queue.offer(i);\n        }\n        assertEquals(1 + 3, queue.size());\n        assertFalse(queue.isEmpty());\n        assertFalse(queue.isFull());\n\n        // Check size when the queue is full (i.e., size() == capacity())\n        for (int i = 5; i < 6; ++i) {\n            queue.offer(i);\n        }\n        assertEquals(1 + 3, queue.size());\n        assertFalse(queue.isEmpty());\n        assertTrue(queue.isFull());\n    }\n}",
        "package org.jctools.queues;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    public void sizeTest() {\n        MpscGrowableAtomicArrayQueue<Integer> queue = new MpscGrowableAtomicArrayQueue<Integer>(16);\n        final int expectedCapacity = 16;\n        assertEquals(expectedCapacity, queue.capacity());\n    }\n}\n    \n### Response:",
        "package org.jctools.queues;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseLinkedQueuePad0Test {\n    private final MpscArrayQueue<Integer> queue = new MpscArrayQueue<>(16);\n\n    @Test\n    public void sizeTest() {\n       \t\t\t\tint capacity() throws Exception {\n            assertEquals(0, queue.size());\n\n            queue = new MpscArrayQueue<>(16);\n            final int iterations = 10_000;\n            for (int i = 0; i < iterations; i++) {\n                queue.addLast(i);\n            }\n\n            assertEquals(iterations, queue.size());\n        }\n    }\n}\n    \n### Response:",
        "package org.jctools.queues;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Unit tests for {@link BaseLinkedQueuePad0}.\n */\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    /**\n     * Tests size calculation method.\n     */\n    public void testSize() {\n        final int SIZE = 16;\n        final BaseLinkedQueue<Object> queue = new ArrayQueue<>(SIZE);\n        assertEquals(queue.capacity(), SIZE, \"The size of the queue is incorrect.\");\n    }\n}"
    ]
}