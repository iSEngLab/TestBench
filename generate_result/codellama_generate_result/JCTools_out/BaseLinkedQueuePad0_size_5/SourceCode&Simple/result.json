{
    "project_name": "JCTools",
    "file_name": "BaseLinkedQueue.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/queues/BaseLinkedQueue.java",
    "execute_path": "JCTools",
    "package": "org.jctools.queues",
    "docstring": "/**\n     * {@inheritDoc} <br>\n     * <p>\n     * IMPLEMENTATION NOTES:<br>\n     * This is an O(n) operation as we run through all the nodes and count them.<br>\n     * The accuracy of the value returned by this method is subject to races with producer/consumer threads. In\n     * particular when racing with the consumer thread this method may under estimate the size.<br>\n     *\n     * @see java.util.Queue#size()\n     */",
    "source_code": "\n@Override\npublic final int size()\n{\n    // Read consumer first, this is important because if the producer is node is 'older' than the consumer\n    // the consumer may overtake it (consume past it) invalidating the 'snapshot' notion of size.\n    LinkedQueueNode<E> chaserNode = lvConsumerNode();\n    LinkedQueueNode<E> producerNode = lvProducerNode();\n    int size = 0;\n    // must chase the nodes all the way to the producer node, but there's no need to count beyond expected head.\n    while (chaserNode != producerNode && // don't go passed producer node\n        chaserNode != null && // stop at last node\n        size < Integer.MAX_VALUE) // stop at max int\n    {\n        LinkedQueueNode<E> next;\n        next = chaserNode.lvNext();\n        // check if this node has been consumed, if so return what we have\n        if (next == chaserNode)\n        {\n            return size;\n        }\n        chaserNode = next;\n        size++;\n    }\n    return size;\n}\n",
    "class_name": "BaseLinkedQueuePad0",
    "method_name": "size",
    "arguments": [],
    "generate_test": [
        "public int size() {\n    LinkedQueueNode<E> curr = head;\n    int count = 0;\n    \n    while (curr != null) {\n        ++count;\n        curr = curr.getNext();\n    }\n    \n    return count;\n}",
        "\n@Test\npublic void sizeTest() {\n    <FILL>\n}\n\n### Response:",
        "package org.jctools.queues;\n\nimport java.util.Iterator;\n\nabstract class BaseLinkedQueuePad0<E> extends BaseLinkedQueueConsumerNodeRef<E> {\n    long p0, p1, p2, p3, p4, p5, p6, p7;\n    long p10, p11, p12, p13, p14, p15, p16;\n}\n\nabstract class BaseLinkedQueuePad1<E> extends BaseLinkedQueuePad0<E> {\n    public String toString();\n    protected final void checkAndSignalNext(LinkedQueueNode<E> currConsumerNode);\n}\n\nabstract class BaseLinkedQueuePad2<E> extends BaseLinkedQueuePad1<E> {\n    byte b000, b001, b002, b003, b004, b005, b006, b007;\n    byte b010, b011, b012, b013, b014, b015, b016, b017;\n    byte b020, b021, b022, b023, b024, b025, b026, b027;\n    byte b030, b031, b032, b033, b034, b035, b036, b037;\n    byte b040, b041, b042, b043, b044, b045, b046, b047;\n    byte b050, b051, b052, b053, b054, b055, b056, b057;\n    byte b060, b061, b062, b063, b064, b065, b066, b067;\n    byte b070, b071, b072, b073, b074, b075, b076, b077;\n    byte b100, b101, b102, b103, b104, b105, b106, b107;\n    byte b110, b111, b112, b113, b114, b115, b116, b117;\n    byte b120, b121, b122, b123, b124, b125, b126, b127;\n    byte b130, b131, b132, b133, b134, b135, b136, b137;\n    byte b140, b141, b142, b143, b144, b145, b146, b147;\n    byte b150, b151, b152, b153, b154, b155, b156, b157;\n    byte b160, b161, b162, b163, b164, b165, b166, b167;\n    byte b170, b171, b172, b173, b174, b175, b176, b177;\n}\n\nabstract class BaseLinkedQueueConsumerNodeRef<E> extends BaseLinkedQueuePad2<E> {\n    public void clear();\n    public int fill(Supplier<E> s);\n    abstract public boolean offer(final E e);\n    abstract public boolean offer(final E e, final E value);\n    public Iterator<E> iterator();\n}\n    \n\n### Response:",
        "    public void sizeTest() {\n        int capacity = 2;\n        BaseLinkedQueue<Integer> queue = new MpscArrayQueue<>(capacity);\n        assertEquals(0, queue.size());\n        \n        queue.relaxedOffer(1);\n        queue.relaxedOffer(2);\n        assertEquals(2, queue.size());\n    }",
        "\npackage org.jctools.queues;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    public void sizeTest() {\n        assertEquals(0, new MpscGrowableAtomicArrayQueue<>(8).size());\n    }\n}\n    \n\n### JUNIT Test case:\npackage org.jctools.queues;\n\nimport static org.junit.Assert.*;\n\npublic class BaseLinkedQueuePad1Test {\n    @Test\n    public void testCasConsumerNode() {\n        <FILL>\n    }\n}\n    \n\n### Response:",
        "    package org.jctools.queues;\n    \n    import java.util.ArrayList;\n    import java.util.List;\n    \n    public class BaseLinkedQueuePad0Test {\n        @Test\n        public void sizeTest() {\n            LinkedQueue<Integer> queue = new MpscLinkedQueue<>();\n            assertEquals(queue.size(), 0);\n            queue.relaxedOffer(1);\n            assertEquals(queue.size(), 1);\n            queue.relaxedOffer(2);\n            assertEquals(queue.size(), 2);\n            queue.poll();\n            assertEquals(queue.size(), 1);\n        }\n    }\n    \n    ",
        "    // Fixed size not allowed for this queue.\n    @Test\n    public void sizeTest() {\n        final int expectedCapacity = 16;\n        MpscLinkedQueue<String> q = new MpscLinkedQueue<>();\n        \n        assertTrue(q.isEmpty());\n        // Fill the queue with a bunch of elements\n        for (int i = 0; i < expectedCapacity; i++) {\n            q.relaxedOffer(\"foo\" + i);\n        }\n        assertFalse(q.isEmpty());\n        \n        int size = 0;\n        // Iterate over the queue\n        for (String s : q) {\n            size++;\n        }\n        assertEquals(expectedCapacity, size);\n    }",
        "package org.jctools.queues;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\npublic class BaseLinkedQueuePad0<E> extends BaseLinkedQueueConsumerNodeRef<E> {\n    public final int capacity() { return 8192; }\n}\n    \npackage org.jctools.queues;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    public void sizeTest() {\n        BaseLinkedQueuePad0<Integer> q = new BaseLinkedQueuePad0<>();\n        assertEquals(q.capacity(), 8192);\n    }\n}\n    ",
        "@Test\npublic void sizeTest() {\n    assertEquals(<FILL>, q.size(), \"Expected size\");\n}",
        "package org.jctools.queues;\n\nimport java.util.*;\n\npublic class BaseLinkedQueuePad0Test {\n    @Test\n    public void sizeTest() {\n        LinkedQueueNode<String> curr = new LinkedQueueNode<>();\n        curr.spins = 1;\n        assertEquals(0, BaseLinkedQueue.size(curr));\n        // TODO: add more tests for size() method\n    }\n}"
    ]
}