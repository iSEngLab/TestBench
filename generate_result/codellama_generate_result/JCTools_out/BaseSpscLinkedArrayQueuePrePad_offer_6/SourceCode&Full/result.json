{
    "project_name": "JCTools",
    "file_name": "BaseSpscLinkedArrayQueue.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/queues/BaseSpscLinkedArrayQueue.java",
    "execute_path": "JCTools",
    "package": "org.jctools.queues",
    "docstring": "/**\n     * {@inheritDoc}\n     * <p>\n     * This implementation is correct for single producer thread use only.\n     */",
    "source_code": "\n@Override\npublic boolean offer(final E e)\n{\n    // Objects.requireNonNull(e);\n    if (null == e)\n    {\n        throw new NullPointerException();\n    }\n    // local load of field to avoid repeated loads after volatile reads\n    final E[] buffer = producerBuffer;\n    final long index = lpProducerIndex();\n    final long mask = producerMask;\n    final long offset = calcCircularRefElementOffset(index, mask);\n    // expected hot path\n    if (index < producerBufferLimit)\n    {\n        writeToQueue(buffer, e, index, offset);\n        return true;\n    }\n    return offerColdPath(buffer, mask, index, offset, e, null);\n}\n",
    "class_name": "BaseSpscLinkedArrayQueuePrePad",
    "method_name": "offer",
    "arguments": [
        "E e"
    ],
    "generate_test": [
        "@Test\npublic void offerTest() {\n    final MpscLinkedQueue<Integer> queue = new MpscLinkedQueue<>();\n    \n    // Test 1: Queue is empty, so we should be able to add an element\n    assertTrue(queue.offer(0));\n    assertEquals(1, queue.size());\n    \n    // Test 2: Queue is full (capacity of 8), so we shouldn't be able to add another element\n    for (int i = 1; i < 7; i++) {\n        queue.offer(i);\n    }\n    assertFalse(queue.offer(7));\n    \n    // Test 3: Queue is not full, so we should be able to add another element\n    assertTrue(queue.offer(8));\n    assertEquals(8, queue.size());\n}\n\n### JUNIT Test case:\npackage org.jctools.queues;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseMpscLinkedQueueColdTest {\n    @Test\n    public void offerAndPollWithWrapAround() throws InterruptedException {\n        final MpscLinkedQueue<Integer> queue = new MpscLinkedQueue<>();\n        \n        // Test 1: Queue is empty, so we should be able to add an element\n        assertTrue(queue.offer(0));\n        assertEquals(1, queue.size());\n        assertEquals(0, (int) queue.poll());\n        \n        // Test 2: Add a bunch of elements and make sure they are all there\n        for (int i = 1; i <= 8; i++) {\n            queue.offer(i);\n        }\n        assertEquals(8, queue.size());\n        for (int i = 0; i < 9; i++) {\n            assertEquals(i, (int) queue.poll());\n        }\n        \n        // Test 3: Add a bunch of elements and make sure they are all there\n        for (int i = 1; i <= 8; i++) {\n            queue.offer(i);\n        }\n        assertEquals(8, queue.size());\n        for (int i = 0; i < 9; i++) {\n            assertEquals(i, (int) queue.poll());\n        }\n        \n        // Test 4: Make sure the size is correct\n        assertTrue(queue.offer(1));\n        assertTrue(queue.offer(2));\n        assertEquals(2, queue.size());\n    }\n}\n    \n\n### Response:",
        "import org.jctools.queues.BaseSpscLinkedArrayQueue;\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\n\npublic class BaseSpscLinkedArrayQueuePrePadTest extends TestCase {\n    public void testOffer() throws Exception {\n        <FILL>\n    }\n}\n",
        "# Testing offer method\n\n<FILL>\n\n@Test\npublic void offerTest() {\n    // given\n    final var queue = new SpscArrayQueue<String>(16);\n    \n    // when\n    final boolean result = queue.offer(\"element\");\n    \n    // then\n    assertTrue(result);\n}\n\n# Testing poll method\n\n@Test\npublic void pollTest() {\n    // given\n    final var queue = new SpscArrayQueue<String>(16);\n    queue.offer(\"element\");\n    \n    // when\n    final String result = queue.poll();\n    \n    // then\n    assertEquals(\"element\", result);\n}\n\n# Testing peek method\n\n@Test\npublic void peekTest() {\n    // given\n    final var queue = new SpscArrayQueue<String>(16);\n    queue.offer(\"element\");\n    \n    // when\n    final String result = queue.peek();\n    \n    // then\n    assertEquals(\"element\", result);\n}\n\n# Testing clear method\n\n@Test\npublic void clearTest() {\n    // given\n    final var queue = new SpscArrayQueue<String>(16);\n    queue.offer(\"element\");\n    \n    // when\n    queue.clear();\n    \n    // then\n    assertEquals(0, queue.size());\n}\n\n# Testing drain method\n\n@Test\npublic void drainTest() {\n    // given\n    final var queue = new SpscArrayQueue<String>(16);\n    queue.offer(\"element\");\n    \n    // when\n    final List<String> result = queue.drain();\n    \n    // then\n    assertEquals(Collections.singletonList(\"element\"), result);\n}\n\n# Testing fill method\n\n@Test\npublic void fillTest() {\n    // given\n    final var queue = new SpscArrayQueue<String>(16);\n    final var elements = Arrays.asList(\"a\", \"b\", \"c\");\n    \n    // when\n    queue.fill(elements);\n    \n    // then\n    assertEquals(3, queue.size());\n}",
        "package org.jctools.queues;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class BaseSpscLinkedArrayQueuePrePadTest {\n    @Test\n    public void offerTest() {\n        <FILL>\n    }\n}",
        "package org.jctools.queues;\n\nimport java.util.*;\n\npublic class BaseSpscLinkedArrayQueuePrePadTest {\n    @Test\n    public void offerTest() {\n        int size = 1024 * 8; // 8K elements\n        final Queue<Integer> queue = new BaseSpscLinkedArrayQueue<>(size);\n\n        for (int i = 0; i < size; i++) {\n            assertTrue(queue.offer(i));\n        }\n\n        for (int i = 0; i < size; i++) {\n            Integer result = queue.poll();\n            assertNotNull(result);\n            assertEquals(result, i);\n        }\n    }\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BaseSpscLinkedArrayQueuePrePadTest {\n    @Test\n    public void offerTest() {\n        // Create an instance of your queue implementation:\n        BaseSpscLinkedArrayQueuePrePad<Integer> q = new MyQueue();\n        \n        // Try offering some elements into the queue:\n        assertTrue(q.offer(1));\n        assertTrue(q.offer(2));\n        assertTrue(q.offer(3));\n        \n        // Make sure that only the first three elements were accepted:\n        assertEquals(3, q.size());\n    }\n}",
        "SpscLinkedArrayQueuePrePad.java:\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\n\nabstract class BaseSpscLinkedArrayQueuePrePad<E> extends ConcurrentSequencedCircularArrayQueuePrePad<E> {\n    long p0, p1, p2, p3, p4, p5, p6;\n    long p10, p11, p12, p13, p14, p15;\n    \n    public BaseSpscLinkedArrayQueuePrePad(int capacity) {\n        super(capacity);\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\n\nabstract class BaseSpscLinkedArrayQueue<E> extends ConcurrentSequencedCircularArrayQueue<E> {\n    long p0, p1, p2, p3, p4, p5, p6;\n    long p10, p11, p12, p13, p14, p15;\n    \n    public BaseSpscLinkedArrayQueue(int capacity) {\n        super(capacity);\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\n\nabstract class BaseSpscLinkedArrayQueuePostPad<E> extends ConcurrentSequencedCircularArrayQueuePostPad<E> {\n    long p0, p1, p2, p3, p4, p5, p6;\n    long p10, p11, p12, p13, p14, p15;\n    \n    public BaseSpscLinkedArrayQueuePostPad(int capacity) {\n        super(capacity);\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\nabstract class BaseSpscLinkedArrayQueueL2Pad<E> extends ConcurrentSequencedCircularArrayQueueL1Pad<E> {\n    long p0, p1, p2, p3, p4, p5, p6;\n    long p10, p11, p12, p13, p14, p15;\n    \n    public BaseSpscLinkedArrayQueueL2Pad(int capacity) {\n        super(capacity);\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\nabstract class BaseSpscLinkedArrayQueueL1Pad<E> extends ConcurrentSequencedCircularArrayQueueFields<E> {\n    long p0, p1, p2, p3, p4, p5, p6;\n    long p10, p11, p12, p13, p14, p15;\n    \n    public BaseSpscLinkedArrayQueueL1Pad(int capacity) {\n        super(capacity);\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\nabstract class BaseSpscLinkedArrayQueueFields<E> {\n    // offer indices are even, poll indices are odd (even for initial value)\n    private final long producerIndexCache;\n    protected final int length;// fixed for the instance, could be set via constructor param\n    protected E[] buffer; // fixed for the instance, could be set via constructor param\n    \n    public BaseSpscLinkedArrayQueueFields(int capacity) {\n        this.producerIndexCache = 0L;\n        this.length = calculateSize(capacity);\n        @SuppressWarnings(\"unchecked\")\n        E[] buff = (E[]) new Object[length];\n        this.buffer = buff;\n    }\n    \n    private static int calculateSize(final int capacity) {\n        return 1 << Bits.log2Ceil(capacity);\n    }\n    \n    public final long lvProducerIndexCache() {\n        return producerIndexCache;\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\n/**\n * Common base for all Spsc queues.\n */\nabstract class ConcurrentSequencedCircularArrayQueue<E> extends BaseSpscLinkedArrayQueueL2Pad<E> {\n    long consumerIndex;\n    \n    public ConcurrentSequencedCircularArrayQueue(int capacity) {\n        super(capacity);\n        \n        this.consumerIndex = 0L;\n        soPadding();\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeAccess.fieldOffset;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\n/**\n * Common base for all Spsc queues.\n */\nabstract class BaseSpscLinkedArrayQueue<E> extends ConcurrentSequencedCircularArrayQueueL1Pad<E> {\n    private static final long PRODUCER_INDEX_OFFSET;\n    \n    static {\n        try {\n            PRODUCER_INDEX_OFFSET = fieldOffset(BaseSpscLinkedArrayQueue.class.getDeclaredField(\"producerIndex\"));\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n    \n    public BaseSpscLinkedArrayQueue(int capacity) {\n        super(capacity);\n        \n        soPadding();\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\n/**\n * Common base for all Spsc queues.\n */\nabstract class ConcurrentSequencedCircularArrayQueueL1Pad<E> extends BaseSpscLinkedArrayQueueFields<E> {\n    long p0, p1, p2, p3, p4, p5, p6;\n    \n    public ConcurrentSequencedCircularArrayQueueL1Pad(int capacity) {\n        super(capacity);\n        \n        soPadding();\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\n/**\n * Common base for all Spsc queues.\n */\nabstract class BaseSpscLinkedArrayQueueFields<E> extends ConcurrentSequencedCircularArrayQueueL2Pad<E> {\n    private static final long PRODUCER_INDEX_OFFSET;\n    \n    public BaseSpscLinkedArrayQueueFields(int capacity) {\n        super(capacity);\n        \n        soPadding();\n    }\n}\n\npackage org.jctools.queues;\n\nimport static org.jctools.util.UnsafeAccess.*;\nimport static org.jctools.util.UnsafeRefArrayAccess.*;\n\n/**\n * Common base for all Spsc queues.\n */\nabstract class ConcurrentSequencedCircularArrayQueueL2Pad<E> extends BaseSpscLinkedArrayQueueFields<E> {\n    long p0, p1, p2, p3, p4, p5, p6;\n    \n    public ConcurrentSequencedCircularArrayQueueL2Pad(int capacity) {\n        super(capacity);\n        \n        soPadding();\n    }\n}",
        "package org.jctools.queues;\n\nimport java.util.AbstractQueue;\nimport java.util.Iterator;\n\n/**\n * A LinkedArrayQueue is an implementation of the {@link MessagePassingQueue} interface. The queue uses a linked array\n * structure and preallocates arrays to minimize garbage collection.\n */\npublic class BaseSpscLinkedArrayQueue<E> extends AbstractQueue<E> implements SpscLinkedArrayQueue<E>, QueueProgressIndicators {\n    static final long INDEX_OFFSET = UnsafeAccess.UNSAFE.objectFieldOffset(\n            BaseSpscLinkedArrayQueueProducerFields.class, \"producerIndex\");\n\n    private static final Object JUMP = new Object();\n\n    // consumer fields are initialized before the producer in the same way as the MPMCSS queue (see below),\n    // so that we can create instance with all fields pre-initialized:\n    protected long consumerMask;\n    protected E[] consumerBuffer;\n    private final int offset;\n    private int minConsumerIndex;//used by hasNext() to determine if it's stale.\n    private volatile long producerLookAhead; // we use a single lookahead for both the index and size, so that we only need to update one field when producing (we could keep separate values, but this would require an extra load for each insertion)\n\n    /**\n     * Creates a {@link BaseSpscLinkedArrayQueue} instance.\n     */\n    public BaseSpscLinkedArrayQueue(int chunkSize) {\n        int p2capacity = Pow2.roundToPowerOfTwo(chunkSize);\n        offset = calcCircularRefElementOffset(p2capacity, p2capacity - 1);\n        // must evaluate value to be assigned to final field before constructor is complete:\n        E[] buf = createBuffer(p2capacity);\n        producerLookAhead = minConsumerIndex = offset;\n        consumerMask = mask(buf.length - 2);\n        soProducerLimit(maskNull(buf, 2));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public final Iterator<E> iterator() {\n        throw new UnsupportedOperationException();\n    }\n\n    private static long mask(long m) {\n        return m;//m - 1;\n    }\n\n    private long lvProducerLookAhead() {\n        return producerLookAhead; // LoadLoad\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long currentProducerIndex() {\n        return lvProducerIndex();\n    }\n\n    private long lvProducerIndex() {\n        return producerLookAhead; // LoadLoad\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long currentConsumerIndex() {\n        return (minConsumerIndex == offset) ? lpConsumerIndex() : minConsumerIndex;\n    }\n\n    private long lvProducerLimit() {\n        return producerLimit.value; // LoadLoad\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int capacity() {\n        return (int) (mask(producerBuffer.length - 1));\n    }\n\n    private void soProducerLimit(long producerLimit) {\n        UnsafeAccess.UNSAFE.putOrderedLong(this, P_LIMIT_OFFSET, producerLimit); // StoreStore\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int size() {\n        return ((int) (producerLookAhead - minConsumerIndex));\n    }\n\n    private long lvProducerTail() {\n        return producerTail.value; // LoadLoad\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isEmpty() {\n        return minConsumerIndex == producerLookAhead;\n    }\n\n    private void soProducerTail(long tail) {\n        UnsafeAccess.UNSAFE.putOrderedLong(this, P_TAIL_OFFSET, tail); // StoreStore\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void clear() {\n        while (poll(lvProducerIndex())) ;\n    }\n\n    private static int calcCircularRefElementOffset(int mask) {\n        return UnsafeAccess.UNSAFE.objectFieldOffset(BaseSpscLinkedArrayQueueProducerFields.class, \"producerBuffer\") + UnsafeAccess.UNSAFE.arrayIndexScale(mask) * (Long.SIZE / 8);\n    }\n\n    private E[] createBuffer(int capacity) {\n        return (E[]) new Object[capacity]; // TODO: add support for ClassLoaders\n    }\n\n    @Override\n    public String toString() {\n        return this.getClass().getSimpleName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offer(E e) {\n        if (null == e) throw new NullPointerException(\"Null is not a valid element\");\n        final long mask = this.producerMask; // TODO: could calculate this value just once\n        final long capacity = mask + 1; // TODO: could be assigned in the constructor, and removed here\n        final E[] buffer = this.producerBuffer;\n\n        // Look ahead to next buffer and wrap pointer if necessary\n        final long producerIndex = lvProducerIndex();// LoadLoad\n        for (int i = 0; i < capacity; i++) {\n            final long index = calcCircularRefElementOffset(i);\n            E[] newBuffer = createBuffer(capacity);\n            Object o = UnsafeAccess.UNSAFE.getObjectVolatile(buffer, index); // TODO: fix\n            if (o == null) continue;\n            else {\n                producerIndex--;\n                producerTail.value++;\n                buffer[i] = newBuffer;\n            }\n        }\n\n        long maskedIndex = calcCircularRefElementOffset(producerIndex + offset);// LoadLoad\n\n        // Claim the index and attempt to insert, if we fail to claim the slot we abort.\n        E[] buffer = producerBuffer;// LoadLoad\n        final long limit = lvProducerLimit();// LoadLoad\n        final long wrapPoint = limit - capacity + 1;// TODO: calculate once in constructor\n\n        // Attempt to insert the element\n        E e1 = e;// LoadLoad\n        if (producerIndex >= wrapPoint) {// TODO: replace with <= and remove else below\n            buffer[maskedIndex] = e1;\n            soProducerIndex(producerIndex + 1); // StoreStore\n            return true;\n        } else {\n            E[] newBuffer = createBuffer(capacity);// LoadLoad\n            UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, newBuffer);// TODO: fix\n            if (producerTail.value == limit) {\n                producerTail.lazySet(limit - capacity + 1); // StoreStore\n                soProducerLimit(maskNull(newBuffer, 2)); // StoreStore\n                return false;\n            } else {\n                UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, e1);// TODO: fix\n                soProducerTail(producerTail.value + 1); // StoreStore\n                soProducerIndex(producerIndex + 1); // StoreStore\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offer(E e, E e1) {\n        if (null == e || null == e1) throw new NullPointerException(\"Null is not a valid element\");\n        final long mask = this.producerMask; // TODO: could calculate this value just once\n        final long capacity = mask + 1; // TODO: could be assigned in the constructor, and removed here\n        final E[] buffer = this.producerBuffer;\n\n        // Look ahead to next buffer and wrap pointer if necessary\n        final long producerIndex = lvProducerIndex();// LoadLoad\n        for (int i = 0; i < capacity; i++) {\n            final long index = calcCircularRefElementOffset(i);\n            E[] newBuffer = createBuffer(capacity);\n            Object o = UnsafeAccess.UNSAFE.getObjectVolatile(buffer, index); // TODO: fix\n            if (o == null) continue;\n            else {\n                producerIndex--;\n                producerTail.value++;\n                buffer[i] = newBuffer;\n            }\n        }\n\n        long maskedIndex = calcCircularRefElementOffset(producerIndex + offset);// LoadLoad\n\n        // Claim the index and attempt to insert, if we fail to claim the slot we abort.\n        E[] buffer = producerBuffer;// LoadLoad\n        final long limit = lvProducerLimit();// LoadLoad\n        final long wrapPoint = limit - capacity + 1;// TODO: calculate once in constructor\n\n        // Attempt to insert the element\n        if (producerIndex >= wrapPoint) {// TODO: replace with <= and remove else below\n            buffer[maskedIndex] = e;\n            soProducerIndex(producerIndex + 1); // StoreStore\n            return true;\n        } else {\n            E[] newBuffer = createBuffer(capacity);// LoadLoad\n            UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, newBuffer);// TODO: fix\n            if (producerTail.value == limit) {\n                producerTail.lazySet(limit - capacity + 1); // StoreStore\n                soProducerLimit(maskNull(newBuffer, 2)); // StoreStore\n                return false;\n            } else {\n                UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, e);// TODO: fix\n                soProducerTail(producerTail.value + 1); // StoreStore\n                soProducerIndex(producerIndex + 1); // StoreStore\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offer(E e, E e1, E e2) {\n        if (null == e || null == e1 || null == e2) throw new NullPointerException(\"Null is not a valid element\");\n        final long mask = this.producerMask; // TODO: could calculate this value just once\n        final long capacity = mask + 1; // TODO: could be assigned in the constructor, and removed here\n        final E[] buffer = this.producerBuffer;\n\n        // Look ahead to next buffer and wrap pointer if necessary\n        final long producerIndex = lvProducerIndex();// LoadLoad\n        for (int i = 0; i < capacity; i++) {\n            final long index = calcCircularRefElementOffset(i);\n            E[] newBuffer = createBuffer(capacity);\n            Object o = UnsafeAccess.UNSAFE.getObjectVolatile(buffer, index); // TODO: fix\n            if (o == null) continue;\n            else {\n                producerIndex--;\n                producerTail.value++;\n                buffer[i] = newBuffer;\n            }\n        }\n\n        long maskedIndex = calcCircularRefElementOffset(producerIndex + offset);// LoadLoad\n\n        // Claim the index and attempt to insert, if we fail to claim the slot we abort.\n        E[] buffer = producerBuffer;// LoadLoad\n        final long limit = lvProducerLimit();// LoadLoad\n        final long wrapPoint = limit - capacity + 1;// TODO: calculate once in constructor\n\n        // Attempt to insert the element\n        if (producerIndex >= wrapPoint) {// TODO: replace with <= and remove else below\n            buffer[maskedIndex] = e;\n            soProducerIndex(producerIndex + 1); // StoreStore\n            return true;\n        } else {\n            E[] newBuffer = createBuffer(capacity);// LoadLoad\n            UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, newBuffer);// TODO: fix\n            if (producerTail.value == limit) {\n                producerTail.lazySet(limit - capacity + 1); // StoreStore\n                soProducerLimit(maskNull(newBuffer, 2)); // StoreStore\n                return false;\n            } else {\n                UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, e);// TODO: fix\n                soProducerTail(producerTail.value + 1); // StoreStore\n                soProducerIndex(producerIndex + 1); // StoreStore\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean offer(E e, E e1, E e2, E... otherElements) {\n        if (null == e || null == e1 || null == e2 || null == otherElements) throw new NullPointerException(\"Null is not a valid element\");\n        final long mask = this.producerMask; // TODO: could calculate this value just once\n        final long capacity = mask + 1; // TODO: could be assigned in the constructor, and removed here\n        final E[] buffer = this.producerBuffer;\n\n        // Look ahead to next buffer and wrap pointer if necessary\n        final long producerIndex = lvProducerIndex();// LoadLoad\n        for (int i = 0; i < capacity; i++) {\n            final long index = calcCircularRefElementOffset(i);\n            E[] newBuffer = createBuffer(capacity);\n            Object o = UnsafeAccess.UNSAFE.getObjectVolatile(buffer, index); // TODO: fix\n            if (o == null) continue;\n            else {\n                producerIndex--;\n                producerTail.value++;\n                buffer[i] = newBuffer;\n            }\n        }\n\n        long maskedIndex = calcCircularRefElementOffset(producerIndex + offset);// LoadLoad\n\n        // Claim the index and attempt to insert, if we fail to claim the slot we abort.\n        E[] buffer = producerBuffer;// LoadLoad\n        final long limit = lvProducerLimit();// LoadLoad\n        final long wrapPoint = limit - capacity + 1;// TODO: calculate once in constructor\n\n        // Attempt to insert the element\n        if (producerIndex >= wrapPoint) {// TODO: replace with <= and remove else below\n            buffer[maskedIndex] = e;\n            soProducerIndex(producerIndex + 1); // StoreStore\n            return true;\n        } else {\n            E[] newBuffer = createBuffer(capacity);// LoadLoad\n            UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, newBuffer);// TODO: fix\n            if (producerTail.value == limit) {\n                producerTail.lazySet(limit - capacity + 1); // StoreStore\n                soProducerLimit(maskNull(newBuffer, 2)); // StoreStore\n                return false;\n            } else {\n                UnsafeAccess.UNSAFE.putObjectVolatile(buffer, maskedIndex, e);// TODO: fix\n                soProducerTail(producerTail.value + 1); // StoreStore\n                soProducerIndex(producerIndex + 1); // StoreStore\n            }\n        }\n    }\n}",
        "package org.jctools.queues;\n\nimport static java.lang.System.out;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.*;\n\nimport org.junit.jupiter.api.Test;\n\npublic class BaseSpscLinkedArrayQueuePrePadTest {\n    @Test\n    public void offerTest() throws InterruptedException, ExecutionException {\n        final int testSize = 10_000_000;\n\n        final int producerCount = Runtime.getRuntime().availableProcessors();\n        final List<Thread> producerThreads = new ArrayList<>();\n        for (int i = 0; i < producerCount; i++) {\n            Thread thread = new Thread(() -> {\n                while (!Thread.interrupted()) {\n                    try {\n                        spscLinkedArrayQueuePrePad.offer(\"1\");\n                    } catch (Throwable ex) {\n                        fail(ex);\n                    }\n                }\n            });\n            thread.setDaemon(true);\n            producerThreads.add(thread);\n            thread.start();\n        }\n\n        final int consumerCount = Runtime.getRuntime().availableProcessors() * 2;\n        final List<Thread> consumerThreads = new ArrayList<>();\n        for (int i = 0; i < consumerCount; i++) {\n            Thread thread = new Thread(() -> {\n                while (!Thread.interrupted()) {\n                    try {\n                        spscLinkedArrayQueuePrePad.poll();\n                    } catch (Throwable ex) {\n                        fail(ex);\n                    }\n                }\n            });\n            thread.setDaemon(true);\n            consumerThreads.add(thread);\n            thread.start();\n        }\n\n        final long startNanos = System.nanoTime();\n        final ExecutorService executorService = Executors.newCachedThreadPool();\n        try {\n            for (int i = 0; i < producerCount; i++) {\n                executorService.submit(() -> {\n                    while (!Thread.interrupted()) {\n                        try {\n                            spscLinkedArrayQueuePrePad.offer(\"1\");\n                        } catch (Throwable ex) {\n                            fail(ex);\n                        }\n                    }\n                });\n            }\n            final Future<Long> pollFuture = executorService.submit(() -> {\n                long count = 0;\n                while (!Thread.interrupted()) {\n                    try {\n                        spscLinkedArrayQueuePrePad.poll();\n                        if (++count % 1_000_000 == 0) {\n                            out.println(count);\n                        }\n                    } catch (Throwable ex) {\n                        fail(ex);\n                    }\n                }\n                return count;\n            });\n            Thread.sleep(5_000);\n            executorService.shutdownNow();\n            final long polledCount = pollFuture.get();\n            assertEquals(testSize, polledCount);\n        } finally {\n            producerThreads.forEach(Thread::interrupt);\n            consumerThreads.forEach(Thread::interrupt);\n        }\n    }\n}",
        "@RestController\npublic class GreetingController {\n    @RequestMapping(\"/greeting\")\n    public String greeting(@RequestParam(value=\"name\", defaultValue=\"World\") String name) {\n        return \"Hello, \" + name + \"!\";\n    }\n}\n    \n\n### Response:"
    ]
}