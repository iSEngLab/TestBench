{
    "project_name": "JCTools",
    "file_name": "FixedSizeStripedLongCounter.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
    "execute_path": "JCTools",
    "package": "org.jctools.counters",
    "docstring": "/**\n     * Returns the probe value for the current thread.\n     * If target JDK version is 7 or higher, than ThreadLocalRandom-specific\n     * value will be used, xorshift with thread id otherwise.\n     */",
    "source_code": "\nprivate int probe() {\n    // Fast path for reliable well-distributed probe, available from JDK 7+.\n    // As long as PROBE is final static this branch will be constant folded\n    // (i.e removed).\n    if (PROBE != -1) {\n        int probe;\n        if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {\n            ThreadLocalRandom.current(); // force initialization\n            probe = UNSAFE.getInt(Thread.currentThread(), PROBE);\n        }\n        return probe;\n    }\n\n    /*\n     * Else use much worse (for values distribution) method:\n     * Mix thread id with golden ratio and then xorshift it\n     * to spread consecutive ids (see Knuth multiplicative method as reference).\n     */\n    int probe = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n    // xorshift\n    probe ^= probe << 13;\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n    return probe;\n}\n\n",
    "class_name": "FixedSizeStripedLongCounterPrePad",
    "method_name": "probe",
    "arguments": [],
    "generate_test": [
        "package org.jctools.counters;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.*;\n/**\n * A pre-padded implementation of {@link FixedSizeStripedLongCounter}.\n * @author nitsanw\n */\npublic abstract class FixedSizeStripedLongCounterPrePad extends FixedSizeStripedLongCounter {\n    protected static final long[] cells; // 8b\n    private static Unsafe unsafe = null; // 16b\n    private static final long baseOffset;// 24b\n    private static int pad0, pad1, pad2, pad3;// 32b\n    byte b000,b001,b002,b003,b004,b005,b006,b007;// 40b\n    byte b010,b011,b012,b013,b014,b015,b016,b017;// 48b\n    byte b020,b021,b022,b023,b024,b025,b026,b027;// 56b\n    byte b030,b031,b032,b033,b034,b035,b036,b037;// 64b\n    byte b040,b041,b042,b043,b044,b045,b046,b047;// 72b\n    byte b050,b051,b052,b053,b054,b055,b056,b057;// 80b\n    private static int mask = 0xff; // 88b\n    \n    protected FixedSizeStripedLongCounterPrePad(int stripesCount) {\n        super(stripesCount);\n    }\n    \n    @Override\n    protected void inc(long[] cells, long offset, long value) {\n        <FILL>\n    }\n    \n    @Override\n    protected long getAndReset(long[] cells, long offset) {\n        return UNSAFE.getAndSetLong(cells, offset, 0L);\n    }\n}\npackage org.jctools.counters;\nimport sun.misc.Unsafe;\nimport java.lang.reflect.*;\n/**\n * A post-padded implementation of {@link FixedSizeStripedLongCounter}.\n * @author nitsanw\n */\npublic abstract class FixedSizeStripedLongCounterPostPad extends FixedSizeStripedLongCounter {\n    private int pad0, pad1, pad2, pad3;// 8b\n    protected static final long[] cells; // 16b\n    private static Unsafe unsafe = null; // 24b\n    private static final long baseOffset;// 32b\n    \n    protected FixedSizeStripedLongCounterPostPad(int stripesCount) {\n        super(stripesCount);\n    }\n    \n    @Override\n    protected void inc(long[] cells, long offset, long value) {\n        <FILL>\n    }\n    \n    @Override\n    protected long getAndReset(long[] cells, long offset) {\n        return UNSAFE.getAndSetLong(cells, offset, 0L);\n    }\n}",
        "@Test\npublic void probeTest() {\n    int probe = <FILL>; // Fill in here.\n    assertEquals(probe, probe());\n}",
        "package org.jctools.counters;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n    @BeforeEach\n    public void before() {\n        if (PROBE != -1) {\n            // Force initialization for ThreadLocalRandom-specific case.\n            ThreadLocalRandom.current();\n        }\n    }\n    \n    @Test\n    public void probeTest() {\n        assertEquals(Thread.currentThread().getId(), index());\n        \n        int expected = 0;\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            if ((i & Long.SIZE - 1) == 0) {\n                // skip already visited probe values\n                ++expected;\n            } else if ((PROBE != -1 ? UNSAFE.getInt(Thread.currentThread(), PROBE) : Thread.currentThread().hashCode()) == i) {\n                break;\n            }\n        }\n        \n        assertEquals(expected, index());\n    }\n    \n    private int probe() {\n        // Fast path for reliable well-distributed probe, available from JDK 7+.\n        // As long as PROBE is final static this branch will be constant folded\n        // (i.e removed).\n        if (PROBE != -1) {\n            int probe;\n            if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {\n                ThreadLocalRandom.current(); // force initialization\n                probe = UNSAFE.getInt(Thread.currentThread(), PROBE);\n            }\n            return probe;\n        }\n        \n        /*\n         * Else use much worse (for values distribution) method:\n         * Mix thread id with golden ratio and then xorshift it\n         * to spread consecutive ids (see Knuth multiplicative method as reference).\n         */\n        int probe = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n        // xorshift\n        probe ^= probe << 13;\n        probe ^= probe >>> 17;\n        probe ^= probe << 5;\n        return probe;\n    }\n    \n    private int index() {\n        long probe = probe();\n        \n        while (true) {\n            if ((probe & Long.SIZE - 1) == 0) {\n                break; // reached first stripe, don't increment expected value\n            } else if ((PROBE != -1 ? UNSAFE.getInt(Thread.currentThread(), PROBE) : Thread.currentThread().hashCode()) == probe) {\n                return (int) probe >>> ELEMENT_SHIFT; // fast path for known probe value\n            } else if ((probe = (18446744073709551559L * probe + 1)) == 0) {\n                ThreadLocalRandom.current(); // force initialization\n            }\n        }\n        \n        return (int) probe >>> ELEMENT_SHIFT; // slow path with xorshifted probe value\n    }\n    \n    private static final int PROBE = -1;\n    \n    private static final int ELEMENT_SHIFT = 6;\n    \n    @BeforeEach\n    public void before() {\n        if (PROBE != -1) {\n            // Force initialization for ThreadLocalRandom-specific case.\n            ThreadLocalRandom.current();\n        }\n    }\n}\n    ",
        "@Test\npublic void probeTest() {\n    // Test case 1: Probe with 0 as input, should return a non-zero value.\n    assertNotEquals(0, FixedSizeStripedLongCounterPrePadTest.probe());\n    \n    // Test case 2: Probe with positive values, should return the same result.\n    for (int i = 1; i < 10; i++) {\n        int probe = FixedSizeStripedLongCounterPrePadTest.probe();\n        assertEquals(probe, FixedSizeStripedLongCounterPrePadTest.probe());\n    }\n    \n    // Test case 3: Probe with negative values, should return the same result.\n    for (int i = -10; i < 0; i++) {\n        int probe = FixedSizeStripedLongCounterPrePadTest.probe();\n        assertEquals(probe, FixedSizeStripedLongCounterPrePadTest.probe());\n    }\n    \n    // Test case 4: Probe with a mix of positive and negative values, should return the same result.\n    for (int i = -10; i < 10; i++) {\n        int probe = FixedSizeStripedLongCounterPrePadTest.probe();\n        assertEquals(probe, FixedSizeStripedLongCounterPrePadTest.probe());\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n    @Test\n    public void probeTest() {\n        int probe = 0;\n        \n        // Fast path for reliable well-distributed probe, available from JDK 7+.\n        // As long as PROBE is final static this branch will be constant folded (i.e removed).\n        if (FixedSizeStripedLongCounter.PROBE != -1) {\n            int _probe;\n            if ((_probe = UNSAFE.getInt(Thread.currentThread(), FixedSizeStripedLongCounter.PROBE)) == 0) {\n                ThreadLocalRandom.current(); // force initialization\n                _probe = UNSAFE.getInt(Thread.currentThread(), FixedSizeStripedLongCounter.PROBE);\n            }\n            probe = _probe;\n        } else {\n            /*\n             * Else use much worse (for values distribution) method:\n             * Mix thread id with golden ratio and then xorshift it\n             * to spread consecutive ids (see Knuth multiplicative method as reference).\n             */\n            long t = Thread.currentThread().getId() * 0x9e3779b9L;\n            probe ^= (int) ((t >>> 32) ^ t);\n            \n            // xorshift\n            probe ^= probe << 13;\n            probe ^= probe >>> 17;\n            probe ^= probe << 5;\n        }\n        \n        assertEquals(probe, FixedSizeStripedLongCounter.probe());\n    }\n}",
        "package org.jctools.counters;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n    private static final int PAD = <FILL>;\n\n    @Test\n    public void probeTest() {\n        assertTrue(PAD == 1); // fill here with the correct value\n    }\n}",
        "@Test\npublic void probeTest() {\n    assertTrue(FixedSizeStripedLongCounter.probe() >= 0);\n}\n",
        "package org.jctools.counters;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class FixedSizeStripedLongCounterPrePadTest {\n    @Test\n    public void probeTest() {\n        // Fast path for reliable well-distributed probe, available from JDK 7+.\n        // As long as PROBE is final static this branch will be constant folded (i.e removed).\n        if (PROBE != -1) {\n            int probe;\n            if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {\n                ThreadLocalRandom.current(); // force initialization\n                probe = UNSAFE.getInt(Thread.currentThread(), PROBE);\n            }\n            assertTrue(probe != 0, \"Probe must be initialized\");\n        } else {\n            int probe = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n            // xorshift\n            probe ^= probe << 13;\n            probe ^= probe >>> 17;\n            probe ^= probe << 5;\n            assertTrue(probe != 0, \"Probe must be initialized\");\n        }\n    }\n}",
        "Timeout",
        "package org.jctools.counters;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n    public static final int SIZE = 32; // power of two less than or equal to SIZE\n    private long[] b00,b01,b02,b03,b04,b05,b06,b07;//  8b\n    private long[] b08,b09,b10,b11,b12,b13,b14,b15;// 16b\n    byte b100,b101,b102,b103,b104,b105,b106,b107;// 24b\n    private long[] b16,b17,b18,b19,b20,b21,b22,b23;// 32b\n    \n    @Test\n    public void probeTest() {\n        assertEquals(305419896L, new FixedSizeStripedLongCounter(SIZE) {\n            long nextRandomProbe = ThreadLocalRandom.current().nextInt();\n        \n            protected int probe() {\n                return nextRandomProbe++; // thread local random probe\n            }\n        }.probe());\n    }\n}"
    ]
}