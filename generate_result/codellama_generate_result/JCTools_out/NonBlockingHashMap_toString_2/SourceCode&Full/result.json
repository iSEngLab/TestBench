{
    "project_name": "JCTools",
    "file_name": "NonBlockingHashMap.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
    "execute_path": "JCTools",
    "package": "org.jctools.maps",
    "docstring": "/**\n   * Returns a string representation of this map.  The string representation\n   * consists of a list of key-value mappings in the order returned by the\n   * map's <tt>entrySet</tt> view's iterator, enclosed in braces\n   * (<tt>\"{}\"</tt>).  Adjacent mappings are separated by the characters\n   * <tt>\", \"</tt> (comma and space).  Each key-value mapping is rendered as\n   * the key followed by an equals sign (<tt>\"=\"</tt>) followed by the\n   * associated value.  Keys and values are converted to strings as by\n   * {@link String#valueOf(Object)}.\n   *\n   * @return a string representation of this map\n   */",
    "source_code": "\n@Override\npublic String toString() {\n  Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n  if( !i.hasNext())\n    return \"{}\";\n\n  StringBuilder sb = new StringBuilder();\n  sb.append('{');\n  for (;;) {\n    Entry<TypeK,TypeV> e = i.next();\n    TypeK key = e.getKey();\n    TypeV value = e.getValue();\n    sb.append(key   == this ? \"(this Map)\" : key);\n    sb.append('=');\n    sb.append(value == this ? \"(this Map)\" : value);\n    if( !i.hasNext())\n      return sb.append('}').toString();\n    sb.append(\", \");\n  }\n}\n",
    "class_name": "NonBlockingHashMap",
    "method_name": "toString",
    "arguments": [],
    "generate_test": [
        "import java.util.Objects;\n\npublic class MyObject {\n    private int id;\n    private String name;\n\n    public MyObject(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return \"MyObject{\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n}",
        "The NonBlockingHashMap class is not thread-safe, so it cannot be used in a multi-threaded environment. However, there are several alternatives that you can use instead:\n\n1. ConcurrentHashMap: This is a thread-safe implementation of the HashMap interface. It uses fine-grained locks to ensure that each operation is atomic and thread-safe.\n2. Hashtable: This class is similar to HashMap but is synchronized, making it thread-safe. However, it may be slower than ConcurrentHashMap for high concurrency use cases.\n3. JCS: Java Collections Framework is a library of collection classes that provide alternative implementations of the standard Java collection interfaces. It includes a thread-safe version of HashMap called JCSHashMap.\n4. Apache Commons collections: This library provides several thread-safe hash maps, including the AbstractConcurrentMap class, which can be used as a base class for implementing your own thread-safe hash map classes.\n5. Guava's concurrent hash maps: Google's Guava library provides several implementation of the ConcurrentMap interface, including the ConcurrentHashMap class, which is an implementation based on ConcurrentSkipListMap.\n\nIt's important to note that while these alternatives may be thread-safe, they may not perform as well as a specialized concurrent hash map implementation. You should consider the specific requirements of your application and choose the appropriate solution accordingly.",
        "    \nimport java.util.*;\nimport org.jctools.maps.NonBlockingHashMap;\n\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        // Create a test map with some data\n        Map<String, String> myMap = new NonBlockingHashMap<>();\n        myMap.put(\"apple\", \"red\");\n        myMap.put(\"banana\", \"yellow\");\n        myMap.put(\"cherry\", \"red\");\n        \n        // Expected toString result with map entries in alphabetical order by key\n        String expectedToStringResult = \"{\\\"apple\\\":\\\"red\\\", \\\"banana\\\":\\\"yellow\\\", \\\"cherry\\\":\\\"red\\\"}\";\n        \n        assertEquals(expectedToStringResult, myMap.toString());\n    }\n    \n    \n### Response:",
        "\npackage org.jctools.maps;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class NonBlockingHashMap<K,V> {\n    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n    private static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    private static final int MINIMUM_CAPACITY = 4;\n    \n    /**\n     * The default load factor. Note that the value of {@link #DEFAULT_LOAD_FACTOR} is\n     * stored in a <code>float</code>, which allows the <code>*_factor</code> methods to be\n     * used as locks in some cases.\n     */\n    private static final float LOAD_FACTOR = DEFAULT_LOAD_FACTOR;\n    /**\n     * The maximum capacity of a map. This value must always be a power of two.\n     */\n    private static final int MAXIMUM_CAPACITY = 1 << 30;\n\n    /**\n     * The minimum capacity of a map. Must be a power of two greater than or equal to the load factor.\n     */\n    private static final int MINIMUM_CAPACITY = 4;\n    \n    /**\n     * The number of table entries that can be altered before growing or shrinking the map. This value is used\n     * in conjunction with the load factor to determine the appropriate capacity for the map.\n     */\n    private static final int RESIZE_THRESHOLD = 64; // TODO: Make this dynamic?\n    /**\n     * The default initial capacity of a map. This value is used when creating a new map if no initial capacity is\n     * specified in the constructor or using the default constructor.\n     */\n    private static final int DEFAULT_INITIAL_CAPACITY = 16; // TODO: Make this dynamic?\n\n    /**\n     * A reusable table entry used for chaining. This class is never exposed outside of the package, so it need not be\n     * a public class. The garbage collector will automatically clean up any chained entries that are no longer in use.\n     */\n    private static final class Entry<K,V> {\n        /**\n         * A unique identifier for this entry. This value is never exposed outside of the package, so it need not be\n         * a public field.\n         */\n        private int _hash;\n        /**\n         * The key for this entry, which is used to look up the value in the map. This value may be <code>null</code>.\n         */\n        private K _key;\n        /**\n         * The value associated with this entry. This value may be <code>null</code>, but the <code>_key</code> field\n         * must contain a non-<code>null</code> value if the value is non-<code>null</code>.\n         */\n        private V _value;\n        /**\n         * The next entry in the list, which is used to create a linked list of entries. This field may be <code>null</code>,\n         * but it must contain a non-<code>null</code> value if the <code>_key</code> and <code>_value</code> fields are\n         * non-<code>null</code>.\n         */\n        private Entry _next;\n    }\n    \n    /**\n     * An internal array used to store the table entries. The size of this array must always be a power of two, and it is\n     * used in conjunction with the <code>_mask</code> field to compute an index into the array given a hash value. This\n     * field may not be <code>null</code>, but it should be treated as read-only data by the user.\n     */\n    private Entry[] _table;\n    /**\n     * A mask used in conjunction with the <code>_hash</code> field to compute an index into the internal table array. This\n     * field may not be <code>null</code>, but it should be treated as read-only data by the user.\n     */\n    private int _mask;\n    /**\n     * The number of entries in the map. This value is used to determine when the internal table needs to be resized, and\n     * it may be accessed directly by the user. However, this field should only be updated using the <code>_count</code>\n     * field or the <code>_addEntry()</code> and <code>_removeEntry()</code> methods.\n     */\n    private int _count;\n    /**\n     * The load factor for the map, which is a ratio of the number of entries to the size of the internal table. This value\n     * must always be greater than or equal to zero and less than or equal to one. If this field is set to <code>0</code>,\n     * then no resizing will take place until at least one entry has been removed from the map, which can cause a significant\n     * performance penalty on large maps that are constantly filled and emptied. If this value is set to <code>1</code>,\n     * then the internal table will be exactly twice the necessary size to hold all entries that have been added to the map.\n     */\n    private float _loadFactor;\n    \n    /**\n     * Creates a new instance of the {@link NonBlockingHashMap} class with an initial capacity of <code>16</code>, a load\n     * factor of <code>0.75</code>, and no internal table entries. The map will automatically resize as needed to stay\n     * within the specified capacity limits. However, the user should take care to manually call the {@link #trim()} method\n     * on this map whenever possible to avoid holding onto unnecessary memory.\n     */\n    public NonBlockingHashMap() {\n        this(DEFAULT_INITIAL_CAPACITY);\n    }\n    \n    /**\n     * Creates a new instance of the {@link NonBlockingHashMap} class with an initial capacity of <code>16</code>, a load\n     * factor of <code>0.75</code>, and no internal table entries. The map will automatically resize as needed to stay\n     * within the specified capacity limits. However, the user should take care to manually call the {@link #trim()} method\n     * on this map whenever possible to avoid holding onto unnecessary memory.\n     */\n    public NonBlockingHashMap(int initialCapacity) {\n        this(initialCapacity, 0.75f);\n    }\n    \n    /**\n     * Creates a new instance of the {@link NonBlockingHashMap} class with an initial capacity of <code>16</code>, and no\n     * internal table entries. The map will automatically resize as needed to stay within the specified capacity limits.\n     * However, the user should take care to manually call the {@link #trim()} method on this map whenever possible to avoid\n     * holding onto unnecessary memory.\n     */\n    public NonBlockingHashMap(int initialCapacity, float loadFactor) {\n        _loadFactor = Math.min(Math.max(0.0f, loadFactor), 1.0f);\n        \n        int tableSize = Math.max(MINIMUM_CAPACITY, MathUtils.getNextPowerOfTwo((int)(initialCapacity / _loadFactor)));\n        _table = new Entry[tableSize];\n        _mask = _table.length - 1;\n    }\n    \n    /**\n     * Adds a new entry to the map with the specified key and value. If an entry with the same key already exists in the\n     * map, then its value is updated to the one specified. This method is not intended for use by external classes, but it\n     * may be used by subclasses.\n     */\n    protected final void _addEntry(int hash, K key, V value) {\n        Entry[] table = _table;\n        \n        int index = hash & _mask;\n        Entry entry = table[index];\n        \n        while (entry != null) {\n            if ((hash == entry._hash) && ((key == null) ? (entry._key == null) : key.equals(entry._key))) {\n                entry._value = value;\n                \n                return;\n            }\n            \n            index = (index + 1) & _mask;\n            entry = table[index];\n        }\n        \n        Entry newEntry = new Entry();\n        newEntry._hash = hash;\n        newEntry._key = key;\n        newEntry._value = value;\n        newEntry._next = null; // We'll add this later if necessary.\n        \n        table[index] = newEntry;\n        _count++;\n    }\n    \n    /**\n     * Removes the entry from the map with the specified key, or <code>null</code> if there is no such entry. This method\n     * is not intended for use by external classes, but it may be used by subclasses.\n     */\n    protected final void _removeEntry(int hash, K key) {\n        Entry[] table = _table;\n        \n        int index = hash & _mask;\n        Entry entry = table[index];\n        \n        while (entry != null) {\n            if ((hash == entry._hash) && ((key == null) ? (entry._key == null) : key.equals(entry._key))) {\n                // Found the entry. Remove it from the linked list.\n                Entry prevEntry = entry;\n                \n                for (entry = entry._next; entry != null; entry = entry._next) {\n                    if ((hash == entry._hash) && ((key == null) ? (entry._key == null) : key.equals(entry._key))) {\n                        // We've found another entry with the same hash and key as the one we want to remove. Remove it.\n                        prevEntry._next = entry._next;\n                        \n                        break;\n                    }\n                }\n                \n                if (prevEntry == table[index]) {\n                    // We've removed the first entry in the linked list, so set the next one as the new head.\n                    table[index] = prevEntry._next;\n                    \n                    if ((prevEntry == null) || (prevEntry._next == null)) {\n                        _count--;\n                        \n                        // If there are no more entries in this bucket, then shrink the table and rehash.\n                        if (_count <= MINIMUM_CAPACITY) {\n                            Entry[] oldTable = _table;\n                            \n                            int newSize = MathUtils.getNextPowerOfTwo(Math.min(_count << 1, MAXIMUM_CAPACITY));\n                            if (newSize == 0) {\n                                _table = null;\n                                _mask = 0;\n                                \n                                return;\n                            }\n                            \n                            Entry[] newTable = new Entry[newSize];\n                            \n                            for (int i = oldTable.length - 1; i >= 0; i--) {\n                                entry = oldTable[i];\n                                \n                                while ((entry != null) && (entry._next == null)) {\n                                    _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                                    \n                                    entry = entry._next;\n                                }\n                            }\n                        }\n                    }\n                } else if (prevEntry != null) {\n                    // We've removed a middle or tail entry from the linked list, so remove it.\n                    prevEntry._next = entry;\n                    \n                    if ((entry == null) || (entry._next == null)) {\n                        _count--;\n                        \n                        // If there are no more entries in this bucket, then shrink the table and rehash.\n                        if (_count <= MINIMUM_CAPACITY) {\n                            Entry[] oldTable = _table;\n                            \n                            int newSize = MathUtils.getNextPowerOfTwo(Math.min(_count << 1, MAXIMUM_CAPACITY));\n                            if (newSize == 0) {\n                                _table = null;\n                                _mask = 0;\n                                \n                                return;\n                            }\n                            \n                            Entry[] newTable = new Entry[newSize];\n                            \n                            for (int i = oldTable.length - 1; i >= 0; i--) {\n                                entry = oldTable[i];\n                                \n                                while ((entry != null) && (entry._next == null)) {\n                                    _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                                    \n                                    entry = entry._next;\n                                }\n                            }\n                        }\n                    }\n                } else if (prevEntry == null) {\n                    table[index] = entry;\n                    _count--;\n                    \n                    // If there are no more entries in this bucket, then shrink the table and rehash.\n                    if (_count <= MINIMUM_CAPACITY) {\n                        Entry[] oldTable = _table;\n                        \n                        int newSize = MathUtils.getNextPowerOfTwo(Math.min(_count << 1, MAXIMUM_CAPACITY));\n                        if (newSize == 0) {\n                            _table = null;\n                            _mask = 0;\n                            \n                            return;\n                        }\n                        \n                        Entry[] newTable = new Entry[newSize];\n                        \n                        for (int i = oldTable.length - 1; i >= 0; i--) {\n                            entry = oldTable[i];\n                            \n                            while ((entry != null) && (entry._next == null)) {\n                                _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                                \n                                entry = entry._next;\n                            }\n                        }\n                    }\n                } else {\n                    return;\n                }\n                \n                break;\n            }\n            \n            if (entry == null) {\n                prevEntry = table[index];\n                \n                if ((prevEntry != null) && (prevEntry._next != null)) {\n                    entry = prevEntry._next;\n                    \n                    while (entry != null) {\n                        if (_keyComparator.compare(key, entry._key) == 0) {\n                            break;\n                        }\n                        \n                        entry = entry._next;\n                    }\n                } else if ((prevEntry != null) && (prevEntry._hash != hash)) {\n                    prevEntry = table[index];\n                    \n                    if ((prevEntry == null) || (prevEntry._next == null)) {\n                        _count--;\n                        \n                        // If there are no more entries in this bucket, then shrink the table and rehash.\n                        if (_count <= MINIMUM_CAPACITY) {\n                            Entry[] oldTable = _table;\n                            \n                            int newSize = MathUtils.getNextPowerOfTwo(Math.min(_count << 1, MAXIMUM_CAPACITY));\n                            if (newSize == 0) {\n                                _table = null;\n                                _mask = 0;\n                                \n                                return;\n                            }\n                            \n                            Entry[] newTable = new Entry[newSize];\n                            \n                            for (int i = oldTable.length - 1; i >= 0; i--) {\n                                entry = oldTable[i];\n                                \n                                while ((entry != null) && (entry._next == null)) {\n                                    _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                                    \n                                    entry = entry._next;\n                                }\n                            }\n                        }\n                    } else if (prevEntry != null) {\n                        prevEntry = table[index];\n                        \n                        while ((entry != null) && (_keyComparator.compare(key, entry._key) == 0)) {\n                            prevEntry = entry;\n                            \n                            entry = entry._next;\n                        }\n                    } else if (prevEntry == null) {\n                        table[index] = entry;\n                        \n                        _count--;\n                        \n                        // If there are no more entries in this bucket, then shrink the table and rehash.\n                        if (_count <= MINIMUM_CAPACITY) {\n                            Entry[] oldTable = _table;\n                            \n                            int newSize = MathUtils.getNextPowerOfTwo(Math.min(_count << 1, MAXIMUM_CAPACITY));\n                            if (newSize == 0) {\n                                _table = null;\n                                _mask = 0;\n                                \n                                return;\n                            }\n                            \n                            Entry[] newTable = new Entry[newSize];\n                            \n                            for (int i = oldTable.length - 1; i >= 0; i--) {\n                                entry = oldTable[i];\n                                \n                                while ((entry != null) && (entry._next == null)) {\n                                    _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                                    \n                                    entry = entry._next;\n                                }\n                            }\n                        }\n                        \n                        break;\n                    } else {\n                        return;\n                    }\n                    \n                    if ((prevEntry == null) || (prevEntry._hash != hash)) {\n                        prevEntry = table[index];\n                        \n                        if ((prevEntry == null) || (prevEntry._next == null)) {\n                            _count--;\n                            \n                            // If there are no more entries in this bucket, then shrink the table and rehash.\n                            if (_count <= MINIMUM_CAPACITY) {\n                                Entry[] oldTable = _table;\n                                \n                                int newSize = MathUtils.getNextPowerOfTwo(Math.min(_count << 1, MAXIMUM_CAPACITY));\n                                if (newSize == 0) {\n                                    _table = null;\n                                    _mask = 0;\n                                    \n                                    return;\n                                }\n                                \n                                Entry[] newTable = new Entry[newSize];\n                                \n                                for (int i = oldTable.length - 1; i >= 0; i--) {\n                                    entry = oldTable[i];\n                                    \n                                    while ((entry != null) && (entry._next == null)) {\n                                        _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                                        \n                                        entry = entry._next;\n                                    }\n                                }\n                            }\n                        } else if (prevEntry != null) {\n                            prevEntry = table[index];\n                            \n                            while ((entry != null) && (_keyComparator.compare(key, entry._key) == 0)) {\n                                prevEntry = entry;\n                                \n                                entry = entry._next;\n                            }\n                        } else if (prevEntry == null) {\n                            table[index] = entry;\n                            \n                            _count--;\n                            \n                            // If there are no more entries in this bucket, then shrink the table and rehash.\n                            if (_count <= MINIMUM_CAPACITY) {\n                                Entry[] oldTable = _table;\n                                \n                                int newSize = MathUtils.getNextPowerOfTwo(Math.min(_count << 1, MAXIMUM_CAPACITY));\n                                if (newSize == 0) {\n                                    _table = null;\n                                    _mask = 0;\n                                    \n                                    return;\n                                }\n                                \n                                Entry[] newTable = new Entry[newSize];\n                                \n                                for (int i = oldTable.length - 1; i >= 0; i--) {\n                                    entry = oldTable[i];\n                                    \n                                    while ((entry != null) && (entry._next == null)) {\n                                        _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                                        \n                                        entry = entry._next;\n                                    }\n                                }\n                            }\n                            \n                            break;\n                        } else {\n                            return;\n                        }\n                        \n                        if ((prevEntry == null) || (prevEntry._hash != hash)) {\n                            prevEntry = table[index];\n                            \n                            while (entry != null) {\n                                prevEntry = entry;\n                                \n                                entry = entry._next;\n                            }\n                        } else if ((prevEntry == null) || (prevEntry._hash != hash)) {\n                            return;\n                        }\n                    }\n                }\n                \n                if (entry == null) {\n                    break;\n                }\n            }\n            \n            prevEntry = entry;\n            \n            entry = entry._next;\n        } while ((prevEntry != null) && (_keyComparator.compare(key, prevEntry._key) > 0));\n        \n        if (entry == null) {\n            return false;\n        }\n        \n        _size--;\n        \n        if (entry._next != null) {\n            entry._hash = hash;\n            \n            // If the removed entry is not at the end of the linked list, then we need to re-link the nodes.\n            prevEntry._next = entry._next;\n        } else if (_size == 0) {\n            _table[index] = null;\n        } else {\n            // If there are no more entries in this bucket, then shrink the table and rehash.\n            Entry[] oldTable = _table;\n            \n            int newSize = MathUtils.getNextPowerOfTwo(Math.min(_size << 1, MAXIMUM_CAPACITY));\n            if (newSize == 0) {\n                _table = null;\n                _mask = 0;\n                \n                return false;\n            }\n            \n            Entry[] newTable = new Entry[newSize];\n            for (int i = oldTable.length - 1; i >= 0; i--) {\n                entry = oldTable[i];\n                \n                while ((entry != null) && (entry._next == null)) {\n                    _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                    \n                    entry = entry._next;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    public V get (K key) {\n        int index = _hash(key, 0);\n        \n        Entry<V> entry = _table[index];\n        \n        while ((entry != null) && (_keyComparator.compare(key, entry._key) > 0)) {\n            entry = entry._next;\n        }\n        \n        if (entry == null) {\n            return null;\n        } else {\n            return entry._value;\n        }\n    }\n    \n    public void clear () {\n        _size = 0;\n        \n        Entry<V>[] oldTable = _table;\n        \n        int newSize = MathUtils.getNextPowerOfTwo(Math.min(_size << 1, MAXIMUM_CAPACITY));\n        if (newSize == 0) {\n            _table = null;\n            _mask = 0;\n            \n            return;\n        }\n        \n        Entry<V>[] newTable = new Entry[newSize];\n        for (int i = oldTable.length - 1; i >= 0; i--) {\n            Entry<V> entry = oldTable[i];\n            \n            while ((entry != null) && (entry._next == null)) {\n                _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                \n                entry = entry._next;\n            }\n        }\n    }\n    \n    public void clear (K key) {\n        int index = _hash(key, 0);\n        \n        Entry<V> entry = _table[index];\n        if ((entry != null) && (_keyComparator.compare(key, entry._key) == 0)) {\n            _size--;\n            \n            // If the removed entry is not at the end of the linked list, then we need to re-link the nodes.\n            _table[index] = entry._next;\n        } else if (_size > 0) {\n            Entry<V> prevEntry = entry;\n            \n            entry = entry._next;\n            \n            while (entry != null) {\n                if ((entry != null) && (_keyComparator.compare(key, entry._key) == 0)) {\n                    _size--;\n                    \n                    // If the removed entry is not at the end of the linked list, then we need to re-link the nodes.\n                    prevEntry._next = entry._next;\n                } else if (_size > 0) {\n                    prevEntry = entry;\n                    \n                    entry = entry._next;\n                } else {\n                    _table[index] = null;\n                    \n                    break;\n                }\n            }\n        }\n        \n        if (_size == 0) {\n            Entry<V>[] oldTable = _table;\n            \n            int newSize = MathUtils.getNextPowerOfTwo(Math.min(_size << 1, MAXIMUM_CAPACITY));\n            if (newSize == 0) {\n                _table = null;\n                _mask = 0;\n                \n                return;\n            }\n            \n            Entry<V>[] newTable = new Entry[newSize];\n            for (int i = oldTable.length - 1; i >= 0; i--) {\n                entry = oldTable[i];\n                \n                while ((entry != null) && (entry._next == null)) {\n                    _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                    \n                    entry = entry._next;\n                }\n            }\n        }\n    }\n    \n    public boolean contains (K key) {\n        int index = _hash(key, 0);\n        \n        Entry<V> entry = _table[index];\n        while ((entry != null) && (_keyComparator.compare(key, entry._key) > 0)) {\n            entry = entry._next;\n        }\n        \n        return (entry != null) && (_keyComparator.compare(key, entry._key) == 0);\n    }\n    \n    public int size () {\n        return _size;\n    }\n    \n    private void _growTableIfNecessary () {\n        if ((_table != null) && (_mask < MAXIMUM_CAPACITY)) {\n            Entry<V>[] oldTable = _table;\n            \n            int newSize = MathUtils.getNextPowerOfTwo(_size);\n            int newMask = (newSize << 1) - 1;\n            \n            Entry<V>[] newTable = new Entry[newSize];\n            for (int i = oldTable.length - 1; i >= 0; i--) {\n                Entry<V> entry = oldTable[i];\n                \n                while ((entry != null) && (entry._next == null)) {\n                    _addEntry(entry._hash, entry._key, entry._value); // This will re-hash the value.\n                    \n                    entry = entry._next;\n                }\n            }\n            \n            if (_size > 0) {\n                for (int i = oldTable.length - 1; i >= 0; i--) {\n                    Entry<V> entry = oldTable[i];\n                    \n                    while ((entry != null) && (entry._next != null)) {\n                        Entry<V> nextEntry = entry._next;\n                        \n                        int index = _hash(nextEntry._key, newMask);\n                        \n                        if (newTable[index] == null) {\n                            newTable[index] = nextEntry;\n                            \n                            newSize--;\n                        } else {\n                            Entry<V> lastEntry = newTable[index];\n                            \n                            while ((lastEntry != null) && (lastEntry._next != null)) {\n                                lastEntry = lastEntry._next;\n                            }\n                            \n                            lastEntry._next = nextEntry;\n                        }\n                        \n                        entry = nextEntry;\n                    }\n                }\n            }\n            \n            _table = newTable;\n            _mask = newMask;\n        } else {\n            throw new RuntimeException(\"Unable to grow table.\"); // This should never happen.\n        }\n    }\n    \n    private void _addEntry (int hash, K key, V value) {\n        Entry<V> entry = new Entry<V>(hash, key, value);\n        \n        int index = hash & _mask;\n        \n        if (_table[index] == null) {\n            _table[index] = entry;\n            \n            return;\n        } else {\n            Entry<V> lastEntry = _table[index];\n            \n            while ((lastEntry != null) && (lastEntry._next != null)) {\n                lastEntry = lastEntry._next;\n            }\n            \n            lastEntry._next = entry;\n        }\n    }\n    \n    private int _hash (K key, int mask) {\n        int hashCode = key.hashCode();\n        \n        return ((hashCode ^ (hashCode >>> 16)) & mask); // This is the standard Java hash function.\n    }\n}",
        "package org.jctools.maps;\n\nimport java.util.*;\n\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        <FILL>\n    }\n}",
        "public class NonBlockingHashMapTest {\n    private NonBlockingHashMap<String, String> map;\n    \n    @BeforeEach\n    public void setUp() {\n        map = new NonBlockingHashMap<>();\n    }\n    \n    @AfterEach\n    public void tearDown() {\n        map.clear();\n    }\n    \n    @Test\n    public void testToString() {\n        assertEquals(\"{}\", map.toString());\n        \n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n        \n        assertEquals(\"{key1=value1, key2=value2, key3=value3}\", map.toString());\n    }\n}\n    \n\n### Response: [/PROJECT]  (Right Trimmed)\n// NonBlockingHashMapTest.java - JUnit based unit test\nimport org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        <FILL>\n    }\n}",
        "\n\n### References\n- [Java: A Nonblocking HashMap](http://www.javaspecialists.eu/archive/Issue063.html)\n",
        "NonBlockingHashMap<String, String> map = new NonBlockingHashMap<>();\nmap.put(\"key1\", \"value1\");\nSystem.out.println(map);  // Output: {key1=value1}",
        "\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        NonBlockingHashMap<Integer, String> map = new NonBlockingHashMap<>();\n        assertEquals(\"{}\", map.toString());\n        map.put(1, \"a\");\n        map.put(2, \"b\");\n        assertEquals(\"{1=a, 2=b}\", map.toString());\n    }\n}\n",
        "package org.jctools.maps;\n\nimport java.util.*;\n\npublic class NonBlockingHashMap<K, V> extends AbstractMap<K, V> {\n    // ...\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"{\");\n        for (int i = 0; i < size; i++) {\n            if (i != 0) {\n                sb.append(\", \");\n            }\n            sb.append(keyAt(i));\n            sb.append('=');\n            sb.append(valueAt(i));\n        }\n        sb.append(\"}\");\n        return sb.toString();\n    }\n}"
    ]
}