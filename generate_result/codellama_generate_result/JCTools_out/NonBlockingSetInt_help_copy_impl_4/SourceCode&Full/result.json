{
    "project_name": "JCTools",
    "file_name": "NonBlockingSetInt.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
    "execute_path": "JCTools",
    "package": "org.jctools.maps",
    "docstring": null,
    "source_code": "// Help copy this one word.  State Machine.\n// (1) If not \"made immutable\" in the old array, set the sign bit to make\n//     it immutable.\n// (2) If non-zero in old array & zero in new, CAS new from 0 to copy-of-old\n// (3) If non-zero in old array & non-zero in new, CAS old to zero\n// (4) Zero in old, new is valid\n// At this point, old should be immutable-zero & new has a copy of bits\nprivate NBSI help_copy_impl( int i ) {\n  // Handle every 64th bit via using a nested array\n  NBSI old = this;          // The bit array being copied from\n  NBSI nnn = _new;          // The bit array being copied to\n  if( nnn == null ) return this; // Promoted already\n  int j = i;                // The bit index being added\n  while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n    old = old._nbsi64;      // Recurse\n    nnn = nnn._nbsi64;      // Recurse\n    j = j>>6;               // Strip off low 6 bits (all set)\n  }\n\n  // Transit from state 1: word is not immutable yet\n  // Immutable is in bit 63, the sign bit.\n  long bits = old._bits[j>>6];\n  while( bits >= 0 ) {      // Still in state (1)?\n    long oldbits = bits;\n    bits |= mask(63);       // Target state of bits: sign-bit means immutable\n    if( old.CAS( j>>6, oldbits, bits ) ) {\n      if( oldbits == 0 ) _copyDone.addAndGet(1);\n      break;                // Success - old array word is now immutable\n    }\n    bits = old._bits[j>>6]; // Retry if CAS failed\n  }\n\n  // Transit from state 2: non-zero in old and zero in new\n  if( bits != mask(63) ) {  // Non-zero in old?\n    long new_bits = nnn._bits[j>>6];\n    if( new_bits == 0 ) {   // New array is still zero\n      new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n      // One-shot CAS attempt, no loop, from 0 to non-zero.\n      // If it fails, somebody else did the copy for us\n      if( !nnn.CAS( j>>6, 0, new_bits ) )\n        new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n      assert new_bits != 0;\n    }\n\n    // Transit from state 3: non-zero in old and non-zero in new\n    // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n    if( old.CAS( j>>6, bits, mask(63) ) )\n      _copyDone.addAndGet(1); // One more word finished copying\n  }\n\n  // Now in state 4: zero (and immutable) in old\n\n  // Return the self bitvector for 'fluid' programming style\n  return this;\n}\n",
    "class_name": "NonBlockingSetInt",
    "method_name": "help_copy_impl",
    "arguments": [
        "int i"
    ],
    "generate_test": [
        "\nHere is the completed test case for `help_copy_impl`:\n\nimport org.junit.jupiter.api.*;\n\npublic class NonBlockingSetIntTest {\n    @Test\n    public void help_copy_implTest() {\n        // Test 1: State 2: non-zero in old and zero in new\n        NBSI nbsi = new NBSI();\n        int idx = 0;\n        assertTrue(nbsi.help_copy_impl(idx) == nbsi);\n        assertEquals(0, nbsi._bits[0]);\n    }\n}\n\nPlease fill in the missing code and add more test cases as needed.",
        "\npackage org.jctools.maps;\n\nimport java.util.*;\nimport java.util.concurrent.atomic.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n    @Test\n    public void help_copy_implTest() {\n        NBSI nbsi = new NBSI();\n        int i = 0;\n        nbsi._nbsi64 = new NBSI(nbsi);\n        \n        // Test that we can add a word in the middle of an empty set.\n        assertTrue(nbsi.help_copy_impl(i) == nbsi, \"Expected to return self.\");\n        assertEquals(1, nbsi._sum_bits_length, \"Expected 1 word added.\");\n        \n        // Test that we can add a word in the middle of a non-empty set.\n        i = 32;\n        NBSI newNbsi = new NBSI(nbsi);\n        nbsi._nbsi64 = newNbsi;\n        assertTrue(nbsi.help_copy_impl(i) == nbsi, \"Expected to return self.\");\n        assertEquals(2, nbsi._sum_bits_length, \"Expected 1 word added.\");\n        \n        // Test that we can add a word at the end of an empty set.\n        i = Integer.MAX_VALUE;\n        newNbsi = new NBSI(nbsi);\n        nbsi._nbsi64 = newNbsi;\n        assertTrue(nbsi.help_copy_impl(i) == nbsi, \"Expected to return self.\");\n        assertEquals(3, nbsi._sum_bits_length, \"Expected 1 word added.\");\n        \n        // Test that we can add a word at the end of a non-empty set.\n        i = Integer.MAX_VALUE - 32;\n        newNbsi = new NBSI(nbsi);\n        nbsi._nbsi64 = newNbsi;\n        assertTrue(nbsi.help_copy_impl(i) == nbsi, \"Expected to return self.\");\n        assertEquals(4, nbsi._sum_bits_length, \"Expected 1 word added.\");\n    }\n}\n",
        "@Test\n  public void help_copy_implTest() {\n    // Copy from a state to another:\n    // (1) old is mutable, new is not zero and not immutable\n    // (2) old is non-zero & new is zero\n    // (3) old is non-zero & new is zero but immutable\n    // (4) old is zero & new is zero\n    //\n    // This state machine works with a nested array.  The outer array has one\n    // element for each nesting level in the array, and points to another\n    // NBSI object.  Each bit array (except the lowest-level) has a length\n    // equal to the number of bits divided by the word size.  For example, a\n    // 64-bit JVM uses NBSI's with length=8 for each outer array element.  The\n    // lowest level bit arrays are always length==1 and contain no nesting.\n    //\n    // If we have an array of length n (n<=64), then the number of words in\n    // the set is at most 2*n-1: 1 word for each bit, plus 1 extra word if the\n    // last bit is a 1.  To see this, note that the first set bit in an array\n    // of length n sets the first bit in every subarray of length <=n/2.  For\n    // example, if we start with length=8, then set bit 4 (bit index 3) will\n    // set bits 0,1,2 and 4 in every outer array element.  But bit 4 itself is\n    // not a valid bit; only 63 bits are valid.  Bit 5 will set the first 7\n    // bits of the first two subarrays (bit index 4), but no higher.\n    //\n    // This means that if we have an array with length n, and there is some set\n    // bit with bit index >=n/2 then we need 2 words to represent it.  We also\n    // need at most 2 words for any other set bit.  So the worst case is to set\n    // a single bit: in this case we need length=1, but in general we need\n    // length=2*n-1.\n    //\n    // In practice the average array has at most a few hundred bits (i.e.,\n    // less than 32 words).  To reduce the memory footprint of large sets we\n    // use an object pool to recycle old arrays when they become too small.\n    // The pool is organized by length, so it's easy to find a suitable array\n    // for a set with some number of bits in it.\n    //\n    // The help_copy_impl method is called whenever we see that the bit at an\n    // index has changed from zero (state 1) to non-zero.  It's also called\n    // when the bit at an index is already non-zero and becomes zero (state 2).\n    // This is a bit tricky, since it means we have to copy from one state to\n    // another:\n    // (1) old is mutable, new is not zero and not immutable\n    // (2) old is non-zero & new is zero\n    // (3) old is non-zero & new is zero but immutable\n    // (4) old is zero & new is zero\n    NBSI x = nbsi.help_copy_impl(1);\n    assertNotNull(x);\n  }",
        "This method is quite complex and it would be better to split this into smaller testable methods.\nAdditionally, you can also use the JUnit5 Parameterized Test feature to make the tests more readable and less error-prone.\nHere's an example of how you could restructure this code:\n\n    @ParameterizedTest\n    @MethodSource(\"help_copy_impl_args\")\n    public void help_copy_impl(NBSI nbsi, int i, NBSI expected) {\n        // Act\n        NBSI result = nbsi.help_copy_impl(i);\n        \n        // Assert\n        assertEquals(expected, result);\n    }\n    \n    @Test\n    public void test_print() {\n        <FILL>\n    }\n}",
        "NBSI nbsi = new NBSI(4);\nnbsi.help_copy_impl(2);\n// Expected output: NBSI - _bits.len=5 1976392\n\n<FILL>\n",
        "@Test\npublic void help_copy_implTest() {\n  // Create the bitset\n  NonBlockingSetInt nbsi = new NonBlockingSetInt(128);\n  assertTrue(nbsi.help_copy_impl(64) instanceof NBSI);\n}\n    \n### Response:",
        "package org.jctools.maps;\nimport java.util.*;\npublic class NonBlockingSetIntTest {\n  @Test public void help_copy_implTest() {\n    NBSI nbsi = new NBSI();\n    int i0 = 42;\n    assertTrue(nbsi.help_copy_impl(i0) == nbsi); // Return self for fluid programming\n    NBSI _new = nbsi._new; // New array must be made\n    long[] bits = _new._bits;\n    int len = bits.length, j = i0>>6;\n    while( j > 0 ) {\n      assertEquals(0L, bits[--j]); // All words in new array are zero\n    }\n    // First word in the 'new' is non-zero since help_copy_impl should have set bit #42.\n    assertNotEquals(0L, bits[i0>>6]);\n  }\n}\n    \n",
        "    @Test\n    public void test_help_copy_impl() {\n      NBSI nbsi = new NBSI();\n      for (int i = 0; i < 128; i++) { // Set bits\n        assertEquals(i, nbsi.size());\n        assertTrue(nbsi.add(i));\n        if ((i & 63) == 63) {         // Bit 63? (low 6 bits are all set)\n          assertEquals(1, nbsi._copyIdx.get());    // Copy idx should be 1\n          assertEquals(0, nbsi._copyDone.get());   // No copy done yet\n        }\n      }\n      \n      for (int i = 0; i < 256; i++) { // Clear bits\n        if ((i & 63) == 0) continue;  // Skip clearing bit 0 of each word\n        assertEquals(128 - i, nbsi.size());\n        assertTrue(nbsi.remove((char)i));\n      }\n    }\n\n### JUNIT Test case:\npackage org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n    @Test\n    public void test_help_copy_impl() {\n      <FILL>\n    }\n}\n    \n\n### Response:",
        "@Test\npublic void help_copy_implTest() {\n    final int N = 1024; // Maximum number of bits to test\n\n    NonBlockingSetInt nbs = new NonBlockingSetInt();\n    for (int i = 0; i < N; ++i) {\n        assertFalse(nbs.contains(i));\n        assertTrue(nbs.add(i));\n        assertTrue(nbs.contains(i));\n        nbs.help_copy_impl(i);\n    }\n}",
        "package org.jctools.maps;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NonBlockingSetIntTest {\n    @Test\n    public void help_copy_implTest() {\n        // Create some empty bit arrays (64 bits each) and link them together\n        NBSI old = new NBSI(0, 1);\n        NBSI newOne = new NBSI(0, 2);\n        NBSI nnn = new NBSI(old._bits[0], null);\n\n        // Set some bits in the old array and verify they are copied to the new array\n        assertTrue(old.set(1));\n        assertFalse(old.set(1));\n        assertEquals(newOne._nbsi64._bits[0], 2L << 1);\n    }\n}"
    ]
}