{
    "project_name": "Java",
    "file_name": "ArrayCombination.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Find all combinations of 1..n by creating an array and using backtracking in Combination.java\n     * @param n max value of the array.\n     * @param k length of combination\n     * @return a list of all combinations of length k. If k == 0, return null.\n     */",
    "source_code": "\npublic static List<TreeSet<Integer>> combination(int n, int k) {\n    if (n <= 0) {\n        return null;\n    }\n    length = k;\n    Integer[] arr = new Integer[n];\n    for (int i = 1; i <= n; i++) {\n        arr[i - 1] = i;\n    }\n    return Combination.combination(arr, length);\n}\n",
    "class_name": "ArrayCombination",
    "method_name": "combination",
    "arguments": [
        "int n",
        "int k"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        int n = 4;\n        int k = 2;\n        List<TreeSet<Integer>> actualOutput = ArrayCombination.combination(n, k);\n        \n        // Expected output: [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n        List<TreeSet<Integer>> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new TreeSet<>(Arrays.asList(1, 2)));\n        expectedOutput.add(new TreeSet<>(Arrays.asList(1, 3)));\n        expectedOutput.add(new TreeSet<>(Arrays.asList(1, 4)));\n        expectedOutput.add(new TreeSet<>(Arrays.asList(2, 3)));\n        expectedOutput.add(new TreeSet<>(Arrays.asList(2, 4)));\n        expectedOutput.add(new TreeSet<>(Arrays.asList(3, 4)));\n        \n        assertEquals(expectedOutput, actualOutput);\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        int n = 5, k = 3;\n        List<TreeSet<Integer>> result = ArrayCombination.combination(n, k);\n        assertNotNull(result);\n        for (int i = 0; i < result.size(); i++) {\n            TreeSet<Integer> set = result.get(i);\n            assertEquals(k, set.size());\n            for (Integer element : set) {\n                assertTrue(element >= 1 && element <= n);\n            }\n        }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        int n = 4; // Input array length\n        int k = 3; // Combination length\n        List<TreeSet<Integer>> actual = ArrayCombination.combination(n, k);\n        \n        // Expected output:\n        // [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]\n        List<TreeSet<Integer>> expected = new ArrayList<>();\n        TreeSet<Integer> set = new TreeSet<>();\n        set.add(1);\n        set.add(2);\n        set.add(3);\n        expected.add(set);\n        set = new TreeSet<>();\n        set.add(1);\n        set.add(2);\n        set.add(4);\n        expected.add(set);\n        set = new TreeSet<>();\n        set.add(1);\n        set.add(3);\n        set.add(4);\n        expected.add(set);\n        set = new TreeSet<>();\n        set.add(2);\n        set.add(3);\n        set.add(4);\n        expected.add(set);\n        \n        assertEquals(expected, actual);\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport java.util.*;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        int n = 5;\n        int k = 3;\n        List<TreeSet<Integer>> expected = new ArrayList<>();\n        TreeSet<Integer> set1 = new TreeSet<>();\n        set1.add(1);\n        set1.add(2);\n        set1.add(3);\n        TreeSet<Integer> set2 = new TreeSet<>();\n        set2.add(1);\n        set2.add(4);\n        set2.add(5);\n        expected.add(set1);\n        expected.add(set2);\n\n        List<TreeSet<Integer>> actual = ArrayCombination.combination(n, k);\n\n        assertEquals(expected, actual);\n    }\n}",
        "@Test\npublic void combinationTest() {\n    int n = 5;\n    int k = 3;\n    List<TreeSet<Integer>> result = ArrayCombination.combination(n, k);\n    assertEquals(10, result.size());\n    for (int i = 0; i < result.size(); i++) {\n        TreeSet<Integer> set = result.get(i);\n        assertEquals(k, set.size());\n        int[] arr = new int[k];\n        int j = 0;\n        for (Integer num : set) {\n            arr[j++] = num;\n        }\n        Arrays.sort(arr);\n        if (i == 0) {\n            assertArrayEquals(new int[]{1, 2, 3}, arr);\n        } else if (i == 1) {\n            assertArrayEquals(new int[]{1, 2, 4}, arr);\n        } else if (i == 2) {\n            assertArrayEquals(new int[]{1, 3, 4}, arr);\n        } else if (i == 3) {\n            assertArrayEquals(new int[]{2, 3, 4}, arr);\n        } else if (i == 4) {\n            assertArrayEquals(new int[]{1, 5, 6}, arr);\n        } else if (i == 5) {\n            assertArrayEquals(new int[]{2, 5, 6}, arr);\n        } else if (i == 6) {\n            assertArrayEquals(new int[]{3, 5, 6}, arr);\n        } else if (i == 7) {\n            assertArrayEquals(new int[]{4, 5, 6}, arr);\n        } else if (i == 8) {\n            assertArrayEquals(new int[]{1, 7, 8}, arr);\n        } else if (i == 9) {\n            assertArrayEquals(new int[]{2, 7, 8}, arr);\n        }\n    }\n}",
        "@Test\npublic void combinationTest() {\n    int n = 5;\n    int k = 3;\n    List<TreeSet<Integer>> result = ArrayCombination.combination(n, k);\n    assertEquals(10, result.size());\n}",
        "\n@Test\npublic void combinationTest() {\n    // Arrange\n    int n = 5;\n    int k = 3;\n    List<TreeSet<Integer>> expectedCombinations = new ArrayList<>();\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(1, 2, 3)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(1, 2, 4)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(1, 2, 5)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(1, 3, 4)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(1, 3, 5)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(1, 4, 5)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(2, 3, 4)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(2, 3, 5)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(2, 4, 5)));\n    expectedCombinations.add(new TreeSet<>(Arrays.asList(3, 4, 5)));\n    \n    // Act\n    List<TreeSet<Integer>> actualCombinations = ArrayCombination.combination(n, k);\n    \n    // Assert\n    assertEquals(expectedCombinations, actualCombinations);\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        // Test case 1: n = 0, k = 1\n        int n = 0;\n        int k = 1;\n        List<TreeSet<Integer>> actual = ArrayCombination.combination(n, k);\n        assertEquals(actual.size(), 1); // Expected size of output list is 1\n        TreeSet<Integer> expected = new TreeSet<>();\n        expected.add(0);\n        assertEquals(expected, actual.get(0)); // Expected output is a single-element TreeSet containing the value 0\n\n        // Test case 2: n = 3, k = 2\n        n = 3;\n        k = 2;\n        actual = ArrayCombination.combination(n, k);\n        assertEquals(actual.size(), 6); // Expected size of output list is 6\n        expected = new TreeSet<>();\n        expected.add(0);\n        expected.add(1);\n        assertTrue(actual.contains(expected)); // Expected output contains the element [0, 1]\n    }\n}\n",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        int n = 3;\n        int k = 2;\n        List<TreeSet<Integer>> result = ArrayCombination.combination(n, k);\n        assertEquals(result.size(), 10);\n        \n        // Test case 1: [1,2]\n        TreeSet<Integer> expected = new TreeSet<>();\n        expected.add(1);\n        expected.add(2);\n        assertTrue(result.contains(expected));\n        \n        // Test case 2: [1,3]\n        expected = new TreeSet<>();\n        expected.add(1);\n        expected.add(3);\n        assertTrue(result.contains(expected));\n        \n        // Test case 3: [2,3]\n        expected = new TreeSet<>();\n        expected.add(2);\n        expected.add(3);\n        assertTrue(result.contains(expected));\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        // Test case 1: n = 0, k = 2\n        int n = 0;\n        int k = 2;\n        List<TreeSet<Integer>> result = ArrayCombination.combination(n, k);\n        assertNull(result);\n\n        // Test case 2: n = 1, k = 2\n        n = 1;\n        k = 2;\n        result = ArrayCombination.combination(n, k);\n        assertEquals(1, result.size());\n        TreeSet<Integer> expectedResult = new TreeSet<>();\n        expectedResult.add(1);\n        assertTrue(result.contains(expectedResult));\n\n        // Test case 3: n = 2, k = 3\n        n = 2;\n        k = 3;\n        result = ArrayCombination.combination(n, k);\n        assertEquals(3, result.size());\n        expectedResult = new TreeSet<>();\n        expectedResult.add(1);\n        expectedResult.add(2);\n        assertTrue(result.contains(expectedResult));\n    }\n}"
    ]
}