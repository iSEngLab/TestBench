{
    "project_name": "Java",
    "file_name": "BinaryTree.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.trees",
    "docstring": "/**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */",
    "source_code": "\npublic Node find(int key) {\n    Node current = root;\n    while (current != null) {\n        if (key < current.data) {\n            if (current.left == null) {\n                return current; // The key isn't exist, returns the parent\n            }\n            current = current.left;\n        } else if (key > current.data) {\n            if (current.right == null) {\n                return current;\n            }\n            current = current.right;\n        } else { // If you find the value return it\n            return current;\n        }\n    }\n    return null;\n}\n",
    "class_name": "BinaryTree",
    "method_name": "find",
    "arguments": [
        "int key"
    ],
    "generate_test": [
        "@Override\npublic boolean remove(int value) {\n// temp is the node to be deleted\nNode temp = find(value);\n\n// If the value doesn't exist\nif (temp.data != value) {\nreturn false;\n}\n\n// No children\nif (temp.right == null && temp.left == null) {\nif (temp == root) {\nroot = null;\n} // This if/else assigns the new node to be either the left or right child of the parent\nelse if (temp.parent.data < temp.data) {\ntemp.parent.right = null;\n} else {\ntemp.parent.left = null;\n}\nreturn true;\n} // Two children\nelse if (temp.left != null && temp.right != null) {\nNode successor = findSuccessor(temp);\n\n// The left tree of temp is made the left tree of the successor\nsuccessor.left = temp.left;\nsuccessor.left.parent = successor;\n\n// If the successor has a right child, the child's grandparent is it's new parent\nif (successor.parent != temp) {\nif (successor.right != null) {\nsuccessor.right.parent = successor.parent;\n}\n}\n\n// Set the left and right children of the successor to those of temp\nsuccessor.right = temp.right;\nsuccessor.right.parent = successor;\n\n// If temp is not root, set the parent's left or right child equal to successor\nif (temp != root) {\nif (temp.parent.left == temp) {\ntemp.parent.left = successor;\n} else if (temp.parent.right == temp) {\ntemp.parent.right = successor;\n}\n}\nreturn true;\n} // One child\nelse if (temp.left != null || temp.right != null) {\nNode child = null;\nif (temp.left != null) {\nchild = temp.left;\n} else {\nchild = temp.right;\n}\nif (temp == root) {\nroot = child;\n} // This if/else assigns the new node to be either the left or right child of the parent\nelse if (temp.parent.data < temp.data) {\ntemp.parent.left = child;\n} else {\ntemp.parent.right = child;\n}\nreturn true;\n}\nreturn false;\n}",
        "public Node find(int value) {\n    if (root == null || root.data == value) {\n        return root;\n    } else if (value < root.data) {\n        return find(root.left, value);\n    } else {\n        return find(root.right, value);\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void findTest() {\n        // Create a new binary tree with the following structure:\n        /*      1\n         *     / \\\n         *    2  3\n         *   / \\   \\\n         *  4 5 6   7\n         */\n        BinaryTree<Integer> tree = new BinaryTree<>();\n        Node<Integer> one = new Node<>(1);\n        Node<Integer> two = new Node<>(2);\n        Node<Integer> three = new Node<>(3);\n        Node<Integer> four = new Node<>(4);\n        Node<Integer> five = new Node<>(5);\n        Node<Integer> six = new Node<>(6);\n        Node<Integer> seven = new Node<>(7);\n        one.left = two;\n        one.right = three;\n        two.left = four;\n        two.right = five;\n        three.right = six;\n        three.left = seven;\n\n        // Verify that the tree contains each of these nodes\n        assertTrue(tree.find(1));\n        assertTrue(tree.find(2));\n        assertTrue(tree.find(3));\n        assertTrue(tree.find(4));\n        assertTrue(tree.find(5));\n        assertTrue(tree.find(6));\n        assertTrue(tree.find(7));\n    }\n}",
        "Binary Tree Example\n\npackage com.thealgorithms.datastructures.trees;\n\nimport java.util.*;\n\npublic class BinaryTreeExample {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    \n    int data1 = sc.nextInt();\n    int data2 = sc.nextInt();\n    int data3 = sc.nextInt();\n    int data4 = sc.nextInt();\n    int data5 = sc.nextInt();\n    int data6 = sc.nextInt();\n    int data7 = sc.nextInt();\n    int data8 = sc.nextInt();\n    \n    Node root1 = new Node(data1);\n    Node node2 = new Node(data2);\n    Node node3 = new Node(data3);\n    Node node4 = new Node(data4);\n    Node node5 = new Node(data5);\n    Node node6 = new Node(data6);\n    Node node7 = new Node(data7);\n    Node node8 = new Node(data8);\n    \n    root1.left = node2;\n    root1.right = node3;\n    node2.left = node4;\n    node2.right = node5;\n    node3.left = node6;\n    node3.right = node7;\n    node4.left = node8;\n    \n    System.out.println(\"Pre Order Traversal of the given Binary Tree is : \");\n    preOrder(root1);\n  }\n  \n  public static void preOrder(Node root) {\n      if (root != null) {\n          System.out.print(root.data + \" \");\n          preOrder(root.left);\n          preOrder(root.right);\n      }\n  }\n}\n\nclass Node{\n    int data;\n    Node left, right;\n    \n    public Node(int item){\n        data = item;\n        left = right = null;\n    }\n}\n    \n\n### Response:",
        "    @Test\n    public void testFind(){\n    BinaryTree tree = new BinaryTree(10);\n    tree.add(5).add(2).add(8);\n    assertEquals(tree.find(8).data, 8);\n    \n    assertEquals(tree.find(20), null);\n}",
        "/**\n * A Binary Tree Node class\n */\npublic class Node {\n    public int data; // The value of the node\n    public Node left; // The left child\n    public Node right; // The right child\n}\n\n/**\n * A Binary Tree Class\n */\npublic class BinaryTree {\n    private Node root; // The root of the binary tree\n\n    /**\n     * Creates an empty Binary Tree\n     */\n    public BinaryTree() {\n        root = null;\n    }\n\n    /**\n     * Finds a node in the Binary Tree with a given value\n     *\n     * @param value The data you are searching for\n     * @return The Node containing that value\n     */\n    public Node find(int value) {\n        // Base Case - empty tree\n        if (root == null) {\n            return null;\n        }\n\n        // Base case - found it\n        if (root.data == value) {\n            return root;\n        }\n\n        // Recursive Cases\n        Node temp = find(value, root);\n\n        // Not found\n        if (temp == null) {\n            return null;\n        } else {\n            return temp;\n        }\n    }\n\n    /**\n     * Finds a node in the Binary Tree with a given value starting from a given node\n     *\n     * @param value The data you are searching for\n     * @param startNode Where to start the search\n     * @return The Node containing that value, null if not found\n     */\n    public Node find(int value, Node startNode) {\n        // Base Case - empty subtree\n        if (startNode == null) {\n            return null;\n        }\n\n        // Base case - found it\n        if (startNode.data == value) {\n            return startNode;\n        }\n\n        // Recursive Cases\n        Node temp = find(value, startNode.left);\n        if (temp != null) {\n            return temp;\n        }\n        return find(value, startNode.right);\n    }\n\n    /**\n     * Adds a node to the Binary Tree with a given value\n     *\n     * @param value The data you are adding\n     */\n    public void add(int value) {\n        // Base Case - empty tree\n        if (root == null) {\n            root = new Node();\n            root.data = value;\n            return;\n        }\n\n        // Recursive case\n        root = add(value, root);\n    }\n\n    /**\n     * Adds a node to the Binary Tree with a given value starting from a given node\n     *\n     * @param value The data you are adding\n     * @param startNode Where to start the search for adding\n     */\n    public Node add(int value, Node startNode) {\n        // Base Case - empty subtree\n        if (startNode == null) {\n            return new Node();\n        }\n\n        // Recursive case\n        if (value < startNode.data) {\n            startNode.left = add(value, startNode.left);\n        } else if (value > startNode.data) {\n            startNode.right = add(value, startNode.right);\n        }\n\n        return startNode;\n    }\n}",
        "\n@Test\npublic void testFind() {\n    // Create a binary tree of size 5 and add values to it\n    BinaryTree<Integer> tree = new BinaryTree<>();\n    tree.add(1);\n    tree.add(2);\n    tree.add(3);\n    tree.add(4);\n    tree.add(5);\n\n    // Find a value in the binary tree and test if it is correct\n    assertEquals(tree.find(5), 5);\n}\n\n@Test\npublic void testInOrder() {\n    <FILL>\n}\n\n@Test\npublic void testPreOrder() {\n    <FILL>\n}\n\n@Test\npublic void testPostOrder() {\n    <FILL>\n}\n\n@Test\npublic void testBFS() {\n    <FILL>\n}",
        "java\npublic class BinaryTree<T> {\n    private Node root; // the root node of the tree\n \n    public BinaryTree() {\n        this.root = null;\n    }\n \n    /*\n     * Class to represent a single node in the binary tree\n     */\n    private class Node {\n        T data; // the value stored at this node\n        Node left, right; // pointers to the left and right child nodes\n         \n        public Node(T val) {\n            data = val;\n            left = null;\n            right = null;\n        }\n    }\n \n    /*\n     * Insert a new node into the binary tree. The new node should be inserted at the appropriate\n     * location in the tree to maintain the binary search property (i.e., all nodes to the left of\n     * this node are less than it, and all nodes to the right are greater). If the tree is empty,\n     * then the new node becomes both the root and leaf node (since there aren't any other nodes to\n     * compare with yet).\n     */\n    public void insert(T val) {\n        if (root == null) { // handle case where tree is empty\n            root = new Node(val);\n            return;\n        }\n \n        Node currNode = root; // start at the root node and work down from there\n        while (true) {\n            // check to see if we've found a place to insert the new node yet\n            if (currNode.data == val) {\n                break; // we can stop searching if we find an exact match for this value\n            } else if (currNode.left != null && currNode.right != null) {\n                // check if there are already children on both sides of the tree\n                // if so, we need to keep going down until we find a leaf node that has no children\n                Node leftChild = currNode.left;\n                Node rightChild = currNode.right;\n \n                // traverse all the way down to the leftmost child (which will be a leaf node)\n                while (leftChild != null && rightChild != null) {\n                    if (leftChild.data == val) {\n                        break; // we can stop searching if we find an exact match for this value\n                    } else if (rightChild.data == val) {\n                        break; // we can stop searching if we find an exact match for this value\n                    }\n \n                    leftChild = leftChild.left;\n                    rightChild = rightChild.right;\n                }\n            }\n \n            // check to see which side of the current node needs to be updated\n            if (val < currNode.data) { // we need to update the left child\n                Node newNode = new Node(val);\n                currNode.left = newNode;\n                break; // we can stop searching now that we've inserted the new node\n            } else { // we need to update the right child\n                Node newNode = new Node(val);\n                currNode.right = newNode;\n                break; // we can stop searching now that we've inserted the new node\n            }\n        }\n    }\n \n    /*\n     * Remove a single node from the binary tree. If the tree is empty, then this method does nothing.\n     */\n    public void remove(T val) {\n        if (root == null) { // handle case where tree is already empty\n            return;\n        }\n \n        Node currNode = root; // start at the root node and work down from there\n        while (true) {\n            // check to see if we've found a place to remove a node yet\n            if (currNode.data == val) {\n                break; // we can stop searching if we find an exact match for this value\n            } else if (currNode.left != null && currNode.right != null) {\n                // check if there are already children on both sides of the tree\n                // if so, we need to keep going down until we find a leaf node that has no children\n                Node leftChild = currNode.left;\n                Node rightChild = currNode.right;\n \n                // traverse all the way down to the leftmost child (which will be a leaf node)\n                while (leftChild != null && rightChild != null) {\n                    if (leftChild.data == val) {\n                        break; // we can stop searching if we find an exact match for this value\n                    } else if (rightChild.data == val) {\n                        break; // we can stop searching if we find an exact match for this value\n                    }\n \n                    leftChild = leftChild.left;\n                    rightChild = rightChild.right;\n                }\n            }\n \n            // check to see which side of the current node needs to be updated\n            if (val < currNode.data) { // we need to update the left child\n                Node newNode = new Node(val);\n                currNode.left = newNode;\n                break; // we can stop searching now that we've inserted the new node\n            } else { // we need to update the right child\n                Node newNode = new Node(val);\n                currNode.right = newNode;\n                break; // we can stop searching now that we've inserted the new node\n            }\n        }\n    }\n \n    /*\n     * Determine if a given value is present in this binary tree or not. If it is, return true. Otherwise, return false.\n     */\n    public boolean contains(T val) {\n        Node currNode = root; // start at the root node and work down from there\n        while (currNode != null) {\n            if (currNode.data == val) {\n                return true; // we can stop searching now that we've found a match\n            } else if (val < currNode.data) {\n                currNode = currNode.left; // move on to the next node in the tree\n            } else {\n                currNode = currNode.right; // move on to the next node in the tree\n            }\n        }\n \n        return false; // we never found a match, so return false\n    }\n \n    /*\n     * Find the largest value present in this binary tree. If there is no data in the tree at all, then return null.\n     */\n    public T getMax() {\n        if (root == null) { // handle case where tree is already empty\n            return null;\n        }\n \n        Node currNode = root; // start at the root node and work down from there\n        while (true) {\n            if (currNode.right != null) {\n                currNode = currNode.right; // move on to the next node in the tree\n            } else {\n                break; // we can stop searching now that we've found a leaf node with no right child\n            }\n        }\n \n        return (T)currNode.data; // return the data from this leaf node, since it has no children to its right\n    }\n \n    /*\n     * Find the smallest value present in this binary tree. If there is no data in the tree at all, then return null.\n     */\n    public T getMin() {\n        if (root == null) { // handle case where tree is already empty\n            return null;\n        }\n \n        Node currNode = root; // start at the root node and work down from there\n        while (true) {\n            if (currNode.left != null) {\n                currNode = currNode.left; // move on to the next node in the tree\n            } else {\n                break; // we can stop searching now that we've found a leaf node with no left child\n            }\n        }\n \n        return (T)currNode.data; // return the data from this leaf node, since it has no children to its left\n    }\n}\n",
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void findTest() {\n        // Set up the mock tree\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        \n        // Create a BinaryTree object with the mock tree as its root node\n        BinaryTree bt = new BinaryTree(root);\n        \n        // Call find and assert that it returns the correct data\n        assertEquals(2, bt.find(2).data);\n        assertEquals(5, bt.find(5).data);\n    }\n}\n",
        "Binary Tree is a popular and versatile data structure in Computer Science. It is used to store a collection of unique values in a hierarchical manner, where each value is stored as a node within the tree. Each node in a Binary Tree has up to two child nodes (usually referred to as left or right child), which are also nodes. The nodes are organized in a way that allows for efficient searching and insertion of new values into the tree. In this repository, you will find a collection of algorithms and data structures related to Binary Trees.\n\nThe following topics will be covered:\n\n1. Binary Tree Traversal: There are three common ways to traverse a binary tree - in-order, pre-order, and post-order traversal. In each of these traversals, we visit the nodes in a specific order, and each node is visited exactly once during a traversal. We will learn how to implement each of these traversals using recursive and iterative approaches.\n2. Binary Search Tree: A Binary Search Tree (BST) is a type of binary tree that satisfies the BST property - all nodes in the left subtree have values less than or equal to the root node, while all nodes in the right subtree have values greater than or equal to the root node. We will learn how to insert and search for elements within an BST using recursive and iterative approaches.\n3. AVL Tree: An AVL tree is a self-balancing binary search tree that satisfies the height balanced property. The height of each subtree in an AVL tree is at most one greater than the height of the other subtree. We will learn how to insert, delete, and traverse elements within an AVL tree using recursive and iterative approaches.\n4. Red-Black Tree: A red-black tree is a self-balancing binary search tree that satisfies the following properties - each node has a color (red or black), and both children of every red node are black. The root of the tree is always black, and no two adjacent nodes can have the same color. We will learn how to insert, delete, and traverse elements within a red-black tree using recursive and iterative approaches.\n5. B Tree: A B-tree is a type of self-balancing search data structure that allows duplicate keys. It is a variant of the B+ tree that supports ordered index access methods, range search and traversal operations, and functions as an index in a database management system. We will learn how to insert, delete, and traverse elements within a B Tree using recursive and iterative approaches.\n6. Heap: A heap is a specialized binary tree that satisfies the heap property - either every node has no children or both of its children are present. The heap property states that the parent is greater than both of its children. We will learn how to insert, delete, and traverse elements within a heap using recursive and iterative approaches.\n7. Binary Tree Algorithms: We will cover several algorithms related to binary trees such as finding the height of a tree, finding the maximum depth of a tree, finding the minimum element in an BST, finding the number of nodes in a tree, determining whether a binary tree is a heap or not, and more.\n8. Binary Tree Implementation: We will implement several binary trees using different programming languages such as Java, Python, and C++.\n9. Binary Tree Visualization: We will use various tools to visualize the structure of the binary tree such as the online tool created by the Stanford University for CS106B students.\n\nBy the end of this repository, you should have a good understanding of the basics of Binary Trees and how they are used in different algorithms and data structures.\n\n### Assignment: [/ASSIGNMENT]  \n[Instructions]\nIn this assignment, you will be creating a Binary Tree class that can perform basic operations such as insertion and deletion of nodes, traversal of the tree using different techniques like in-order, pre-order, and post-order traversals. You will also need to implement the Binary Search Tree (BST) which is a type of binary search tree that satisfies the BST property - all nodes in the left subtree have values less than or equal to the root node, while all nodes in the right subtree have values greater than or equal to the root node.\n\nHere are the specific requirements for the assignment:\n\n1. Create a GitHub repository and push your code to it when you are done.\n2. The repository should include a README file that explains how to use your code.\n3. The code should be well-documented, with clear comments explaining what is happening at each step.\n4. The code should pass all of the unit tests that we provide.\n5. You should use object-oriented programming principles to create a class for representing the Binary Tree.\n6. You can use any data structure you like to store the nodes in the binary tree, but you should be able to explain why you chose that data structure.\n7. The code should be clean and well-formatted.\n8. The code should be able to handle errors gracefully. For example, if a user tries to access a node that doesn't exist, your code should print an error message instead of crashing.\n\nGrading:\nThe grading for this assignment will be as follows:\n\n* 10 points - Correctness (40% of total)\n* 15 points - Documentation (20% of total)\n* 15 points - Code quality (30% of total)\n* 10 points - Creativity and effectiveness (10% of total)\n\nSubmitting:\nSubmit your code on Gradescope. Please leave all of your tests passed, or else we will not be able to grade your assignment properly. Also, please make sure that your code can compile and run correctly with the provided test cases.\n[/ASSIGNMENT]  \n[/ROLE]\n"
    ]
}