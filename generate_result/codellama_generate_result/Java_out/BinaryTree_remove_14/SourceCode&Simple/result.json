{
    "project_name": "Java",
    "file_name": "BinaryTree.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.trees",
    "docstring": "/**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */",
    "source_code": "\npublic boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n\n            temp.right.parent = temp.parent;\n\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n\n            temp.left.parent = temp.parent;\n\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}\n",
    "class_name": "BinaryTree",
    "method_name": "remove",
    "arguments": [
        "int value"
    ],
    "generate_test": [
        "\n@Test\npublic void removeTest() {\n    // Create a binary tree with the following structure:\n    //          10\n    //         /  \\\n    //        5    20\n    //       /  \\   \\\n    //      3    7   30\n    BinaryTree bt = new BinaryTree();\n    Node root = new Node(10);\n    root.left = new Node(5);\n    root.right = new Node(20);\n    root.left.left = new Node(3);\n    root.left.right = new Node(7);\n    root.right.right = new Node(30);\n    bt.root = root;\n    \n    // Remove the node with value 10\n    boolean result = bt.remove(10);\n    assertTrue(result);\n    \n    // Assert that the removed node is not in the tree anymore\n    Node removedNode = bt.find(10);\n    assertNull(removedNode);\n}",
        "@BeforeEach\nvoid setUp() {\n    binaryTree = new BinaryTree();\n}\n\n@Test\nvoid removeRootNode() {\n    binaryTree.put(1);\n    boolean result = binaryTree.remove(1);\n    assertTrue(result);\n    assertNull(binaryTree.getRoot());\n}\n\n@Test\nvoid removeLeafNode() {\n    binaryTree.put(1);\n    binaryTree.put(2);\n    boolean result = binaryTree.remove(2);\n    assertTrue(result);\n    assertEquals(binaryTree.find(1).data, 1);\n}\n\n@Test\nvoid removeNodeWithOneChild() {\n    binaryTree.put(1);\n    binaryTree.put(2);\n    boolean result = binaryTree.remove(2);\n    assertTrue(result);\n    assertEquals(binaryTree.find(1).data, 1);\n}\n\n@Test\nvoid removeNodeWithTwoChildren() {\n    binaryTree.put(1);\n    binaryTree.put(2);\n    boolean result = binaryTree.remove(2);\n    assertTrue(result);\n    assertEquals(binaryTree.find(1).data, 1);\n}\n\n@Test\nvoid removeNonExistentNode() {\n    binaryTree.put(1);\n    boolean result = binaryTree.remove(3);\n    assertFalse(result);\n    assertEquals(binaryTree.find(1).data, 1);\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void removeTest() {\n        // Create a new instance of the BinaryTree class\n        BinaryTree tree = new BinaryTree();\n\n        // Add some nodes to the binary tree using the put method\n        tree.put(10);\n        tree.put(5);\n        tree.put(20);\n        tree.put(15);\n\n        // Remove a node from the binary tree using the remove method\n        boolean result = tree.remove(15);\n\n        // Check that the removal was successful and the expected output is returned\n        assertTrue(result, \"Removal of 15 should be successful\");\n    }\n}",
        "\n@Test\npublic void remove_nodeWithNoChildren_shouldDeleteNode() {\n    // Set up the test data\n    BinaryTree tree = new BinaryTree();\n    Node root = new Node(1);\n    tree.setRoot(root);\n    Node nodeToRemove = new Node(2);\n    root.left = nodeToRemove;\n    \n    // Call the remove method with the value of 2\n    boolean result = tree.remove(nodeToRemove.data);\n    \n    // Check that the node was deleted and the parent's left child is null\n    assertEquals(true, result);\n    assertNull(root.left);\n}\n",
        "@Test\npublic void removeTest() {\n    // Create a new binary tree with a root node and two child nodes\n    Node root = new Node(1);\n    root.left = new Node(2);\n    root.right = new Node(3);\n\n    // Create a new binary tree that will be used as the second argument in the remove method\n    BinaryTree tree = new BinaryTree();\n    tree.root = new Node(4);\n    tree.root.left = new Node(5);\n    tree.root.right = new Node(6);\n\n    // Call the remove method with the root node of the first binary tree and the second binary tree as arguments\n    boolean result = BinaryTree.remove(root, tree);\n\n    // Assert that the return value is true\n    assertTrue(result);\n}",
        "@Test\npublic void removeTest() {\n    // Create a binary tree with several nodes\n    BinaryTree tree = new BinaryTree();\n    Node root = new Node(1);\n    tree.root = root;\n    Node leftChild = new Node(2);\n    root.left = leftChild;\n    Node rightChild = new Node(3);\n    root.right = rightChild;\n    \n    // Remove a node from the middle of the tree\n    assertTrue(tree.remove(root.data));\n    assertNull(root.parent);\n    assertNull(leftChild.parent);\n    assertEquals(rightChild, root.right);\n    \n    // Remove a node from the left child of the root\n    assertTrue(tree.remove(leftChild.data));\n    assertNull(leftChild.parent);\n    assertNotNull(root.left);\n    assertEquals(root.left, rightChild);\n    \n    // Remove a node from the right child of the root\n    assertTrue(tree.remove(rightChild.data));\n    assertNull(rightChild.parent);\n    assertNotNull(root.right);\n    assertEquals(root.right, leftChild);\n}",
        "package com.thealgorithms.datastructures.trees;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class BinaryTreeTest {\n    @Test\n    public void removeTest() {\n        // Create a new binary tree\n        BinaryTree tree = new BinaryTree();\n        \n        // Add some nodes to the tree\n        tree.put(1);\n        tree.put(2);\n        tree.put(3);\n        tree.put(4);\n        tree.put(5);\n        \n        // Remove a node from the tree\n        boolean result = tree.remove(3);\n        \n        // Assert that the remove operation was successful\n        assertTrue(result);\n        \n        // Check that the removed node is no longer in the tree\n        Node removedNode = tree.find(3);\n        assertNull(removedNode);\n    }\n}",
        "@Test\npublic void removeTest() {\n    BinaryTree binaryTree = new BinaryTree();\n    Node root = new Node(1);\n    root.left = new Node(2);\n    root.right = new Node(3);\n    binaryTree.root = root;\n    assertTrue(binaryTree.remove(2)); // check that node with value 2 is removed successfully\n}",
        "public boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp == null || temp.data != value) {\n        return false;\n    }\n\n    // If the node has no children, just delete it\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } else if (temp.parent != null) {\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = null;\n            } else {\n                temp.parent.right = null;\n            }\n        }\n    }\n\n    // If the node has one child, assign it to its parent\n    if (temp.right != null && temp.left == null) {\n        if (temp == root) {\n            root = temp.right;\n        } else if (temp.parent != null) {\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        }\n    } else if (temp.left != null && temp.right == null) {\n        if (temp == root) {\n            root = temp.left;\n        } else if (temp.parent != null) {\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n    }\n\n    // If the node has two children, replace it with its in-order successor\n    if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n        if (successor == root) {\n            root = successor;\n        } else if (successor.parent != null) {\n            if (successor.data < successor.parent.data) {\n                successor.parent.left = successor;\n            } else {\n                successor.parent.right = successor;\n            }\n        }\n    }\n    return true;\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void removeTest() {\n        // Create a new binary tree with the root node set to 50\n        BinaryTree bt = new BinaryTree(new Node(50));\n        \n        // Add some nodes to the tree\n        bt.put(25);\n        bt.put(75);\n        bt.put(10);\n        bt.put(30);\n        bt.put(80);\n        bt.put(90);\n        \n        // Remove a node from the tree\n        boolean removed = bt.remove(25);\n        \n        // Assert that the node was successfully removed\n        assertTrue(removed);\n    }\n}"
    ]
}