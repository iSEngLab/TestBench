{
    "project_name": "Java",
    "file_name": "FFT.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.maths",
    "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
    "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
    "class_name": "FFT",
    "method_name": "fft",
    "arguments": [
        "ArrayList<Complex> x",
        "boolean inverse"
    ],
    "generate_test": [
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Test 1: Input size is a power of two (N = 2^m)\n        ArrayList<Complex> input_power_of_two = new ArrayList<Complex>();\n        for (int i = 0; i < 8; i++) {\n            input_power_of_two.add(new Complex()); // Initialize the array with zeros\n        }\n        int log2N = findLog2(input_power_of_two.size());\n        FFT fft = new FFT();\n        ArrayList<Complex> output_power_of_two = fft.fft(log2N, input_power_of_two);\n        assertEquals(output_power_of_two.size(), (int) Math.pow(2, log2N)); // Output size should be the same as the input size\n        \n        // Test 2: Input size is not a power of two (N = 2^m + 1)\n        ArrayList<Complex> input_not_power_of_two = new ArrayList<Complex>();\n        for (int i = 0; i < 9; i++) {\n            input_not_power_of_two.add(new Complex()); // Initialize the array with zeros\n        }\n        log2N = findLog2(input_not_power_of_two.size());\n        output_power_of_two = fft.fft(log2N, input_not_power_of_two);\n        assertEquals(output_power_of_two.size(), (int) Math.pow(2, log2N)); // Output size should be the same as the input size\n    }\n}",
        "import com.thealgorithms.maths.FFT;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Generate a sample signal\n        double[] x = new double[10];\n        for (int i = 0; i < x.length; ++i) {\n            x[i] = Math.sin((2 * Math.PI * i) / 5);\n        }\n        \n        // Apply the FFT algorithm to the sample signal\n        Complex[] X = FFT.fft(x);\n        \n        // Print the frequency components of the signal\n        for (int i = 0; i < X.length; ++i) {\n            System.out.println(\"Component \" + i + \": \" + X[i]);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> timeSignal = new ArrayList<>();\n        for (int i = 0; i < 8; i++) {\n            Complex complex = new Complex(i, i);\n            timeSignal.add(complex);\n        }\n\n        ArrayList<Complex> frequencySignal = FFT.fft(timeSignal);\n        for (int i = 0; i < frequencySignal.size(); i++) {\n            System.out.println(\"(\" + frequencySignal.get(i).re() + \",\" + frequencySignal.get(i).im() + \")\");\n        }\n    }\n}",
        "\n@Test\n    public void fftTest() {\n        int N = 4;\n        ArrayList<Complex> x = new ArrayList<>();\n        Complex[] complexArray = new Complex[N];\n        for (int i = 0; i < N; i++) {\n            complexArray[i] = new Complex(1, 0);\n        }\n        FFT.fft(complexArray);\n    }",
        "@[31-47, 50-86, 92-107]@\n\n### Code after the user has completed the tutorial and is ready to submit their response. The code will check that the user's implementation of `fft` passes all tests in `FFTTest`.\npackage com.thealgorithms.maths;\nimport java.util.*;\npublic class FFT {\n    public static void main(String[] args) {\n        <FILL>\n    }\n    @Test\n    public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n        // Find the length of the input\n        int N = x.size();\n\n        // Reverse the bits if we want to use Cooley-Tukey algorithm\n        x = fftBitReversal(N, findLog2(N), x);\n\n        // Apply Cooley-Tukey recursion\n        for (int len = 1; len < N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n        x = inverseFFT(N, inverse, x);\n        return x;\n    }\n\n    /* Find the log2(N) */\n    public static int findLog2(int N) {\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n        return log2N;\n    }\n\n    /* Swap the values of the signal with bit-reversal method */\n    public static ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x) {\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n        return x;\n    }\n\n    /* Divide by N if we want the inverse FFT */\n    public static ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x) {\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n        return x;\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & 1) == 1)) {\n                reversed |= (1 << (log2N - 1 - i));\n            }\n            num >>= 1;\n        }\n        return reversed;\n    }\n}",
        "@Test\npublic void fftTest() {\n    double[] data = new double[]{1, 2, 3};\n\n    // Test FFT and IFFT for a signal with a length of 3\n    ArrayList<Complex> x = new ArrayList<>();\n    for (double v : data) {\n        x.add(new Complex(v));\n    }\n    ArrayList<Complex> y = FFT.fft(true, x);\n    assertEquals(6, y.size()); // Expected: 6 due to padding with zeros\n\n    double[] expectedX = new double[]{1, 2, 3};\n    for (int i = 0; i < x.size(); i++) {\n        Complex z = x.get(i);\n        assertEquals(expectedX[i], z.re()); // Expected: original signal\n    }\n\n    double[] expectedYRe = new double[]{1, 2, 3};\n    for (int i = 0; i < y.size(); i++) {\n        Complex z = y.get(i);\n        assertEquals(expectedYRe[i], z.re()); // Expected: only real part of the FFT signal\n        assertEquals(0, z.im()); // Expected: imaginary part is zero for a real-valued signal\n    }\n\n    ArrayList<Complex> xInv = FFT.fft(false, y);\n    double[] expectedXInvRe = new double[]{1, 2, 3};\n    for (int i = 0; i < xInv.size(); i++) {\n        Complex z = xInv.get(i);\n        assertEquals(expectedXInvRe[i], z.re()); // Expected: inverse FFT reconstructs the original signal\n        assertEquals(0, z.im(), 1e-9); // Expected: imaginary part is zero for a real-valued signal\n    }\n}\n    \n\n### Response:",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> x = new ArrayList<>();\n        x.add(new Complex(1, 0));\n        x.add(new Complex(2, 0));\n        x.add(new Complex(3, 0));\n        x.add(new Complex(4, 0));\n        FFT fft = new FFT();\n        ArrayList<Complex> y = fft.fft(x);\n        assertEquals(5, y.size());\n    }\n}",
        "\n  FFT Code\n  ========\n  \n  Copyright (c) 2021, The Algorithmic Artist\n  All rights reserved.\n  \n  This code is based on the FFT implementation by The Algorithmic Artist, which can be found at https://github.com/TheAlgorithmicArtist/fft\n",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        int[] input = new int[]{1, 2, 3, 4};\n        int expectedSize = 8;\n        ArrayList<Complex> output = FFT.fft(input);\n        assertEquals(expectedSize, output.size());\n    }\n}",
        "@Test\npublic void fftTest() {\n    ArrayList<Complex> x = new ArrayList<>();\n    assertThrows(IllegalArgumentException.class, () -> fft(x));\n}"
    ]
}