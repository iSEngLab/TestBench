{
    "project_name": "Java",
    "file_name": "FFT.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.maths",
    "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
    "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
    "class_name": "FFT",
    "method_name": "fft",
    "arguments": [
        "ArrayList<Complex> x",
        "boolean inverse"
    ],
    "generate_test": [
        "\nimport java.util.ArrayList;\n\nimport org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(1, 0));\n        input.add(new Complex(2, 0));\n        input.add(new Complex(3, 0));\n        input.add(new Complex(4, 0));\n        \n        ArrayList<Complex> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Complex(1, 0));\n        expectedOutput.add(new Complex(2, 0));\n        expectedOutput.add(new Complex(3, 0));\n        expectedOutput.add(new Complex(4, 0));\n        \n        assertEquals(expectedOutput, FFT.fft(input, false));\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Test a simple input\n        ArrayList<Complex> x = new ArrayList<>();\n        x.add(new Complex(1, 0));\n        x.add(new Complex(2, 0));\n        x.add(new Complex(3, 0));\n        x.add(new Complex(4, 0));\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(1, 0));\n        expected.add(new Complex(2, 0));\n        expected.add(new Complex(3, 0));\n        expected.add(new Complex(4, 0));\n        assertEquals(expected, fft(x, false));\n\n        // Test a complex input\n        x = new ArrayList<>();\n        x.add(new Complex(1, 2));\n        x.add(new Complex(3, -4));\n        x.add(new Complex(-5, 6));\n        x.add(new Complex(7, -8));\n        expected = new ArrayList<>();\n        expected.add(new Complex(1, 2));\n        expected.add(new Complex(3, -4));\n        expected.add(new Complex(-5, 6));\n        expected.add(new Complex(7, -8));\n        assertEquals(expected, fft(x, false));\n    }\n}",
        "public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    // Pad the signal with zeros if necessary\n    paddingPowerOfTwo(x);\n    \n    // Calculate the number of bits required to represent the signal (i.e., log2N)\n    int N = x.size();\n    int log2N = findLog2(N);\n    \n    // Perform a bit reversal operation on the input array using the fftBitReversal function\n    x = fftBitReversal(N, log2N, x);\n    \n    // Calculate the direction of the FFT (i.e., whether it is a forward or inverse transform)\n    int direction = inverse ? -1 : 1;\n    \n    // Calculate the angle of rotation for each iteration of the main loop\n    double angle = -2 * Math.PI / N * direction;\n    \n    // Main loop: iterate over each element in the input array, starting at index 0 and ending at N - 1\n    for (int i = 0; i < N; i++) {\n        Complex w = new Complex(Math.cos(angle), Math.sin(angle));\n        \n        // Perform two FFT operations on each pair of elements in the input array\n        x.set(i, x.get(i).add(w.multiply(x.get(i + N / 2))));\n        x.set(i + N / 2, x.get(i + N / 2).subtract(w.multiply(x.get(i))));\n    }\n    \n    // Call the inverseFFT function to perform the actual inverse transform if necessary\n    if (inverse) {\n        x = inverseFFT(N, true, x);\n    }\n    \n    return x;\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Test with a simple signal that consists of only two frequencies: 10 Hz and 20 Hz\n        double[] x = new double[100];\n        for (int i = 0; i < x.length; i++) {\n            x[i] = Math.sin(2 * Math.PI * 10 * i / 100) + Math.sin(2 * Math.PI * 20 * i / 100);\n        }\n\n        // Compute the frequency domain representation of the signal using the fft method\n        ArrayList<Complex> y = FFT.fft(Arrays.asList(x), false);\n\n        // Verify that the output from the method matches the expected frequency domain representation\n        assertEquals(y.size(), 100);\n        for (int i = 0; i < x.length; i++) {\n            double expectedReal = Math.cos(2 * Math.PI * (i / 100));\n            double expectedImag = Math.sin(2 * Math.PI * (i / 100));\n            assertEquals(y.get(i).real(), expectedReal, 1e-6);\n            assertEquals(y.get(i).imag(), expectedImag, 1e-6);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> x = new ArrayList<>();\n        // Pad the signal with zeros if necessary\n        paddingPowerOfTwo(x);\n        int N = x.size();\n        int log2N = findLog2(N);\n        x = fftBitReversal(N, log2N, x);\n        int direction = inverse ? -1 : 1;\n        \n        // Main loop of the algorithm\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n        \n        // Check the output of the algorithm against a known result\n        ArrayList<Complex> expected = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            Complex u = x.get(i).add(new Complex(Math.random(), Math.random()));\n            expected.add(u);\n        }\n        \n        assertEquals(expected, fft(x, false));\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Test forward transform for a sequence of length 4\n        ArrayList<Complex> x = new ArrayList<>();\n        x.add(new Complex(1, 0));\n        x.add(new Complex(2, 0));\n        x.add(new Complex(3, 0));\n        x.add(new Complex(4, 0));\n        assertEquals(fft(x, false), Arrays.asList(new Complex(1, 0), new Complex(2, 0), new Complex(3, 0), new Complex(4, 0)));\n        \n        // Test inverse transform for a sequence of length 4\n        x = new ArrayList<>();\n        x.add(new Complex(1, 0));\n        x.add(new Complex(2, 0));\n        x.add(new Complex(3, 0));\n        x.add(new Complex(4, 0));\n        assertEquals(fft(x, true), Arrays.asList(new Complex(-1, 0), new Complex(-2, 0), new Complex(-3, 0), new Complex(-4, 0)));\n        \n        // Test forward transform for a sequence of length 8\n        x = new ArrayList<>();\n        x.add(new Complex(1, 0));\n        x.add(new Complex(2, 0));\n        x.add(new Complex(3, 0));\n        x.add(new Complex(4, 0));\n        x.add(new Complex(5, 0));\n        x.add(new Complex(6, 0));\n        x.add(new Complex(7, 0));\n        x.add(new Complex(8, 0));\n        assertEquals(fft(x, false), Arrays.asList(new Complex(1, 0), new Complex(2, 0), new Complex(3, 0), new Complex(4, 0), new Complex(5, 0), new Complex(6, 0), new Complex(7, 0), new Complex(8, 0)));\n        \n        // Test inverse transform for a sequence of length 8\n        x = new ArrayList<>();\n        x.add(new Complex(1, 0));\n        x.add(new Complex(2, 0));\n        x.add(new Complex(3, 0));\n        x.add(new Complex(4, 0));\n        x.add(new Complex(5, 0));\n        x.add(new Complex(6, 0));\n        x.add(new Complex(7, 0));\n        x.add(new Complex(8, 0));\n        assertEquals(fft(x, true), Arrays.asList(new Complex(-1, 0), new Complex(-2, 0), new Complex(-3, 0), new Complex(-4, 0), new Complex(-5, 0), new Complex(-6, 0), new Complex(-7, 0), new Complex(-8, 0)));\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(1, 0));\n        input.add(new Complex(2, -1));\n        input.add(new Complex(-3, 4));\n        input.add(new Complex(5, -6));\n\n        ArrayList<Complex> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Complex(3, 7));\n        expectedOutput.add(new Complex(12, -8));\n        expectedOutput.add(new Complex(-49, -10));\n        expectedOutput.add(new Complex(-63, 24));\n\n        assertEquals(expectedOutput, FFT.fft(input, false));\n    }\n}",
        "\n@Test\npublic void fftTest() {\n    /* Test with a simple signal */\n    ArrayList<Complex> x = new ArrayList<>();\n    x.add(new Complex(1, 0));\n    x.add(new Complex(2, 0));\n    x.add(new Complex(3, 0));\n\n    /* Expected result for the FFT of the simple signal */\n    ArrayList<Complex> expectedResult = new ArrayList<>();\n    expectedResult.add(new Complex(6, 0));\n    expectedResult.add(new Complex(-2, 0));\n    expectedResult.add(new Complex(1, 0));\n\n    /* Compute the FFT of the simple signal */\n    ArrayList<Complex> actualResult = fft(x);\n\n    /* Check that the result is correct */\n    assertEquals(expectedResult, actualResult);\n}",
        "\nThe FFT algorithm is a widely used technique for efficiently computing the discrete Fourier transform (DFT) of a sequence. The test case provided in the instruction is designed to test the correctness of the FFT implementation. However, it appears that some parts of the test are missing, and therefore cannot be completed. Therefore, I suggest providing more information or clarification on the task at hand before proceeding with the completion of the test case.",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Create a list of complex numbers to test the algorithm with\n        ArrayList<Complex> x = new ArrayList<>();\n        x.add(new Complex(1, 0));\n        x.add(new Complex(2, 3));\n        x.add(new Complex(-4, 5));\n        x.add(new Complex(6, -7));\n        \n        // Create a list to store the expected output after applying FFT\n        ArrayList<Complex> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Complex(1, 0));\n        expectedOutput.add(new Complex(-2, 3));\n        expectedOutput.add(new Complex(4, -5));\n        expectedOutput.add(new Complex(-6, 7));\n        \n        // Apply FFT to the input list and check if the output matches the expected output\n        ArrayList<Complex> actualOutput = fft(x);\n        assertEquals(expectedOutput, actualOutput);\n    }\n}"
    ]
}