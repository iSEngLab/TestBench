{
    "project_name": "Java",
    "file_name": "FibonacciHeap.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.heaps",
    "docstring": "/**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */",
    "source_code": "\npublic HeapNode insert(int key) {\n    HeapNode toInsert = new HeapNode(key); // creates the node\n    if (this.empty()) {\n        this.min = toInsert;\n    } else { // tree is not empty\n        min.setNext(toInsert);\n        this.updateMin(toInsert);\n    }\n    this.numOfHeapNodes++;\n    this.numOfTrees++;\n    return toInsert;\n}\n",
    "class_name": "FibonacciHeap",
    "method_name": "insert",
    "arguments": [
        "int key"
    ],
    "generate_test": [
        "// TODO\n\n### Acknowledgement\n- Thank you for reaching out to us. We will be happy to help you with your question. \n\n",
        "@RestController\n@RequestMapping(path = \"/fibonacci-heap\")\npublic class FibonacciHeapController {\nprivate final FibonacciHeap<Integer, String> fibonacciHeap;\n\n    public <FILL> {\n    }\n\n    @PostMapping(path = \"/insert\", consumes = {\"application/json\"}, produces = {\"application/json\"})\n    public ResponseEntity insert(@RequestBody(value = \"{\\\"key\\\": 123}\") String value) {\n        Integer key = Integer.parseInt(value);\n        fibonacciHeap.insert(key, value);\n\n        return new ResponseEntity(\"Item successfully added to the heap!\", HttpStatus.OK);\n    }\n}",
        "@AlgorithmName\n@AlgorithmDescription\n[Details](https://en.wikipedia.org/wiki/Fibonacci_heap)\n\n## Heap Data Structure:\n* A heap is a specialized tree data structure in which the tree is a complete binary tree (a perfect binary tree).\n* Each node of the tree contains an element, and may also have two children nodes, called left and right.\n* The root node has no parent node.\n* The left child node is connected to its parent's right child node.\n* The right child node is connected to its parent's left child node.\n* The root node is a leaf node if the heap only contains one element.\n* A non-root node is a leaf node if it has no children nodes.\n* Every non-leaf node of a tree in which every node contains an element has two or more children.\n* All the leaves are at the same level and form a doubly linked list called \"circulation list\".\n\n### Advantages:\n* Minimum extra memory usage to maintain a heap data structure.\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\\ *\t    9\"    \n\n\n\nComment:\n\nComment_\n    for(.\n 130  by  The `2, for (C), which is not a lot of\n 198674, 5, not to be able to say 10 0.\n\nAnswer: You have the ability to add a \"hidden\" input element?\n\nComment: @Ashutoshin89 Yes! That will work, thanks for your response!",
        "import java.util.ArrayList;\n\npublic class FibonacciHeap<E extends Comparable<? super E>> {\n    private ArrayList<Node<E>> mMinRootList = new ArrayList<>();\n    private int mCount = 0;\n    private int mMagnitude = Integer.MAX_VALUE;\n    \n    public boolean insert(E key) {\n        Node node = new Node(key);\n        \n        if (mMinRootList.isEmpty()) {\n            mMinRootList.add(node);\n            \n        } else {\n            Node<E> smallest = getSmallest();\n            \n            if (smallest.getKey().compareTo(node.getKey()) > 0) {\n                mMinRootList.set(0, node);\n                \n            } else {\n                mMinRootList.add(node);\n            }\n        }\n        \n        mCount++;\n        return true;\n    }\n    \n    public E delete() {\n        if (mCount == 0) {\n            throw new NoSuchElementException();\n            \n        } else {\n            Node<E> smallest = getSmallest();\n            \n            for (Node<E> node : mMinRootList) {\n                if (node.getKey().compareTo(smallest.getKey()) == 0 && node != smallest) {\n                    return null;\n                }\n            }\n        }\n        \n        Node<E> deleted = getSmallest();\n        mCount--;\n        return deleted.getKey();\n    }\n    \n    public void decreaseKey(E key, int amount) {\n        Node node = new Node(key);\n        if (!mMinRootList.contains(node)) {\n            throw new NoSuchElementException();\n            \n        } else {\n            for (Node<E> node : mMinRootList) {\n                if (node.getKey().compareTo(key) == 0 && amount > 0) {\n                    Node<E> child = new Node(amount);\n                    \n                    node.mChildren.add(child);\n                    \n                    int newMagnitude = Math.max(node.getKey().intValue(), (int) (Math.log10(2) + amount));\n                    \n                    node.setMagnitude(newMagnitude);\n                }\n            }\n        }\n    }\n    \n    private Node<E> getSmallest() {\n        int smallestKey = Integer.MAX_VALUE;\n        \n        for (Node<E> node : mMinRootList) {\n            if (node.getKey().intValue() < smallestKey) {\n                smallestKey = node.getKey().intValue();\n                \n            }\n        }\n        \n        Node<E> smallest = null;\n        \n        for (Node<E> node : mMinRootList) {\n            if (node.getKey().compareTo(smallestKey)) == 0 && smallest != null) {\n                smallest = node;\n                \n            }\n        }\n        \n        return smallest;\n    }\n    \n    private static class Node<E extends Comparable<? super E>> {\n        public int magnitude;\n        public ArrayList<Node<E>> children = new ArrayList<>();\n        public Node<E> parent;\n        public E key;\n        \n        public Node(E key) {\n            this.key = key;\n            mMagnitude = Integer.MAX_VALUE;\n            \n        }\n        \n        public int getKey() {\n            return key.intValue();\n        }\n        \n        private void setMagnitude(int magnitude) {\n            this.magnitude = Math.max(magnitude, mMagnitude);\n        }\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\nimport java.util.*;\n\n/**\n * FibonacciHeap implementation of PriorityQueue using Fibonacci Heap data structure\n */\npublic class FibonacciHeap {\n    private List<Integer> queue = new ArrayList<>();\n    \n    /**\n     * Add an integer to the priority queue.\n     * @param value integer to be added to the priority queue\n     */\n    public void add(int value) {\n        // TODO: Implement this method\n    }\n\n    /**\n     * Remove and return the smallest integer currently in the\n     * priority queue.\n     * \n     * @return the smallest integer currently in the priority queue\n     */\n    public int remove() {\n        // TODO: Implement this method\n        return -1;\n    }\n}",
        "<@response>Your submission is being reviewed for plagiarism. Please make sure to only submit your own work and use proper citation, if you're referencing another source.</@response> ",
        "<FILL>\n",
        "FibonacciHeap heap = new FibonacciHeap();\n\nheap.insert(3);\nheap.insert(4);\nheap.insert(1);\nheap.insert(6);\nheap.insert(7);\nheap.insert(5);\nheap.insert(9);\nassertEquals(heap.size(), 6);",
        "<FILL>\n",
        "java\npackage com.thealgorithms.datastructures.heaps;\n\npublic class FibonacciHeap {\n    private static final double GOLDEN_RATIO = 1.618033988749; // (phi^5 - phi) / phi\n    private static final int NIL = Integer.MIN_VALUE;\n\n    /**\n     * The root of this Fibonacci heap\n     */\n    private HeapNode mRoot;\n\n    /**\n     * Returns true if this is empty\n     * @return  true if this is empty\n     */\n    public boolean isEmpty() {\n        return (mRoot == null);\n    }\n\n    /**\n     * Creates a new heap node with given element\n     * @param <E>  the element to be stored in the node\n     * @return  a new heap node storing the given element\n     */\n    private static <N extends Comparable<E>> HeapNode<E, N> createNewHeapNode(final E e) {\n        return new HeapNode<E, N>(e);\n    }\n\n    /**\n     * Adds a new element to this heap\n     * @param <E>  the element to be stored in the heap\n     */\n    public void add(final E e) {\n        if (mRoot == null) {\n            // if there is no root, we simply create one with given element and it will become new root of this heap\n            mRoot = createNewHeapNode(e);\n            return;\n        }\n\n        final HeapNode<E, N> x = createNewHeapNode(e), y = null; // Create a new node storing the given element\n        if (mRoot.key > x.key) {\n            // we use the max heap property, which states that if the key of the root node is larger than all keys in its subtree then it must be greater than all other keys in this heap\n            y = mRoot; // set y to point to current root\n            // now x will become new root, and y (the old root) will be connected as one of x's children\n        }\n\n        HeapNode<E, N> z = null; // Auxiliary node used in consolidation process, not part of this heap\n\n        while (y != null && y.key > x.key) {\n            // we use the max heap property, which states that a parent node is greater than all its children\n            z = y; // set z to point to current root's parent\n            y = y.p; // set y to point to current root's grandparent\n        }\n\n        if (z != null) {\n            // in this case x and z are siblings, so we connect them as such\n            x.p = z.c; // set x's previous pointer to point to point to z's children\n            z.c = x; // set z's children pointer to point to x\n        } else {\n            // otherwise we simply make x a child of y (if y is not null) or connect it as a child of the root node mRoot if y is null\n            x.p = y;\n        }\n\n        if (mRoot == null) {\n            // in this case we just set x to be the new root, and return since there was no root before adding this element\n            mRoot = x;\n            return;\n        }\n\n        final HeapNode<E, N> r = consolidate(x); // call consolidate method with given node x as argument\n        if (r != null) {\n            // in this case the returned value of the consolidate method was not null, so we set it to be a new root of this heap\n            mRoot = r;\n        }\n    }\n\n    /**\n     * Returns true if there is no node in this heap\n     * @return  true if there is no node in this heap\n     */\n    public boolean isEmpty() {\n        return (mRoot == null); // simply check whether root of this heap is null or not\n    }\n\n    /**\n     * Returns the size of this heap, i.e. returns the number of nodes in this heap\n     * @return  the size of this heap\n     */\n    public int size() {\n        return (mRoot == null) ? 0 : mRoot.size; // simply check whether root of this heap is null or not, and if it's not null then get its size value using recursive calculation method\n    }\n\n    /**\n     * Performs a consolidation on the heap\n     * @param <E>  a node in the heap\n     * @return  the new root of this heap after consolidating, or null if no consolidation is performed\n     */\n    private HeapNode<E, N> consolidate(final HeapNode<E, N> x) {\n        // set current node to point to given argument x\n        HeapNode<E, N> current = x;\n        while (current != null && current.mark == false) {\n            final HeapNode<E, N> y = current.p; // set y to point to current root's parent\n            if (y == mRoot) {\n                return null;\n            }\n\n            current.p = y.c; // set current node's previous pointer to point to y's children\n            y.c = current; // set y's children pointer to point to current\n            if ((current.key * GOLDEN_RATIO) + 1 > (y.key * GOLDEN_RATIO)) || ((current.key * GOLDEN_RATIO) == (y.key * GOLDEN_RATIO)) && current.mark) {\n                return null; // if there is a consolidation, then we must return null since the returned node would not be part of this heap anymore\n            }\n            current = y;\n        }\n\n        return x; // otherwise simply return given argument x\n    }\n\n    /**\n     * Returns true if the maximum value in this heap is greater than or equal to given element, and false otherwise\n     * @param <E>  the element to be compared with maximum value in this heap\n     * @return  true if the maximum value in this heap is greater than or equal to given element, and false otherwise\n     */\n    public boolean isGreaterThanMax(final E e) {\n        return (mRoot == null) ? false : mRoot.isGreaterThanMax(e); // simply check whether root of this heap is null or not, and if it's not null then check its maximum value with given argument element e using recursive calculation method\n    }\n\n    /**\n     * Returns the minimum value in this heap, i.e. the smallest element stored in this heap\n     * @return  the minimum value in this heap\n     */\n    public E min() {\n        return (mRoot == null) ? null : mRoot.min(); // simply check whether root of this heap is null or not, and if it's not null then get its minimum value using recursive calculation method\n    }\n\n    /**\n     * Removes the minimum element from this heap and returns that removed minimum element, i.e. removes the node with the smallest key in this heap\n     * @return  the removed minimum element, or null if this heap is empty\n     */\n    public E removeMin() {\n        return (mRoot == null) ? null : mRoot.removeMin(); // simply check whether root of this heap is null or not, and if it's not null then get its minimum value using recursive calculation method\n    }\n}\n\\end{code}"
    ]
}