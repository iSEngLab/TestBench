{
    "project_name": "Java",
    "file_name": "FloodFill.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */",
    "source_code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
    "class_name": "FloodFill",
    "method_name": "floodFill",
    "arguments": [
        "int[][] image",
        "int x",
        "int y",
        "int newColor",
        "int oldColor"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Set up the input parameters for the test case\n        int[][] image = new int[5][5];\n        int x = 2;\n        int y = 3;\n        int oldColor = 0xFFFFFF;\n        int newColor = 0x000000;\n\n        // Call the floodFill method with the input parameters\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Check that the expected output values are correct\n        assertEquals(newColor, image[x][y]);\n        assertEquals(oldColor, image[x + 1][y]);\n        assertEquals(oldColor, image[x - 1][y]);\n        assertEquals(oldColor, image[x][y + 1]);\n        assertEquals(oldColor, image[x][y - 1]);\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[5][5];\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                image[i][j] = 1;\n            }\n        }\n        FloodFill.floodFill(image, 2, 3, 3, 1);\n        assertEquals(image[2][3], 3);\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[3][3];\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                image[i][j] = 0;\n            }\n        }\n        \n        // Test case 1: The new color is the same as the old color.\n        int x = 0, y = 0, newColor = 0, oldColor = 0;\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        assertEquals(newColor, image[x][y]);\n        \n        // Test case 2: The new color is different from the old color.\n        int x = 1, y = 1, newColor = 1, oldColor = 0;\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        assertEquals(newColor, image[x][y]);\n        \n        // Test case 3: The coordinates are out of bounds.\n        int x = -1, y = -1, newColor = 0, oldColor = 0;\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        assertEquals(oldColor, image[x][y]);\n    }\n}\n",
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[4][5]; // create an empty 4x5 image\n        int x = 2;\n        int y = 3;\n        int oldColor = 1;\n        int newColor = 2;\n        \n        // initialize the image with a single old color at (x, y)\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                if (i == x && j == y) {\n                    image[i][j] = oldColor;\n                } else {\n                    image[i][j] = 0;\n                }\n            }\n        }\n        \n        // call the floodFill method to fill the image with new color\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        // check that all old colors have been replaced with new color\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                if (image[i][j] == oldColor) {\n                    fail(\"Old color not replaced with new color\");\n                } else if (image[i][j] != newColor) {\n                    fail(\"Incorrectly filled pixels in the image\");\n                }\n            }\n        }\n        \n        // check that the image is fully filled with new color\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                if (image[i][j] != newColor) {\n                    fail(\"Image not fully filled with new color\");\n                }\n            }\n        }\n    }\n}\n",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Create a 2D image with some pixels of different colors\n        int[][] image = new int[5][5];\n        image[0][0] = 1;\n        image[0][1] = 2;\n        image[0][2] = 3;\n        image[0][3] = 4;\n        image[0][4] = 5;\n        image[1][0] = 6;\n        image[1][1] = 7;\n        image[1][2] = 8;\n        image[1][3] = 9;\n        image[1][4] = 10;\n        image[2][0] = 11;\n        image[2][1] = 12;\n        image[2][2] = 13;\n        image[2][3] = 14;\n        image[2][4] = 15;\n        image[3][0] = 16;\n        image[3][1] = 17;\n        image[3][2] = 18;\n        image[3][3] = 19;\n        image[3][4] = 20;\n        image[4][0] = 21;\n        image[4][1] = 22;\n        image[4][2] = 23;\n        image[4][3] = 24;\n        image[4][4] = 25;\n\n        // Fill the image with a new color (e.g. blue) at a specific coordinate (e.g. (2, 3)) while preserving the old colors\n        int x = 2;\n        int y = 3;\n        int newColor = 10;\n        FloodFill.floodFill(image, x, y, newColor);\n\n        // Check that the correct pixels have been filled with the new color (e.g. blue) while preserving the old colors\n        assertEquals(1, image[0][0]);\n        assertEquals(2, image[0][1]);\n        assertEquals(3, image[0][2]);\n        assertEquals(4, image[0][3]);\n        assertEquals(5, image[0][4]);\n        assertEquals(6, image[1][0]);\n        assertEquals(7, image[1][1]);\n        assertEquals(8, image[1][2]);\n        assertEquals(9, image[1][3]);\n        assertEquals(10, image[1][4]);\n        assertEquals(11, image[2][0]);\n        assertEquals(12, image[2][1]);\n        assertEquals(13, image[2][2]);\n        assertEquals(14, image[2][3]);\n        assertEquals(15, image[2][4]);\n        assertEquals(16, image[3][0]);\n        assertEquals(17, image[3][1]);\n        assertEquals(18, image[3][2]);\n        assertEquals(19, image[3][3]);\n        assertEquals(20, image[3][4]);\n        assertEquals(21, image[4][0]);\n        assertEquals(22, image[4][1]);\n        assertEquals(23, image[4][2]);\n        assertEquals(24, image[4][3]);\n        assertEquals(25, image[4][4]);\n    }\n}\n",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = {{0, 0, 0}, {0, 1, 2}, {3, 4, 5}}; // 3x3 image with values 0-5\n        int x = 1; // starting point: row 1, column 1 (indexes start at 0)\n        int y = 1;\n        int newColor = 7; // new color to be filled in the image\n        int oldColor = 2; // old color to be replaced in the image\n\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        assertEquals(newColor, image[0][1]); // row 0, column 1 should be filled with newColor\n        assertEquals(newColor, image[1][1]); // row 1, column 1 should be filled with newColor\n        assertEquals(oldColor, image[2][1]); // row 2, column 1 should remain unchanged (oldColor)\n    }\n}",
        "\n@Test\npublic void floodFillTest() {\n    int[][] image = new int[][] {{0, 1, 2}, {3, 4, 5}}; // 2x3 matrix\n    int x = 0;\n    int y = 0;\n    int newColor = 6;\n    int oldColor = 5;\n\n    FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n    assertEquals(6, image[0][0]); // Verify that the color at [0, 0] has been changed to the new color\n    assertEquals(6, image[1][1]); // Verify that the color at [1, 1] has been changed to the new color\n}",
        "\n@Test\npublic void floodFillTest() {\n    int[][] image = new int[][]{\n            {0, 0, 0},\n            {1, 1, 1},\n            {0, 0, 0}\n    };\n    \n    FloodFill.floodFill(image, 1, 1, 2, 1);\n    \n    assertEquals(image[0][0], 2);\n    assertEquals(image[0][1], 2);\n    assertEquals(image[0][2], 2);\n    assertEquals(image[1][0], 2);\n    assertEquals(image[1][1], 2);\n    assertEquals(image[1][2], 2);\n    assertEquals(image[2][0], 2);\n    assertEquals(image[2][1], 2);\n    assertEquals(image[2][2], 2);\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[][] {{0, 0, 0}, {1, 1, 1}, {2, 2, 2}};\n        int oldColor = 1;\n        int newColor = 3;\n\n        FloodFill.floodFill(image, 1, 1, newColor, oldColor);\n\n        assertEquals(newColor, image[0][0]);\n        assertEquals(newColor, image[2][2]);\n    }\n}",
        "\nThe `floodFill` method is a recursive implementation of the Flood Fill algorithm. It takes an image, x and y coordinates, new color, and old color as parameters. The method first checks if the new color is equal to the old color or if the x coordinate is less than 0 or greater than the length of the image array, or if the y coordinate is less than 0 or greater than the length of the image[x] array. If any of these conditions are true, the method returns without changing anything in the image.\n\nOtherwise, the method puts the new color at the current x and y coordinates in the image using the `putPixel` method. It then recursively calls itself to check for horizontally and vertically adjacent pixels, as well as diagonally adjacent pixels. If any of these recursive calls result in a pixel being changed from the old color to the new color, the method returns and stops propagating the change further.\n\nThe reason why this method uses recursion is because the Flood Fill algorithm needs to check all the pixels in the image that are connected to the current pixel. Recursion allows us to easily explore all the possible paths of connected pixels without having to worry about keeping track of which pixels have already been visited.\n\nIn summary, the `floodFill` method is a recursive implementation of the Flood Fill algorithm in Java. It takes an image, x and y coordinates, new color, and old color as parameters, and uses recursion to change all connected pixels from the old color to the new color."
    ]
}