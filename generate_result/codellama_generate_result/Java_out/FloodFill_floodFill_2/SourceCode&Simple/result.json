{
    "project_name": "Java",
    "file_name": "FloodFill.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */",
    "source_code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
    "class_name": "FloodFill",
    "method_name": "floodFill",
    "arguments": [
        "int[][] image",
        "int x",
        "int y",
        "int newColor",
        "int oldColor"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[10][10];\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                image[i][j] = 0; // Initialize the image with all zeros\n            }\n        }\n\n        int x = 5, y = 5; // Coordinates of the starting point for flood filling\n        int newColor = 1, oldColor = 0; // New and old colors for flood filling\n        \n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        assertEquals(newColor, image[x][y]); // Check if the starting point has been replaced with the new color\n        assertEquals(newColor, image[x+1][y]); // Check if the horizontally adjacent pixels have been replaced with the new color\n        assertEquals(newColor, image[x-1][y]); // Check if the horizontally adjacent pixels have been replaced with the new color\n        assertEquals(newColor, image[x][y+1]); // Check if the vertically adjacent pixels have been replaced with the new color\n        assertEquals(newColor, image[x][y-1]); // Check if the vertically adjacent pixels have been replaced with the new color\n    }\n}",
        "\nThe instructions provided are not clear and do not provide enough information to complete the task. It is important to clarify the requirements and provide more details about what needs to be done. Additionally, it would be helpful to know what the expected output of the test case should be. Without further clarification, I cannot provide a response that completes the task.",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Create a 3x3 image with one color\n        int[][] image = new int[3][3];\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                image[i][j] = 1;\n            }\n        }\n\n        // Call the floodFill method with a new color and an old color that is different from the current color\n        int newColor = 2;\n        int oldColor = 3;\n        FloodFill.floodFill(image, 0, 1, newColor, oldColor);\n\n        // Check that all positions with a value of 1 in the original image have been replaced with the new color\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                if (image[i][j] == 1) {\n                    assertEquals(newColor, image[i][j]);\n                } else {\n                    assertEquals(oldColor, image[i][j]);\n                }\n            }\n        }\n    }\n}",
        "@Test\npublic void floodFillTest() {\n    // Test 1: Check that the method returns when the new color and old color are the same\n    int[][] image = {{1, 2}, {3, 4}};\n    int x = 0;\n    int y = 0;\n    int newColor = 5;\n    int oldColor = 5;\n    floodFill(image, x, y, newColor, oldColor);\n    assertArrayEquals(new int[][] {{1, 2}, {3, 4}}, image);\n\n    // Test 2: Check that the method returns when the coordinates are outside of the image bounds\n    image = new int[2][2];\n    x = -1;\n    y = -1;\n    newColor = 5;\n    oldColor = 10;\n    floodFill(image, x, y, newColor, oldColor);\n    assertArrayEquals(new int[][] {{1, 2}, {3, 4}}, image);\n\n    // Test 3: Check that the method correctly replaces pixels with the same color as the old color\n    image = new int[3][3];\n    x = 0;\n    y = 0;\n    newColor = 5;\n    oldColor = 10;\n    floodFill(image, x, y, newColor, oldColor);\n    assertArrayEquals(new int[][] {{5, 2}, {3, 4}}, image);\n\n    // Test 4: Check that the method correctly replaces pixels with different colors as the old color\n    image = new int[3][3];\n    x = 0;\n    y = 0;\n    newColor = 5;\n    oldColor = 10;\n    floodFill(image, x, y, newColor, oldColor);\n    assertArrayEquals(new int[][] {{5, 2}, {3, 4}}, image);\n\n    // Test 5: Check that the method correctly replaces pixels with different colors as the old color when multiple coordinates are passed\n    image = new int[3][3];\n    x = 0;\n    y = 0;\n    newColor = 5;\n    oldColor = 10;\n    floodFill(image, x, y, newColor, oldColor);\n    assertArrayEquals(new int[][] {{5, 2}, {3, 4}}, image);\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[][] {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        int x = 0;\n        int y = 0;\n        int newColor = 10;\n        int oldColor = 0;\n\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        assertEquals(newColor, image[x][y]);\n        assertEquals(oldColor, image[x + 1][y]); // should not fill this pixel\n        assertEquals(oldColor, image[x - 1][y]); // should not fill this pixel\n        assertEquals(oldColor, image[x][y + 1]); // should not fill this pixel\n        assertEquals(oldColor, image[x][y - 1]); // should not fill this pixel\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        int x = 0;\n        int y = 0;\n        int newColor = 1;\n        int oldColor = 1;\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        assertEquals(newColor, image[x][y]);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[5][6];\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                image[i][j] = 1;\n            }\n        }\n        int x = 2, y = 3, newColor = 5, oldColor = 4;\n        floodFill(image, x, y, newColor, oldColor);\n        assertEquals(newColor, image[x][y]);\n    }\n}",
        "The given code is a recursive algorithm for performing a flood fill operation on a 2D array. The method takes five arguments:\n\n* `image` - the 2D array representing the image to be filled\n* `x` - the x-coordinate of the starting point\n* `y` - the y-coordinate of the starting point\n* `newColor` - the new color that will replace the old color in the area being filled\n* `oldColor` - the current color at the starting point\n\nThe method first checks if the coordinates are within the bounds of the image, and if the pixel at the starting point is the same as the old color. If not, it returns immediately without making any changes to the image.\n\nIf the starting point is valid, the method puts the new color in the current position, and then recursively calls itself for each adjacent coordinate (horizontally and vertically) that has the same old color. Finally, it also recursively calls itself for each diagonal adjacent coordinate that has the same old color.\n\nThe purpose of this test case is to test the `floodFill` method by passing in different arguments and verifying that the expected results are returned. The test case should include a series of assertions that check the behavior of the method under different scenarios, such as:\n\n* A valid starting point with a matching old color should result in the new color being filled into the area\n* An invalid starting point (outside the bounds of the image) should not modify the image\n* A mismatch between the current and old colors at the starting point should not modify the image\n* Tests for various edge cases, such as:\n\t+ The starting point is on an edge of the image\n\t+ The area being filled is larger than a single pixel\n\t+ The new color is the same as the old color\n\t+ The old color is not found in the area being filled\n\nThe test case should also include assertions to check that the method does not modify any pixels outside the area being filled, and that it correctly handles cases where there are multiple connected areas of different colors.",
        "\n@Test\npublic void floodFillTest() {\n    int[][] image = new int[5][5];\n    for (int i = 0; i < 5; i++) {\n        for (int j = 0; j < 5; j++) {\n            if (i == 0 || j == 0) {\n                image[i][j] = 1; // black pixel\n            } else {\n                image[i][j] = 2; // white pixel\n            }\n        }\n    }\n\n    int x = 3, y = 3, newColor = 0, oldColor = 2; // replace the color of all pixels in a 5x5 image with black color from white color\n    floodFill(image, x, y, newColor, oldColor);\n\n    assertEquals(1, getPixel(image, 1, 1)); // top left pixel should be black\n    assertEquals(0, getPixel(image, 2, 2)); // bottom right pixel should be black\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = {{1, 2}, {3, 4}};\n        int x = 0, y = 0, newColor = 5, oldColor = 1;\n        \n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        assertEquals(5, image[0][0]);\n        assertEquals(2, image[0][1]);\n        assertEquals(3, image[1][0]);\n        assertEquals(4, image[1][1]);\n    }\n}"
    ]
}