{
    "project_name": "Java",
    "file_name": "FloodFill.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */",
    "source_code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
    "class_name": "FloodFill",
    "method_name": "floodFill",
    "arguments": [
        "int[][] image",
        "int x",
        "int y",
        "int newColor",
        "int oldColor"
    ],
    "generate_test": [
        "@Test\npublic void floodFillTest() {\n    int[][] image = new int[5][5]; // Initialize the 2D array of size 5x5\n    int x = 0, y = 0; // Set the starting coordinates (x=0, y=0)\n    int oldColor = 1; // Set the initial color to be replaced (oldColor=1)\n    int newColor = 2; // Set the replacement color (newColor=2)\n\n    image[0][0] = 1; // Initialize the first element of the array\n    image[1][1] = 1; // Initialize the second element of the array\n    image[2][2] = 1; // Initialize the third element of the array\n    image[3][3] = 1; // Initialize the fourth element of the array\n    image[4][4] = 1; // Initialize the fifth element of the array\n\n    floodFill(image, x, y, newColor, oldColor); // Call the floodFill function\n\n    assertEquals(2, image[0][0]); // Assert that the first element has been replaced\n    assertEquals(2, image[1][1]); // Assert that the second element has been replaced\n    assertEquals(2, image[2][2]); // Assert that the third element has been replaced\n    assertEquals(2, image[3][3]); // Assert that the fourth element has been replaced\n    assertEquals(2, image[4][4]); // Assert that the fifth element has been replaced\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[3][3];\n        int x = 0;\n        int y = 1;\n        int newColor = 255;\n        int oldColor = 0;\n\n        image[x][y] = oldColor;\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        assertEquals(newColor, image[x][y]);\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[][] {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        int x = 0;\n        int y = 0;\n        int newColor = 10;\n        int oldColor = 0;\n        \n        floodFill(image, x, y, newColor, oldColor);\n        \n        assertEquals(newColor, image[x][y]);\n    }\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[3][3];\n        image[0][0] = 1; // blue pixel\n        image[1][0] = 2; // red pixel\n        image[2][0] = 3; // green pixel\n        image[0][1] = 4; // yellow pixel\n        image[1][1] = 5; // purple pixel\n        image[2][1] = 6; // blue pixel\n        image[0][2] = 7; // brown pixel\n        image[1][2] = 8; // pink pixel\n        image[2][2] = 9; // orange pixel\n\n        int x = 1, y = 1, newColor = 10, oldColor = 5;\n        floodFill(image, x, y, newColor, oldColor);\n\n        assertEquals(10, image[0][0]);\n        assertEquals(2, image[1][0]); // unchanged pixel\n        assertEquals(3, image[2][0]);\n        assertEquals(4, image[0][1]);\n        assertEquals(10, image[1][1]); // changed pixel\n        assertEquals(6, image[2][1]);\n        assertEquals(7, image[0][2]);\n        assertEquals(8, image[1][2]);\n        assertEquals(9, image[2][2]);\n    }\n}",
        "\nBefore:\n0 0 0\n0 0 0\n0 0 0\n\nAfter:\n1 1 1\n1 1 1\n1 1 1\n",
        "@Test\npublic void floodFillTest() {\n    // Set up the test data\n    int[][] image = new int[3][4];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 4; j++) {\n            if ((i == 1 && j == 2) || (i == 2 && j == 3)) {\n                image[i][j] = 1; // Set the pixel to old color\n            } else {\n                image[i][j] = 0; // Set the pixel to new color\n            }\n        }\n    }\n\n    // Test that the flood fill algorithm correctly fills the image\n    FloodFill.floodFill(image, 1, 2, 1, 0);\n    assertEquals(1, image[0][0]); // Top left pixel should be filled\n    assertEquals(1, image[0][1]); // Top right pixel should be filled\n    assertEquals(1, image[0][2]); // Bottom left pixel should be filled\n    assertEquals(1, image[0][3]); // Bottom right pixel should be filled\n    assertEquals(1, image[1][0]); // Left side of the fill area should be filled\n    assertEquals(1, image[1][1]); // Right side of the fill area should be filled\n    assertEquals(1, image[2][0]); // Top row of the fill area should be filled\n    assertEquals(1, image[2][1]); // Bottom row of the fill area should be filled\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = new int[3][4];\n        image[0][0] = 1;\n        image[1][2] = 2;\n        image[2][3] = 3;\n        image[1][1] = 0;\n        floodFill(image, 1, 1, 4, 0);\n        assertEquals(4, getPixel(image, 0, 0));\n        assertEquals(4, getPixel(image, 1, 2));\n        assertEquals(3, getPixel(image, 2, 3));\n        assertEquals(4, getPixel(image, 1, 1));\n    }\n}",
        "The `floodFill` method is a recursive method that fills in an image with the specified color. The method takes four arguments:\n\n* `image`: A 2D array representing the image to be filled.\n* `x`: The x-coordinate of the starting pixel.\n* `y`: The y-coordinate of the starting pixel.\n* `newColor`: The new color that will be used to fill the image.\n* `oldColor`: The original color of the pixels in the image.\n\nThe method first checks if the new and old colors are the same or if the x and y coordinates are outside the bounds of the image. If so, it returns immediately without making any changes.\n\nOtherwise, the method sets the pixel at the specified coordinates to the new color using the `putPixel` method. It then recursively calls itself with different coordinates to fill in the entire image. The coordinates that are checked for each pixel are:\n\n* Horizontally adjacent pixels (left and right)\n* Vertically adjacent pixels (up and down)\n* Diagonally adjacent pixels (top-right, bottom-right, top-left, bottom-left)\n\nThe method uses the `floodFill` method to recursively fill in each of these areas. The method continues until all pixels have been filled with the new color.",
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Create an image with two disconnected regions of different colors\n        int[][] image = new int[5][5];\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (i == 2 || j == 2) {\n                    image[i][j] = 1; // Color of the first region\n                } else {\n                    image[i][j] = 2; // Color of the second region\n                }\n            }\n        }\n        \n        // Call the floodFill method with the coordinates (0, 0) and color 3\n        int[][] resultImage = new int[5][5];\n        FloodFill.floodFill(image, 0, 0, 3, 1);\n        \n        // Check that all pixels in the first region are now colored with 3\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (i == 2 || j == 2) {\n                    assertEquals(resultImage[i][j], 3);\n                } else {\n                    assertNotEquals(resultImage[i][j], 3);\n                }\n            }\n        }\n        \n        // Check that all pixels in the second region are not colored with 3\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (i != 2 && j != 2) {\n                    assertNotEquals(resultImage[i][j], 3);\n                } else {\n                    assertEquals(resultImage[i][j], 1);\n                }\n            }\n        }\n        \n        // Check that the image is now connected and has no disconnected regions\n        for (int i = 0; i < 5; i++) {\n            for (int j = 0; j < 5; j++) {\n                assertEquals(resultImage[i][j], resultImage[i + 1][j]);\n                assertEquals(resultImage[i][j], resultImage[i][j + 1]);\n            }\n        }\n    }\n}\n",
        "@Test\npublic void floodFillTest() {\n    int[][] image = new int[3][3];\n    int x = 1;\n    int y = 1;\n    int newColor = 2;\n    int oldColor = 1;\n    \n    // Test case 1: The pixel at coordinates (x, y) has the value oldColor and is surrounded by pixels with different values.\n    image[0][0] = oldColor;\n    image[0][1] = newColor;\n    image[0][2] = newColor;\n    image[1][0] = newColor;\n    image[1][1] = oldColor;\n    image[1][2] = newColor;\n    image[2][0] = newColor;\n    image[2][1] = newColor;\n    image[2][2] = oldColor;\n    \n    floodFill(image, x, y, newColor, oldColor);\n    \n    assertEquals(newColor, image[x][y]);\n    assertEquals(newColor, image[0][1]);\n    assertEquals(newColor, image[1][0]);\n    assertEquals(newColor, image[2][0]);\n    assertEquals(newColor, image[1][2]);\n    \n    // Test case 2: The pixel at coordinates (x, y) has the value oldColor and is surrounded by pixels with the same value.\n    image = new int[3][3];\n    image[0][0] = oldColor;\n    image[0][1] = oldColor;\n    image[0][2] = oldColor;\n    image[1][0] = oldColor;\n    image[1][1] = oldColor;\n    image[1][2] = oldColor;\n    image[2][0] = oldColor;\n    image[2][1] = oldColor;\n    image[2][2] = oldColor;\n    \n    floodFill(image, x, y, newColor, oldColor);\n    \n    assertEquals(oldColor, image[x][y]);\n    assertEquals(oldColor, image[0][1]);\n    assertEquals(oldColor, image[1][0]);\n    assertEquals(oldColor, image[2][0]);\n    assertEquals(oldColor, image[1][2]);\n}"
    ]
}