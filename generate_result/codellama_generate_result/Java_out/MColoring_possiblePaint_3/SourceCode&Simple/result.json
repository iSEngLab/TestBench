{
    "project_name": "Java",
    "file_name": "MColoring.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": null,
    "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
    "class_name": "MColoring",
    "method_name": "possiblePaint",
    "arguments": [
        "ArrayList<Node> nodes",
        "int n",
        "int m"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a graph with 3 nodes and maximum color count of 2\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(new Node(1, new HashSet<>(Arrays.asList(2, 3))));\n        nodes.add(new Node(2, new HashSet<>(Arrays.asList(1, 3))));\n        nodes.add(new Node(3, new HashSet<>(Arrays.asList(1, 2))));\n\n        // Check that the graph can be painted with at most 2 colors\n        assertEquals(MColoring.possiblePaint(nodes, 3, 2), 1);\n    }\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a graph with 4 nodes and maximum of 2 colors\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(new Node(1, new HashSet<Integer>(Arrays.asList(2, 3))));\n        nodes.add(new Node(2, new HashSet<Integer>(Arrays.asList(1, 4))));\n        nodes.add(new Node(3, new HashSet<Integer>(Arrays.asList(1, 4))));\n        nodes.add(new Node(4, new HashSet<Integer>(Arrays.asList(2, 3))));\n        \n        // Test if the graph can be painted with maximum of 2 colors\n        int result = MColoring.possiblePaint(nodes, 4, 2);\n        assertEquals(1, result);\n    }\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        // create some nodes with edges between them\n        Node node1 = new Node(0, new HashSet<>());\n        Node node2 = new Node(1, new HashSet<>());\n        Node node3 = new Node(2, new HashSet<>());\n        Node node4 = new Node(3, new HashSet<>());\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n        nodes.add(node4);\n        \n        // create some edges between the nodes\n        node1.edges.add(node2);\n        node1.edges.add(node3);\n        node1.edges.add(node4);\n        node2.edges.add(node1);\n        node2.edges.add(node3);\n        node2.edges.add(node4);\n        node3.edges.add(node1);\n        node3.edges.add(node2);\n        node3.edges.add(node4);\n        node4.edges.add(node1);\n        node4.edges.add(node2);\n        node4.edges.add(node3);\n        \n        // test the possiblePaint method with different values of m\n        assertEquals(MColoring.possiblePaint(nodes, 4, 0), 0);\n        assertEquals(MColoring.possiblePaint(nodes, 4, 1), 1);\n        assertEquals(MColoring.possiblePaint(nodes, 4, 2), 1);\n        assertEquals(MColoring.possiblePaint(nodes, 4, 3), 1);\n    }\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a list of nodes with 3 edges each\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < 12; i++) {\n            nodes.add(new Node());\n        }\n        for (int i = 0; i < 4; i++) {\n            nodes.get(i).edges.add(i + 1);\n        }\n        for (int i = 5; i < 8; i++) {\n            nodes.get(i).edges.add(i - 1);\n        }\n        for (int i = 9; i < 12; i++) {\n            nodes.get(i).edges.add(i + 3);\n        }\n\n        // Test that the method returns 0 when the number of colors used exceeds m\n        assertEquals(MColoring.possiblePaint(nodes, 5, 4), 0);\n\n        // Test that the method returns 1 when the number of colors used does not exceed m\n        assertEquals(MColoring.possiblePaint(nodes, 5, 6), 1);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a graph with 3 nodes and maximum 2 colors\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n        \n        // Connect the nodes with edges\n        node1.edges = Set.of(node2, node3);\n        node2.edges = Set.of(node1, node3);\n        node3.edges = Set.of(node1, node2);\n        \n        // Test that the graph can be painted with 2 colors\n        assertEquals(MColoring.possiblePaint(nodes, 3, 2), 1);\n    }\n}",
        "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a list of nodes with 4 edges each, where each edge has a color value of 1, 2, or 3\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < 4; i++) {\n            Node node = new Node();\n            node.color = i % 3 + 1; // Set the color of each node to 1, 2, or 3\n            node.edges = new HashSet<>();\n            for (int j = 0; j < 4; j++) {\n                if (i != j) {\n                    Node neighbor = nodes.get(j);\n                    node.edges.add(neighbor.color);\n                }\n            }\n        }\n\n        // Test that the possiblePaint method returns 1 when all nodes can be painted with at most 3 colors\n        int m = 3;\n        assertEquals(1, MColoring.possiblePaint(nodes, m));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a list of nodes with edges\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            Node node = new Node();\n            node.edges = new HashSet<>();\n            for (int j = 0; j < 4; j++) {\n                node.edges.add(j);\n            }\n            nodes.add(node);\n        }\n        \n        // Test with m = 2, which should return 1\n        int n = 5;\n        int m = 2;\n        assertEquals(1, MColoring.possiblePaint(nodes, n, m));\n    }\n}",
        "@Test\npublic void possiblePaintTest() {\n    // Create a list of nodes with edges between them\n    ArrayList<Node> nodes = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n        Node node = new Node();\n        node.color = i + 1;\n        node.edges = new HashSet<>();\n        if (i == 0) {\n            node.edges.add(2);\n        } else if (i == 1) {\n            node.edges.add(3);\n        } else if (i == 2) {\n            node.edges.add(1);\n        } else if (i == 3) {\n            node.edges.add(0);\n        }\n        nodes.add(node);\n    }\n\n    // Test case 1: m = 4\n    int n = 4;\n    int m = 4;\n    assertEquals(1, possiblePaint(nodes, n, m));\n\n    // Test case 2: m = 3\n    m = 3;\n    assertEquals(0, possiblePaint(nodes, n, m));\n}",
        "import java.util.*;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a list of nodes with 3 edges each\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            Node node = new Node();\n            node.color = 1;\n            node.edges = new HashSet<>();\n            for (int j = 0; j < 3; j++) {\n                int edge = i * 3 + j;\n                node.edges.add(edge);\n            }\n            nodes.add(node);\n        }\n\n        // Test that the method returns 1 if all nodes are connected\n        assertEquals(1, MColoring.possiblePaint(nodes, 2, 3));\n\n        // Test that the method returns 0 if there is a disconnected node\n        Node disconnectedNode = new Node();\n        disconnectedNode.color = 1;\n        disconnectedNode.edges = new HashSet<>();\n        nodes.add(disconnectedNode);\n        assertEquals(0, MColoring.possiblePaint(nodes, 2, 3));\n    }\n}",
        "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        // Create a graph with 4 nodes and 3 edges\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n        Node node4 = new Node();\n        node1.edges.add(node2);\n        node1.edges.add(node3);\n        node1.edges.add(node4);\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n        nodes.add(node4);\n\n        // Test with n = 2 and m = 3\n        assertEquals(1, possiblePaint(nodes, 2, 3));\n    }\n}"
    ]
}