{
    "project_name": "Java",
    "file_name": "MColoring.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": null,
    "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
    "class_name": "MColoring",
    "method_name": "possiblePaint",
    "arguments": [
        "ArrayList<Node> nodes",
        "int n",
        "int m"
    ],
    "generate_test": [
        "@Test\npublic void possiblePaintTest() {\n    // Create a list of nodes for the test case\n    ArrayList<Node> nodes = new ArrayList<>();\n\n    // Add node 1 with edges to 2 and 3\n    nodes.add(new Node(1, Arrays.asList(2, 3)));\n\n    // Add node 2 with edge to 4\n    nodes.add(new Node(2, Arrays.asList(4)));\n\n    // Add node 3 with edges to 5 and 6\n    nodes.add(new Node(3, Arrays.asList(5, 6)));\n\n    // Add node 4 with edge to 7\n    nodes.add(new Node(4, Arrays.asList(7)));\n\n    // Add node 5 with edges to 8 and 9\n    nodes.add(new Node(5, Arrays.asList(8, 9)));\n\n    // Add node 6 with edge to 10\n    nodes.add(new Node(6, Arrays.asList(10)));\n\n    // Add node 7 with edges to 11 and 12\n    nodes.add(new Node(7, Arrays.asList(11, 12)));\n\n    // Add node 8 with edge to 13\n    nodes.add(new Node(8, Arrays.asList(13)));\n\n    // Add node 9 with edges to 14 and 15\n    nodes.add(new Node(9, Arrays.asList(14, 15)));\n\n    // Add node 10 with edge to 16\n    nodes.add(new Node(10, Arrays.asList(16)));\n\n    // Add node 11 with edges to 17 and 18\n    nodes.add(new Node(11, Arrays.asList(17, 18)));\n\n    // Add node 12 with edge to 19\n    nodes.add(new Node(12, Arrays.asList(19)));\n\n    // Add node 13 with edges to 20 and 21\n    nodes.add(new Node(13, Arrays.asList(20, 21)));\n\n    // Add node 14 with edge to 22\n    nodes.add(new Node(14, Arrays.asList(22)));\n\n    // Add node 15 with edges to 23 and 24\n    nodes.add(new Node(15, Arrays.asList(23, 24)));\n\n    // Add node 16 with edge to 25\n    nodes.add(new Node(16, Arrays.asList(25)));\n\n    // Add node 17 with edges to 26 and 27\n    nodes.add(new Node(17, Arrays.asList(26, 27)));\n\n    // Add node 18 with edge to 28\n    nodes.add(new Node(18, Arrays.asList(28)));\n\n    // Add node 19 with edges to 29 and 30\n    nodes.add(new Node(19, Arrays.asList(29, 30)));\n\n    // Add node 20 with edge to 31\n    nodes.add(new Node(20, Arrays.asList(31)));\n\n    // Add node 21 with edges to 32 and 33\n    nodes.add(new Node(21, Arrays.asList(32, 33)));\n\n    // Add node 22 with edge to 34\n    nodes.add(new Node(22, Arrays.asList(34)));\n\n    // Add node 23 with edges to 35 and 36\n    nodes.add(new Node(23, Arrays.asList(35, 36)));\n\n    // Add node 24 with edge to 37\n    nodes.add(new Node(24, Arrays.asList(37)));\n\n    // Add node 25 with edges to 38 and 39\n    nodes.add(new Node(25, Arrays.asList(38, 39)));\n\n    // Add node 26 with edge to 40\n    nodes.add(new Node(26, Arrays.asList(40)));\n\n    // Add node 27 with edges to 41 and 42\n    nodes.add(new Node(27, Arrays.asList(41, 42)));\n\n    // Add node 28 with edge to 43\n    nodes.add(new Node(28, Arrays.asList(43)));\n\n    // Add node 29 with edges to 44 and 45\n    nodes.add(new Node(29, Arrays.asList(44, 45)));\n\n    // Add node 30 with edge to 46\n    nodes.add(new Node(30, Arrays.asList(46)));\n\n    // Add node 31 with edges to 47 and 48\n    nodes.add(new Node(31, Arrays.asList(47, 48)));\n\n    // Add node 32 with edge to 49\n    nodes.add(new Node(32, Arrays.asList(49)));\n\n    // Add node 33 with edges to 50 and 51\n    nodes.add(new Node(33, Arrays.asList(50, 51)));\n\n    // Add node 34 with edge to 52\n    nodes.add(new Node(34, Arrays.asList(52)));\n\n    // Add node 35 with edges to 53 and 54\n    nodes.add(new Node(35, Arrays.asList(53, 54)));\n\n    // Add node 36 with edge to 55\n    nodes.add(new Node(36, Arrays.asList(55)));\n\n    // Add node 37 with edges to 56 and 57\n    nodes.add(new Node(37, Arrays.asList(56, 57)));\n\n    // Add node 38 with edge to 58\n    nodes.add(new Node(38, Arrays.asList(58)));\n\n    // Add node 39 with edges to 59 and 60\n    nodes.add(new Node(39, Arrays.asList(59, 60)));\n\n    // Add node 40 with edge to 61\n    nodes.add(new Node(40, Arrays.asList(61)));\n\n    // Add node 41 with edges to 62 and 63\n    nodes.add(new Node(41, Arrays.asList(62, 63)));\n\n    // Add node 42 with edge to 64\n    nodes.add(new Node(42, Arrays.asList(64)));\n\n    // Add node 43 with edges to 65 and 66\n    nodes.add(new Node(43, Arrays.asList(65, 66)));\n\n    // Add node 44 with edge to 67\n    nodes.add(new Node(44, Arrays.asList(67)));\n\n    // Add node 45 with edges to 68 and 69\n    nodes.add(new Node(45, Arrays.asList(68, 69)));\n\n    // Add node 46 with edge to 70\n    nodes.add(new Node(46, Arrays.asList(70)));\n\n    // Add node 47 with edges to 71 and 72\n    nodes.add(new Node(47, Arrays.asList(71, 72)));\n\n    // Add node 48 with edge to 73\n    nodes.add(new Node(48, Arrays.asList(73)));\n\n    // Add node 49 with edges to 74 and 75\n    nodes.add(new Node(49, Arrays.asList(74, 75)));\n\n    // Add node 50 with edge to 76\n    nodes.add(new Node(50, Arrays.asList(76)));\n\n    // Add node 51 with edges to 77 and 78\n    nodes.add(new Node(51, Arrays.asList(77, 78)));\n\n    // Add node 52 with edge to 79\n    nodes.add(new Node(52, Arrays.asList(79)));\n\n    // Add node 53 with edges to 80 and 81\n    nodes.add(new Node(53, Arrays.asList(80, 81)));\n\n    // Add node 54 with edge to 82\n    nodes.add(new Node(54, Arrays.asList(82)));\n\n    // Add node 55 with edges to 83 and 84\n    nodes.add(new Node(55, Arrays.asList(83, 84)));\n\n    // Add node 56 with edge to 85\n    nodes.add(new Node(56, Arrays.asList(85)));\n\n    // Add node 57 with edges to 86 and 87\n    nodes.add(new Node(57, Arrays.asList(86, 87)));\n\n    // Add node 58 with edge to 88\n    nodes.add(new Node(58, Arrays.asList(88)));\n\n    // Add node 59 with edges to 89 and 90\n    nodes.add(new Node(59, Arrays.asList(89, 90)));\n\n    // Add node 60 with edge to 91\n    nodes.add(new Node(60, Arrays.asList(91)));\n\n    // Add node 61 with edges to 92 and 93\n    nodes.add(new Node(61, Arrays.asList(92, 93)));\n\n    // Add node 62 with edge to 94\n    nodes.add(new Node(62, Arrays.asList(94)));\n\n    // Add node 63 with edges to 95 and 96\n    nodes.add(new Node(63, Arrays.asList(95, 96)));\n\n    // Add node 64 with edge to 97\n    nodes.add(new Node(64, Arrays.asList(97)));\n\n    // Add node 65 with edges to 98 and 99\n    nodes.add(new Node(65, Arrays.asList(98, 99)));\n\n    // Add node 66 with edge to 100\n    nodes.add(new Node(66, Arrays.asList(100)));\n\n    return nodes;\n}\n\\end{code}\n\nComment: I think this is an issue with your `Node` class and how you are using it in the `Graph` class. It would be helpful if you included those classes as well, or at least any methods that relate to creating and storing a `List<Node>`. You might also want to try adding some print statements or debug messages within your for loops so you can see where exactly your code is failing.\n\nComment: I have added my Node class and the method that creates nodes in the Graph class. Thank you!\n\nAnswer: So i think the error comes from the fact that you are using an ArrayList instead of a LinkedList to store your graph structure. You are adding and removing elements of that list during the algorithm execution, which can lead to a lot of shifting when you remove elements in the middle of the list. This can cause problems in other parts of your program as well because it changes the index of each element in the list. So instead of using an ArrayList for storing your graph structure I would suggest using a LinkedList, this should make your code run much faster and prevent similar bugs from happening.\n\nHere is some documentation on the difference between the two structures: https://beginnersbook.com/2013/12/java-arraylist-vs-linkedlist/\n\nComment: Thank you so much! I changed ArrayList<Node> adjList to LinkedList<Node> and it worked fine. However, i tried running my code with a large dataset and it didn't work because LinkedList adds nodes in the order of insertion. My edges are undirected, so in order for the algorithm to run correctly, I need to have each node in its corresponding edge in the list. Is there any way around this?\n\nComment: @ShanZhuang No problem! Sorry i couldn't help you more on your question. I would suggest trying out a different structure, maybe even make it an array and use the index as a pointer to another array where each node has a corresponding edge. I also think that using an hashmap could be a solution, but im not sure if that would work with undirected edges. Good luck!\n\nComment: Thank you for your help though!",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        int n = 2;\n        int m = 3;\n\n        // Create a visited array of n nodes\n        ArrayList<Integer> visited = new ArrayList<Integer>();\n        for (int i = 0; i < n + 1; i++) {\n            visited.add(0);\n        }\n\n        // maxColors used till now are 1 as\n        // all nodes are painted color 1\n        int maxColors = 1;\n\n        for (int sv = 1; sv <= n; sv++) {\n            if (visited.get(sv) > 0) {\n                continue;\n            }\n\n            // If the starting point is unvisited,\n            // mark it visited and push it in queue\n            visited.set(sv, 1);\n            Queue<Integer> q = new LinkedList<>();\n            q.add(sv);\n\n            // BFS\n            while (q.size() != 0) {\n                int top = q.peek();\n                q.remove();\n\n                // Checking all adjacent nodes\n                // to \"top\" edge in our queue\n                for (int it : nodes.get(top).edges) {\n\n                    // If the color of the\n                    // adjacent node is same, increase it by\n                    // 1\n                    if (nodes.get(top).color == nodes.get(it).color) {\n                        nodes.get(it).color += 1;\n                    }\n\n                    // If number of colors used exceeds m,\n                    // return 0\n                    maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                    if (maxColors > m) return 0;\n\n                    // If the adjacent node is not visited,\n                    // mark it visited and push it in queue\n                    if (visited.get(it) == 0) {\n                        visited.set(it, 1);\n                        q.add(it);\n                    }\n                }\n            }\n        }\n        assertEquals(possiblePaint(nodes, n, m), 1);\n    }\n}",
        "\nimport java.util.ArrayList;\n\n@Test\npublic void possiblePaintTest() {\n    ArrayList<Node> nodes = new ArrayList<>();\n    int n = 5, m = 3;\n\n    Node node1 = new Node(1);\n    Node node2 = new Node(2);\n    Node node3 = new Node(3);\n    Node node4 = new Node(4);\n    Node node5 = new Node(5);\n\n    nodes.add(node1);\n    nodes.add(node2);\n    nodes.add(node3);\n    nodes.add(node4);\n    nodes.add(node5);\n\n    node1.edges = new ArrayList<>();\n    node1.edges.add(2);\n    node1.edges.add(3);\n\n    node2.edges = new ArrayList<>();\n    node2.edges.add(4);\n    node2.edges.add(5);\n\n    node3.edges = new ArrayList<>();\n    node3.edges.add(1);\n\n    node4.edges = new ArrayList<>();\n    node4.edges.add(3);\n\n    node5.edges = new ArrayList<>();\n    node5.edges.add(2);\n\n    assertEquals(possiblePaint(nodes, n, m), 1);\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node1 = new Node(1, Arrays.asList(2));\n        Node node2 = new Node(2, Arrays.asList(3));\n        Node node3 = new Node(3, Arrays.asList(4));\n        Node node4 = new Node(4, Arrays.asList(5));\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n        nodes.add(node4);\n        assertEquals(possiblePaint(nodes, 4, 3), 1);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a list of nodes with 3 edges each\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            Node node = new Node();\n            node.edges = new ArrayList<>();\n            for (int j = 0; j < 3; j++) {\n                node.edges.add(j);\n            }\n            nodes.add(node);\n        }\n\n        // Set the colors of the first two nodes to 1\n        nodes.get(0).color = 1;\n        nodes.get(1).color = 1;\n\n        // Check that the method returns 1 when all colors are different and less than or equal to m\n        assertEquals(possiblePaint(nodes, 2, 2), 1);\n\n        // Check that the method returns 0 when there is a cycle with the same color\n        nodes.get(0).edges.add(2);\n        assertEquals(possiblePaint(nodes, 3, 3), 0);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a graph with 5 nodes and 4 edges\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(new Node(1, new ArrayList<Integer>() {{ add(2); }}));\n        nodes.add(new Node(2, new ArrayList<Integer>() {{ add(3); add(4); }}));\n        nodes.add(new Node(3, new ArrayList<Integer>() {{ add(5); }}));\n        nodes.add(new Node(4, new ArrayList<Integer>() {{ add(1); }}));\n        nodes.add(new Node(5, new ArrayList<Integer>() {{ add(2); }})));\n\n        // Test the possiblePaint method with n = 5 and m = 3\n        int result = possiblePaint(nodes, 5, 3);\n        assertEquals(result, 1);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(new Node(1, new ArrayList<Integer>(Arrays.asList(2))));\n        nodes.add(new Node(2, new ArrayList<Integer>(Arrays.asList(3))));\n        nodes.add(new Node(3, new ArrayList<Integer>(Arrays.asList(4))));\n        int n = 3;\n        int m = 10;\n        assertEquals(possiblePaint(nodes, n, m), 1);\n    }\n}",
        "@Test\npublic void possiblePaintTest() {\n    // Create a list of nodes with edges between them\n    ArrayList<Node> nodes = new ArrayList<>();\n    Node node1 = new Node(0, 2);\n    Node node2 = new Node(1, 3);\n    Node node3 = new Node(4, 5);\n    Node node4 = new Node(6, 7);\n    nodes.add(node1);\n    nodes.add(node2);\n    nodes.add(node3);\n    nodes.add(node4);\n\n    // Set the edges between the nodes\n    node1.edges.add(0);\n    node1.edges.add(1);\n    node2.edges.add(1);\n    node2.edges.add(3);\n    node3.edges.add(4);\n    node3.edges.add(5);\n    node4.edges.add(6);\n    node4.edges.add(7);\n\n    // Test that the method returns 1 when there are no conflicts between nodes\n    assertEquals(1, possiblePaint(nodes, 8, 3));\n\n    // Add a conflict between two nodes by giving them the same color\n    nodes.get(0).color = nodes.get(1).color;\n\n    // Test that the method returns 0 when there is a conflict between nodes\n    assertEquals(0, possiblePaint(nodes, 8, 3));\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            nodes.add(new Node());\n        }\n        \n        nodes.get(0).edges = Arrays.asList(1, 2);\n        nodes.get(1).edges = Arrays.asList(0, 3);\n        nodes.get(2).edges = Arrays.asList(0, 4);\n        nodes.get(3).edges = Arrays.asList(1, 5);\n        nodes.get(4).edges = Arrays.asList(2, 6);\n        \n        int n = 7;\n        int m = 5;\n        \n        assertEquals(possiblePaint(nodes, n, m), 1);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        int n = 10; // Number of nodes\n        int m = 2; // Maximum number of colors\n\n        // Add nodes to the list\n        for (int i = 0; i < n; i++) {\n            Node node = new Node();\n            node.edges = new ArrayList<>();\n            nodes.add(node);\n        }\n\n        // Connect nodes with edges\n        nodes.get(0).edges.add(nodes.get(1));\n        nodes.get(1).edges.add(nodes.get(2));\n        nodes.get(2).edges.add(nodes.get(3));\n        nodes.get(3).edges.add(nodes.get(4));\n        nodes.get(4).edges.add(nodes.get(5));\n        nodes.get(5).edges.add(nodes.get(6));\n        nodes.get(6).edges.add(nodes.get(7));\n        nodes.get(7).edges.add(nodes.get(8));\n        nodes.get(8).edges.add(nodes.get(9));\n\n        // Run the possiblePaint method and check the result\n        int result = Node.possiblePaint(nodes, n, m);\n        assertEquals(result, 1);\n    }\n}"
    ]
}