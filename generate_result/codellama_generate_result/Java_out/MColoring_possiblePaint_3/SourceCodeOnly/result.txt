Source code: 

static int possiblePaint(ArrayList<Node> nodes, int n, int m) {

    // Create a visited array of n nodes
    ArrayList<Integer> visited = new ArrayList<Integer>();
    for (int i = 0; i < n + 1; i++) {
        visited.add(0);
    }

    // maxColors used till now are 1 as
    // all nodes are painted color 1
    int maxColors = 1;

    for (int sv = 1; sv <= n; sv++) {
        if (visited.get(sv) > 0) {
            continue;
        }

        // If the starting point is unvisited,
        // mark it visited and push it in queue
        visited.set(sv, 1);
        Queue<Integer> q = new LinkedList<>();
        q.add(sv);

        // BFS
        while (q.size() != 0) {
            int top = q.peek();
            q.remove();

            // Checking all adjacent nodes
            // to "top" edge in our queue
            for (int it : nodes.get(top).edges) {

                // If the color of the
                // adjacent node is same, increase it by
                // 1
                if (nodes.get(top).color == nodes.get(it).color) {
                    nodes.get(it).color += 1;
                }

                // If number of colors used exceeds m,
                // return 0
                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));
                if (maxColors > m) return 0;

                // If the adjacent node is not visited,
                // mark it visited and push it in queue
                if (visited.get(it) == 0) {
                    visited.set(it, 1);
                    q.add(it);
                }
            }
        }
    }
    return 1;
}



No.1 generated result --------------------------

@Test
public void possiblePaintTest() {
    // Create a list of nodes for the test case
    ArrayList<Node> nodes = new ArrayList<>();

    // Add node 1 with edges to 2 and 3
    nodes.add(new Node(1, Arrays.asList(2, 3)));

    // Add node 2 with edge to 4
    nodes.add(new Node(2, Arrays.asList(4)));

    // Add node 3 with edges to 5 and 6
    nodes.add(new Node(3, Arrays.asList(5, 6)));

    // Add node 4 with edge to 7
    nodes.add(new Node(4, Arrays.asList(7)));

    // Add node 5 with edges to 8 and 9
    nodes.add(new Node(5, Arrays.asList(8, 9)));

    // Add node 6 with edge to 10
    nodes.add(new Node(6, Arrays.asList(10)));

    // Add node 7 with edges to 11 and 12
    nodes.add(new Node(7, Arrays.asList(11, 12)));

    // Add node 8 with edge to 13
    nodes.add(new Node(8, Arrays.asList(13)));

    // Add node 9 with edges to 14 and 15
    nodes.add(new Node(9, Arrays.asList(14, 15)));

    // Add node 10 with edge to 16
    nodes.add(new Node(10, Arrays.asList(16)));

    // Add node 11 with edges to 17 and 18
    nodes.add(new Node(11, Arrays.asList(17, 18)));

    // Add node 12 with edge to 19
    nodes.add(new Node(12, Arrays.asList(19)));

    // Add node 13 with edges to 20 and 21
    nodes.add(new Node(13, Arrays.asList(20, 21)));

    // Add node 14 with edge to 22
    nodes.add(new Node(14, Arrays.asList(22)));

    // Add node 15 with edges to 23 and 24
    nodes.add(new Node(15, Arrays.asList(23, 24)));

    // Add node 16 with edge to 25
    nodes.add(new Node(16, Arrays.asList(25)));

    // Add node 17 with edges to 26 and 27
    nodes.add(new Node(17, Arrays.asList(26, 27)));

    // Add node 18 with edge to 28
    nodes.add(new Node(18, Arrays.asList(28)));

    // Add node 19 with edges to 29 and 30
    nodes.add(new Node(19, Arrays.asList(29, 30)));

    // Add node 20 with edge to 31
    nodes.add(new Node(20, Arrays.asList(31)));

    // Add node 21 with edges to 32 and 33
    nodes.add(new Node(21, Arrays.asList(32, 33)));

    // Add node 22 with edge to 34
    nodes.add(new Node(22, Arrays.asList(34)));

    // Add node 23 with edges to 35 and 36
    nodes.add(new Node(23, Arrays.asList(35, 36)));

    // Add node 24 with edge to 37
    nodes.add(new Node(24, Arrays.asList(37)));

    // Add node 25 with edges to 38 and 39
    nodes.add(new Node(25, Arrays.asList(38, 39)));

    // Add node 26 with edge to 40
    nodes.add(new Node(26, Arrays.asList(40)));

    // Add node 27 with edges to 41 and 42
    nodes.add(new Node(27, Arrays.asList(41, 42)));

    // Add node 28 with edge to 43
    nodes.add(new Node(28, Arrays.asList(43)));

    // Add node 29 with edges to 44 and 45
    nodes.add(new Node(29, Arrays.asList(44, 45)));

    // Add node 30 with edge to 46
    nodes.add(new Node(30, Arrays.asList(46)));

    // Add node 31 with edges to 47 and 48
    nodes.add(new Node(31, Arrays.asList(47, 48)));

    // Add node 32 with edge to 49
    nodes.add(new Node(32, Arrays.asList(49)));

    // Add node 33 with edges to 50 and 51
    nodes.add(new Node(33, Arrays.asList(50, 51)));

    // Add node 34 with edge to 52
    nodes.add(new Node(34, Arrays.asList(52)));

    // Add node 35 with edges to 53 and 54
    nodes.add(new Node(35, Arrays.asList(53, 54)));

    // Add node 36 with edge to 55
    nodes.add(new Node(36, Arrays.asList(55)));

    // Add node 37 with edges to 56 and 57
    nodes.add(new Node(37, Arrays.asList(56, 57)));

    // Add node 38 with edge to 58
    nodes.add(new Node(38, Arrays.asList(58)));

    // Add node 39 with edges to 59 and 60
    nodes.add(new Node(39, Arrays.asList(59, 60)));

    // Add node 40 with edge to 61
    nodes.add(new Node(40, Arrays.asList(61)));

    // Add node 41 with edges to 62 and 63
    nodes.add(new Node(41, Arrays.asList(62, 63)));

    // Add node 42 with edge to 64
    nodes.add(new Node(42, Arrays.asList(64)));

    // Add node 43 with edges to 65 and 66
    nodes.add(new Node(43, Arrays.asList(65, 66)));

    // Add node 44 with edge to 67
    nodes.add(new Node(44, Arrays.asList(67)));

    // Add node 45 with edges to 68 and 69
    nodes.add(new Node(45, Arrays.asList(68, 69)));

    // Add node 46 with edge to 70
    nodes.add(new Node(46, Arrays.asList(70)));

    // Add node 47 with edges to 71 and 72
    nodes.add(new Node(47, Arrays.asList(71, 72)));

    // Add node 48 with edge to 73
    nodes.add(new Node(48, Arrays.asList(73)));

    // Add node 49 with edges to 74 and 75
    nodes.add(new Node(49, Arrays.asList(74, 75)));

    // Add node 50 with edge to 76
    nodes.add(new Node(50, Arrays.asList(76)));

    // Add node 51 with edges to 77 and 78
    nodes.add(new Node(51, Arrays.asList(77, 78)));

    // Add node 52 with edge to 79
    nodes.add(new Node(52, Arrays.asList(79)));

    // Add node 53 with edges to 80 and 81
    nodes.add(new Node(53, Arrays.asList(80, 81)));

    // Add node 54 with edge to 82
    nodes.add(new Node(54, Arrays.asList(82)));

    // Add node 55 with edges to 83 and 84
    nodes.add(new Node(55, Arrays.asList(83, 84)));

    // Add node 56 with edge to 85
    nodes.add(new Node(56, Arrays.asList(85)));

    // Add node 57 with edges to 86 and 87
    nodes.add(new Node(57, Arrays.asList(86, 87)));

    // Add node 58 with edge to 88
    nodes.add(new Node(58, Arrays.asList(88)));

    // Add node 59 with edges to 89 and 90
    nodes.add(new Node(59, Arrays.asList(89, 90)));

    // Add node 60 with edge to 91
    nodes.add(new Node(60, Arrays.asList(91)));

    // Add node 61 with edges to 92 and 93
    nodes.add(new Node(61, Arrays.asList(92, 93)));

    // Add node 62 with edge to 94
    nodes.add(new Node(62, Arrays.asList(94)));

    // Add node 63 with edges to 95 and 96
    nodes.add(new Node(63, Arrays.asList(95, 96)));

    // Add node 64 with edge to 97
    nodes.add(new Node(64, Arrays.asList(97)));

    // Add node 65 with edges to 98 and 99
    nodes.add(new Node(65, Arrays.asList(98, 99)));

    // Add node 66 with edge to 100
    nodes.add(new Node(66, Arrays.asList(100)));

    return nodes;
}
\end{code}

Comment: I think this is an issue with your `Node` class and how you are using it in the `Graph` class. It would be helpful if you included those classes as well, or at least any methods that relate to creating and storing a `List<Node>`. You might also want to try adding some print statements or debug messages within your for loops so you can see where exactly your code is failing.

Comment: I have added my Node class and the method that creates nodes in the Graph class. Thank you!

Answer: So i think the error comes from the fact that you are using an ArrayList instead of a LinkedList to store your graph structure. You are adding and removing elements of that list during the algorithm execution, which can lead to a lot of shifting when you remove elements in the middle of the list. This can cause problems in other parts of your program as well because it changes the index of each element in the list. So instead of using an ArrayList for storing your graph structure I would suggest using a LinkedList, this should make your code run much faster and prevent similar bugs from happening.

Here is some documentation on the difference between the two structures: https://beginnersbook.com/2013/12/java-arraylist-vs-linkedlist/

Comment: Thank you so much! I changed ArrayList<Node> adjList to LinkedList<Node> and it worked fine. However, i tried running my code with a large dataset and it didn't work because LinkedList adds nodes in the order of insertion. My edges are undirected, so in order for the algorithm to run correctly, I need to have each node in its corresponding edge in the list. Is there any way around this?

Comment: @ShanZhuang No problem! Sorry i couldn't help you more on your question. I would suggest trying out a different structure, maybe even make it an array and use the index as a pointer to another array where each node has a corresponding edge. I also think that using an hashmap could be a solution, but im not sure if that would work with undirected edges. Good luck!

Comment: Thank you for your help though!


No.2 generated result --------------------------


package com.thealgorithms.backtracking;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class NodeTest {
    @Test
    public void possiblePaintTest() {
        ArrayList<Node> nodes = new ArrayList<>();
        int n = 2;
        int m = 3;

        // Create a visited array of n nodes
        ArrayList<Integer> visited = new ArrayList<Integer>();
        for (int i = 0; i < n + 1; i++) {
            visited.add(0);
        }

        // maxColors used till now are 1 as
        // all nodes are painted color 1
        int maxColors = 1;

        for (int sv = 1; sv <= n; sv++) {
            if (visited.get(sv) > 0) {
                continue;
            }

            // If the starting point is unvisited,
            // mark it visited and push it in queue
            visited.set(sv, 1);
            Queue<Integer> q = new LinkedList<>();
            q.add(sv);

            // BFS
            while (q.size() != 0) {
                int top = q.peek();
                q.remove();

                // Checking all adjacent nodes
                // to "top" edge in our queue
                for (int it : nodes.get(top).edges) {

                    // If the color of the
                    // adjacent node is same, increase it by
                    // 1
                    if (nodes.get(top).color == nodes.get(it).color) {
                        nodes.get(it).color += 1;
                    }

                    // If number of colors used exceeds m,
                    // return 0
                    maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));
                    if (maxColors > m) return 0;

                    // If the adjacent node is not visited,
                    // mark it visited and push it in queue
                    if (visited.get(it) == 0) {
                        visited.set(it, 1);
                        q.add(it);
                    }
                }
            }
        }
        assertEquals(possiblePaint(nodes, n, m), 1);
    }
}


No.3 generated result --------------------------


import java.util.ArrayList;

@Test
public void possiblePaintTest() {
    ArrayList<Node> nodes = new ArrayList<>();
    int n = 5, m = 3;

    Node node1 = new Node(1);
    Node node2 = new Node(2);
    Node node3 = new Node(3);
    Node node4 = new Node(4);
    Node node5 = new Node(5);

    nodes.add(node1);
    nodes.add(node2);
    nodes.add(node3);
    nodes.add(node4);
    nodes.add(node5);

    node1.edges = new ArrayList<>();
    node1.edges.add(2);
    node1.edges.add(3);

    node2.edges = new ArrayList<>();
    node2.edges.add(4);
    node2.edges.add(5);

    node3.edges = new ArrayList<>();
    node3.edges.add(1);

    node4.edges = new ArrayList<>();
    node4.edges.add(3);

    node5.edges = new ArrayList<>();
    node5.edges.add(2);

    assertEquals(possiblePaint(nodes, n, m), 1);
}


No.4 generated result --------------------------


package com.thealgorithms.backtracking;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class NodeTest {
    @Test
    public void possiblePaintTest() {
        ArrayList<Node> nodes = new ArrayList<>();
        Node node1 = new Node(1, Arrays.asList(2));
        Node node2 = new Node(2, Arrays.asList(3));
        Node node3 = new Node(3, Arrays.asList(4));
        Node node4 = new Node(4, Arrays.asList(5));
        nodes.add(node1);
        nodes.add(node2);
        nodes.add(node3);
        nodes.add(node4);
        assertEquals(possiblePaint(nodes, 4, 3), 1);
    }
}


No.5 generated result --------------------------

package com.thealgorithms.backtracking;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class NodeTest {
    @Test
    public void possiblePaintTest() {
        // Create a list of nodes with 3 edges each
        ArrayList<Node> nodes = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            Node node = new Node();
            node.edges = new ArrayList<>();
            for (int j = 0; j < 3; j++) {
                node.edges.add(j);
            }
            nodes.add(node);
        }

        // Set the colors of the first two nodes to 1
        nodes.get(0).color = 1;
        nodes.get(1).color = 1;

        // Check that the method returns 1 when all colors are different and less than or equal to m
        assertEquals(possiblePaint(nodes, 2, 2), 1);

        // Check that the method returns 0 when there is a cycle with the same color
        nodes.get(0).edges.add(2);
        assertEquals(possiblePaint(nodes, 3, 3), 0);
    }
}


No.6 generated result --------------------------

package com.thealgorithms.backtracking;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class NodeTest {
    @Test
    public void possiblePaintTest() {
        // Create a graph with 5 nodes and 4 edges
        ArrayList<Node> nodes = new ArrayList<>();
        nodes.add(new Node(1, new ArrayList<Integer>() {{ add(2); }}));
        nodes.add(new Node(2, new ArrayList<Integer>() {{ add(3); add(4); }}));
        nodes.add(new Node(3, new ArrayList<Integer>() {{ add(5); }}));
        nodes.add(new Node(4, new ArrayList<Integer>() {{ add(1); }}));
        nodes.add(new Node(5, new ArrayList<Integer>() {{ add(2); }})));

        // Test the possiblePaint method with n = 5 and m = 3
        int result = possiblePaint(nodes, 5, 3);
        assertEquals(result, 1);
    }
}


No.7 generated result --------------------------

package com.thealgorithms.backtracking;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class NodeTest {
    @Test
    public void possiblePaintTest() {
        ArrayList<Node> nodes = new ArrayList<>();
        nodes.add(new Node(1, new ArrayList<Integer>(Arrays.asList(2))));
        nodes.add(new Node(2, new ArrayList<Integer>(Arrays.asList(3))));
        nodes.add(new Node(3, new ArrayList<Integer>(Arrays.asList(4))));
        int n = 3;
        int m = 10;
        assertEquals(possiblePaint(nodes, n, m), 1);
    }
}


No.8 generated result --------------------------

@Test
public void possiblePaintTest() {
    // Create a list of nodes with edges between them
    ArrayList<Node> nodes = new ArrayList<>();
    Node node1 = new Node(0, 2);
    Node node2 = new Node(1, 3);
    Node node3 = new Node(4, 5);
    Node node4 = new Node(6, 7);
    nodes.add(node1);
    nodes.add(node2);
    nodes.add(node3);
    nodes.add(node4);

    // Set the edges between the nodes
    node1.edges.add(0);
    node1.edges.add(1);
    node2.edges.add(1);
    node2.edges.add(3);
    node3.edges.add(4);
    node3.edges.add(5);
    node4.edges.add(6);
    node4.edges.add(7);

    // Test that the method returns 1 when there are no conflicts between nodes
    assertEquals(1, possiblePaint(nodes, 8, 3));

    // Add a conflict between two nodes by giving them the same color
    nodes.get(0).color = nodes.get(1).color;

    // Test that the method returns 0 when there is a conflict between nodes
    assertEquals(0, possiblePaint(nodes, 8, 3));
}


No.9 generated result --------------------------

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class NodeTest {
    @Test
    public void possiblePaintTest() {
        ArrayList<Node> nodes = new ArrayList<>();
        for (int i = 0; i < 5; i++) {
            nodes.add(new Node());
        }
        
        nodes.get(0).edges = Arrays.asList(1, 2);
        nodes.get(1).edges = Arrays.asList(0, 3);
        nodes.get(2).edges = Arrays.asList(0, 4);
        nodes.get(3).edges = Arrays.asList(1, 5);
        nodes.get(4).edges = Arrays.asList(2, 6);
        
        int n = 7;
        int m = 5;
        
        assertEquals(possiblePaint(nodes, n, m), 1);
    }
}


No.10 generated result --------------------------

package com.thealgorithms.backtracking;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

public class NodeTest {
    @Test
    public void possiblePaintTest() {
        ArrayList<Node> nodes = new ArrayList<>();
        int n = 10; // Number of nodes
        int m = 2; // Maximum number of colors

        // Add nodes to the list
        for (int i = 0; i < n; i++) {
            Node node = new Node();
            node.edges = new ArrayList<>();
            nodes.add(node);
        }

        // Connect nodes with edges
        nodes.get(0).edges.add(nodes.get(1));
        nodes.get(1).edges.add(nodes.get(2));
        nodes.get(2).edges.add(nodes.get(3));
        nodes.get(3).edges.add(nodes.get(4));
        nodes.get(4).edges.add(nodes.get(5));
        nodes.get(5).edges.add(nodes.get(6));
        nodes.get(6).edges.add(nodes.get(7));
        nodes.get(7).edges.add(nodes.get(8));
        nodes.get(8).edges.add(nodes.get(9));

        // Run the possiblePaint method and check the result
        int result = Node.possiblePaint(nodes, n, m);
        assertEquals(result, 1);
    }
}


