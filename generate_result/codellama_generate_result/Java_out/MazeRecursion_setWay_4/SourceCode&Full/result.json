{
    "project_name": "Java",
    "file_name": "MazeRecursion.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
    "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
    "class_name": "MazeRecursion",
    "method_name": "setWay",
    "arguments": [
        "int[][] map",
        "int i",
        "int j"
    ],
    "generate_test": [
        "The `setWay()` method is a recursive function that tries to find a path for the ball in the maze. It works by checking each possible move (up, down, left, right) from its current position and marking those moves as \"feasible\" or \"not feasible\". If the ball reaches the end of the maze, it returns `true`. Otherwise, it recursively calls itself to try all possible paths until a path is found.\n\nThe method starts by checking if the ball has reached the end of the maze already (i.e., if the current position is at `[6][5]`). If so, it returns true indicating that a path was found. Otherwise, it checks each of the four possible moves from its current position and marks those moves as \"feasible\" or \"not feasible\".\n\nIf the ball cannot move in any direction (i.e., all four moves are not feasible), it marks the current position as \"dead end\" and returns `false`. This indicates that there is no path to the maze's exit from this point, and the backtracking algorithm can go one step up in the recursion tree and try another move at the previous position.\n\nThe method calls itself recursively until a path is found or all possible moves have been exhausted.\n\nThe `setWay2()` method is similar to the `setWay()` method but with an alternative set of moves (up, right, down, left). This is done to show that there can be multiple solutions for a maze problem and the backtracking algorithm can find different paths if it is given different starting points.\n\nHere are some possible test cases:\n1. The ball starts from position `[0][0]` in the maze and reaches the exit at `[6][5]`: The `setWay()` method should return `true` because a path was found, and the `setWay2()` method should also return `true`.\n2. The ball starts from position `[0][0]` in the maze but cannot reach the exit: The `setWay()` method should return `false` because there is no path to the maze's exit from this point, and the `setWay2()` method should also return `false`.\n3. The ball starts from position `[6][5]` in the maze but cannot reach the exit: The `setWay()` method should return `false` because there is no path to the maze's exit from this point, and the `setWay2()` method should also return `false`.\n4. The ball starts from position `[3][3]` in the maze but cannot reach the exit: The `setWay()` method should return `false` because there is no path to the maze's exit from this point, and the `setWay2()` method should also return false.\n5. The ball starts from position `[0][4]` in the maze but cannot reach the exit: Both methods (`setWay()` and `setWay2()`) should return false indicating that there is no path to the maze's exit from this point.\n\n### Response:",
        "[/response]  \n[/inst]  \n[inst:paragraph]  \nIf you're interested in learning more about algorithms and data structures, I would recommend checking out \"Cracking the Coding Interview\" by Gayle Laakmann McDowell. It's a comprehensive book that covers a wide range of topics, including recursion and backtracking. Additionally, there are many online resources and practice platforms available, such as LeetCode, HackerRank, and CodeWars, where you can find challenging algorithmic problems to solve and practice your skills. [2]\n[/inst]  \n[inst:bookmark]  \nHere are a few more resources that might be helpful for learning about algorithms and data structures:\n\n* \"Algorithms\" by Robert Sedgewick and Kevin Wayne - This book is considered a classic in the field of algorithms and covers a wide range of topics, including recursion and backtracking.\n* \"Data Structures and Algorithms in Python\" by Michael T. Goodrich et al. - This book covers both data structures and algorithms, and uses Python as the programming language to illustrate concepts. It's a great resource for anyone looking to learn about these topics in Python specifically.\n* \"Problem Solving with Algorithms and Data Structures using Python\" by David Masad - This book uses Python to introduce readers to problem-solving strategies, algorithms, and data structures. It covers a wide range of topics, including recursion and backtracking.\n[/inst]  \n[inst:online-resources]  \nHere are some additional online resources that might be helpful for learning about algorithms and data structures:\n\n* Codecademy - This website offers interactive coding lessons on a variety of programming topics, including algorithms and data structures.\n* Coursera - This platform offers a wide range of courses on computer science and related topics, including algorithm design and implementation.\n* edX - This website offers a variety of online courses and certificates from top universities and organizations, many of which cover topics in algorithms and data structures.\n* FreeCodeCamp - This website offers interactive coding lessons and projects, with a focus on web development. It also covers a range of other topics, including algorithms and data structures.\n* GeeksforGeeks - This website provides detailed explanations and practice problems for a wide range of algorithms and data structures, including recursion and backtracking.\n* HackerRank - This website offers a variety of algorithmic problems to solve, many of which involve recursion and backtracking. It also has a strong focus on competitive programming.\n* LeetCode - This website offers a wide range of algorithmic problems to solve, many of which involve recursion and backtracking. It also has a strong focus on competitive programming.\n* Udemy - This website offers free online courses from top universities and organizations, including topics like algorithms and data structures.\n[/inst]  \n[inst:youtube-video-id]  \nHere's a YouTube video that demonstrates how to solve the \"N Queen Problem\" using recursion and backtracking in Python:\n[/yt:vehicle]  \n[1]: https://www.amazon.com/Cracking-Coding-Interview-Questions-Programming-ebook/dp/B00D9GX26\n[2]: https://www.coursera.org/learn/python\n[3]: https://www.udemy.com/courses/programming-languages/python/745186/0/1\n[4]: https://www.leetcode.com\n[5]: https://www.freecodecamp.org/news/how-to-solve-n-queen-problem-using-recursion-backtracking-python-example-explained-3673392a5b08/\n[/yt:vehicle]  ",
        "<FILL>\n",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = {{1, 0, 1, 1, 1, 1, 1}, // 1 represents the wall\uff0c0 means the ball can go through this position\n                       {1, 1, 0, 1, 1, 1, 1},\n                       {1, 1, 1, 0, 1, 1, 1},\n                       {1, 1, 1, 1, 0, 1, 1},\n                       {1, 1, 1, 1, 1, 0, 1},\n                       {1, 1, 1, 1, 1, 1, 0}}; // 2 means the path is feasible\uff0c3 means the ball has gone through this point but this path is dead end\n        assertTrue(MazeRecursion.setWay(map, 0, 0)); // assert that we can find a way in the maze\n    }\n}\n",
        "The test case should pass all the unit tests and have a good code coverage.\nHere is an example of how you could implement this test case:\n\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[7][8]; // 7 rows, 8 columns\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 6; j++) {\n                map[i][j] = 0;\n            }\n        }\n        map[3][2] = 1; // set wall at position [3][2]\n        assertFalse(MazeRecursion.setWay(map, 0, 0)); // check if the ball can reach the end of the maze with initial position [0][0]\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 6; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n    /**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */\n    public static boolean setWay(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : down -> right -> up -> left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                           // first\u3002\n            if (setWay(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay(map, i - 1,j)) { // go up\n                return true;\n            } else if (setWay(map, i, j - 1)) { // go left\n                        return true;\n            } else {\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3.\n            // In this case, return false because the ball cannot hit the wall,\n            // go through the path that has gone through before, and go to the dead end.\n            return false;\n        }\n    }\n}\n",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\n\nclass MazeRecursionTest {\n    @Test\n    void setWayTest() {\n        int[][] map = new int[8][7];\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (i == 6 && j == 5) {\n                    map[i][j] = 2; // The ball can reach the end of maze. means the we have found a path for the ball\n                } else {\n                    map[i][j] = 0;\n                }\n            }\n        }\n        assertTrue(MazeRecursion.setWay(map, 0, 0)); // Testing setWay() by giving starting point (0,0)\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                if ((i == 6 && j == 5) || (i == 3 && j == 2)) {\n                    assertEquals(map[i][j], 1); // Verify that the path has been marked.\n                } else {\n                    assertEquals(map[i][j], 0); // Verify that other position are not visited.\n                }\n            }\n        }\n    }\n}\n    \n",
        "\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        // Set up the maze map and ball coordinates as needed for your test case\n        int[][] map = {{0, 1, 1, 1, 1, 1}, \n                       {1, 0, 1, 1, 1, 1}, \n                       {1, 1, 0, 1, 1, 1}, \n                       {1, 1, 1, 0, 1, 1}, \n                       {1, 1, 1, 1, 0, 1}, \n                       {1, 1, 1, 1, 1, 0}};\n        int i = 0;\n        int j = 0;\n        \n        // Call the setWay method and verify that it returns true if the ball finds a path to the end of the maze\n        assertTrue(setWay(map, i, j));\n    }\n}\n",
        "<FILL>\n\n### Solution 2: Using backtracking to find the path for the ball in the maze\n\n* [Ttps://en.wikipedia.org/wiki/Maze_solving_algorithm](https://en.wikipedia.org/wiki/Maze_solving_algorithm)\n* [https://www.geeksforgeeks.org/backtracking-algorithms/](https://www.geeksforgeeks.org/backtracking-algorithms/)\n* [Backtracking Tutorial and Example Problems | GeeksforGeeks](https://www.geeksforgeeks.org/backtracking-tutorial-and-example-problems/)\n\n### Algorithm:\n\n1. If the ball is in position `map[6][5]`, means that we have found a path, return true\n2. If the current position of the ball is not 0, means it has been gone through before or cannot go to the wall\uff0creturn false\n3. If the path can be done(means we can pass through this point), then let the ball go through and set `map[i][j]` to 2\n4. Recursive call for each move: down->right->up->left, if any of these moves does not work, then it will backtrack to the previous step and try another path\n5. If all possible paths are tried but still cannot find the path, return false\n6. Print out the new map with the ball footprint, you should be able to see how the ball is moving in the maze\n7. After we found a path for the ball, then let the ball go through the maze according to the path we set\n8. Set the `map[i][j]` back to 0 to indicate that the ball has passed through this point and update the position of the ball\n9. If the ball cannot find its way out in the maze, it will stay at a dead end\n10. Print out the new map with the ball footprint again, you should be able to see how the ball is moving in the maze after the ball goes through the maze for one time \n11. After we find a path for the ball, let's try another strategy: up->right->down->left and repeat step 3-10\n12. Now you have two maps with the ball footprint, one is from down->right->up->left, and another one is from up->right->down->left, print them out to show the difference between the two strategies\n\n### Code: [/Cs/15-30-2021_backtracking_maze.java]\npackage com.thealgorithms.backtracking;\nimport java.util.*;;\npublic class MazeRecursion {\n    public static void main(String[] args) {\n        int[][] map = new int[6][5];\n        // Create maze with the ball starting at position [0][0]\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (i == 0 && j == 0) { // Set ball in the start point [0][0]\n                    map[i][j] = 1;\n                } else if (Math.random() > 0.8) { // Add walls with 80% probability\n                    map[i][j] = 0;\n                } else { // Set free space with 20% probability\n                    map[i][j] = 1;\n                }\n            }\n        }\n        System.out.println(\"\\nMap with the ball:\"); // Print out the maze with the ball\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (map[i][j] == 1) System.out.print(\" O \"); // Print out the ball\n                else System.out.print(\"  \"); // Print out the wall\n            }\n            System.out.println();\n        }\n         // Set ball in the start point [0][0] and set it to go through the maze\n        map[0][0] = 1;\n        boolean hasPath = false;\n        int i, j;\n        for (i = 0; i < 6 && !hasPath; i++) { // Loop until we find a path or reach the bottom row of the maze\n            for (j = 0; j < 5 && !hasPath; j++) {\n                if (map[i][j] == 1) hasPath = findPath(map, i, j); // Call recursive method to find a path\n            }\n        }\n         // Set the ball in the start point [0][0] and set it to go through the maze with down->right->up->left\n        map[0][0] = 1;\n        boolean hasPath2 = false;\n        for (i = 0; i < 6 && !hasPath2; i++) { // Loop until we find a path or reach the bottom row of the maze\n            for (j = 0; j < 5 && !hasPath2; j++) {\n                if (map[i][j] == 1) hasPath2 = findPath2(map, i, j); // Call recursive method to find a path\n            }\n        }\n         // Print out the two maps with the ball footprints and compare them\n        System.out.println(\"\\nMap with down->right->up->left strategy:\");\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (map[i][j] == 1) System.out.print(\" O \"); // Print out the ball\n                else System.out.print(\"  \"); // Print out the wall\n            }\n            System.out.println();\n        }\n        \n        System.out.println(\"\\nMap with up->right->down->left strategy:\");\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (map[i][j] == 1) System.out.print(\" O \"); // Print out the ball\n                else System.out.print(\"  \"); // Print out the wall\n            }\n            System.out.println();\n        }\n    }\n    \n    /**\n     * Recursive method to find a path for the ball in the maze\n     */\n    public static boolean findPath(int[][] map, int i, int j) {\n         // Check if we have found a path or reach the bottom row of the maze\n        if (i == 5 && j == 4) return true;\n        if ((i == 5 || j == 4) && map[i][j] != 1)) return false;\n         // If the current position is not a wall or has been gone through before, then call recursive method to find a path\n        if (map[i][j] != 0) {\n            // Set the current position of the ball and set it to go through the maze\n            map[i][j] = 1;\n             // If we have found a path or reach the bottom row of the maze, then return true\n            if (findPath(map, i - 1, j) || findPath(map, i + 1, j) || findPath(map, i, j - 1) || findPath(map, i, j + 1)) {\n                return true;\n             } else { // If we have not found a path or reach the bottom row of the maze, then return false\n                map[i][j] = 0;\n                return false;\n            }\n        } else { // If the current position is a wall and has been gone through before, then call recursive method to find a path\n             if (map[i][j] == 1) {\n                    // Set the current position of the ball and set it to go through the maze\n                    map[i][j] = 0;\n                     // If we have found a path or reach the bottom row of the maze, then return true\n                    if (findPath(map, i - 1, j) || findPath(map, i + 1, j) || findPath(map, i, j - 1) || findPath(map, i, j + 1)) {\n                        map[i][j] = 0;\n                        return true;\n                    } else { // If we have not found a path or reach the bottom row of the maze, then return false\n                        map[i][j] = 0;\n                        return false;\n                    }\n                }\n            }\n            if (findPath(map, i - 1, j) || findPath(map, i + 1, j) || findPath(map, i, j - 1) || findPath(map, i, j + 1)) { // If we have found a path or reach the bottom row of the maze, then return true\n                map[i][j] = 0;\n                return true;\n            } else { // If we have not found a path or reach the bottom row of the maze, then return false\n                map[i][j] = 0;\n                return false;\n            }\n        }\n    \n    /**\n     * Recursive method to find a path for the ball in the maze with up->right->down->left strategy\n     */\n    public static boolean findPath2(int[][] map, int i, int j) {\n         // Check if we have found a path or reach the bottom row of the maze\n        if (i == 5 && j == 4) return true;\n        if ((i == 5 || j == 4) && map[i][j] != 1)) return false;\n         // If the current position is not a wall or has been gone through before, then call recursive method to find a path\n        if (map[i][j] != 0) {\n            // Set the current position of the ball and set it to go through the maze\n            map[i][j] = 1;\n             // If we have found a path or reach the bottom row of the maze, then return true\n            if (findPath2(map, i - 1, j) || findPath2(map, i + 1, j) || findPath2(map, i, j - 1) || findPath2(map, i, j + 1)) {\n                return true;\n             } else { // If we have not found a path or reach the bottom row of the maze, then return false\n                map[i][j] = 0;\n                return false;\n            }\n        } else { // If the current position is a wall and has been gone through before, then call recursive method to find a path\n             if (map[i][j] == 1) {\n                    // Set the current position of the ball and set it to go through the maze\n                    map[i][j] = 0;\n                     // If we have found a path or reach the bottom row of the maze, then return true\n                    if (findPath2(map, i - 1, j) || findPath2(map, i + 1, j) || findPath2(map, i, j - 1) || findPath2(map, i, j + 1)) {\n                        map[i][j] = 0;\n                        return true;\n                    } else { // If we have not found a path or reach the bottom row of the maze, then return false\n                        map[i][j] = 0;\n                        return false;\n                    }\n                }\n            }\n            if (findPath2(map, i - 1, j) || findPath2(map, i + 1, j) || findPath2(map, i, j - 1) || findPath2(map, i, j + 1)) { // If we have found a path or reach the bottom row of the maze, then return true\n                map[i][j] = 0;\n                return true;\n            } else { // If we have not found a path or reach the bottom row of the maze, then return false\n                map[i][j] = 0;\n                return false;\n            }\n        }\n    \n    /**\n     * Main method\n     * @param args\n     */\n    public static void main(String[] args) {\n        int[][] map = {{1, 1, 1}, {1, 1, 0}, {1, 0, 1}};\n        \n        System.out.println(\"Original Map: \");\n        printMap(map);\n        System.out.println();\n    \n        System.out.println(\"Island Map: \");\n        if (islandMap(map)) { // If we have not found a path or reach the bottom row of the maze, then return false\n            System.out.println(\"true\");\n        } else {\n            System.out.println(\"false\");\n        }\n    }\n    \n    /**\n     * Method to print map\n     * @param map\n     */\n    public static void printMap(int[][] map) {\n        for (int[] row : map) {\n            for (int col : row) {\n                System.out.print(\" \" + col);\n            }\n            System.out.println();\n        }\n    }\n    \n    /**\n     * Method to check if the path exists between two points in a matrix.\n     * @param map\n     * @return \n     */\n    public static boolean islandMap(int[][] map) {\n        \n        int row = 0; // Row index of matrix\n        for (int[] arr : map) { // Iterate through the rows\n            int col = 0; // Column index of matrix\n            \n            while (row < map.length && col < map[row].length) {\n                \n                if (map[row][col] == 1) { // If the current position is not a wall and has been gone through before, then call recursive method to find a path\n                    return true;\n                    \n                    /**\n                     * IMPORTANT: In order for this algorithm to work correctly, it MUST set the current position of the ball to 0! \n                     */\n                } else if (map[row][col] == 0) { // If the current position is a wall and has been gone through before, then return false\n                    map[row][col] = 1; // Set the current position of the ball to 0!\n                    return false;\n                } else if (map[row][col] == -1) { // If the current position is a wall and has NOT been gone through before, then call recursive method to find a path\n                    \n                    /**\n                     * IMPORTANT: In order for this algorithm to work correctly, it MUST set the current position of the ball to 0! \n                     */\n                    return false;\n                } else { // If the current position is not a wall and has NOT been gone through before, then call recursive method to find a path\n                    \n                    /**\n                     * IMPORTANT: In order for this algorithm to work correctly, it MUST set the current position of the ball to 0! \n                     */\n                    return false;\n                }\n            \n                col++; // Iterate through columns\n            }\n            row++; // Iterate through rows\n        }\n        \n        /**\n         * IMPORTANT: In order for this algorithm to work correctly, it MUST set the current position of the ball to 0! \n         */\n        \n        return true; // If we have found a path or reach the bottom row of the maze, then return true\n    }\n}\n",
        "Timeout"
    ]
}