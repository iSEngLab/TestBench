{
    "project_name": "Java",
    "file_name": "MazeRecursion.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
    "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
    "class_name": "MazeRecursion",
    "method_name": "setWay",
    "arguments": [
        "int[][] map",
        "int i",
        "int j"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[10][10];\n        // Initialize the map with a maze\n        // ...\n        \n        boolean result = setWay(map, 0, 0);\n        assertTrue(result);\n    }\n}",
        "The `setWay()` method is a recursive function that is used to find the shortest path in a 2D array. It takes three arguments: `map`, which is a 2D array representing the maze; `i` and `j`, which are the coordinates of the current position in the maze.\n\nThe method first checks if the ball has reached its destination by checking if the value at the current position is equal to 2. If it is, then the method returns true, indicating that the ball has found its path.\n\nIf the ball has not reached its destination, the method checks if the current position is unvisited (i.e., the value at the current position is 0). If it is, then the method follows a move strategy: first, it sets the current position to 2 and then tries to go down, right, up, or left. If any of these movements leads to a feasible path, then the method returns true.\n\nIf all possible moves lead to dead ends, then the method sets the current position to 3 and returns false, indicating that the ball cannot proceed further in this direction. This is a backtracking step, where the ball will go to the previous step and try to find a feasible path from there.\n\nThe `setWayTest()` method is a JUnit test case that tests the `setWay()` method with different scenarios. The test case first creates a 2D array representing a maze and initializes it with the values 0, 1, or 2, depending on whether the position is unvisited, a wall, or the destination, respectively.\n\nThe test case then calls the `setWay()` method with different arguments, such as the starting point of the ball (i.e., the first move) and the coordinates of the end point. The test case checks that the `setWay()` method returns the correct value based on the scenario.\n\nFor example, if the maze has only one path to the destination, then the `setWay()` method should return true when called with the starting point and the end point as arguments. If there are multiple paths to the destination, then the test case checks that the `setWay()` method returns false for all but one of the possible moves, indicating that the ball cannot proceed further in those directions.\n\nOverall, the `setWayTest()` method is a useful tool for testing the correctness of the `setWay()` method and ensuring that it can find the shortest path in a maze.",
        "\n@Test\npublic void setWayTest() {\n    int[][] map = new int[7][6]; // create a 7 x 6 map matrix\n    assertTrue(setWay(map, 0, 0)); // test the function with an empty map and a starting point of (0,0)\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[7][6]; // Initialize the 2D array with size [7, 6]\n        assertEquals(true, setWay(map, 0, 0)); // Test if the ball can find its path starting from (0, 0)\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[7][6];\n        assertTrue(setWay(map, 0, 0)); // test the case when the ball find its path in the middle of the maze\n        \n        map = new int[7][6];\n        map[0][0] = 1; // set the ball to a point that is not feasible (a wall)\n        assertFalse(setWay(map, 0, 0)); // test the case when the ball hit a wall and cannot proceed\n        \n        map = new int[7][6];\n        map[1][2] = 2; // set the ball to a point that is feasible but has been reached before (a dead end)\n        assertFalse(setWay(map, 0, 0)); // test the case when the ball find itself in a dead end and cannot proceed\n        \n        map = new int[7][6];\n        map[1][2] = 1; // set the ball to a point that is feasible but has not been reached before (a path)\n        assertTrue(setWay(map, 0, 0)); // test the case when the ball find a path and can proceed\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = {{0, 0, 0}, {0, 1, 2}, {3, 4, 5}};\n        assertEquals(true, MazeRecursion.setWay(map, 6, 5));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[7][6]; // create a 7x6 matrix for the test case\n        boolean result = setWay(map, 0, 0); // start at the top left corner of the matrix\n        assertEquals(true, result); // ensure that the method returns true when it reaches the bottom right corner of the matrix\n    }\n}",
        "\npackage com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[7][6]; // 7 rows and 6 columns\n        assertTrue(setWay(map, 0, 0)); // starting point should lead to a feasible path\n        \n        map = new int[7][6]; // reset the map for the next test case\n        map[0][0] = 1; // set the starting point as a dead end\n        assertFalse(setWay(map, 0, 0)); // dead end should lead to a false return value\n        \n        map = new int[7][6]; // reset the map for the next test case\n        map[5][4] = 2; // set a wall at (5, 4)\n        assertFalse(setWay(map, 0, 0)); // dead end should lead to a false return value\n    }\n}\n",
        "@Test\npublic void setWayTest() {\n    int[][] map = new int[7][6]; // Create a 7x6 matrix with all elements initialized to 0\n    boolean result = MazeRecursion.setWay(map, 2, 4); // Call the setWay function with input [2][4]\n    assertEquals(result, true); // Assert that the output is true (i.e., the ball has found its path)\n}",
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        // Create a 2D array to represent the map\n        int[][] map = new int[7][6];\n        \n        // Initialize the map with some values\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 6; j++) {\n                map[i][j] = 1;\n            }\n        }\n        \n        // Set the current point to 2, which means that we have already visited this point before\n        map[5][4] = 2;\n        \n        // Call the setWay method with the current point and check if it returns true\n        assertTrue(setWay(map, 5, 4));\n    }\n}\n"
    ]
}