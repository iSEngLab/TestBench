{
    "project_name": "commons-math",
    "file_name": "AccurateMathCalc.java",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "execute_path": "commons-math/commons-math-core",
    "package": "org.apache.commons.math4.core.jdkmath",
    "docstring": "/** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */",
    "source_code": "\nstatic void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n\n    /* Resplit */\n    resplit(result);\n\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}\n",
    "class_name": "AccurateMathCalc",
    "method_name": "splitReciprocal",
    "arguments": [
        "double[] in",
        "double[] result"
    ],
    "generate_test": [
        "@Test\npublic void splitReciprocalTest() {\n    double[] x = new double[2];\n    double[] y = new double[2];\n    \n    x[0] = 1.0;\n    resplit(x);\n    splitReciprocal(x, y);\n    assertEquals(\"-0.5\", formatDouble(y));\n    \n    x[0] = -0.5;\n    resplit(x);\n    splitReciprocal(x, y);\n    assertEquals(\"2\", formatDouble(y));\n}",
        "<FILL>\n\n---\n\nCopyright 2021 [Your Name]. All rights reserved.\n",
        "    \n    import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        double x[] = new double[2];\n        double y[] = new double[2];\n        x[0] = 1d;\n        x[1] = 1e-300;\n        \n        AccurateMathCalc.splitReciprocal(x, y);\n        \n        assertEquals(y[0], -1d, 0);\n        assertEquals(y[1], -1e-300, 0);\n    }\n}",
        "@Test\npublic void splitReciprocalTest() {\n    double[] a = new double[2];\n    a[0] = -1.75;\n    a[1] = 3.5;\n\n    double[] expected = new double[2];\n    expected[0] = 0.44444444444444446;\n    expected[1] = -0.7894736842105263;\n    \n    assertArrayEquals(expected, AccurateMathCalc.splitReciprocal(a));\n}",
        "\nstatic double[] splitReciprocal(double x) {\n    double r1 = 1.0 / (x + 1);\n    double r2 = r1 - ((r1 - 1) * (x + 1));\n\n    return new double[] { r1, r2 };\n}\n",
        "AccurateMathCalc.java:\npackage org.apache.commons.math4.core;\n\nimport java.io.PrintStream;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Some accurate math calculations that are not available in the JDK.\n */\npublic class AccurateMathCalc {\n    /** Split a double into two parts.\n     *  @param x number to split\n     *  @return array containing the two parts of x, or null if x is infinite or NaN.\n     */\n    public static double[] split(double x) {\n        if (Double.isInfinite(x)) {\n            return null;\n        } else if (Double.isNaN(x)) {\n            return null;\n        }\n\n        long bits = Double.doubleToLongBits(x);\n\n        // mask off the low order 27 bits\n        bits &= ~0x3ffffffL;\n\n        double result = Double.longBitsToDouble(bits + ((1L << 52) - (1L << 27)));\n\n        return new double[] {result, x - result};\n    }\n\n    /** Split a double into two parts, and negate the second part.\n     *  @param x number to split\n     *  @return array containing the two parts of x, or null if x is infinite or NaN.\n     */\n    public static double[] splitNeg(double x) {\n        double[] result = split(x);\n        if (result != null) {\n            result[1] = -result[1];\n        }\n        return result;\n    }\n\n    /** Reassemble a split double.\n     *  @param x first part of the number\n     *  @param y second part of the number\n     *  @return the reassembled double value\n     */\n    public static double resplit(double x, double y) {\n        long bitsX = Double.doubleToLongBits(x);\n        long bitsY = Double.doubleToLongBits(y);\n\n        // mask off the high order 27 bits from X\n        bitsX &= (1L << 52) - 1;\n        bitsY &= ~0x3ffffffL;\n\n        return Double.longBitsToDouble((bitsX >> 27) + bitsY);\n    }\n\n    /** Split\n     * Compute x / y rounded towards zero.  This is done by\n     * just using the integer part of the double value, so this may not give exact results, but it should be faster than any alternative.\n     * @param x numerator\n     * @param y denominator\n     * @return x/y rounded towards zero.\n     */\n    public static int divide(int x, int y) {\n        if (x < 0 || y == 0) {\n            return x / y;\n        }\n        // normalize Y\n        while (y != Integer.MIN_VALUE && ((y & 1) << 27) == 0)) {\n            y >>= 1;\n        }\n\n        int quotient = x / y;\n        if (quotient * y == x) {\n            return quotient;\n        } else {\n            return quotient - ((x % y + y) >> 31);\n        }\n    }\n}\n    \n\n### Response:",
        "Timeout",
        "@Test\npublic void splitReciprocalTest() {\n    double[] x = new double[2];\n    double[] y = new double[2];\n    \n    // Test case 1: 1.0e-6 <= x < 1/3 (inclusive)\n    x[0] = 1.0e-7;\n    x[1] = -1.0e-8;\n    AccurateMathCalc.splitReciprocal(x, y);\n    assertEquals(-1.0 / x[0], y[0]);\n    \n    // Test case 2: 1/3 <= x < 1 (inclusive)\n    x[0] = 0.4;\n    x[1] = -1.5e-6;\n    AccurateMathCalc.splitReciprocal(x, y);\n    assertEquals(-1.0 / x[0], y[0]);\n    \n    // Test case 3: 1 <= x < INF (inclusive)\n    x[0] = Double.POSITIVE_INFINITY;\n    x[1] = -1.5e-6;\n    AccurateMathCalc.splitReciprocal(x, y);\n    assertEquals(-1.0 / x[0], y[0]);\n    \n    // Test case 4: INF < x <= 1/3 (inclusive)\n    x[0] = Double.POSITIVE_INFINITY;\n    x[1] = -1.5e-6;\n    AccurateMathCalc.splitReciprocal(x, y);\n    assertEquals(-1.0 / x[0], y[0]);\n    \n    // Test case 5: x < 1/3 (inclusive)\n    x[0] = -1.5e-6;\n    x[1] = 2.0;\n    AccurateMathCalc.splitReciprocal(x, y);\n    assertEquals(-1.0 / x[0], y[0]);\n    \n    // Test case 6: 1 <= x (inclusive)\n    x[0] = Double.POSITIVE_INFINITY;\n    x[1] = -1.5e-6;\n    AccurateMathCalc.splitReciprocal(x, y);\n    assertEquals(-1.0000001 / x[0], y[1]);\n}",
        "package org.apache.commons.math4.core.jdkmath;\nimport java.util.*;\n\npublic class AccurateMathCalcTest {\n    public static void main(String[] args) {\n        splitReciprocalTest();\n    }\n\n    public static void splitReciprocalTest() {\n        double[] x = new double[2];\n        double[] a = new double[2];\n        \n        // Test 1: Split Reciprocal of x to y, x = 0.5d;\n        x[0] = 0.5d;\n        AccurateMath.splitReciprocal(x, a);\n        assertEquals(a[0], 2d);\n        \n        // Test 2: Split Reciprocal of x to y, x = 1.5d;\n        x[0] = 1.5d;\n        AccurateMath.splitReciprocal(x, a);\n        assertEquals(a[0], 0.6666666666666667d);\n    }\n}",
        "\npublic class AccurateMathCalc {\n    public static void main(String[] args) {\n        // Generate a table of split-reciprocal values and errors\n        double[][] reciprocals = new double[5][2];\n        for (int i = 0; i < 5; i++) {\n            double[] r = splitReciprocal(Math.pow(10, -i));\n            reciprocals[i] = r;\n        }\n        \n        // Print the table using a format string that includes 14 decimal places\n        System.out.println(\"Reciprocal of x with error\");\n        for (double[] r : reciprocals) {\n            System.out.printf(\"%14.12f %8.7f\\n\", r[0], r[1]);\n        }\n    }\n    \n    // Modified version of the splitReciprocal method to return an array of two elements: \n    // the reciprocal and the error.\n    public static double[] splitReciprocal(double x) {\n        double hi = x;\n        double lo = 0;\n        \n        int n = (int) Math.ceil(Math.log10(x));\n        for (int i = 0; i < n; i++) {\n            double f = splitDivide(hi, lo);\n            \n            // Split the result into two parts: hi and lo\n            split(f, hi, lo);\n        }\n        \n        // Return an array of two elements: the reciprocal and the error.\n        return new double[] {hi, lo};\n    }\n}\n"
    ]
}