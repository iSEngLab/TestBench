{
    "project_name": "commons-math",
    "file_name": "AccurateMathCalc.java",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "execute_path": "commons-math/commons-math-core",
    "package": "org.apache.commons.math4.core.jdkmath",
    "docstring": "/** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */",
    "source_code": "\nstatic void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n\n    /* Resplit */\n    resplit(result);\n\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}\n",
    "class_name": "AccurateMathCalc",
    "method_name": "splitReciprocal",
    "arguments": [
        "double[] in",
        "double[] result"
    ],
    "generate_test": [
        "double[] in = {1000, 2000};\ndouble[] result = new double[2];\nAccurateMathCalc.splitReciprocal(in, result);\nassertEquals(result[0], 0.001);\nassertEquals(result[1], 0.0005);",
        "\npackage org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = new double[1]; // input array\n        double[] result = new double[2]; // output array\n\n        // set the input value to 0.5\n        in[0] = 0.5;\n\n        // call the splitReciprocal method with our arrays as arguments\n        AccurateMathCalc.splitReciprocal(in, result);\n\n        // check that the expected value is returned in the second element of the result array\n        assertEquals(2.0, result[1], 1e-5); // 2.0 is the reciprocal of 0.5\n    }\n}\n",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = new double[2];\n        double[] result = new double[2];\n        \n        // Test case 1: in[0] is equal to zero\n        in[0] = 0.0;\n        AccurateMathCalc.splitReciprocal(in, result);\n        assertEquals(result[0], 0.0);\n        assertEquals(result[1], 1.0 / (in[0] * in[0]));\n        \n        // Test case 2: in[0] is not equal to zero\n        in[0] = 1.0;\n        AccurateMathCalc.splitReciprocal(in, result);\n        assertEquals(result[0], 1.0 / (in[0] * in[0]));\n        assertEquals(result[1], 0.0);\n    }\n}",
        "\n@Test\npublic void splitReciprocalTest() {\n    // Test case 1:\n    double[] input = new double[]{1.0, 2.0};\n    double[] expectedResult = new double[]{1.0 / 3.0, -1.0 / 6.0};\n    AccurateMathCalc.splitReciprocal(input, expectedResult);\n    assertArrayEquals(expectedResult, input, 1e-9);\n\n    // Test case 2:\n    double[] input = new double[]{4.0, 5.0};\n    double[] expectedResult = new double[]{3.0 / 7.0, -5.0 / 11.0};\n    AccurateMathCalc.splitReciprocal(input, expectedResult);\n    assertArrayEquals(expectedResult, input, 1e-9);\n}",
        "\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = new double[] {1.0};\n        double[] result = new double[2];\n        AccurateMathCalc.splitReciprocal(in, result);\n        assertEquals(result[0], 1.0, 0.001); // expected value is 1.0\n    }\n}\n",
        "@Test\npublic void splitReciprocalTest() {\n    // Test with valid input\n    double[] in = new double[] {10.0, 20.0};\n    double[] result = new double[2];\n    AccurateMathCalc.splitReciprocal(in, result);\n    assertEquals(result[0], 0.1);\n    assertEquals(result[1], -0.05);\n\n    // Test with invalid input (zero in denominator)\n    in = new double[] {0.0, 20.0};\n    result = new double[2];\n    AccurateMathCalc.splitReciprocal(in, result);\n    assertEquals(result[0], Double.NaN);\n    assertEquals(result[1], Double.NaN);\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = new double[2];\n        double[] result = new double[2];\n\n        // Test case 1: reciprocal of [1, 0] should be [1, -1/2]\n        in[0] = 1;\n        in[1] = 0;\n        splitReciprocal(in, result);\n        assertEquals(1.0, result[0], 1e-15); // absolute error of less than 1e-15\n        assertEquals(-0.5, result[1], 1e-15); // absolute error of less than 1e-15\n\n        // Test case 2: reciprocal of [1, 1] should be [1/2, -1/4]\n        in[0] = 1;\n        in[1] = 1;\n        splitReciprocal(in, result);\n        assertEquals(0.5, result[0], 1e-15); // absolute error of less than 1e-15\n        assertEquals(-0.25, result[1], 1e-15); // absolute error of less than 1e-15\n    }\n}",
        "@Test\npublic void splitReciprocalTest() {\n    // Arrange\n    double[] input1 = new double[]{4, 6};\n    double[] input2 = new double[]{8, 9};\n    double[] expectedResult = new double[]{0.05555555555555555, 0.03703703703703704};\n\n    // Act\n    double[] actualResult = AccurateMathCalc.splitReciprocal(input1, input2);\n\n    // Assert\n    assertArrayEquals(expectedResult, actualResult, 0.00001);\n}",
        "\n@Test\npublic void splitReciprocalTest() {\n    double[] in = new double[2];\n    double[] result = new double[2];\n    \n    in[0] = 1.0;\n    in[1] = 0.0;\n    AccurateMathCalc.splitReciprocal(in, result);\n    assertEquals(1.0, result[0], 1e-6);\n    assertEquals(0.0, result[1], 1e-6);\n    \n    in[0] = 2.0;\n    in[1] = -3.0;\n    AccurateMathCalc.splitReciprocal(in, result);\n    assertEquals(0.5, result[0], 1e-6);\n    assertEquals(-0.75, result[1], 1e-6);\n    \n    in[0] = 4.0;\n    in[1] = -2.0;\n    AccurateMathCalc.splitReciprocal(in, result);\n    assertEquals(0.25, result[0], 1e-6);\n    assertEquals(-0.375, result[1], 1e-6);\n}",
        "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        // Test with a positive input value\n        double[] result = new double[2];\n        AccurateMathCalc.splitReciprocal(1.0, result);\n        assertEquals(1.0, result[0], 1e-6);\n        assertEquals(0.0, result[1], 1e-6);\n\n        // Test with a negative input value\n        result = new double[2];\n        AccurateMathCalc.splitReciprocal(-1.0, result);\n        assertEquals(-1.0, result[0], 1e-6);\n        assertEquals(0.0, result[1], 1e-6);\n\n        // Test with a zero input value\n        result = new double[2];\n        AccurateMathCalc.splitReciprocal(0.0, result);\n        assertEquals(Double.NaN, result[0]);\n        assertEquals(Double.NaN, result[1]);\n    }\n}"
    ]
}