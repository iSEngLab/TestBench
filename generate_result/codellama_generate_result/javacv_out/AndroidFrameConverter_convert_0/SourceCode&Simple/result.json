{
    "project_name": "javacv",
    "file_name": "AndroidFrameConverter.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/AndroidFrameConverter.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Convert YUV 4:2:0 SP (NV21) data to BGR, as received, for example,\n     * via {@link Camera.PreviewCallback#onPreviewFrame(byte[],Camera)}.\n     */",
    "source_code": "\npublic Frame convert(byte[] data, int width, int height) {\n    if (frame == null || frame.imageWidth != width\n            || frame.imageHeight != height || frame.imageChannels != 3) {\n        if (frame != null) {\n            frame.close();\n        }\n        frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    }\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n\n    // ported from https://android.googlesource.com/platform/development/+/master/tools/yuv420sp2rgb/yuv420sp2rgb.c\n    int offset = height * width;\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[offset + (i/2) * width + 2 * (j/2)    ] & 0xFF;\n            int U = data[offset + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n\n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n\n            if (Y < 0)\n                Y = 0;\n\n            // R = (int)(1.164 * Y + 2.018 * U);\n            // G = (int)(1.164 * Y - 0.813 * V - 0.391 * U);\n            // B = (int)(1.164 * Y + 1.596 * V);\n\n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n\n            R = Math.min(262143, Math.max(0, R));\n            G = Math.min(262143, Math.max(0, G));\n            B = Math.min(262143, Math.max(0, B));\n\n            R >>= 10; R &= 0xff;\n            G >>= 10; G &= 0xff;\n            B >>= 10; B &= 0xff;\n\n            out.put(i * stride + 3 * j,     (byte)B);\n            out.put(i * stride + 3 * j + 1, (byte)G);\n            out.put(i * stride + 3 * j + 2, (byte)R);\n        }\n    }\n    return frame;\n}\n",
    "class_name": "AndroidFrameConverter",
    "method_name": "convert",
    "arguments": [
        "byte[] data",
        "int width",
        "int height"
    ],
    "generate_test": [
        "\n@Test\npublic void convertTest() {\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    byte[] data = new byte[24];\n    int width = 8;\n    int height = 3;\n    Frame frame = converter.convert(data, width, height);\n    \n    assertEquals(frame.imageWidth, width);\n    assertEquals(frame.imageHeight, height);\n    assertEquals(frame.imageChannels, 3);\n    assertEquals(frame.imageStride, width * 3);\n    assertArrayEquals(frame.image[0].array(), data);\n}",
        "\n@Test\npublic void convertTest() {\n    // Create a Frame with the appropriate dimensions and fill in the image data\n    Frame frame = new Frame(width, height, 3); // 3 channels for RGB\n    byte[] data = new byte[width * height]; // initialize to 0s\n    for (int i = 0; i < width * height; i++) {\n        data[i] = (byte)i; // fill in some arbitrary image data\n    }\n    frame.image[0] = data;\n    \n    // Convert the Frame and verify that the output is what we expect\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    Frame convertedFrame = converter.convert(frame);\n    assertEquals(width, convertedFrame.imageWidth);\n    assertEquals(height, convertedFrame.imageHeight);\n    // Verify that the image data has been correctly converted to RGB\n    for (int i = 0; i < width * height; i++) {\n        int expectedPixelValue = (i % 256) + (i / 256) * 256;\n        assertEquals(expectedPixelValue, convertedFrame.image[0][i]);\n    }\n}\n",
        "The provided Java code is a method called `convert` that takes in an array of bytes, the width and height of an image, and returns a new `Frame` object with the converted pixel data. The method appears to be converting the input bytes from a YUV format (as suggested by the variable names) to RGB.\n\nThe JUnit test case provided is testing the `convert` method by passing in a sample array of bytes, width and height, and verifying that the output frame has the expected dimensions and pixel data. The test case is incomplete, as it does not specify any assertions or expectations for the output frame's pixel data.\n\nTo complete the test case, you would need to add more assertions or expectations about the output frame's pixel data. For example, you could verify that the RGB values are within a certain range or that they match specific colors. You could also use JUnit's built-in `assertEquals` method to check that the output frame has the expected dimensions and pixel data.",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    private AndroidFrameConverter converter;\n    private Frame frame;\n    private byte[] data;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        frame = new Frame(1280, 720, Frame.DEPTH_UBYTE, 3);\n        data = new byte[frame.imageWidth * frame.imageHeight];\n    }\n\n    @Test\n    public void convertTest() {\n        // Set up the test data\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte)i;\n        }\n\n        // Convert the data to a frame and check that it is correct\n        Frame convertedFrame = converter.convert(data, frame.imageWidth, frame.imageHeight);\n        assertEquals(frame.imageChannels, convertedFrame.imageChannels);\n        assertEquals(frame.imageDepth, convertedFrame.imageDepth);\n        assertArrayEquals(frame.image[0], convertedFrame.image[0]);\n    }\n}",
        "\n@Test\npublic void convertTest() {\n    // Arrange\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    byte[] data = new byte[] { 0, 1, 2, 3, 4, 5 };\n    int width = 2;\n    int height = 3;\n    Frame expectedFrame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    ByteBuffer out = (ByteBuffer)expectedFrame.image[0];\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[height * width + i/2 * width + 2 * (j/2)    ] & 0xFF;\n            int U = data[height * width + i/2 * width + 2 * (j/2) + 1] & 0xFF;\n            \n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n            \n            if (Y < 0)\n                Y = 0;\n                        \n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n            \n            R = Math.min(262143, Math.max(0, R));\n            G = Math.min(262143, Math.max(0, G));\n            B = Math.min(262143, Math.max(0, B));\n            \n            R >>= 10; R &= 0xff;\n            G >>= 10; G &= 0xff;\n            B >>= 10; B &= 0xff;\n            \n            out.put(i * width + j,     (byte)B);\n            out.put(i * width + j + 1, (byte)G);\n            out.put(i * width + j + 2, (byte)R);\n        }\n    }\n    \n    // Act\n    Frame actualFrame = converter.convert(data, width, height);\n    \n    // Assert\n    assertEquals(expectedFrame.imageWidth, actualFrame.imageWidth);\n    assertEquals(expectedFrame.imageHeight, actualFrame.imageHeight);\n    assertArrayEquals(expectedFrame.image[0].array(), actualFrame.image[0].array());\n}",
        "\npackage org.bytedeco.javacv;\n\nimport android.graphics.Bitmap;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    private AndroidFrameConverter converter;\n    private Bitmap bitmap;\n    private ByteBuffer buffer;\n    private byte[] row;\n    \n    @BeforeEach\n    public void setup() {\n        converter = new AndroidFrameConverter();\n        bitmap = Bitmap.createBitmap(10, 10, Bitmap.Config.ARGB_8888);\n        buffer = ByteBuffer.allocate(bitmap.getRowBytes() * bitmap.getHeight());\n        row = new byte[bitmap.getRowBytes()];\n    }\n    \n    @Test\n    public void convertTest() {\n        Frame frame = converter.convert(buffer, 10, 10);\n        assertEquals(frame.imageWidth, 10);\n        assertEquals(frame.imageHeight, 10);\n        assertEquals(frame.imageChannels, 3);\n    }\n    \n    @Test\n    public void convertBitmapTest() {\n        Frame frame = converter.convert(bitmap);\n        assertEquals(frame.imageWidth, bitmap.getWidth());\n        assertEquals(frame.imageHeight, bitmap.getHeight());\n        assertEquals(frame.imageChannels, 3);\n    }\n    \n    @Test\n    public void gray2rgbaTest() {\n        ByteBuffer in = ByteBuffer.allocate(10 * 10 * 3);\n        int width = 10;\n        int height = 10;\n        int stride = width;\n        int rowBytes = 3;\n        \n        ByteBuffer out = converter.gray2rgba(in, width, height, stride, rowBytes);\n        assertEquals(out.capacity(), width * height * 4);\n    }\n    \n    @Test\n    public void bgr2rgbaTest() {\n        ByteBuffer in = ByteBuffer.allocate(10 * 10 * 3);\n        int width = 10;\n        int height = 10;\n        int stride = width;\n        int rowBytes = 3;\n        \n        ByteBuffer out = converter.bgr2rgba(in, width, height, stride, rowBytes);\n        assertEquals(out.capacity(), width * height * 4);\n    }\n    \n    @Test\n    public void convertFrameTest() {\n        Frame frame = new Frame(10, 10, Frame.DEPTH_UBYTE, 3);\n        Bitmap bitmap = converter.convert(frame);\n        assertEquals(bitmap.getWidth(), frame.imageWidth);\n        assertEquals(bitmap.getHeight(), frame.imageHeight);\n    }\n}",
        "@Test\npublic void convertTest() {\n    // Arrange\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    byte[] data = ...; // Initialize with valid values\n    int width = ...; // Initialize with valid values\n    int height = ...; // Initialize with valid values\n\n    // Act\n    Frame frame = converter.convert(data, width, height);\n\n    // Assert\n    assertEquals(width, frame.imageWidth);\n    assertEquals(height, frame.imageHeight);\n    assertEquals(Frame.DEPTH_UBYTE, frame.imageDepth);\n    assertEquals(3, frame.imageChannels);\n}",
        "\n@Test\npublic void convertTest() {\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    \n    byte[] data = new byte[10];\n    int width = 2;\n    int height = 3;\n    \n    Frame frame = converter.convert(data, width, height);\n    assertNotNull(frame);\n    assertEquals(frame.imageWidth, width);\n    assertEquals(frame.imageHeight, height);\n    assertEquals(frame.imageChannels, 3);\n}",
        "\n@Test\npublic void convertTest() {\n    byte[] data = new byte[10];\n    int width = 2;\n    int height = 5;\n    \n    Frame frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n    \n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    Frame result = converter.convert(data, width, height);\n    \n    assertEquals(width, result.imageWidth);\n    assertEquals(height, result.imageHeight);\n    assertEquals(3, result.imageChannels);\n    assertEquals(stride, result.imageStride);\n    \n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[height * width + (i/2) * width + 2 * (j/2)] & 0xFF;\n            int U = data[height * width + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n            \n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n            \n            if (Y < 0) {\n                Y = 0;\n            }\n            \n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n            \n            B >>= 10; B &= 0xff;\n            G >>= 10; G &= 0xff;\n            R >>= 10; R &= 0xff;\n            \n            assertEquals(B, out.get(i * stride + 3 * j));\n            assertEquals(G, out.get(i * stride + 3 * j + 1));\n            assertEquals(R, out.get(i * stride + 3 * j + 2));\n        }\n    }\n}",
        "\n@Test\npublic void convertTest() {\n    // Arrange\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    int width = 10;\n    int height = 20;\n    ByteBuffer data = ByteBuffer.allocate(width * height);\n    for (int i = 0; i < width * height; i++) {\n        data.put((byte)i);\n    }\n    Frame frame = converter.convert(data, width, height);\n\n    // Act\n    Bitmap bitmap = converter.convert(frame);\n\n    // Assert\n    assertNotNull(bitmap);\n    assertEquals(width, bitmap.getWidth());\n    assertEquals(height, bitmap.getHeight());\n}"
    ]
}