{
    "project_name": "javacv",
    "file_name": "AndroidFrameConverter.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/AndroidFrameConverter.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Convert YUV 4:2:0 SP (NV21) data to BGR, as received, for example,\n     * via {@link Camera.PreviewCallback#onPreviewFrame(byte[],Camera)}.\n     */",
    "source_code": "\npublic Frame convert(byte[] data, int width, int height) {\n    if (frame == null || frame.imageWidth != width\n            || frame.imageHeight != height || frame.imageChannels != 3) {\n        if (frame != null) {\n            frame.close();\n        }\n        frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    }\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n\n    // ported from https://android.googlesource.com/platform/development/+/master/tools/yuv420sp2rgb/yuv420sp2rgb.c\n    int offset = height * width;\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[offset + (i/2) * width + 2 * (j/2)    ] & 0xFF;\n            int U = data[offset + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n\n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n\n            if (Y < 0)\n                Y = 0;\n\n            // R = (int)(1.164 * Y + 2.018 * U);\n            // G = (int)(1.164 * Y - 0.813 * V - 0.391 * U);\n            // B = (int)(1.164 * Y + 1.596 * V);\n\n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n\n            R = Math.min(262143, Math.max(0, R));\n            G = Math.min(262143, Math.max(0, G));\n            B = Math.min(262143, Math.max(0, B));\n\n            R >>= 10; R &= 0xff;\n            G >>= 10; G &= 0xff;\n            B >>= 10; B &= 0xff;\n\n            out.put(i * stride + 3 * j,     (byte)B);\n            out.put(i * stride + 3 * j + 1, (byte)G);\n            out.put(i * stride + 3 * j + 2, (byte)R);\n        }\n    }\n    return frame;\n}\n",
    "class_name": "AndroidFrameConverter",
    "method_name": "convert",
    "arguments": [
        "byte[] data",
        "int width",
        "int height"
    ],
    "generate_test": [
        "@Test\npublic void convertTest() {\n    // Arrange\n    byte[] data = new byte[1024];\n    int width = 640;\n    int height = 480;\n    Frame frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    \n    // Act\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[height * width + (i/2) * width + 2 * (j/2)] & 0xFF;\n            int U = data[height * width + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n            \n            Y -= 16;\n            U -= 128;\n            V -= 128;\n            \n            if (Y < 0) {\n                Y = 0;\n            }\n                \n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n            \n            B >>= 10; B &= 0xff;\n            G >>= 10; G &= 0xff;\n            R >>= 10; R &= 0xff;\n                        \n            out.put(i * stride + 3 * j,     (byte)B);\n            out.put(i * stride + 3 * j + 1, (byte)G);\n            out.put(i * stride + 3 * j + 2, (byte)R);\n        }\n    }\n    \n    // Assert\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int B = out.get(i * stride + 3 * j) & 0xFF;\n            int G = out.get(i * stride + 3 * j + 1) & 0xFF;\n            int R = out.get(i * stride + 3 * j + 2) & 0xFF;\n            \n            assertEquals(B, data[i * width + j]);\n            assertEquals(G, data[height * width + (i/2) * width + 2 * (j/2)]);\n            assertEquals(R, data[height * width + (i/2) * width + 2 * (j/2) + 1]);\n        }\n    }\n}",
        "I'm not sure I understand what you are asking. Could you please provide more context or clarify your question?",
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    @Test\n    public void convertTest() {\n        Frame frame = new Frame(10, 10, Frame.DEPTH_UBYTE, 3);\n        byte[] data = new byte[10];\n        for (int i = 0; i < 10; i++) {\n            data[i] = (byte)i;\n        }\n        frame.imageData = data;\n        \n        Frame convertedFrame = AndroidFrameConverter.convert(frame, 2, 3);\n        \n        assertEquals(48, convertedFrame.width());\n        assertEquals(60, convertedFrame.height());\n        assertArrayEquals(new byte[] {1, 2, 3}, convertedFrame.imageData);\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class AndroidFrameConverterTest {\n    private final AndroidFrameConverter converter = new AndroidFrameConverter();\n    \n    @Test\n    public void convertTest() {\n        byte[] data = {0, 127, 255}; // YUV420SP image data\n        int width = 3;\n        int height = 3;\n        \n        Frame frame = converter.convert(data, width, height);\n        \n        assertEquals(frame.getWidth(), width);\n        assertEquals(frame.getHeight(), height);\n        assertEquals(frame.getDepth(), Frame.DEPTH_UBYTE);\n        assertEquals(frame.getImageChannels(), 3);\n        \n        ByteBuffer out = frame.getImage()[0];\n        int stride = frame.getImageStride();\n        \n        // Check that the output image has the expected RGB values\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                byte B = out.get(i * stride + 3 * j);\n                byte G = out.get(i * stride + 3 * j + 1);\n                byte R = out.get(i * stride + 3 * j + 2);\n                \n                assertEquals(B, expectedRgbValue[0]);\n                assertEquals(G, expectedRgbValue[1]);\n                assertEquals(R, expectedRgbValue[2]);\n            }\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    @Test\n    public void convertTest() {\n        // Test case 1: YUV420sp data with correct dimensions\n        byte[] data = new byte[3 * width * height]; // Initialize the input data array\n        Frame frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3); // Create an output frame with the correct dimensions\n        AndroidFrameConverter converter = new AndroidFrameConverter(); // Create a new AndroidFrameConverter instance\n        byte[] result = converter.convert(data, width, height); // Convert the input data to RGB using the convert() method\n        assertArrayEquals(frame.image[0], result); // Assert that the output frame has the correct dimensions and contents\n    }\n}",
        "\n@Test\npublic void convertTest() {\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    byte[] data = new byte[10];\n    int width = 10;\n    int height = 10;\n    Frame frame = null;\n    try {\n        frame = converter.convert(data, width, height);\n        assertNotNull(frame);\n        assertEquals(width, frame.imageWidth);\n        assertEquals(height, frame.imageHeight);\n        assertEquals(Frame.DEPTH_UBYTE, frame.imageDepth);\n        assertEquals(3, frame.imageChannels);\n        ByteBuffer out = (ByteBuffer)frame.image[0];\n        int stride = frame.imageStride;\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                int Y = data[i * width + j] & 0xFF;\n                int V = data[10 * width + (i/2) * width + 2 * (j/2)] & 0xFF;\n                int U = data[10 * width + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n                Y -= 16;\n                U -= 128;\n                V -= 128;\n                if (Y < 0) {\n                    Y = 0;\n                }\n                int R = (int)(1.164 * Y + 2.018 * U);\n                int G = (int)(1.164 * Y - 0.813 * V - 0.391 * U);\n                int B = (int)(1.164 * Y + 1.596 * V);\n                R = Math.min(262143, Math.max(0, R));\n                G = Math.min(262143, Math.max(0, G));\n                B = Math.min(262143, Math.max(0, B));\n                R >>= 10;\n                R &= 0xff;\n                G >>= 10;\n                G &= 0xff;\n                B >>= 10;\n                B &= 0xff;\n                out.put(i * stride + 3 * j, (byte)B);\n                out.put(i * stride + 3 * j + 1, (byte)G);\n                out.put(i * stride + 3 * j + 2, (byte)R);\n            }\n        }\n    } finally {\n        if (frame != null) {\n            frame.close();\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    @Test\n    public void convertTest() {\n        // Set up the input data for the test\n        byte[] inputData = new byte[100];\n        int width = 320;\n        int height = 240;\n        \n        // Create a new instance of the class under test\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n        \n        // Invoke the convert method with the input data and check the result\n        Frame outputFrame = converter.convert(inputData, width, height);\n        assertNotNull(outputFrame);\n        assertEquals(width, outputFrame.imageWidth);\n        assertEquals(height, outputFrame.imageHeight);\n        assertEquals(3, outputFrame.imageChannels);\n        \n        // Check the data in the output frame\n        ByteBuffer out = (ByteBuffer)outputFrame.image[0];\n        int stride = outputFrame.imageStride;\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                // Verify that the RGB values are correct\n                assertEquals(out.get(), (byte)255);\n                assertEquals(out.get(), (byte)127);\n                assertEquals(out.get(), (byte)0);\n            }\n        }\n    }\n}",
        "The given JAVA Source Code is for converting a YUV420SP image to RGB format. It is expected that the converted result matches the original data in the \"frame\" object. The code has been modified to include a unit test case using JUnit 5, which can be used to verify the functionality of the convert() method.\n\nThe unit test case consists of a single test method, \"convertTest\", which will be executed when the test is run. The test method first creates a new Frame object with the specified width and height, then populates it with some sample data. Next, it calls the convert() method with this frame as an argument, along with the expected width and height of the converted result.\n\nThe test method then checks that the output frame has the same width and height as the input frame, and that the RGB values for each pixel match the expected values. If any differences are found, the test will fail. If all differences are within a certain tolerance (e.g., 1 or 2 pixels), the test will pass.\n\nThe test method also checks that the output frame has the same data type as the input frame, which is important for compatibility with other parts of the code.\n\nTo use this unit test case, you would need to add it to a JUnit 5 test suite and run the test suite using a tool like Maven or Gradle. This will execute the \"convertTest\" method and print the results to the console. If the test passes, it means that the convert() method is working correctly and producing output that matches the input data.",
        "@Test\npublic void convertTest() {\n    // Create a test image with known dimensions and pixel values\n    int width = 10;\n    int height = 10;\n    byte[] data = new byte[width * height];\n    for (int i = 0; i < data.length; i++) {\n        data[i] = (byte) (i % 256);\n    }\n    \n    // Create a frame object to store the converted image data\n    Frame frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    \n    // Convert the test image using the AndroidFrameConverter class\n    AndroidFrameConverter converter = new AndroidFrameConverter();\n    converter.convert(data, width, height, frame);\n    \n    // Check if the output frame has the correct dimensions and pixel values\n    assertEquals(frame.imageWidth, width);\n    assertEquals(frame.imageHeight, height);\n    for (int i = 0; i < data.length; i++) {\n        int expectedRgbValue = (i % 256) << 16 | (i % 256) << 8 | (i % 256);\n        assertEquals(frame.image[0][i], expectedRgbValue);\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    @Test\n    public void convertTest() {\n        // Create a new instance of the AndroidFrameConverter class\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n        \n        // Create a byte[] array of YUV data for a 640x480 image with 3 channels (RGB)\n        int width = 640;\n        int height = 480;\n        int channels = 3;\n        byte[] yuvData = new byte[width * height * channels];\n        \n        // Initialize the YUV data to a known value\n        for (int i = 0; i < width * height; i++) {\n            yuvData[i] = (byte)i;\n        }\n        \n        // Convert the YUV data into an RGB frame\n        Frame rgbFrame = converter.convert(yuvData, width, height);\n        \n        // Verify that the RGB frame has the correct dimensions and format\n        assertEquals(rgbFrame.imageWidth, width);\n        assertEquals(rgbFrame.imageHeight, height);\n        assertEquals(rgbFrame.imageChannels, channels);\n        \n        // Check that each pixel in the RGB frame has the expected value\n        for (int i = 0; i < width * height; i++) {\n            byte[] rgbPixel = new byte[channels];\n            rgbFrame.get(i, 0, rgbPixel);\n            \n            // The expected value is just the same as the YUV data for this pixel\n            assertArrayEquals(rgbPixel, yuvData[i]);\n        }\n    }\n}"
    ]
}