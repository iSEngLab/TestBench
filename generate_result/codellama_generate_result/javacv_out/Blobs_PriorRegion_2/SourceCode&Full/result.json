{
    "project_name": "javacv",
    "file_name": "Blobs.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/Blobs.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": null,
    "source_code": "// Determine the prior (lower number) region that meets the desired conditions\npublic static int PriorRegion(int Parent, int Color, double MinArea, double MaxArea, int Label)\n{\n    double DParent = (double) Parent; \n    double DColor = (double) Color; if(DColor > 0) DColor = 1;\n    \n    int i;\n    for(i = Label; i >= 0; i--)\n    {\n        double [] Region = RegionData[i];\n        double ThisParent = Region[BLOBPARENT];\n        double ThisColor = Region[BLOBCOLOR];\n        if(DParent >= 0 && DParent != ThisParent) continue;\n        if(DColor >= 0 && DColor != ThisColor) continue;\n        if(Region[BLOBAREA] < MinArea || Region[BLOBAREA] > MaxArea) continue;  \n        break;      // We have a match!\n    }\n    if(i < 0) i = -1;   // Use -1 to flag that there was no match\n    return i;\n}\n",
    "class_name": "Blobs",
    "method_name": "PriorRegion",
    "arguments": [
        "int Parent",
        "int Color",
        "double MinArea",
        "double MaxArea",
        "int Label"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BlobsTest {\n    @Test\n    public void PriorRegionTest() {\n        double[][] image = new double[][]{\n            { 0, 1, 2 },\n            { 3, 4, 5 },\n            { 6, 7, 8 }\n        };\n        Blobs blobs = new Blobs();\n        blobs.LabelImage(image);\n        \n        // Test that the region with label 1 is correctly subsumed by the neighboring region with label 2\n        double[] regionData = blobs.PriorRegion(-1, -1, 0);\n        assertArrayEquals(new double[]{5.67, 13.34, 21.0}, regionData, 1E-8);\n    }\n}",
        "import java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.IOException;\nimport java.io.File;\nimport java.util.*;\n\npublic class Blobs {\n    static BufferedImage image;\n    static int MaxLabel = 0;\n    \n    public static void main(String[] args) throws IOException {\n        File file = new File(\"image.jpg\"); // change the image name according to your requirements\n        image = ImageIO.read(file);\n        \n        // call the BlobDetection method for getting the blobs in an image\n        GetBlobs();\n    }\n    \n    public static void GetBlobs() {\n        int width = image.getWidth();\n        int height = image.getHeight();\n        int [][] pixelData = new int[height][width]; // create a 2D array of integers to store the RGB values of each pixel\n        \n        for(int i=0;i<height;i++) {\n            for(int j=0;j<width;j++) {\n                pixelData[i][j] = image.getRGB(i, j); // fill the array with the RGB values of each pixel\n            }\n        }\n        \n        int [][] labelData = new int[height][width]; // create a 2D array to store the labels of each blob\n        for(int i=0;i<height;i++) {\n            for(int j=0;j<width;j++) {\n                if((pixelData[i][j] & 0xff) < 150) // thresholding to identify pixels corresponding to black color\n                    labelData[i][j] = 255;\n            }\n        }\n        \n        // apply connected component labeling on the binary image generated from the above step\n        int noOfLabels = LabelComponents(labelData);\n        System.out.println(\"No of labels = \" + noOfLabels);\n    }\n    \n    public static int LabelComponents(int [][] BinaryImage) {\n        int height = BinaryImage.length;\n        int width = BinaryImage[0].length;\n        \n        // initialize the labelData array to -1, which means no labels have been assigned to the pixels yet\n        int [][] labelData = new int[height][width];\n        for(int i=0;i<height;i++) {\n            for(int j=0;j<width;j++)\n                labelData[i][j] = -1;\n        }\n        \n        // iterate through each pixel in the image\n        for(int i=0;i<height;i++) {\n            for(int j=0;j<width;j++) {\n                if((BinaryImage[i][j] & 0xff) == 255 && labelData[i][j] != 0) // check whether the pixel is black (& 0xff to extract only the lower 8 bits) and not previously labeled\n                    FloodFill(labelData, i, j); // call the flood fill method on this pixel\n            }\n        }\n        \n        // find the maximum label assigned by the flood fill method\n        for(int i=0;i<height;i++) {\n            for(int j=0;j<width;j++) {\n                if(labelData[i][j] > MaxLabel)\n                    MaxLabel = labelData[i][j]; // update the maximum label assigned so far\n        }\n    }\n    \n    // method to flood fill a blob\n    public static void FloodFill(int [][] BinaryImage, int i, int j) {\n        if((BinaryImage[i][j] & 0xff) == 255)) // check whether the current pixel is black (& 0xff to extract only the lower 8 bits)\n            labelData[i][j] = MaxLabel + 1; // assign a new label to the current pixel\n        \n        if(labelData[i+1][j] < 0 && BinaryImage[i+1][j] == 255)) // check whether the pixel below the current one is black and not previously labeled\n            FloodFill(BinaryImage, i+1, j); // recurse on this new pixel with the same label as that of the current one\n        \n        if(labelData[i][j+1] < 0 && BinaryImage[i][j+1] == 255)) // check whether the pixel to the right of the current one is black and not previously labeled\n            FloodFill(BinaryImage, i, j+1); // recurse on this new pixel with the same label as that of the current one\n        \n        if(labelData[i-1][j] < 0 && BinaryImage[i-1][j] == 255)) // check whether the pixel above the current one is black and not previously labeled\n            FloodFill(BinaryImage, i-1, j); // recurse on this new pixel with the same label as that of the current one\n        \n        if(labelData[i][j-1] < 0 && BinaryImage[i][j-1] == 255)) // check whether the pixel to the left of the current one is black and not previously labeled\n            FloodFill(BinaryImage, i, j-1); // recurse on this new pixel with the same label as that of the current one\n    }\n}",
        "// We have to use an \"in-place\" algorithm because we are operating directly on the source image.\n// Here is a simple example of how to do this:\n\n#include <opencv2/core.hpp>\n#include <opencv2/imgproc.hpp>\n\nusing namespace cv;\nusing namespace std;\n\nvoid PriorRegionTest(Mat &src, Mat &dst) {\n    // Convert image to grayscale\n    cvtColor(src, src, COLOR_BGR2GRAY);\n    \n    // Threshold the image\n    threshold(src, src, 100.0, 255.0, THRESH_BINARY);\n    \n    // Find contours in the binary image using a contour apporach\n    vector<vector<Point>> contours;\n    findContours(src, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);\n    \n    // For each contour, draw it on the original image\n    for (int i = 0; i < contours.size(); i++) {\n        vector<Point> thisContour = contours[i];\n        \n        // Draw the contour using a red color\n        Scalar red(255, 0, 0);\n        drawContours(dst, thisContour, -1, red, FILLED, LINE_8);\n    }\n}\n\n// Example usage:\nint main() {\n    // Load an image\n    Mat src = imread(\"path/to/image.jpg\");\n    \n    // Create a destination image with the same size and type as the source image\n    Mat dst(src.size(), src.type());\n    \n    // Apply our filter to the images\n    PriorRegionTest(src, dst);\n    \n    // Save the resulting image\n    imwrite(\"path/to/result.jpg\", dst);\n}",
        "@Nickname\nHello! I'm happy to help with your question. However, I need more context to provide a helpful response. Could you please clarify the situation or provide more information about what you are trying to do? Additionally, it would be helpful if you could let me know which language and platform you are using so that I can provide you with tailored advice.",
        "    public void PriorRegionTest() {\n        // Set up blobs\n        double [] RegionData = new double [10];\n        RegionData[BLOBLABEL] = (double) 1;\n        RegionData[BLOBPARENT] = (double) 0;\n        RegionData[BLOBAREA] = (double) 32.0E+3;\n        RegionData[BLOBSUMX] = (double) 64.0;\n        RegionData[BLOBSUMY] = (double) 192.0;\n        RegionData[BLOBSUMXX] = (double) 1600.0;\n        RegionData[BLOBSUMYY] = (double) 5760.0;\n        RegionData[BLOBSUMXY] = (double) -480.0;\n\n        double [] PriorRegion = new double [10];\n        PriorRegion[BLOBLABEL] = (double) 2;\n        PriorRegion[BLOBPARENT] = (double) 0;\n        PriorRegion[BLOBAREA] = (double) 32.0E+3;\n        PriorRegion[BLOBSUMX] = (double) 64.0;\n        PriorRegion[BLOBSUMY] = (double) 192.0;\n        PriorRegion[BLOBSUMXX] = (double) 1600.0;\n        PriorRegion[BLOBSUMYY] = (double) 5760.0;\n        PriorRegion[BLOBSUMXY] = (double) -480.0;\n        \n        // Extract region information\n        int MaxLabel = Blobs.Extract(PriorRegion);\n        \n        // Test results\n        assertTrue(MaxLabel == 2, \"Wrong number of labels\");\n        \n        for (int i=1; i<=MaxLabel; ++i) {\n            double [] ThisRegion = RegionData[i];\n            \n            int Label = (int) ThisRegion[BLOBLABEL];\n            assertTrue(Label == i, \"Wrong label\");\n            \n            // Extract fields\n            double Area = ThisRegion[BLOBAREA];\n            double SumX = ThisRegion[BLOBSUMX];\n            double SumY = ThisRegion[BLOBSUMY];\n            double SumXX = ThisRegion[BLOBSUMXX];\n            double SumYY = ThisRegion[BLOBSUMYY];\n            double SumXY = ThisRegion[BLOBSUMXY];\n            \n            // Get averages\n            SumX /= Area;\n            SumY /= Area;\n            SumXX /= Area;\n            SumYY /= Area;\n            SumXY /= Area;\n            \n            // Create moments\n            SumXX -= SumX * SumX;\n            SumYY -= SumY * SumY;\n            SumXY -= SumX * SumY;\n            \n            if (i==1) {\n                assertTrue(Area == 32.0E+3, \"Wrong area for label %d\", i);\n                assertTrue(SumX == 64.0, \"Wrong sum x for label %d\", i);\n                assertTrue(SumY == 19.99999997884185833320, \"Wrong sum y for label %d\", i);\n                assertTrue(SumXX == 1600.0E+2, \"Wrong sum xx for label %d\", i);\n                assertTrue(SumYY == 5760.0E+2, \"Wrong sum yy for label %d\", i);\n            } else {\n                assertTrue(Area == 32.0E+3, \"Wrong area for label %d\", i);\n                assertTrue(SumX == 64.0E+2, \"Wrong sum x for label %d\", i);\n                assertTrue(SumY == 192.0E+2, \"Wrong sum y for label %d\", i);\n                assertTrue(SumXX == 1600.0E+4, \"Wrong sum xx for label %d\", i);\n                assertTrue(SumYY == 5760.0E+4, \"Wrong sum yy for label %d\", i);\n            }\n        }\n    }\n}",
        "\n@SuppressWarnings(\"unused\")\npublic class BlobsTest {\n    private static final int [][] TestData = new int[10][3];\n    \n    @BeforeAll\n    public static void setUpClass() throws Exception {\n        // Fill the test data array with valid regions and a few border regions.\n        \n        for(int i = 0; i < 5; i++)\n            TestData[i][BLOBLABEL] = TestData[i+5][BLOBLABEL] = i;\n    }\n    \n    @Test\n    public void PriorRegionTest() {\n        // Blobs.PriorRegion(int Label)\n        int ResultLabel = -1;\n        \n        // Test 1: Pass valid label\n        for(int Label = 0; Label < 5; Label++)\n            assertEquals(ResultLabel, Blobs.PriorRegion(Label));\n            \n        // Test 2: Pass border label\n        assertEquals(-1, Blobs.PriorRegion(0));\n    }\n    \n}",
        "package org.bytedeco.javacv;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\n\npublic class BlobsTest {\n    @Test\n    public void PriorRegionTest() {\n        int[] priorRegions = new int[10];\n        for (int i = 0; i < 10; i++) {\n            priorRegions[i] = i + 2;\n        }\n        \n        // Test case 1: No overlapping regions.\n        assertEquals(Blobs.PriorRegion(priorRegions, 4), -1);\n        \n        // Test case 2: Overlapping region exists.\n        priorRegions[8] = 3;\n        assertEquals(Blobs.PriorRegion(priorRegions, 4), 3);\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BlobsTest {\n    @Test\n    public void PriorRegionTest() {\n        // Test case 1: No previous region\n        int Label = 5;\n        double [] ThisRegion = RegionData[Label];\n        double Parent = SubsumptionChain(ThisRegion[BLOBPARENT]);\n        \n        if(Parent == -1)\n            assertTrue(PriorRegionTest(Label, 0)); // No previous region to compare against\n    }\n}",
        "/**\n * Checks if a region is within a given rectangular boundary.\n * \n * @param RegionData The data of the region.\n * @param xmin Minimum X-coordinate value in the rectangular boundary.\n * @param ymin Minimum Y-coordinate value in the rectangular boundary.\n * @param xmax Maximum X-coordinate value in the rectangular boundary.\n * @param ymax Maximum Y-coordinate value in the rectangular boundary.\n * \n * @return `true` if the region is within the given rectangular boundary, otherwise `false`.\n */\npublic static boolean PriorRegion(double[] RegionData, double xmin, double ymin, double xmax, double ymax) {\n    int Label = (int) RegionData[BLOBLABEL];\n    if (Label == 0 || Label == -1) {\n        return false; // Border region or invalid region is always outside any rectangular boundary.\n    }\n    \n    double xcenter = RegionData[BLOBXCENTER];\n    double ycenter = RegionData[BLOBYCENTER];\n    if (xmin <= xcenter && xmax >= xcenter && ymin <= ycenter && ymax >= ycenter) {\n        return true; // The region is fully within the given rectangular boundary.\n    }\n    \n    double Width = RegionData[BLOBWIDTH];\n    double Height = RegionData[BLOBHEIGHT];\n    if (xmin - xcenter > Width || xmax - xcenter < 0) {\n        return false; // The region is not intersecting the given rectangular boundary in the X-axis.\n    } else if (ymin - ycenter > Height || ymax - ycenter < 0) {\n        return false; // The region is not intersecting the given rectangular boundary in the Y-axis.\n    }\n    \n    return true; // The region is partially or fully within the given rectangular boundary.\n}",
        "package org.bytedeco.javacv;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BlobsTest {\n    @Test\n    public void PriorRegionTest() {\n        // Test case 1: Check that the `PriorRegion()` method returns the correct parent label when there is no subsampling.\n        double[] region = new double[BLOBDATACOUNT];\n        region[BLOBLABEL] = 5;\n        region[BLOBPARENT] = 5;\n        assertEquals(0, Blobs.PriorRegion(region));\n        \n        // Test case 2: Check that the `PriorRegion()` method returns the correct parent label when there is subsampling.\n        double[] parentLabels = {5, 10};\n        region[BLOBLABEL] = 10;\n        for (int i = 0; i < 2; ++i) {\n            // Check that the `PriorRegion()` method returns the correct parent label when there is subsampling.\n            assertEquals(parentLabels[i], Blobs.PriorRegion(region));\n        }\n        \n        // Test case 3: Check that the `PriorRegion()` method returns the correct parent label when there are multiple subsampling levels.\n        double[] subsamplingLevels = {5, 10};\n        region[BLOBLABEL] = 20;\n        \n        for (int i = 0; i < 2; ++i) {\n            // Check that the `PriorRegion()` method returns the correct parent label when there are multiple subsampling levels.\n            assertEquals(parentLabels[i], Blobs.PriorRegion(region));\n        }\n        \n        // Test case 4: Check that the `PriorRegion()` method returns correctly when there are multiple parents in the subsampling chain.\n        parentLabels = {10, 20};\n        region[BLOBLABEL] = 35;\n        \n        for (int i = 0; i < 2; ++i) {\n            // Check that the `PriorRegion()` method returns correctly when there are multiple parents in the subsampling chain.\n            assertEquals(parentLabels[i], Blobs.PriorRegion(region));\n        }\n        \n        // Test case 5: Check that the `PriorRegion()` method returns correctly when there are multiple parents in the subsampling chain and some labels are not present (i.e., they have been removed during condensation).\n        parentLabels = {10, 20};\n        region[BLOBLABEL] = 35;\n        \n        for (int i = 0; i < 2; ++i) {\n            // Check that the `PriorRegion()` method returns correctly when there are multiple parents in the subsampling chain and some labels are not present (i.e., they have been removed during condensation).\n            assertEquals(parentLabels[i], Blobs.PriorRegion(region));\n        }\n    }\n}"
    ]
}