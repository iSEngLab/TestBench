{
    "project_name": "javacv",
    "file_name": "Frame.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/Frame.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * This private method takes a buffer array as input and returns a deep copy.\n     * It is assumed that all buffers in the input array are of the same subclass.\n     *\n     * @param srcBuffers - Buffer array to be cloned\n     * @param clonedBuffers - Buffer array to fill with clones\n     * @return Opaque object to store\n     *\n     *  @author Extension proposed by Dragos Dutu\n     */",
    "source_code": "\nprivate static Pointer cloneBufferArray(Buffer[] srcBuffers, Buffer[] clonedBuffers) {\n    Pointer opaque = null;\n\n    if (srcBuffers != null && srcBuffers.length > 0) {\n        int totalCapacity = 0;\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            totalCapacity += srcBuffers[i].capacity();\n        }\n\n        /*\n         * In order to optimize the transfer we need a type check.\n         *\n         * Most CPUs support hardware memory transfer for different data\n         * types, so it's faster to copy more bytes at once rather\n         * than one byte per iteration as in case of ByteBuffer.\n         *\n         * For example, Intel CPUs support MOVSB (byte transfer), MOVSW\n         * (word transfer), MOVSD (double word transfer), MOVSS (32 bit\n         * scalar single precision floating point), MOVSQ (quad word\n         * transfer) and so on...\n         *\n         * Type checking may be improved by changing the order in\n         * which a buffer is checked against. If it's likely that the\n         * expected buffer is of type \"ShortBuffer\", then it should be\n         * checked at first place.\n         *\n         */\n\n        if (srcBuffers[0] instanceof ByteBuffer) {\n            BytePointer pointer = new BytePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ByteBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof ShortBuffer) {\n            ShortPointer pointer = new ShortPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ShortBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof IntBuffer) {\n            IntPointer pointer = new IntPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((IntBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof LongBuffer) {\n            LongPointer pointer = new LongPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((LongBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof FloatBuffer) {\n            FloatPointer pointer = new FloatPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((FloatBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof DoubleBuffer) {\n            DoublePointer pointer = new DoublePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((DoubleBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        }\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n        }\n    }\n\n    if (opaque != null) {\n        opaque.retainReference();\n    }\n    return opaque;\n}\n",
    "class_name": "Frame",
    "method_name": "cloneBufferArray",
    "arguments": [
        "Buffer srcBuffers",
        "Buffer clonedBuffers"
    ],
    "generate_test": [
        "    public void cloneBufferArrayTest() {\n        ByteBuffer[] srcBuffers = new ByteBuffer[2];\n        srcBuffers[0] = ByteBuffer.allocate(16).put(\"Hello \".getBytes());\n        srcBuffers[1] = ByteBuffer.allocate(16).put(\"World!\".getBytes());\n\n        Frame frame = new Frame();\n        ByteBuffer[] clonedBuffers = frame.cloneByteBufferArray(srcBuffers);\n\n        assertEquals(2, clonedBuffers.length);\n        assertNotSame(clonedBuffers[0], srcBuffers[0]);\n        assertNotSame(clonedBuffers[1], srcBuffers[1]);\n    }",
        "<FILL>\n",
        "@SuppressWarnings(\"unchecked\")\npublic class FrameTest {\n    @Test public void cloneBufferArrayTest() {\n        // Prepare:\n        Buffer[] buffers = new Buffer[3];\n        for (int i = 0; i < buffers.length; i++) {\n            buffers[i] = BufferUtils.createByteBuffer(4);\n        }\n        \n        // Call the method:\n        Object opaque = Frame.cloneOpaqueData(buffers);\n        \n        // Assertions:\n        assertTrue(opaque instanceof Pointer[]);\n        Pointer[] pointers = (Pointer[])opaque;\n        for (int i = 0; i < buffers.length; i++) {\n            assertEquals(pointers[i], BufferUtils.createByteBuffer(4));\n        }\n    }\n}",
        "",
        "Timeout",
        "public static Object[] cloneBufferArray(Object srcBuffers[]) {\n    int totalCapacity = 0;\n    for (int i = 0; i < srcBuffers.length; i++) {\n        Buffer src = (Buffer)srcBuffers[i];\n        totalCapacity += src.remaining();\n    }\n\n    Object[] clonedBuffers = new Object[srcBuffers.length];\n    if (totalCapacity > 0) {\n        byte[] data = new byte[totalCapacity];\n        int offset = 0;\n        for (int i = 0; i < srcBuffers.length; i++) {\n            Buffer src = (Buffer)srcBuffers[i];\n            if (offset + src.remaining() > data.length) {\n                throw new IndexOutOfBoundsException(\"Not enough space in the destination buffer\");\n            }\n            // Copy source buffer to target buffer\n            System.arraycopy(data, offset, srcBuffers[i], 0, src.remaining());\n            offset += src.remaining();\n        }\n    } else {\n        for (int i = 0; i < srcBuffers.length; i++) {\n            clonedBuffers[i] = ((Buffer)srcBuffers[i]).duplicate();\n        }\n    }\n\n    return clonedBuffers;\n}",
        "import org.bytedeco.javacpp.*;\nimport static org.bytedeco.javacpp.opencv_core.*;\nimport static org.bytedeco.javacpp.avutil.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Frame frame = new Frame();\n        frame.image = new Mat(1080, 1920, CV_8UC3);\n        frame.samples = null;\n        frame.data = null;\n\n        // Use the cloneBufferArray method to create a deep copy of the input frame's image data:\n        Frame clonedFrame = new Frame(frame.cloneBufferArray());\n\n        // Verify that the cloned frame has a deep copy of the original frame's image data:\n        assertNotSame(clonedFrame, frame);\n        assertNotNull(clonedFrame.image);\n        assertEquals(0, clonedFrame.image.compareTo(frame.image));\n    }\n}",
        "@Test\npublic void cloneBufferArrayTest() {\n    ByteBuffer[] srcBuffers = new ByteBuffer[3];\n    for (int i = 0; i < srcBuffers.length; i++) {\n        srcBuffers[i] = BufferUtils.createByteBuffer(1 << (i + 2));\n        assertEquals(srcBuffers[i].limit(), 1 << (i + 2));\n    }\n\n    // Clone the buffers to make a deep copy:\n    ByteBuffer[] clonedBuffers = Frame.cloneBufferArray(srcBuffers);\n    for (int i = 0; i < srcBuffers.length; i++) {\n        assertEquals(clonedBuffers[i].limit(), 1 << (i + 2));\n        clonedBuffers[i].put((byte)i).rewind();\n    }\n    for (int i = 0; i < srcBuffers.length; i++) {\n        assertEquals(srcBuffers[i].get(), 0);\n        srcBuffers[i] = null;\n    }\n}",
        "import java.nio.*;\n\npublic class FrameTest {\n    public static void main(String[] args) {\n        ByteBuffer[] srcBuffers = new ByteBuffer[3];\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i] = ByteBuffer.allocate(128);\n        }\n\n        System.out.println(\"Before:\");\n        for (ByteBuffer b : srcBuffers) {\n            System.out.print(\" \" + b.position() + \"/\" + b.limit());\n        }\n\n        ByteBuffer[] clonedBuffers = new ByteBuffer[srcBuffers.length];\n        Frame.cloneBufferArray(clonedBuffers, srcBuffers);\n\n        System.out.println(\"\\nAfter:\");\n        for (ByteBuffer b : clonedBuffers) {\n            System.out.print(\" \" + b.position() + \"/\" + b.limit());\n        }\n    }\n}",
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FrameTest {\n    private Frame frame;\n    \n    @BeforeEach\n    public void setUp() {\n        // Create a new frame object and initialize it here, if necessary\n    }\n    \n    @Test\n    public void cloneBufferArrayTest() {\n        Buffer[] buffers = /* Fill in with test values */;\n        \n        // Call the method being tested and save its return value to a variable\n        Buffer[] clonedBuffers = frame.cloneBufferArray(buffers);\n        \n        // Assert that the return value is what you expect it to be\n    }\n}\n"
    ]
}