{
    "project_name": "javacv",
    "file_name": "JavaCV.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/JavaCV.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Ported to Java/OpenCV from\n     * Bill Triggs. Autocalibration from Planar Scenes. In 5th European Conference\n     * on Computer Vision (ECCV \u201998), volume I, pages 89\u2013105. Springer-Verlag, 1998.\n     */",
    "source_code": "\npublic static double homogToRt(CvMat H,\n        CvMat R1, CvMat t1, CvMat n1,\n        CvMat R2, CvMat t2, CvMat n2) {\n    CvMat S = S3x3.get(), U = U3x3.get(), V = V3x3.get();\n    cvSVD(H, S, U, V, 0);\n    double zeta = homogToRt(S, U, V, R1, t1, n1, R2, t2, n2);\n    return zeta;\n}\n",
    "class_name": "JavaCV",
    "method_name": "homogToRt",
    "arguments": [
        "CvMat H",
        "CvMat R1",
        "CvMat t1",
        "CvMat n1",
        "CvMat R2",
        "CvMat t2",
        "CvMat n2"
    ],
    "generate_test": [
        "import static org.junit.Assert.*;\nimport org.bytedeco.javacv.OpenCV;\nimport org.junit.jupiter.api.*;\nimport org.opencv.core.Core;\nimport org.opencv.core.CvMat;\nimport org.opencv.core.Mat;\n\npublic class JavaCVTest {\n    @BeforeAll\n    public static void setUpClass() throws Exception {\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n    }\n\n    @Test\n    public void homogToRtTest() {\n        Mat H = CvMat.eye(3, 3, CV_64FC1);\n        for (int i = 0; i < 9; ++i) {\n            double angle = i / 9.0 * Math.PI;\n            H.put(new double[]{angle, 2.0}, new double[]{(double)(Math.cos(angle)), (double)(Math.sin(angle))});\n        }\n\n        Mat R = CvMat.eye(3, 3, CV_64FC1);\n        Mat t = CvMat.zeros(3, 1, CV_64FC1);\n\n        HomogToRt(H, R, t);\n\n        for (int i = 0; i < H.rows(); ++i) {\n            double[] hRow = H.get(i, new int[]{0});\n            Mat Rinv = R.inv();\n\n            // Assert that the rotation matrix is orthogonal\n            assertEquals(Rinv.dot(R), 1.0);\n        }\n    }\n}",
        "@Test\n    public void homogToRtTest() {\n        double[] r = new double[3];\n        double[] t = new double[3];\n        double[] K = new double[]{500, 0, 160, 0, 500, 120, 0, 0, 1};\n        CvMat H = cvCreateMat(3, 3, CV_64F);\n        CvMat R = cvCreateMat(3, 3, CV_64F);\n        CvMat T = cvCreateMat(3, 1, CV_64F);\n        // <FILL>\n        JavaCV.homogToRt(H, r, t, K);\n        assertArrayEquals(new double[]{1, 0, 0}, r);\n        assertArrayEquals(new double[]{0, 1, 0}, t);\n    }\n}\n    \n\n### Response:",
        "@Test\n    public void homogToRtTest() {\n        CvMat H = cvCreateMat(3, 3, CV_64F);\n        double[] Hdata = new double[9];\n        assertNotNull(H);\n        Hdata[0] = -1;  Hdata[1] =  0.5;  Hdata[2] = 1;\n        Hdata[3] =  0;  Hdata[4] = -0.5;  Hdata[5] = 2;\n        Hdata[6] =  0;  Hdata[7] =   0;  Hdata[8] = 3;\n        cvSetData(H, Hdata);\n        \n        double[] rt = new double[9];\n        assertNotNull(rt);\n        homogToRt(H, rt);\n        System.out.println(\"homogToRt: \" + Arrays.toString(rt));\n    }",
        "@Test\npublic void homogToRtTest() {\n    double[] src = new double[]{0, 0, 1, 0, 1};\n    double[] dst = new double[]{0, 1, 0, 1, 2};\n    CvMat H = cvCreateMat(3, 3, CV_64F);\n    cvFindHomography(src, dst, H);\n\n    // Get rotation and translation matrices from homography matrix\n    double[] R = new double[9];\n    double[] t = new double[2];\n    cvGetAffineTransform(H, R, 0.0, t);\n\n    // Verify result by applying the homography matrix to a point\n    CvMat pt = cvCreateMat(1, 3, CV_64F);\n    cvSetReal2D(pt, 0, 0, 0.5f);\n    cvSetReal2D(pt, 0, 1, 0.5f);\n    CvMat transformed = cvCreateMat(1, 3, CV_64F);\n    cvMatMul(H, pt, transformed);\n    double[] expected = new double[]{0.5, 1.5, 1};\n    assertArrayEquals(expected, transformed.get());\n}",
        "package org.bytedeco.javacv;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @org.junit.jupiter.api.Test\n    public void homogToRtTest() {\n        assertTrue(true);\n    }\n}\n    \n\n### Response: [/INSTS]  Sorry, I'm not sure what you are referring to with \"<FILL>\". Can you please provide more information or context?\n\n### Response: [/PROD]  <p>JavaCV is a library that provides Java bindings for OpenCV. It allows developers to use the powerful computer vision algorithms provided by OpenCV in their Java applications.</p>\n<p>To get started, you will need to have Java installed on your computer. You can download it from the official website of Oracle: <a href=\"https://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html\">Java Downloads</a>. Once you have installed Java, you can use Maven to add JavaCV as a dependency in your project.</p>\n<pre><code class=\"language-xml hljs xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.bytedeco.javacpp-presets&lt;/groupId&gt;\n    &lt;artifactId&gt;opencv&lt;/artifactId&gt;\n    &lt;version&gt;3.1.0-1.2&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>You can also download the JAR file for JavaCV from the following link: <a href=\"https://search.maven.org/artifact/org.bytedeco.javacpp-presets/opencv\">Maven Repository</a>. Once you have downloaded the JAR file, you can add it to your project's build path in Eclipse.</p>\n<p>Here is a simple example of how to use JavaCV to detect faces in an image:</p>\n<pre><code class=\"language-java\">import org.bytedeco.javacv.*;\nimport static org.bytedeco.javacpp.opencv_core.*;\nimport static org.bytedeco.javacpp.opencv_objdetect.*;\nimport static org.bytedeco.javacpp.opencv_imgproc.*;\n\npublic class JavaCVExample {\n    public void main(String[] args) {\n        // Load the cascade classifier\n        CascadeClassifier classifier = new CascadeClassifier();\n        classifier.load(\"haarcascade_frontalface_alt.xml\");\n\n        // Load the image we will detect faces in\n        Mat img = imread(\"image.jpg\");\n\n        // Detect faces in the image\n        RectVector rects = new RectVector();\n        classifier.detectMultiScale(img, 1.2, 2, 0 |CV_HAAR_SCALE_OUT, rects);\n\n        // Draw a green rectangle around each detected face\n        for (int i = 0; i &lt; rects.size(); i++) {\n            Rect r = rects.get(i);\n            rectangle(img, new Point(r.x(), r.y()), new Point(r.x()+r.width(), r.y()+r.height()),\n                    new Scalar(0, 255, 0), 3, 8, 0);\n        }\n\n        // Save the image with detected faces\n        imwrite(\"output.jpg\", img);\n\n        // Release resources\n        classifier.close();\n        img.close();\n    }\n}\n</code></pre>\n<p>Here is a brief description of what this code does:</p>\n<ul>\n  <li><p><strong>import org.bytedeco.javacv.*;</strong> This line imports the JavaCV library, which contains the OpenCV bindings for Java.</p></li>\n  <li><p><strong>import static org.bytedeco.javacpp.opencv_core.*;</strong> This line imports a set of functions and constants from the OpenCV Core module. This includes functions for loading and saving images, as well as some basic image processing operations such as thresholding.</p></li>\n  <li><p><strong>import static org.bytedeco.javacpp.opencv_objdetect.*;</strong> This line imports a set of functions and constants from the OpenCV Object Detection module. This includes functions for detecting faces in images.</p></li>\n  <li><p><strong>import static org.bytedeco.javacpp.opencv_imgproc.*;</strong> This line imports a set of functions and constants from the OpenCV Image Processing module. This includes functions for resizing images, as well as some basic image processing operations such as thresholding.</p></li>\n  <li><p>The following code loads a cascade classifier that has been trained to detect faces in images:</p>\n<pre><code>CascadeClassifier classifier = new CascadeClassifier();\nclassifier.load(\"haarcascade_frontalface_alt.xml\");</code></pre>\n  <li><p>The following code loads an image from a file named \"image.jpg\":</p>\n<pre><code>Mat img = imread(\"image.jpg\");</code></pre>\n  <li><p>The following code detects faces in the image and stores the locations of the detected faces in a RectVector object:</p>\n<pre><code>RectVector rects = new RectVector();\nclassifier.detectMultiScale(img, 1.2, 2, 0 |CV_HAAR_SCALE_OUT, rects);</code></pre>\n  <li><p>The following code draws a green rectangle around each detected face:</p>\n<pre><code>for (int i = 0; i &lt; rects.size(); i++) {\n    Rect r = rects.get(i);\n    rectangle(img, new Point(r.x(), r.y()), new Point(r.x()+r.width(), r.y()+r.height()),\n                  new Scalar(0, 255, 0), 3, 8, 0);\n}</code></pre>\n  <li><p>The following code saves the image with detected faces to a file named \"output.jpg\":</p>\n<pre><code>imwrite(\"output.jpg\", img);</code></pre>\n  <li><p>Finally, the following code releases resources used by the cascade classifier and the loaded image:</p>\n<pre><code>classifier.close();\nimg.close();</code></pre></li>\n</ul>\n",
        "\npackage org.bytedeco.javacv;\n\nimport static org.bytedeco.javacpp.opencv_core.*;\n\npublic class JavaCV {\n    public void homogToRtTest() {\n        double[] h = new double[9];\n        // <FILL>\n        CvMat H = cvCreateMat(3, 3, CV_64FC1);\n        for (int i = 0; i < h.length; i++) {\n            H.put(i, 0, h[i]);\n        }\n        double[] Rt = new double[12];\n        homogToRt(H, Rt);\n    }\n}\n",
        "    \npublic class JavaCV {\n    @Test\n    public void homogToRtTest() {\n        CvMat K = cvCreateMat(3, 3, CV_64FC1);\n        CvMat R = cvCreateMat(3, 3, CV_64FC1);\n        CvMat T = cvCreateMat(1, 3, CV_64FC1);\n        K.put(0, 0, 525.0);\n        K.put(1, 1, 525.0);\n        K.put(0, 2, 320.0);\n        K.put(1, 2, 240.0);\n        K.put(2, 2, 1.0);\n        R.put(0, 0, 1.0);\n        R.put(1, 1, 1.0);\n        R.put(2, 2, 1.0);\n        T.put(0, 0, -1.54789698e+03);\n        T.put(1, 0, -1.87774138e+03);\n        T.put(2, 0,  9.79497630e+00);\n        \n        CvMat H = cvCreateMat(3, 4, CV_64FC1);\n        cvHomogeneousMatrixFromStereoParams(K, R, T, K, R, T, H);\n    }\n}",
        "@Slf4j\npublic class JavaCVTest {\n    public void homogToRtTest() {\n        // Define the test parameters\n        double[] H = {1, 0, 0, 0, 1, 0, 0, 0, 1};\n\n        // Create the expected output\n        double[] R = new double[9];\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                R[i * 3 + j] = H[i * 3 + j];\n            }\n        }\n\n        // Call the function to be tested\n        double[] result = JavaCV.homogToRt(H);\n\n        // Verify that the result matches what is expected\n        assertArrayEquals(R, result, \"The rotation matrix does not match.\");\n    }\n}",
        "<FILL>\nIf you are having trouble with the homogToRt() function, it is possible that there may be an error in your code. However, without seeing your code, I cannot accurately diagnose the problem. Therefore, please provide more information about the issue you are experiencing and any relevant errors so that I can assist you better.",
        "\npoint.homogenize(); // convert 2D point to 3D homogeneous coordinates\ndouble[] h = homogToRt(matrix);\nMat rt = new Mat(3, 3, CvType.CV_64F).put(0, 0, h[0], h[1], h[2]);\nrt.t(); // transpose the rotation matrix (OpenCV uses column-major storage)\ndouble[] p = point.dot(rt);\np[0] /= p[2];\np[1] /= p[2];\n"
    ]
}