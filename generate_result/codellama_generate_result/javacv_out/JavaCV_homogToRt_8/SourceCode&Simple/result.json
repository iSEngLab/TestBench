{
    "project_name": "javacv",
    "file_name": "JavaCV.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/JavaCV.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Ported to Java/OpenCV from\n     * Bill Triggs. Autocalibration from Planar Scenes. In 5th European Conference\n     * on Computer Vision (ECCV \u201998), volume I, pages 89\u2013105. Springer-Verlag, 1998.\n     */",
    "source_code": "\npublic static double homogToRt(CvMat H,\n        CvMat R1, CvMat t1, CvMat n1,\n        CvMat R2, CvMat t2, CvMat n2) {\n    CvMat S = S3x3.get(), U = U3x3.get(), V = V3x3.get();\n    cvSVD(H, S, U, V, 0);\n    double zeta = homogToRt(S, U, V, R1, t1, n1, R2, t2, n2);\n    return zeta;\n}\n",
    "class_name": "JavaCV",
    "method_name": "homogToRt",
    "arguments": [
        "CvMat H",
        "CvMat R1",
        "CvMat t1",
        "CvMat n1",
        "CvMat R2",
        "CvMat t2",
        "CvMat n2"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        double[] H = new double[9]; // 3x3 matrix representing the homography\n        CvMat R1 = new CvMat(3, 3); // rotation matrix for first camera\n        CvMat t1 = new CvMat(3, 1); // translation vector for first camera\n        CvMat n1 = new CvMat(3, 1); // normal vector for first camera\n        CvMat R2 = new CvMat(3, 3); // rotation matrix for second camera\n        CvMat t2 = new CvMat(3, 1); // translation vector for second camera\n        CvMat n2 = new CvMat(3, 1); // normal vector for second camera\n        \n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n        \n        assertEquals(zeta, expectedZeta, 0.001);\n    }\n}",
        "@ExtendWith(SpringExtension.class)\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        double[] H = new double[] {1, 0, 0, 0, 1, 0, 0, 0, 1};\n        double[] R1 = new double[] {1, 0, 0, 0, 1, 0, 0, 0, 1};\n        double[] t1 = new double[] {0, 0, 0};\n        double[] n1 = new double[] {0, 0, 0};\n        double[] R2 = new double[] {1, 0, 0, 0, 1, 0, 0, 0, 1};\n        double[] t2 = new double[] {0, 0, 0};\n        double[] n2 = new double[] {0, 0, 0};\n        \n        // Call the homogToRt function and verify that it returns the expected result\n        double result = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n        assertEquals(result, 0);\n    }\n}",
        "\n@Test\npublic void homogToRtTest() {\n    CvMat H = new CvMat(3, 3);\n    CvMat R1 = new CvMat(3, 3);\n    CvMat t1 = new CvMat(3, 1);\n    CvMat n1 = new CvMat(3, 1);\n    CvMat R2 = new CvMat(3, 3);\n    CvMat t2 = new CvMat(3, 1);\n    CvMat n2 = new CvMat(3, 1);\n    \n    double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n    assertEquals(0.5 * (zeta + 1), 0.5 * (zeta - 1));\n}",
        "\npackage org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Create two 3x3 transformation matrices\n        CvMat H1 = cvCreateMat(3, 3, CV_64F);\n        CvMat H2 = cvCreateMat(3, 3, CV_64F);\n        \n        // Set the values of the matrices\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                H1.data[i * H1.cols + j] = (double) i * j;\n                H2.data[i * H2.cols + j] = (double) i * j;\n            }\n        }\n        \n        // Create two 3x1 rotation matrices, two 3x1 translation vectors, and two 3x1 normal vectors\n        CvMat R1 = cvCreateMat(3, 1, CV_64F);\n        CvMat t1 = cvCreateMat(3, 1, CV_64F);\n        CvMat n1 = cvCreateMat(3, 1, CV_64F);\n        \n        // Set the values of the rotation matrix, translation vector, and normal vector\n        for (int i = 0; i < 3; i++) {\n            R1.data[i] = (double) i * 2;\n            t1.data[i] = (double) i * 3;\n            n1.data[i] = (double) i * 4;\n        }\n        \n        // Create two 3x1 rotation matrices, two 3x1 translation vectors, and two 3x1 normal vectors for the second image\n        CvMat R2 = cvCreateMat(3, 1, CV_64F);\n        CvMat t2 = cvCreateMat(3, 1, CV_64F);\n        CvMat n2 = cvCreateMat(3, 1, CV_64F);\n        \n        // Set the values of the rotation matrix, translation vector, and normal vector for the second image\n        for (int i = 0; i < 3; i++) {\n            R2.data[i] = (double) i * 5;\n            t2.data[i] = (double) i * 6;\n            n2.data[i] = (double) i * 7;\n        }\n        \n        // Call the homogToRt method to calculate the distance between the two images in the homography\n        double distance = homogToRt(H1, R1, t1, n1, H2, R2, t2, n2);\n        \n        // Assert that the calculated distance is correct\n        assertEquals(distance, 0.0, 1e-6);\n    }\n}\n",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Create input parameters\n        CvMat H = new CvMat();\n        CvMat R1 = new CvMat();\n        CvMat t1 = new CvMat();\n        CvMat n1 = new CvMat();\n        CvMat R2 = new CvMat();\n        CvMat t2 = new CvMat();\n        CvMat n2 = new CvMat();\n        \n        // Set input values\n        H.put(0, 0, 1);\n        H.put(1, 1, 1);\n        R1.put(0, 0, 1);\n        R1.put(1, 1, 2);\n        t1.put(0, 0, 3);\n        t1.put(1, 1, 4);\n        n1.put(0, 0, 5);\n        n1.put(1, 1, 6);\n        R2.put(0, 0, 7);\n        R2.put(1, 1, 8);\n        t2.put(0, 0, 9);\n        t2.put(1, 1, 10);\n        n2.put(0, 0, 11);\n        n2.put(1, 1, 12);\n        \n        // Call method under test\n        double result = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n        \n        // Verify result\n        assertEquals(13.687504949217734, result, 0.00001);\n    }\n}",
        "I'm not sure what you're asking. Could you please provide more context or clarify your question? I'll do my best to help with whatever you need.",
        "\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        double[] src = new double[9];\n        for (int i = 0; i < 9; i++) {\n            src[i] = Math.random();\n        }\n        CvMat H = cvCreateMat(3, 3, CV_64F);\n        H.put(src, 0, 0);\n        \n        double[] R1 = new double[9];\n        for (int i = 0; i < 9; i++) {\n            R1[i] = Math.random();\n        }\n        CvMat t1 = cvCreateMat(3, 1, CV_64F);\n        double[] t1Arr = new double[3];\n        for (int i = 0; i < 3; i++) {\n            t1Arr[i] = Math.random();\n        }\n        t1.put(t1Arr, 0, 0);\n        \n        double[] n1 = new double[3];\n        for (int i = 0; i < 3; i++) {\n            n1[i] = Math.random();\n        }\n        CvMat R2 = cvCreateMat(3, 3, CV_64F);\n        double[] R2Arr = new double[9];\n        for (int i = 0; i < 9; i++) {\n            R2Arr[i] = Math.random();\n        }\n        R2.put(R2Arr, 0, 0);\n        \n        CvMat t2 = cvCreateMat(3, 1, CV_64F);\n        double[] t2Arr = new double[3];\n        for (int i = 0; i < 3; i++) {\n            t2Arr[i] = Math.random();\n        }\n        t2.put(t2Arr, 0, 0);\n        \n        double[] n2 = new double[3];\n        for (int i = 0; i < 3; i++) {\n            n2[i] = Math.random();\n        }\n        \n        double expectedResult = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n        assertEquals(expectedResult, 0.0, 0.01);\n    }\n}",
        "\n@Test\npublic void homogToRtTest() {\n    // Create inputs for the method\n    CvMat H = new CvMat(3, 3);\n    double[] R1 = {0.5, -0.2, 0.8};\n    double[] t1 = {1, 2, 3};\n    double[] n1 = {0.5, 0.5, 0.5};\n    double[] R2 = {-0.4, 0.1, -0.3};\n    double[] t2 = {-1, -2, -3};\n    double[] n2 = {0.5, 0.5, 0.5};\n\n    // Create expected result\n    double expectedResult = Math.sqrt(H.data[0][0] * H.data[0][0] + H.data[0][1] * H.data[0][1] + H.data[0][2] * H.data[0][2]);\n\n    // Call the method and compare result with expected result\n    double actualResult = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n    assertEquals(expectedResult, actualResult, 0.00001);\n}\n",
        "\nimport org.bytedeco.javacv.*;\n\npublic class Example {\n    public static void main(String[] args) {\n        // Create a 3x3 homography matrix H\n        CvMat H = CvMat.create(3, 3);\n        // Set the elements of H to some values\n        double[] hData = new double[] {1, 0, 0, 0, 1, 0, 0, 0, 1};\n        H.put(0, 0, hData[0]);\n        H.put(1, 0, hData[1]);\n        H.put(2, 0, hData[2]);\n        H.put(3, 0, hData[3]);\n        H.put(4, 0, hData[4]);\n        H.put(5, 0, hData[5]);\n        H.put(6, 0, hData[6]);\n        H.put(7, 0, hData[7]);\n        H.put(8, 0, hData[8]);\n\n        // Create a 3x1 column vector for the first coordinate system's rotation matrix R1\n        CvMat R1 = CvMat.create(3, 1);\n        // Set the elements of R1 to some values\n        double[] r1Data = new double[] {0.5, 0.6, 0.7};\n        R1.put(0, 0, r1Data[0]);\n        R1.put(1, 0, r1Data[1]);\n        R1.put(2, 0, r1Data[2]);\n\n        // Create a 3x1 column vector for the first coordinate system's translation vector t1\n        CvMat t1 = CvMat.create(3, 1);\n        // Set the elements of t1 to some values\n        double[] t1Data = new double[] {0.2, 0.3, 0.4};\n        t1.put(0, 0, t1Data[0]);\n        t1.put(1, 0, t1Data[1]);\n        t1.put(2, 0, t1Data[2]);\n\n        // Create a 3x1 column vector for the first coordinate system's normal vector n1\n        CvMat n1 = CvMat.create(3, 1);\n        // Set the elements of n1 to some values\n        double[] n1Data = new double[] {0.5, 0.6, 0.7};\n        n1.put(0, 0, n1Data[0]);\n        n1.put(1, 0, n1Data[1]);\n        n1.put(2, 0, n1Data[2]);\n\n        // Create a 3x1 column vector for the second coordinate system's rotation matrix R2\n        CvMat R2 = CvMat.create(3, 1);\n        // Set the elements of R2 to some values\n        double[] r2Data = new double[] {0.8, 0.9, 1};\n        R2.put(0, 0, r2Data[0]);\n        R2.put(1, 0, r2Data[1]);\n        R2.put(2, 0, r2Data[2]);\n\n        // Create a 3x1 column vector for the second coordinate system's translation vector t2\n        CvMat t2 = CvMat.create(3, 1);\n        // Set the elements of t2 to some values\n        double[] t2Data = new double[] {0.4, 0.5, 0.6};\n        t2.put(0, 0, t2Data[0]);\n        t2.put(1, 0, t2Data[1]);\n        t2.put(2, 0, t2Data[2]);\n\n        // Create a 3x1 column vector for the second coordinate system's normal vector n2\n        CvMat n2 = CvMat.create(3, 1);\n        // Set the elements of n2 to some values\n        double[] n2Data = new double[] {0.8, 0.9, 1};\n        n2.put(0, 0, n2Data[0]);\n        n2.put(1, 0, n2Data[1]);\n        n2.put(2, 0, n2Data[2]);\n\n        // Calculate the rotation angle between the two coordinate systems\n        double angle = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        System.out.println(\"Rotation angle: \" + angle);\n    }\n}\n",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Set up test data\n        CvMat H = new CvMat(3, 3, CV_64FC1);\n        CvMat R1 = new CvMat(3, 3, CV_64FC1);\n        CvMat t1 = new CvMat(3, 1, CV_64FC1);\n        CvMat n1 = new CvMat(3, 1, CV_64FC1);\n        CvMat R2 = new CvMat(3, 3, CV_64FC1);\n        CvMat t2 = new CvMat(3, 1, CV_64FC1);\n        CvMat n2 = new CvMat(3, 1, CV_64FC1);\n\n        // Set up expected result\n        double expectedZeta = 0.0;\n\n        // Perform test\n        double actualZeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Assert that the actual result is equal to the expected result\n        assertEquals(expectedZeta, actualZeta, 0.000001);\n    }\n}"
    ]
}