{
    "project_name": "jeecg-boot",
    "file_name": "JSqlParserAllTableManager.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/util/sqlparse/JSqlParserAllTableManager.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.util.sqlparse",
    "docstring": "/**\n     * \u5f00\u59cb\u89e3\u6790\n     *\n     * @return\n     * @throws JSQLParserException\n     */",
    "source_code": "\npublic Map<String, SelectSqlInfo> parse() throws JSQLParserException {\n    // 1. \u521b\u5efa\u89e3\u6790\u5668\n    CCJSqlParserManager mgr = new CCJSqlParserManager();\n    // 2. \u4f7f\u7528\u89e3\u6790\u5668\u89e3\u6790sql\u751f\u6210\u5177\u6709\u5c42\u6b21\u7ed3\u6784\u7684java\u7c7b\n    Statement stmt = mgr.parse(new StringReader(this.sql));\n    if (stmt instanceof Select) {\n        Select selectStatement = (Select) stmt;\n        SelectBody selectBody = selectStatement.getSelectBody();\n        this.parsedSql = selectBody.toString();\n        // 3. \u89e3\u6790select\u67e5\u8be2sql\u7684\u4fe1\u606f\n        if (selectBody instanceof PlainSelect) {\n            PlainSelect plainSelect = (PlainSelect) selectBody;\n            // 4. \u5408\u5e76 fromItems\n            List<FromItem> fromItems = new ArrayList<>();\n            fromItems.add(plainSelect.getFromItem());\n            // 4.1 \u5904\u7406join\u7684\u8868\n            List<Join> joins = plainSelect.getJoins();\n            if (joins != null) {\n                joins.forEach(join -> fromItems.add(join.getRightItem()));\n            }\n            // 5. \u5904\u7406 fromItems\n            for (FromItem fromItem : fromItems) {\n                // 5.1 \u901a\u8fc7\u8868\u540d\u7684\u65b9\u5f0ffrom\n                if (fromItem instanceof Table) {\n                    this.addSqlInfoByTable((Table) fromItem);\n                }\n                // 5.2 \u901a\u8fc7\u5b50\u67e5\u8be2\u7684\u65b9\u5f0ffrom\n                else if (fromItem instanceof SubSelect) {\n                    this.handleSubSelect((SubSelect) fromItem);\n                }\n            }\n            // 6. \u89e3\u6790 selectFields\n            List<SelectItem> selectItems = plainSelect.getSelectItems();\n            for (SelectItem selectItem : selectItems) {\n                // 6.1 \u67e5\u8be2\u7684\u662f\u5168\u90e8\u5b57\u6bb5\n                if (selectItem instanceof AllColumns) {\n                    // \u5f53 selectItem \u4e3a AllColumns \u65f6\uff0cfromItem \u5fc5\u5b9a\u4e3a Table\n                    String tableName = plainSelect.getFromItem(Table.class).getName();\n                    // \u6b64\u5904\u5fc5\u5b9a\u4e0d\u4e3a\u7a7a\uff0c\u56e0\u4e3a\u5728\u89e3\u6790 fromItem \u65f6\uff0c\u5df2\u7ecf\u5c06\u8868\u540d\u6dfb\u52a0\u5230 allTableMap \u4e2d\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    assert sqlInfo != null;\n                    // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                    sqlInfo.setSelectAll(true);\n                    sqlInfo.setSelectFields(null);\n                    sqlInfo.setRealSelectFields(null);\n                }\n                // 6.2 \u67e5\u8be2\u7684\u662f\u5e26\u8868\u522b\u540d\uff08 u.* )\u7684\u5168\u90e8\u5b57\u6bb5\n                else if (selectItem instanceof AllTableColumns) {\n                    AllTableColumns allTableColumns = (AllTableColumns) selectItem;\n                    String aliasName = allTableColumns.getTable().getName();\n                    // \u901a\u8fc7\u522b\u540d\u83b7\u53d6\u8868\u540d\n                    String tableName = this.tableAliasMap.get(aliasName);\n                    if (tableName == null) {\n                        tableName = aliasName;\n                    }\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    // \u5982\u679c\u6b64\u5904\u4e3a\u7a7a\uff0c\u5219\u8bf4\u660e\u8be5\u5b57\u6bb5\u662f\u901a\u8fc7\u5b50\u67e5\u8be2\u83b7\u53d6\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e0d\u5904\u7406\uff0c\u53ea\u6709\u5b9e\u9645\u8868\u624d\u9700\u8981\u5904\u7406\n                    if (sqlInfo != null) {\n                        // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                        sqlInfo.setSelectAll(true);\n                        sqlInfo.setSelectFields(null);\n                        sqlInfo.setRealSelectFields(null);\n                    }\n                }\n                // 6.3 \u5404\u79cd\u5b57\u6bb5\u8868\u8fbe\u5f0f\u5904\u7406\n                else if (selectItem instanceof SelectExpressionItem) {\n                    SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;\n                    Expression expression = selectExpressionItem.getExpression();\n                    Alias alias = selectExpressionItem.getAlias();\n                    this.handleExpression(expression, alias, plainSelect.getFromItem());\n                }\n            }\n        } else {\n            log.warn(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody: {}\", selectBody.getClass().getName());\n            throw new JeecgBootException(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody\");\n        }\n    } else {\n        // \u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\n        throw new JeecgBootException(\"\u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\");\n    }\n    return this.allTableMap;\n}\n",
    "class_name": "JSqlParserAllTableManager",
    "method_name": "parse",
    "arguments": [],
    "generate_test": [
        "The provided Java code is a method named `parse` that takes no arguments and returns a `Map<String, SelectSqlInfo>` object. The method creates an instance of the `CCJSqlParserManager` class and uses it to parse a SQL string represented by the `this.sql` field of the current class.\n\nThe method then checks if the parsed statement is an instance of the `Select` class and throws an exception otherwise. If the statement is a `Select`, the method casts it to a `Select` object and retrieves its `selectBody`.\n\nThe method then iterates over the `fromItems` list of the `selectBody` and adds each item to a new `ArrayList<FromItem>`. The method also handles any joins in the `PlainSelect` by adding their `rightItem`s to the `fromItems` list.\n\nNext, the method iterates over the `fromItems` list and retrieves the corresponding `SelectSqlInfo` object for each item using its `getName()` method. The method then sets the `selectAll`, `selectFields`, `realSelectFields`, and `handleExpression` fields of the retrieved `SelectSqlInfo` object based on the type of the current `fromItem`.\n\nFinally, the method returns the populated `allTableMap` field.\n\nThe provided JUnit test case is incomplete because it does not provide a sample SQL string to parse and test the behavior of the `parse` method. The test case should include a `@BeforeEach` method that sets up the necessary environment for testing the method, including initializing any fields used by the `parse` method.\n\nThe test case should also include one or more `@Test` methods that exercise different parts of the `parse` method and assert their behavior based on the expected output. For example, a test method may call the `parse` method with a valid SQL string and then check if the returned map contains the expected keys and values. Another test method may call the `parse` method with an invalid SQL string and verify that an exception is thrown.",
        "@Test\npublic void parseTest() {\n    // \u51c6\u5907\u6570\u636e\n    String sql = \"select * from table1\";\n    JSqlParserAllTableManager manager = new JSqlParserAllTableManager();\n    manager.setSql(sql);\n    \n    // \u6267\u884c\u89e3\u6790\n    try {\n        Map<String, SelectSqlInfo> allTableMap = manager.parse();\n        assertNotNull(allTableMap);\n        assertEquals(1, allTableMap.size());\n        \n        String tableName = \"table1\";\n        SelectSqlInfo sqlInfo = allTableMap.get(tableName);\n        assertNotNull(sqlInfo);\n        assertTrue(sqlInfo.isSelectAll());\n    } catch (JSQLParserException e) {\n        fail(\"Unexpected exception: \" + e.getMessage());\n    }\n}",
        "\nThe given Java source code is a method called `parse` that takes no arguments and returns a `Map<String, SelectSqlInfo>` object. The method creates an instance of the `CCJSqlParserManager` class, which is used to parse SQL queries into a hierarchy of Java objects.\n\nThe method then checks if the statement is a `Select` query by checking if it is an instance of the `Select` class. If it is not a `Select` query, the method throws a `JSQLParserException`.\n\nIf the statement is a `Select` query, the method retrieves the select body and converts it to a string using the `toString()` method. The method then checks if the select body is an instance of the `PlainSelect` class. If it is not an instance of `PlainSelect`, the method throws a `JSQLParserException`.\n\nIf the select body is an instance of `PlainSelect`, the method retrieves the list of from items and adds them to an empty array list. The method then checks if there are any joins in the query, and if so, it adds the join tables to the from item list.\n\nThe method then iterates over the from items and adds each one to a map called `allTableMap`. If the from item is an instance of `Table`, the method adds the table name to the map with a key equal to the table name. If the from item is an instance of `SubSelect`, the method handles the subselect by calling the `handleSubSelect` method.\n\nThe method then iterates over the select items and checks if each one is an instance of `AllColumns`. If it is, the method retrieves the table name from the plain select and adds the table name to the map with a key equal to the table name. The method then sets the `selectAll` field of the `SelectSqlInfo` object in the map to true.\n\nThe method also checks if each select item is an instance of `AllTableColumns`, and if so, it retrieves the table name from the alias and adds the table name to the map with a key equal to the table name. The method then sets the `selectAll` field of the `SelectSqlInfo` object in the map to true.\n\nFinally, the method checks if each select item is an instance of `SelectExpressionItem`, and if so, it retrieves the expression and alias from the select expression item. If the expression is not null or empty, the method adds the expression to the select fields list for the corresponding table in the map.\n\nThe method returns the map of all table names and their corresponding `SelectSqlInfo` objects.",
        "import org.jeecg.common.util.sqlparse.JSqlParserAllTableManager;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    @Test\n    public void parseTest() {\n        String sql = \"SELECT u.* FROM users u WHERE u.id = 1\";\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager();\n        Map<String, SelectSqlInfo> result = manager.parse(sql);\n        assertEquals(1, result.size());\n        SelectSqlInfo sqlInfo = result.get(\"users\");\n        assertNotNull(sqlInfo);\n        assertTrue(sqlInfo.isSelectAll());\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    @Test\n    public void parseTest() {\n        // Create an instance of the class under test\n        JSqlParserAllTableManager parser = new JSqlParserAllTableManager();\n        \n        // Define the input SQL statement to be parsed\n        String sqlStatement = \"SELECT * FROM table1\";\n        \n        // Parse the input SQL statement and check if it is a SELECT query\n        Statement stmt = parser.parse(new StringReader(sqlStatement));\n        assertTrue(stmt instanceof Select);\n        \n        // Cast the parsed statement to Select and get its select body\n        Select selectStatement = (Select) stmt;\n        SelectBody selectBody = selectStatement.getSelectBody();\n        \n        // Check if the select body is a PlainSelect\n        assertTrue(selectBody instanceof PlainSelect);\n        \n        // Cast the select body to PlainSelect and get its from item\n        PlainSelect plainSelect = (PlainSelect) selectBody;\n        FromItem fromItem = plainSelect.getFromItem();\n        \n        // Check if the from item is a Table\n        assertTrue(fromItem instanceof Table);\n        \n        // Cast the from item to Table and get its name\n        Table table = (Table) fromItem;\n        String tableName = table.getName();\n        \n        // Check if the table name is as expected\n        assertEquals(\"table1\", tableName);\n    }\n}",
        "The provided JAVA source code is a method named `parse` that appears to be part of a class called `JSqlParserAllTableManager`. This method takes no parameters and returns a `Map<String, SelectSqlInfo>` object.\n\nThe body of the method contains a number of statements that appear to be parsing SQL queries using the JSQLParser library. The code appears to be handling different types of SELECT statements, including those with joins and subqueries.\n\nThe provided JUNIT test case is testing the `parse` method by creating an instance of the `JSqlParserAllTableManager` class and calling the `parse` method on it. However, the test case contains a <FILL> tag, which indicates that there is additional code that needs to be added to the test case in order for it to be complete.\n\nTo complete the test case, you will need to fill in the <FILL> tag with appropriate code that calls the `parse` method and verifies its behavior. This may involve setting up any necessary input data or mocking out any dependencies of the `JSqlParserAllTableManager` class. Once the test case is complete, it should be able to pass if the `parse` method works correctly, and fail otherwise.",
        "private void handleSubSelect(SubSelect subSelect) {\n    // Get the list of tables from the subquery\n    List<Table> tables = subSelect.getFromItem().getTables();\n\n    // Create a new SelectSqlInfo object for each table\n    for (Table table : tables) {\n        String tableName = table.getName();\n        SelectSqlInfo sqlInfo = new SelectSqlInfo(tableName);\n\n        // Set the select all flag to true if there is no selection list in the subquery\n        if (subSelect.getSelectItems() == null || subSelect.getSelectItems().isEmpty()) {\n            sqlInfo.setSelectAll(true);\n        } else {\n            List<String> fieldNames = new ArrayList<>();\n            for (SelectItem selectItem : subSelect.getSelectItems()) {\n                // If the select item is an expression, get its field name\n                if (selectItem instanceof SelectExpressionItem) {\n                    SelectExpressionItem expressionItem = (SelectExpressionItem) selectItem;\n                    Expression expression = expressionItem.getExpression();\n                    String fieldName = expression.toString().split(\"\\\\.\")[1];\n                    fieldNames.add(fieldName);\n                }\n            }\n\n            // Set the selected fields for each table\n            sqlInfo.setSelectFields(fieldNames);\n        }\n\n        this.allTableMap.put(tableName, sqlInfo);\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.StringReader;\n\nimport org.junit.jupiter.api.Test;\n\npublic class JSqlParserAllTableManagerTest {\n    @Test\n    public void parseTest() {\n        String sql = \"SELECT * FROM mytable\";\n        CCJSqlParserManager mgr = new CCJSqlParserManager();\n        Statement stmt = mgr.parse(new StringReader(sql));\n        assertTrue(stmt instanceof Select);\n        Select selectStatement = (Select) stmt;\n        SelectBody selectBody = selectStatement.getSelectBody();\n        assertTrue(selectBody instanceof PlainSelect);\n        PlainSelect plainSelect = (PlainSelect) selectBody;\n        List<FromItem> fromItems = new ArrayList<>();\n        fromItems.add(plainSelect.getFromItem());\n        for (FromItem fromItem : fromItems) {\n            if (fromItem instanceof Table) {\n                assertTrue(this.allTableMap.containsKey(((Table) fromItem).getName()));\n            } else if (fromItem instanceof SubSelect) {\n                this.handleSubSelect((SubSelect) fromItem);\n            }\n        }\n        List<SelectItem> selectItems = plainSelect.getSelectItems();\n        for (SelectItem selectItem : selectItems) {\n            if (selectItem instanceof AllColumns) {\n                assertTrue(this.allTableMap.get(((AllColumns) selectItem).getTable().getName()).isSelectAll());\n            } else if (selectItem instanceof SelectExpressionItem) {\n                this.handleExpression(((SelectExpressionItem) selectItem).getExpression(), ((SelectExpressionItem) selectItem).getAlias(), plainSelect.getFromItem());\n            }\n        }\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.StringReader;\nimport org.jeecg.common.exception.JeecgBootException;\nimport org.jeecg.common.util.sqlparse.CCJSqlParserManager;\nimport org.jeecg.common.util.sqlparse.JSqlParserAllTableManager;\nimport org.junit.jupiter.api.*;\n\npublic class JSqlParserAllTableManagerTest {\n    private String sql = \"SELECT * FROM employee\";\n    private CCJSqlParserManager manager;\n    private JSqlParserAllTableManager parser;\n    \n    @BeforeEach\n    public void setUp() {\n        manager = new CCJSqlParserManager();\n        parser = new JSqlParserAllTableManager(manager);\n    }\n    \n    @Test\n    public void testParse_SelectWithStarAndOneFromItem() throws JeecgBootException {\n        // given\n        String sql = \"SELECT * FROM employee\";\n        \n        // when\n        Map<String, SelectSqlInfo> result = parser.parse(sql);\n        \n        // then\n        assertNotNull(result);\n        assertEquals(1, result.size());\n        assertTrue(result.containsKey(\"employee\"));\n        SelectSqlInfo sqlInfo = result.get(\"employee\");\n        assertNotNull(sqlInfo);\n        assertFalse(sqlInfo.isSelectAll());\n        assertNull(sqlInfo.getSelectFields());\n        assertEquals(1, sqlInfo.getRealSelectFields().size());\n        assertTrue(sqlInfo.getRealSelectFields().contains(\"*\"));\n    }\n    \n    @Test\n    public void testParse_SelectWithStarAndMultipleFromItems() throws JeecgBootException {\n        // given\n        String sql = \"SELECT * FROM employee, department\";\n        \n        // when\n        Map<String, SelectSqlInfo> result = parser.parse(sql);\n        \n        // then\n        assertNotNull(result);\n        assertEquals(2, result.size());\n        assertTrue(result.containsKey(\"employee\"));\n        assertTrue(result.containsKey(\"department\"));\n    }\n    \n    @Test\n    public void testParse_SelectWithSpecificFieldsAndOneFromItem() throws JeecgBootException {\n        // given\n        String sql = \"SELECT id, name FROM employee\";\n        \n        // when\n        Map<String, SelectSqlInfo> result = parser.parse(sql);\n        \n        // then\n        assertNotNull(result);\n        assertEquals(1, result.size());\n        assertTrue(result.containsKey(\"employee\"));\n        SelectSqlInfo sqlInfo = result.get(\"employee\");\n        assertNotNull(sqlInfo);\n        assertFalse(sqlInfo.isSelectAll());\n        assertEquals(2, sqlInfo.getSelectFields().size());\n        assertEquals(1, sqlInfo.getRealSelectFields().size());\n        assertTrue(sqlInfo.getRealSelectFields().contains(\"id\"));\n    }\n    \n    @Test\n    public void testParse_SelectWithSpecificFieldsAndMultipleFromItems() throws JeecgBootException {\n        // given\n        String sql = \"SELECT id, name FROM employee, department\";\n        \n        // when\n        Map<String, SelectSqlInfo> result = parser.parse(sql);\n        \n        // then\n        assertNotNull(result);\n        assertEquals(2, result.size());\n        assertTrue(result.containsKey(\"employee\"));\n        assertTrue(result.containsKey(\"department\"));\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    @Test\n    public void parseTest() {\n        // 1. \u521b\u5efa JSqlParserAllTableManager \u5bf9\u8c61\n        JSqlParserAllTableManager allTableManager = new JSqlParserAllTableManager();\n        // 2. \u8bbe\u7f6e sql\n        String sql = \"SELECT * FROM dual\";\n        allTableManager.setSql(sql);\n        // 3. \u8c03\u7528 parse() \u65b9\u6cd5\u89e3\u6790 sql\n        Map<String, SelectSqlInfo> tableMap = allTableManager.parse();\n        assertNotNull(tableMap);\n        assertTrue(tableMap.size() == 1);\n        SelectSqlInfo selectSqlInfo = tableMap.get(\"DUAL\");\n        assertNotNull(selectSqlInfo);\n        assertTrue(selectSqlInfo.isSelectAll());\n    }\n}"
    ]
}