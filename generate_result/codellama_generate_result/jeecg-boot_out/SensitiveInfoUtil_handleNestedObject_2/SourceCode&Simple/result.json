{
    "project_name": "jeecg-boot",
    "file_name": "SensitiveInfoUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/desensitization/util/SensitiveInfoUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.desensitization.util",
    "docstring": "/**\n     * \u5904\u7406\u5d4c\u5957\u5bf9\u8c61\n     * @param obj \u65b9\u6cd5\u8fd4\u56de\u503c\n     * @param entity \u5b9e\u4f53class\n     * @param isEncode \u662f\u5426\u52a0\u5bc6\uff08true: \u52a0\u5bc6\u64cd\u4f5c / false:\u89e3\u5bc6\u64cd\u4f5c\uff09\n     * @throws IllegalAccessException\n     */",
    "source_code": "\npublic static void handleNestedObject(Object obj, Class entity, boolean isEncode) throws IllegalAccessException {\n    Field[] fields = obj.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(field.getType().isPrimitive()){\n            continue;\n        }\n        if(field.getType().equals(entity)){\n            // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n            field.setAccessible(true);\n            Object nestedObject = field.get(obj);\n            handlerObject(nestedObject, isEncode);\n            break;\n        }else{\n            // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n            if(field.getGenericType() instanceof ParameterizedType){\n                ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                if(pt.getRawType().equals(List.class)){\n                    if(pt.getActualTypeArguments()[0].equals(entity)){\n                        field.setAccessible(true);\n                        Object nestedObject = field.get(obj);\n                        handleList(nestedObject, entity, isEncode);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "class_name": "SensitiveInfoUtil",
    "method_name": "handleNestedObject",
    "arguments": [
        "Object obj",
        "Class entity",
        "boolean isEncode"
    ],
    "generate_test": [
        "\nThe `handleNestedObject` method in the `SensitiveInfoUtil` class is used to handle nested objects. It takes three parameters: an object, a class entity, and a boolean value indicating whether the data should be encoded or not. The method first retrieves all declared fields of the object using the `getDeclaredFields()` method of the `Class` class.\n\nThe next step is to loop through each field and check if it is a primitive type. If it is, the loop continues to the next field. Otherwise, the method checks if the field's type is equal to the entity parameter. If it is, the method sets the accessible flag of the field to `true` using the `setAccessible(true)` method and retrieves the value of the field using the `get()` method.\n\nIf the field's type is not a primitive type but is a list of entities, the method checks if the generic type of the field is an instance of `ParameterizedType`. If it is, the method casts the generic type to `ParameterizedType` and checks if the raw type of the parameterized type is equal to `List.class`. If it is, the method retrieves the actual type argument of the parameterized type and checks if it is equal to the entity parameter.\n\nIf the field's value is an object or a list of objects that need to be handled, the method calls the `handlerObject` method with the nested object as the first parameter and the boolean value indicating whether the data should be encoded or not as the second parameter. If the field's value is a list of entities, the method calls the `handleList` method with the list of entities as the first parameter, the entity class as the second parameter, and the boolean value indicating whether the data should be encoded or not as the third parameter.\n\nThe `handlerObject` method in the `SensitiveInfoUtil` class is used to handle objects that need to be encoded or decoded. It takes two parameters: an object and a boolean value indicating whether the data should be encoded or not. The method first retrieves all declared fields of the object using the `getDeclaredFields()` method of the `Class` class.\n\nThe next step is to loop through each field and check if it has the `@SensitiveField` annotation. If it does, the method checks if the value of the field should be encoded or decoded based on the boolean value passed in as a parameter. If the field's value should be encoded, the method calls the `getEncodeData()` method with the field's value and the appropriate `SensitiveEnum` value as parameters. If the field's value should be decoded, the method calls the `getDecodeData()` method with the field's value as a parameter.\n\nThe `handleList` method in the `SensitiveInfoUtil` class is used to handle lists of objects that need to be encoded or decoded. It takes three parameters: an object, a class entity, and a boolean value indicating whether the data should be encoded or not. The method first retrieves all declared fields of the list using the `getDeclaredFields()` method of the `Class` class.\n\nThe next step is to loop through each field and check if it has the `@SensitiveField` annotation. If it does, the method checks if the value of the field should be encoded or decoded based on the boolean value passed in as a parameter. If the field's value should be encoded, the method calls the `getEncodeData()` method with the field's value and the appropriate `SensitiveEnum` value as parameters. If the field's value should be decoded, the method calls the `getDecodeData()` method with the field's value as a parameter.\n\nThe `getDecodeData` method in the `SensitiveInfoUtil` class is used to decode data. It takes one parameter: a string representing the encoded data. The method first retrieves all declared fields of the object using the `getDeclaredFields()` method of the `Class` class.\n\nThe next step is to loop through each field and check if it has the `@SensitiveField` annotation. If it does, the method checks if the value of the field should be decoded based on the boolean value passed in as a parameter. If the field's value should be decoded, the method calls the `getDecodeData()` method with the field's value and the appropriate `SensitiveEnum` value as parameters.\n\nThe `getEncodeData` method in the `SensitiveInfoUtil` class is used to encode data. It takes two parameters: a string representing the original data and an enum value indicating the type of sensitive information. The method first retrieves all declared fields of the object using the `getDeclaredFields()` method of the `Class` class.\n\nThe next step is to loop through each field and check if it has the `@SensitiveField` annotation. If it does, the method checks if the value of the field should be encoded based on the boolean value passed in as a parameter. If the field's value should be encoded, the method calls the `getEncodeData()` method with the field's value and the appropriate `SensitiveEnum` value as parameters.\n\nOverall, the methods in the `SensitiveInfoUtil` class are used to encode or decode sensitive information contained in objects that need to be handled. The `handlerObject` and `handleList` methods in particular provide a mechanism for handling arbitrary objects and lists of objects that need to be encoded or decoded.",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        // Create a person object with nested objects and lists of objects\n        Person person = new Person(\"John\", 30, \"123 Main St\", \"+1-555-1234\");\n        \n        // Call the handleNestedObject method on the person object\n        SensitiveInfoUtil.handleNestedObject(person, Person.class, true);\n        \n        // Verify that the nested objects and lists of objects are correctly handled\n        assertEquals(\"encodedName\", person.getName());\n        assertEquals(\"encodedAddress\", person.getAddress());\n        assertEquals(\"encodedPhoneNumber\", person.getPhoneNumber());\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        Object obj = new Object();\n        Class entity = String.class;\n        boolean isEncode = true;\n        Field[] fields = obj.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            if(field.getType().isPrimitive()){\n                continue;\n            }\n            if(field.getType().equals(entity)){\n                // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n                field.setAccessible(true);\n                Object nestedObject = field.get(obj);\n                handlerObject(nestedObject, isEncode);\n                break;\n            }else{\n                // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n                if(field.getGenericType() instanceof ParameterizedType){\n                    ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                    if(pt.getRawType().equals(List.class)){\n                        if(pt.getActualTypeArguments()[0].equals(entity)){\n                            field.setAccessible(true);\n                            Object nestedObject = field.get(obj);\n                            handleList(nestedObject, entity, isEncode);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}",
        "@Test\npublic void handleNestedObjectTest() {\n    // Create a mock object that represents the \"obj\" parameter\n    Object obj = Mockito.mock(Object.class);\n    \n    // Create a mock entity class that represents the \"entity\" parameter\n    Class<MyEntity> entityClass = (Class<MyEntity>) MyEntity.class;\n    \n    // Create an instance of the SensitiveInfoUtil class and call the handleNestedObject method on it\n    SensitiveInfoUtil util = new SensitiveInfoUtil();\n    util.handleNestedObject(obj, entityClass, true);\n    \n    // Use JUnit's assertion statements to verify that the result of the handleNestedObject method is what you expect\n    assertEquals(expectedResult, obj.getFieldValue(\"myField\"));\n}",
        "\nThe `handleNestedObject` method in the `SensitiveInfoUtil` class is a recursive method that is used to traverse an object's fields and handle any sensitive information found within. The method takes three parameters: `obj`, which is the object being traversed; `entity`, which is the entity type being searched for; and `isEncode`, which indicates whether the sensitive information should be encoded or not.\n\nThe method first retrieves all of the declared fields in the input object using `obj.getClass().getDeclaredFields()`. It then iterates over each field in the array, checking if it is a primitive type and skipping it if so. If the field is not a primitive, the method checks whether its type matches the entity parameter. If there is a match, the method sets the accessible flag on the field using `field.setAccessible(true)` and retrieves the value of the field using `field.get(obj)`.\n\nIf the field's type does not match the entity parameter, the method checks whether it is a list containing the entity parameter using `field.getGenericType() instanceof ParameterizedType` and `pt.getRawType().equals(List.class)` and `pt.getActualTypeArguments()[0].equals(entity)`. If this is the case, the method sets the accessible flag on the field and retrieves the value of the field using `field.get(obj)`.\n\nThe method then recursively calls itself with the retrieved value, passing in the new object and the entity parameter.\n\nIf there are no more nested objects to traverse, the method returns the original input object.\n\nIt is important to note that this method assumes that all of the sensitive information in the input object has been marked with the `@SensitiveField` annotation. If any sensitive fields are not annotated, they will not be handled by this method and may cause issues with the encoded output.",
        "The `handleNestedObject` method is a recursive method that handles nested objects. It takes three parameters: an object, a class entity, and a boolean value indicating whether the data should be encoded or decoded. The method first gets all declared fields of the object using the `getDeclaredFields()` method and then loops through them to check if any of them is a primitive type. If it finds one, it skips it and continues with the next field.\n\nIf none of the fields are primitives, it checks if the current field's type is equal to the entity class passed as a parameter. If it is, it sets the accessible flag of the field to true using the `setAccessible(true)` method and then gets the value of the field using the `get()` method.\n\nIf the field's type is not equal to the entity class, it checks if the current field is a list with the help of the `ParameterizedType` class. If it is, it checks if the raw type of the parameterized type is equal to `List` and if the actual type argument is equal to the entity class passed as a parameter. If both conditions are true, it sets the accessible flag of the field to true and then gets the value of the field using the `get()` method.\n\nIf none of the above conditions are met, it recursively calls the `handleNestedObject` method with the current field's value as the object parameter and the entity class passed as a parameter. This allows the method to handle nested objects in the same way as the top-level object.\n\nThe `handleList` method is similar to the `handleNestedObject` method, but it is specifically designed to handle lists of objects. It takes three parameters: an object, a class entity, and a boolean value indicating whether the data should be encoded or decoded. The method first gets all declared fields of the object using the `getDeclaredFields()` method and then loops through them to check if any of them is a primitive type. If it finds one, it skips it and continues with the next field.\n\nIf none of the fields are primitives, it checks if the current field's type is equal to the entity class passed as a parameter. If it is, it sets the accessible flag of the field to true using the `setAccessible(true)` method and then gets the value of the field using the `get()` method.\n\nIf the field's type is not equal to the entity class, it checks if the current field is a list with the help of the `ParameterizedType` class. If it is, it checks if the raw type of the parameterized type is equal to `List` and if the actual type argument is equal to the entity class passed as a parameter. If both conditions are true, it sets the accessible flag of the field to true and then gets the value of the field using the `get()` method.\n\nIf none of the above conditions are met, it recursively calls the `handleList` method with the current field's value as the object parameter and the entity class passed as a parameter. This allows the method to handle nested lists in the same way as the top-level list.\n\nThe `handlerObject` method is similar to the `handleNestedObject` method, but it only handles a single object rather than a list of objects. It takes two parameters: an object and a boolean value indicating whether the data should be encoded or decoded. The method first gets all declared fields of the object using the `getDeclaredFields()` method and then loops through them to check if any of them is a primitive type. If it finds one, it skips it and continues with the next field.\n\nIf none of the fields are primitives, it checks if the current field's type is equal to the entity class passed as a parameter. If it is, it sets the accessible flag of the field to true using the `setAccessible(true)` method and then gets the value of the field using the `get()` method.\n\nIf the field's type is not equal to the entity class, it checks if the current field is a list with the help of the `ParameterizedType` class. If it is, it checks if the raw type of the parameterized type is equal to `List` and if the actual type argument is equal to the entity class passed as a parameter. If both conditions are true, it sets the accessible flag of the field to true and then gets the value of the field using the `get()` method.\n\nIf none of the above conditions are met, it recursively calls the `handlerObject` method with the current field's value as the object parameter and the entity class passed as a parameter. This allows the method to handle nested objects in the same way as the top-level object.\n\nThe `handleNestedObjectTest` test case is a unit test that checks if the `handleNestedObject` method works correctly by passing it an object, a class entity, and a boolean value indicating whether the data should be encoded or decoded. The test first creates an object with some nested objects and then passes it to the `handleNestedObject` method along with the class entity and the boolean value. Finally, it checks if the result of the method call is correct by comparing it to an expected result.\n\nThe `handleListTest` test case is similar to the `handleNestedObjectTest` test case but for the `handleList` method. It creates a list with some nested lists and then passes it to the `handleList` method along with the class entity and the boolean value. Finally, it checks if the result of the method call is correct by comparing it to an expected result.\n\nThe `handlerObjectTest` test case is similar to the `handleNestedObjectTest` test case but for the `handlerObject` method. It creates a single object with some nested objects and then passes it to the `handlerObject` method along with the class entity and the boolean value. Finally, it checks if the result of the method call is correct by comparing it to an expected result.\n\nIn summary, these three methods allow for handling of arbitrary structures of objects containing primitive types, lists of objects, and nested objects in a generic way. They are designed to be used recursively to handle any level of nesting.",
        "\n@Test\npublic void handleNestedObjectTest() {\n    Object obj = new Object(); // Create an instance of the object to be tested\n    Class entity = String.class; // The class of the nested object\n    boolean isEncode = true; // Whether or not to encode the data\n    \n    // Set up any necessary mock objects and test data\n    Field[] fields = obj.getClass().getDeclaredFields(); // Get the declared fields of the object\n    for (Field field : fields) {\n        if (field.getType().equals(entity)) { // If the field is of the correct type\n            Object nestedObject = field.get(obj); // Get the nested object\n            handlerObject(nestedObject, isEncode); // Test the handleObject method with the nested object and isEncode flag set to true\n        } else if (field.getGenericType() instanceof ParameterizedType) { // If the field is a List<T> type\n            ParameterizedType pt = (ParameterizedType) field.getGenericType(); // Cast the generic type to a parameterized type\n            if (pt.getRawType().equals(List.class)) { // If the raw type of the list is List.class\n                if (pt.getActualTypeArguments()[0].equals(entity)) { // If the actual type argument of the list is of the same class as the entity parameter\n                    Object nestedObject = field.get(obj); // Get the nested object from the list\n                    handleList(nestedObject, entity, isEncode); // Test the handleList method with the nested object and isEncode flag set to true\n                }\n            }\n        }\n    }\n}",
        "@Test\npublic void handleNestedObjectTest() {\n    // Create a new instance of the class\n    SensitiveInfoUtil util = new SensitiveInfoUtil();\n    \n    // Populate it with some nested objects\n    MyObject obj1 = new MyObject();\n    MyObject obj2 = new MyObject();\n    obj1.setNestedObject(obj2);\n    \n    // Call the method and check that it works correctly\n    util.handleNestedObject(obj1, MyObject.class, true);\n}",
        "@Test\npublic void handleNestedObjectTest() throws IllegalAccessException {\n    Object obj = new Object(); // create an instance of the object\n    Class entity = String.class; // set the type of the nested object to be handled\n    boolean isEncode = true; // set whether to encode or decode the nested object\n    \n    SensitiveInfoUtil.handleNestedObject(obj, entity, isEncode); // call the method to handle the nested object\n    \n    assertEquals(expectedResult, actualResult); // compare the expected result with the actual result\n}",
        "@Test\npublic void handleNestedObjectTest() throws IllegalAccessException {\n    Object obj = new Object();\n    Class entity = String.class;\n    boolean isEncode = true;\n    \n    Field[] fields = obj.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(field.getType().isPrimitive()){\n            continue;\n        }\n        if(field.getType().equals(entity)){\n            // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n            field.setAccessible(true);\n            Object nestedObject = field.get(obj);\n            assertNotNull(nestedObject);\n            break;\n        }else{\n            // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n            if(field.getGenericType() instanceof ParameterizedType){\n                ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                if(pt.getRawType().equals(List.class)){\n                    if(pt.getActualTypeArguments()[0].equals(entity)){\n                        field.setAccessible(true);\n                        Object nestedObject = field.get(obj);\n                        assertNotNull(nestedObject);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}"
    ]
}