{
    "project_name": "jeecg-boot",
    "file_name": "SensitiveInfoUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/desensitization/util/SensitiveInfoUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.desensitization.util",
    "docstring": "/**\n     * \u5904\u7406\u5d4c\u5957\u5bf9\u8c61\n     * @param obj \u65b9\u6cd5\u8fd4\u56de\u503c\n     * @param entity \u5b9e\u4f53class\n     * @param isEncode \u662f\u5426\u52a0\u5bc6\uff08true: \u52a0\u5bc6\u64cd\u4f5c / false:\u89e3\u5bc6\u64cd\u4f5c\uff09\n     * @throws IllegalAccessException\n     */",
    "source_code": "\npublic static void handleNestedObject(Object obj, Class entity, boolean isEncode) throws IllegalAccessException {\n    Field[] fields = obj.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(field.getType().isPrimitive()){\n            continue;\n        }\n        if(field.getType().equals(entity)){\n            // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n            field.setAccessible(true);\n            Object nestedObject = field.get(obj);\n            handlerObject(nestedObject, isEncode);\n            break;\n        }else{\n            // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n            if(field.getGenericType() instanceof ParameterizedType){\n                ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                if(pt.getRawType().equals(List.class)){\n                    if(pt.getActualTypeArguments()[0].equals(entity)){\n                        field.setAccessible(true);\n                        Object nestedObject = field.get(obj);\n                        handleList(nestedObject, entity, isEncode);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "class_name": "SensitiveInfoUtil",
    "method_name": "handleNestedObject",
    "arguments": [
        "Object obj",
        "Class entity",
        "boolean isEncode"
    ],
    "generate_test": [
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Set up a mock object for the input parameter obj\n        Object obj = new Object();\n        \n        // Set up a mock object for the input parameter entity\n        Class entity = String.class;\n        \n        // Call the handleNestedObject method with the mock objects as arguments\n        SensitiveInfoUtil.handleNestedObject(obj, entity, true);\n        \n        // Verify that the expected results are returned by the method\n        assertEquals(\"The nested object should be handled correctly\", obj, SensitiveInfoUtil.getNestedObject(obj, entity));\n    }\n}",
        "@Test\npublic void handleNestedObjectTest() throws IllegalAccessException {\n    Object obj = new Object();\n    Class entity = String.class;\n    boolean isEncode = true;\n    SensitiveInfoUtil.handleNestedObject(obj, entity, isEncode);\n}",
        "import org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        // Create an instance of the entity class\n        Class entityClass = ...;\n        Object obj = new entityClass();\n\n        // Add a field to the object that is an instance of the entity class\n        Field field = new Field(entityClass);\n        obj.setAccessible(true);\n        obj.addField(field);\n\n        // Call the handleNestedObject method on the object and verify that it correctly handles the nested object\n        SensitiveInfoUtil.handleNestedObject(obj, entityClass, true);\n        assertTrue(obj.getAccessible());\n    }\n}",
        "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Create a mock object to use as the input parameter\n        Object obj = mock(Object.class);\n        \n        // Use reflection to retrieve the declared fields of the mock object\n        Field[] fields = obj.getClass().getDeclaredFields();\n        \n        // Iterate through the declared fields and find any nested objects within them\n        for (Field field : fields) {\n            if (field.getType().isPrimitive()) {\n                continue;\n            } else if (field.getType().equals(Object.class)) {\n                // Set the accessible flag of this field to true and retrieve its value\n                field.setAccessible(true);\n                Object nestedObject = field.get(obj);\n                \n                // Call the handlerObject() method with this object as an argument\n                SensitiveInfoUtil.handleNestedObject(nestedObject, Object.class, false);\n            } else if (field.getGenericType() instanceof ParameterizedType) {\n                ParameterizedType pt = (ParameterizedType) field.getGenericType();\n                if (pt.getRawType().equals(List.class)) {\n                    // Retrieve the actual type arguments of this parameterized type and check if they are entities\n                    Class[] actualTypes = (Class[]) pt.getActualTypeArguments();\n                    for (Class actualType : actualTypes) {\n                        if (actualType.equals(Object.class)) {\n                            // Set the accessible flag of this field to true and retrieve its value\n                            field.setAccessible(true);\n                            Object nestedList = field.get(obj);\n                            \n                            // Call the handleList() method with this list as an argument\n                            SensitiveInfoUtil.handleNestedObject(nestedList, Object.class, false);\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Verify that the handlerObject() and handleList() methods were called once each\n        verify(SensitiveInfoUtil).handlerObject(any(), anyBoolean());\n        verify(SensitiveInfoUtil).handleList(any(), any(), anyBoolean());\n    }\n}",
        "@BeforeEach\npublic void setUp() {\n    SensitiveInfoUtil sensitiveInfoUtil = new SensitiveInfoUtil();\n    Object obj = new Object(); // replace with the actual object\n    Class entity = String.class; // replace with the actual class\n    boolean isEncode = true;\n    try {\n        sensitiveInfoUtil.handleNestedObject(obj, entity, isEncode);\n    } catch (IllegalAccessException e) {\n        fail(\"Unexpected IllegalAccessException\");\n    }\n}\n\n@Test\npublic void handleNestedObject_List_Success() {\n    List<String> list = new ArrayList<>(); // replace with the actual list\n    Class entity = String.class; // replace with the actual class\n    boolean isEncode = true;\n    SensitiveInfoUtil sensitiveInfoUtil = new SensitiveInfoUtil();\n    try {\n        sensitiveInfoUtil.handleNestedObject(list, entity, isEncode);\n    } catch (IllegalAccessException e) {\n        fail(\"Unexpected IllegalAccessException\");\n    }\n}\n\n@Test\npublic void handleNestedObject_List_Fail() {\n    List<String> list = new ArrayList<>(); // replace with the actual list\n    Class entity = Integer.class; // replace with the actual class\n    boolean isEncode = true;\n    SensitiveInfoUtil sensitiveInfoUtil = new SensitiveInfoUtil();\n    try {\n        sensitiveInfoUtil.handleNestedObject(list, entity, isEncode);\n        fail(\"Expected IllegalArgumentException\");\n    } catch (IllegalArgumentException e) {\n        // expected exception\n    } catch (IllegalAccessException e) {\n        fail(\"Unexpected IllegalAccessException\");\n    }\n}",
        "\npackage org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        Object obj = null; // Replace with a valid object instance\n        Class entity = null; // Replace with the class of the nested object\n        boolean isEncode = false; // Replace with the desired value for isEncode\n        \n        SensitiveInfoUtil.handleNestedObject(obj, entity, isEncode);\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        Object obj = new Object(); // Create a sample object\n        Class entity = String.class; // Set the entity type to String\n        boolean isEncode = true; // Set the encode flag to true\n\n        try {\n            SensitiveInfoUtil.handleNestedObject(obj, entity, isEncode);\n        } catch (IllegalAccessException e) {\n            fail(\"Encountered an error while handling nested object: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        // Create a sample object with a nested instance of the given class\n        SampleObject sample = new SampleObject();\n        sample.setName(\"John Doe\");\n        sample.setAge(30);\n        SampleChild child = new SampleChild();\n        child.setName(\"Jane Doe\");\n        child.setAge(15);\n        sample.setChild(child);\n        \n        // Call the handleNestedObject method on this instance and verify that it has been modified as expected\n        SensitiveInfoUtil.handleNestedObject(sample, SampleChild.class, true);\n        assertEquals(\"John Doe\", sample.getName());\n        assertEquals(30, sample.getAge());\n        assertTrue(sample.isModified()); // Verify that the object has been modified\n    }\n}",
        "\npackage org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        Object obj = new Object(); // Replace with an instance of the object to test\n        Class entity = String.class; // Replace with the class of the entity you want to test\n        boolean isEncode = true; // Replace with the expected value for the isEncode parameter\n        \n        SensitiveInfoUtil.handleNestedObject(obj, entity, isEncode);\n        \n        assertEquals(\"Expected field.getAccessible() to be called\", true, field.getAccessible());\n        assertEquals(\"Expected handlerObject() to be called with the correct parameters\", obj, nestedObject);\n        assertEquals(\"Expected handleList() to be called with the correct parameters\", obj, nestedObject);\n    }\n}",
        "\npackage org.jeecg.common.desensitization.util;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() throws Exception {\n        // Create a sample object with nested fields\n        Object obj = new SampleObject();\n\n        // Set up the expected output\n        Field[] fields = obj.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            if(field.getType().isPrimitive()){\n                continue;\n            }\n            if(field.getType().equals(SampleObject2.class)){\n                // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n                field.setAccessible(true);\n                Object nestedObject = field.get(obj);\n                handlerObject(nestedObject, true);\n                break;\n            }else{\n                // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n                if(field.getGenericType() instanceof ParameterizedType){\n                    ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                    if(pt.getRawType().equals(List.class)){\n                        if(pt.getActualTypeArguments()[0].equals(SampleObject2.class)){\n                            field.setAccessible(true);\n                            Object nestedObject = field.get(obj);\n                            handleList(nestedObject, SampleObject2.class, true);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Verify that the expected output is correct\n        assertEquals(expectedOutput, actualOutput);\n    }\n}\n\n// Sample Objects\npublic class SampleObject {\n    private SampleObject2 obj1;\n    private List<SampleObject2> listObj;\n\n    public SampleObject() {}\n\n    // Getters and Setters for the fields\n}\n\npublic class SampleObject2 {\n    private String field1;\n    private int field2;\n\n    public SampleObject2() {}\n\n    // Getters and Setters for the fields\n}"
    ]
}