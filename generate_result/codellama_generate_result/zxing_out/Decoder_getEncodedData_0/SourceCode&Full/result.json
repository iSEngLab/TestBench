{
    "project_name": "zxing",
    "file_name": "Decoder.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.decoder",
    "docstring": "/**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */",
    "source_code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
    "class_name": "Decoder",
    "method_name": "getEncodedData",
    "arguments": [
        "boolean[] correctedBits"
    ],
    "generate_test": [
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        // Arrange\n        BitMatrix matrix = new BitMatrix(20, 20);\n        boolean compact = true;\n        int expectedSize = 1024;\n\n        // Act\n        byte[] data = Decoder.getEncodedData(matrix, compact);\n\n        // Assert\n        assertEquals(expectedSize, data.length);\n    }\n}",
        "private byte[] encodedData;\n\n@BeforeEach\npublic void setUp() {\n    encodedData = new byte[20];\n}\n\n@Test\npublic void getEncodedDataWithNoErrors() {\n    for (int i = 0; i < encodedData.length; i++) {\n        encodedData[i] = (byte) i;\n    }\n    BitArray bitArray = new BitArray(encodedData);\n    Decoder decoder = new Decoder();\n    int numDataCodewords = decoder.getNumDataCodewords();\n    Result result = decoder.decode(bitArray, numDataCodewords);\n    assertTrue(result instanceof CorrectedBitsResult);\n    byte[] actualData = ((CorrectedBitsResult) result).getDecodedData();\n    for (int i = 0; i < encodedData.length; i++) {\n        assertEquals(encodedData[i], actualData[i]);\n    }\n}\n\n@Test\npublic void getEncodedDataWithErrors() {\n    for (int i = 0; i < encodedData.length; i++) {\n        encodedData[i] = (byte) i;\n    }\n    BitArray bitArray = new BitArray(encodedData);\n    Decoder decoder = new Decoder();\n    int numDataCodewords = decoder.getNumDataCodewords();\n    Result result = decoder.decode(bitArray, numDataCodewords + 10);\n    assertTrue(result instanceof CorrectedBitsResult);\n    byte[] actualData = ((CorrectedBitsResult) result).getDecodedData();\n    for (int i = 0; i < encodedData.length; i++) {\n        assertEquals(encodedData[i], actualData[i]);\n    }\n}\n\n@Test\npublic void getEncodedDataWithChecksum() {\n    for (int i = 0; i < encodedData.length; i++) {\n        encodedData[i] = (byte) i;\n    }\n    BitArray bitArray = new BitArray(encodedData);\n    Decoder decoder = new Decoder();\n    int numDataCodewords = decoder.getNumDataCodewords();\n    Result result = decoder.decode(bitArray, numDataCodewords + 10);\n    assertTrue(result instanceof CorrectedBitsResult);\n    byte[] actualData = ((CorrectedBitsResult) result).getDecodedData();\n    for (int i = 0; i < encodedData.length; i++) {\n        assertEquals(encodedData[i], actualData[i]);\n    }\n}\n\n@Test\npublic void getEncodedDataWithChecksumAndNoErrors() {\n    for (int i = 0; i < encodedData.length; i++) {\n        encodedData[i] = (byte) i;\n    }\n    BitArray bitArray = new BitArray(encodedData);\n    Decoder decoder = new Decoder();\n    int numDataCodewords = decoder.getNumDataCodewords();\n    Result result = decoder.decode(bitArray, numDataCodewords + 10);\n    assertTrue(result instanceof CorrectedBitsResult);\n    byte[] actualData = ((CorrectedBitsResult) result).getDecodedData();\n    for (int i = 0; i < encodedData.length; i++) {\n        assertEquals(encodedData[i], actualData[i]);\n    }\n}\n\n@Test\npublic void getEncodedDataWithChecksumAndErrors() {\n    for (int i = 0; i < encodedData.length; i++) {\n        encodedData[i] = (byte) i;\n    }\n    BitArray bitArray = new BitArray(encodedData);\n    Decoder decoder = new Decoder();\n    int numDataCodewords = decoder.getNumDataCodewords();\n    Result result = decoder.decode(bitArray, numDataCodewords + 10);\n    assertTrue(result instanceof CorrectedBitsResult);\n    byte[] actualData = ((CorrectedBitsResult) result).getDecodedData();\n    for (int i = 0; i < encodedData.length; i++) {\n        assertEquals(encodedData[i], actualData[i]);\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        int numDataCodewords = 0;\n        int maskedMode = 1;\n        int[] dataWords = new int[numDataCodewords];\n        boolean compact = false;\n        \n        Decoder decoder = new Decoder();\n        CorrectedBitsResult result = decoder.getEncodedData(dataWords, numDataCodewords, maskedMode, compact);\n    }\n}",
        "@Test\npublic void getEncodedDataTest() {\n    byte[] encodedBits = convertBoolArrayToByteArray(extractBits(matrix));\n    DecoderResult result = DecodedBitStreamParser.decode(encodedBits);\n}",
        "\npackage com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        String expectedMessage = \"Hello World\";\n        byte[] encodedBytes = new byte[0]; // <FILL_ME>\n        DecoderResult result = new Decoder().getDecoderResult(encodedBytes);\n        assertEquals(expectedMessage, result.getText());\n    }\n}\n",
        "@Override\npublic List<Result> decodeMultiple(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n    // The list to hold results.\n    ArrayList<Result> resultList = new ArrayList<>();\n\n    // Attempt to read an Aztec code in \"full\" mode -- that is, as if it were a complete 2D matrix.\n    // Look for at least foursquare modules to succeed; less will still work with some difficulty.\n    Result rawResultFull = getDecoder().decode(image, true);\n    resultList.add(rawResultFull);\n\n    // Now look for a data matrix in \"sparse\" mode -- that is, assuming that it is only part of a larger\n    // 2D matrix. This assumes that any partial decoding that hasn't happened has been done already in full mode.\n    Result rawResultSparse = getDecoder().decode(image, false);\n    resultList.add(rawResultSparse);\n\n    return resultList;\n}\n    ",
        "@Test\n  public void encodedBits1() {\n    int[] d = new int[]{30,20,70,56,84,27,69,14};\n    String expectedString = \"Hello World!\";\n    \n    assertEquals(expectedString, getEncodedData(d));\n  }\n  \n  @Test\n  public void encodedBits2() {\n    int[] d = new int[]{30,20,70,56,84,27,69,14,87};\n    String expectedString = \"Hello World!\";\n    \n    assertEquals(expectedString, getEncodedData(d));\n  }\n  \n  @Test\n  public void encodedBits3() {\n    int[] d = new int[]{60,24,19,70,56,84,27,69,14};\n    String expectedString = \"Hello World!\";\n    \n    assertEquals(expectedString, getEncodedData(d));\n  }\n  \n  @Test\n  public void encodedBits4() {\n    int[] d = new int[]{30,20,70,56,84,27,69,14,87};\n    String expectedString = \"Hello World!\";\n    \n    assertEquals(expectedString, getEncodedData(d));\n  }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() throws Exception {\n        List<byte[]> encodedBits = new ArrayList<>();\n        boolean compact = false;\n        \n        // Check if the list of encoded bits is empty\n        assertEquals(0, encodedBits.size());\n        \n        int layers = 0;\n        try {\n            Decoder.getEncodedData(encodedBits, compact, layers);\n            fail(\"Expected an IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            assertTrue(true);\n        }\n        \n        // Check if the number of layers is 0\n        encodedBits.add(new byte[] {});\n        try {\n            Decoder.getEncodedData(encodedBits, compact, layers);\n            fail(\"Expected an IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            assertTrue(true);\n        }\n        \n        // Check if the number of layers is 1 and the list of encoded bits has 8 elements\n        encodedBits.clear();\n        layers = 1;\n        for (int i = 0; i < 8; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than 20 and less or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n        \n        // Check if the number of layers is greater than or equal to 90\n        encodedBits.clear();\n        for (int i = 0; i < Decoder.TOTAL_BOXES_PER_PARTITION * Decoder.MAX_PARTITIONS + 1; ++i) {\n            encodedBits.add(new byte[] {});\n        }\n    }\n}",
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        int[] dataWords = new int[]{1, 2, 3};\n        BitMatrix matrix = null; // Fill in the value for this field.\n        Decoder decoder = new Decoder();\n        CorrectedBitsResult result = decoder.decode(dataWords, matrix);\n        assertNotNull(result);\n        boolean[] expectedBits = new boolean[]{true, false, true, false};\n        assertArrayEquals(expectedBits, result.getCorrectedBits());\n        int expectedErrors = 2;\n        assertEquals(expectedErrors, result.getErrorCount());\n    }\n}\n",
        "@Override\n  public boolean check(char[] encodedData, int length) {\n    if (length % 2 != 0) {\n      return false;\n    }\n    for (int i = 0; i < length; i++) {\n      char c = encodedData[i];\n      if (!isHexCharacter(c)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}"
    ]
}