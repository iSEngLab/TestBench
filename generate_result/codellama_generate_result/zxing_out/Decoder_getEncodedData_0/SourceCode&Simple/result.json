{
    "project_name": "zxing",
    "file_name": "Decoder.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.decoder",
    "docstring": "/**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */",
    "source_code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
    "class_name": "Decoder",
    "method_name": "getEncodedData",
    "arguments": [
        "boolean[] correctedBits"
    ],
    "generate_test": [
        "@Given(\"I have some code\")\ndef given_code(context):\n    pass\n\n\n@When(\"I decode it with the decoder\")\ndef when_decode(context):\n    context.actual = aztec_decoder.Decoder()\n\n\n@Then(\"I get {int} errors corrected\")\ndef then_get_errors_corrected(context, expected):\n    assert context.actual == expected\n",
        "\nprivate static String getEncodedData(boolean[] correctedBits) {\n  // Create a StringBuilder to store the decoded data\n  StringBuilder result = new StringBuilder();\n  \n  // Get the length of the corrected bits array\n  int size = correctedBits.length;\n  \n  // Iterate through the corrected bits array\n  for (int i = 0; i < size; i += 8) {\n    // Get the next 8 corrected bits as a byte\n    byte b = readByte(correctedBits, i);\n    \n    // Append the corresponding character to the result string builder\n    result.append((char)b);\n  }\n  \n  return result.toString();\n}\n",
        "package com.google.zxing.aztec;\n\nimport com.google.zxing.BarcodeFormat;\n\nimport com.google.zxing.BinaryBitmap;\n\nimport com.google.zxing.ChecksumException;\n\nimport com.google.zxing.DecodeHintType;\n\nimport com.google.zxing.FormatException;\n\nimport com.google.zxing.NotFoundException;\n\nimport com.google.zxing.Reader;\n\nimport com.google.zxing.Result;\n\nimport com.google.zxing.common.BitMatrix;\n\nimport java.util.Map;\n\npublic final class AztecReader implements Reader {\n    @Override\n    public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n        return decode(image, null);\n    }\n    @Override\n    public void reset() {}\n    private static DecoderResult getDecoderResult(BitMatrix matrix, Map<DecodeHintType, ?> hints) throws FormatException, ChecksumException, NotFoundException {\n      AztecDetectorResult ddata = new AztecDetector(matrix).detect();\n      boolean compact = ddata.isCompact();\n      int layers = ddata.getLayers();\n      if (hints != null && hints.containsKey(DecodeHintType.PURE_BARCODE)) {\n        // Look for a split-up, version info in the data of the barcode.\n        // No point in this for normal Aztec code since it will be read by\n        // the detector anyway.\n        if (compact) {\n          return Decoder.decode(matrix);\n        } else {\n          String raw;\n          try {\n            raw = new com.google.zxing.aztec.detector.Detector(matrix).detect().getDataRaw();\n          } catch (NotFoundException nfe) {\n            return Decoder.decode(matrix);\n          }\n          // Version info is between the end of the data and the start of the error correction code\n          int iVersion = raw.length() / 2;\n          if ((raw.charAt(iVersion - 1) != '+' || raw.charAt(iVersion + 1) != '-') && (raw.charAt(iVersion - 1) != '%' || raw.charAt(iVersion + 1) != '*')) {\n            return Decoder.decode(matrix);\n          } else if (iVersion <= 6) {\n            layers = iVersion;\n          } else if (iVersion == 9) {\n            compact = true;\n          } else {\n            throw NotFoundException.getNotFoundInstance();\n          }\n        }\n      }\n      return Decoder.decode(ddata, hints);\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        String expected = \"CTRL_PS:Table A\\n\";\n        StringBuilder result = new StringBuilder();\n        int index = 0;\n        boolean compact = false;\n        while (index < 32) {\n            char[] characters = {'U', 'L'};\n            CharacterSetECI eci;\n            try {\n                eci = CharacterSetECI.getCharacterSetECIByValue(characters[index % 2]);\n            } catch (UnsupportedEncodingException uee) {\n                throw new RuntimeException(\"No mapping for \" + characters[index % 2] + \": \" + uee);\n            }\n            if (eci != null) {\n                result.append(Decoder.getEncodedData(expected, compact));\n            } else {\n                break;\n            }\n        }\n        assertEquals(result.toString(), expected);\n    }\n}",
        "private static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int length = correctedBits.length;\n  StringBuilder result = new StringBuilder((length * 10 / 8) + 1); // 10 bits per character, 0.5 characters per byte\n  for (int i = 0; i < length; i += 8) {\n    int word = getWord(correctedBits, i);\n    if (word >= 32768) {\n      result.append((char) ((word - 32768) % 95 + 33)); // 95 printable ASCII characters\n    } else if (word > 127) {\n      result.append((char) (word - 128)); // 128-255\n    } else {\n      throw FormatException.getFormatInstance();\n    }\n  }\n  return result.toString();\n}\n\nprivate static int getWord(boolean[] correctedBits, int i) throws FormatException {\n  if (correctedBits[i] != true) {\n    return -1;\n  }\n  int word = 0;\n  for (int j = 0; j < 4; j++) {\n    word <<= 1;\n    boolean b = correctedBits[i + j];\n    if (b == true) {\n      throw FormatException.getFormatInstance();\n    } else if (b == false) {\n      word++;\n    }\n  }\n  return word;\n}",
        "package com.google.zxing.aztec;\n\nimport com.google.zxing.*;\n\nimport java.util.List;\n\npublic class AztecReader extends Reader {\n  private static final ResultPoint[] NO_POINTS = new ResultPoint[0];\n  private final Decoder decoder = new Decoder();\n\n  @Override\n  public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n    return decode(image, null);\n  }\n\n  @Override\n  public Result decode(BinaryBitmap image, java.util.Map<DecodeHintType,?> hints) throws NotFoundException, ChecksumException, FormatException {\n    List<AztecCode> codes = AztecCodeFinder.findAztecCodes(image);\n    if (codes == null || codes.isEmpty()) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    // Decode only the code with the smallest bounding box, which should be the most stable\n    AztecCode smallest = null;\n    int minSize = Integer.MAX_VALUE;\n    for (AztecCode code : codes) {\n      if (code.getBoundingBox().width < minSize && code.getBoundingBox().height < minSize) {\n        smallest = code;\n        minSize = Math.min(code.getBoundingBox().width, code.getBoundingBox().height);\n      }\n    }\n\n    // Decode the code\n    DecoderResult result = decoder.decode(smallest.getMatrix(), hints);\n    return new Result(result.getText(), result.getRawBytes(), NO_POINTS, BarcodeFormat.AZTEC);\n  }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DecoderTest {\n  @Test\n  public void getEncodedDataTest() {\n    // Arrange\n    String correctEncoding = \"ABC\";\n    int dataBits = 100;\n    BitMatrix matrix = new BitMatrix(dataBits, dataBits);\n    for (int i = 0; i < dataBits; i++) {\n      matrix.set(i, i);\n    }\n    AztecDetectorResult detectorResult = new AztecDetectorResult(matrix);\n    \n    // Act\n    String result = Decoder.getEncodedData(detectorResult.getBits());\n    \n    // Assert\n    assertEquals(correctEncoding, result);\n  }\n}\n",
        "The method `getEncodedData` returns the data encoded in the Aztec symbol, given its representation as a boolean array.\n\nFirst, it converts the boolean array into a string of binary digits using the following steps:\n\n1. It initializes an empty string `result`.\n2. It iterates over each element of the input boolean array. For each element, it appends to `result` either `\"0\"` or `\"1\"`, depending on whether the element is `false` or `true`.\n3. After all elements have been processed, `result` contains a binary representation of the input array.\n\nThen, this method converts the resulting string into a character sequence using the encoding specified in the symbol's encoding mode (UPPER, LOWER, MIXED, DIGIT, PUNCT, or BINARY). The encoding is defined by the `getCharacter` function, which takes an integer code representing the position of a character in the relevant table and returns the corresponding character.\n\nFinally, this method applies error correction to the character sequence and returns it as a `String`.\n\nYou can use [this JUnit test case](https://github.com/zxing/zxing/blob/master/core/src/test/java/com/google/zxing/aztec/decoder/DecoderTestCase.java) as a reference to see how the method can be used in practice.\n\nNote that `getEncodedData` is a private method, and it's not meant to be called from outside of this class. It's only intended to be used by the other methods in this class.",
        "package com.google.zxing.aztec.decoder;\n\nimport java.util.ArrayList;\n\nimport org.junit.jupiter.api.Assertions;\n\nimport org.junit.jupiter.api.Test;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        String correctText = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n        Assertions.assertEquals(correctText, Decoder.getEncodedData(correctText));\n        \n        String inputWithNoSpaces = \"HelloWorld\";\n        String expectedOutput = \"HELLO WORLD\";\n        Assertions.assertEquals(expectedOutput, Decoder.getEncodedData(inputWithNoSpaces));\n    }\n}\n    \n\n### Response:",
        "\n// Assuming `rawBits` contains the raw binary data from an Aztec 2D barcode\nString encodedData = Decoder.getEncodedData(rawBits);\nSystem.out.println(\"Decoded message: \" + encodedData);\n"
    ]
}