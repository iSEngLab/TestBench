{
    "project_name": "zxing",
    "file_name": "Detector.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/detector/Detector.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.detector",
    "docstring": "/**\n   * Finds a candidate center point of an Aztec code from an image\n   *\n   * @return the center point\n   */",
    "source_code": "\nprivate Point getMatrixCenter() {\n\n  ResultPoint pointA;\n  ResultPoint pointB;\n  ResultPoint pointC;\n  ResultPoint pointD;\n\n  //Get a white rectangle that can be the border of the matrix in center bull's eye or\n  try {\n\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n\n  } catch (NotFoundException e) {\n\n    // This exception can be in case the initial rectangle is white\n    // In that case, surely in the bull's eye, we try to expand the rectangle.\n    int cx = image.getWidth() / 2;\n    int cy = image.getHeight() / 2;\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n\n  }\n\n  //Compute the center of the rectangle\n  int cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  int cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n\n  // Redetermine the white rectangle starting from previously computed center.\n  // This will ensure that we end up with a white rectangle in center bull's eye\n  // in order to compute a more accurate center.\n  try {\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image, 15, cx, cy).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n  } catch (NotFoundException e) {\n    // This exception can be in case the initial rectangle is white\n    // In that case we try to expand the rectangle.\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n  }\n\n  // Recompute the center of the rectangle\n  cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n\n  return new Point(cx, cy);\n}\n",
    "class_name": "Detector",
    "method_name": "getMatrixCenter",
    "arguments": [],
    "generate_test": [
        "    package com.google.zxing.aztec.detector;\n\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DetectorTest {\n    private final BufferedImage image = new BufferedImage(10, 10, BufferedImage.TYPE_BYTE_GRAY);\n    \n    @Test\n    public void getMatrixCenterTest() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertEquals(new Point(4, 5), detector.getMatrixCenter().toResultPoint());\n        }\n    }\n    \n    @Test\n    public void getDimensionTest() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertEquals(14, detector.getDimension());\n        }\n    }\n    \n    @Test\n    public void getCenterTest() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertEquals(new Point(4, 5), detector.getMatrixCenter().toResultPoint());\n        }\n    }\n    \n    @Test\n    public void isValidTest() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertTrue(detector.isValid(4, 5));\n            assertFalse(detector.isValid(-1, -1));\n            assertFalse(detector.isValid(-1, 0));\n            assertFalse(detector.isValid(image.getWidth(), image.getHeight()));\n        }\n    }\n    \n    @Test\n    public void isValidResultPoint() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertTrue(detector.isValid(new ResultPoint(4, 5)));\n            assertFalse(detector.isValid(new ResultPoint(-1, -1)));\n            assertFalse(detector.isValid(new ResultPoint(-1, 0)));\n        }\n    }\n    \n    @Test\n    public void expandSquareResultPoint() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertArrayEquals(new ResultPoint[]{new ResultPoint(2, 3), new ResultPoint(5, 7), new ResultPoint(12, 9), new ResultPoint(8, 15)}, detector.expandSquare(new ResultPoint[]{new ResultPoint(0, 0), new ResultPoint(2, 3), new ResultPoint(4, 6), new ResultPoint(8, 9)}, 4, 16));\n        }\n    }\n    \n    @Test\n    public void findAlignmentInRegion() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertEquals(new Point(1, 2), detector.findAlignmentInRegion(image, new Rectangle(0, 0, image.getWidth(), image.getHeight())));\n        }\n    }\n    \n    @Test\n    public void calculateSkew() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertEquals(0, detector.calculateSkew(image), 0);\n        }\n    }\n    \n    @Test\n    public void calculateModuleSize() throws IOException {\n        final Collection<Detector> detectors = createDetectors();\n        \n        for (final Detector detector : detectors) {\n            assertEquals(1, detector.calculateModuleSize(image), 0);\n        }\n    }\n    \n    private static Collection<Detector> createDetectors() throws IOException {\n        final AztecDetectorResult result = new AztecDetectorResult();\n        \n        return Detector.createDetectors(result, image);\n    }\n}\n    ",
        "@SuppressWarnings(\"unused\")\npublic class DetectorTest {\n  private static final int NB_LAYERS = 4;\n  private static final float TOLERANCE = 0.1f;\n  private Detector detector;\n  \n  @BeforeEach\n  public void setUp() {\n    this.detector = new Detector(NB_LAYERS, true);\n  }\n  \n  @Test\n  public void getMatrixCenterTest() {\n    Point[] cornerPoints = new Point[]{\n        new Point(0f, 0f),\n        new Point(1f, 0f),\n        new Point(2f, 1f),\n        new Point(3f, 1f)\n      };\n    \n    // Top left corner is at (0.0, 0.0)\n    ResultPoint topLeft = this.detector.getMatrixCenter(cornerPoints);\n    assertEquals(0f, topLeft.getX(), TOLERANCE);\n    assertEquals(0f, topLeft.getY(), TOLERANCE);\n    \n    // Top right corner is at (3.0, 0.0)\n    ResultPoint topRight = this.detector.getMatrixCenter(cornerPoints);\n    assertEquals(3f, topRight.getX(), TOLERANCE);\n    assertEquals(0f, topRight.getY(), TOLERANCE);\n    \n    // Bottom left corner is at (0.0, 1.0)\n    ResultPoint bottomLeft = this.detector.getMatrixCenter(cornerPoints);\n    assertEquals(0f, bottomLeft.getX(), TOLERANCE);\n    assertEquals(1f, bottomLeft.getY(), TOLERANCE);\n    \n    // Bottom right corner is at (3.0, 1.0)\n    ResultPoint bottomRight = this.detector.getMatrixCenter(cornerPoints);\n    assertEquals(3f, bottomRight.getX(), TOLERANCE);\n    assertEquals(1f, bottomRight.getY(), TOLERANCE);\n    \n    // Center is at (1.5, 0.5)\n    ResultPoint center = this.detector.getMatrixCenter(cornerPoints);\n    assertEquals(1.5f, center.getX(), TOLERANCE);\n    assertEquals(0.5f, center.getY(), TOLERANCE);\n  }\n}\n",
        "\n// 1. You could create a private field called `matrixCenter` and initialize it in the constructor of your class.\nprivate Point matrixCenter;\npublic Detector(AztecDetectorResult aztecDetectorResult) {\n    // ...\n    this.matrixCenter = getMatrixCenter();\n}\n// 2. Or, you could create a public method called `getMatrixCenter()` that computes the center of the matrix.\npublic Point getMatrixCenter() {\n    // ...\n}\n",
        "\npackage com.google.zxing.aztec.detector;\n\nimport java.util.*;\nimport com.google.zxing.*;\nimport com.google.zxing.aztec.AztecDetectorResult;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DetectorTest {\n    @Test\n    public void getMatrixCenterTest() {\n        // Arrange\n        List<ResultPoint> corners = new ArrayList<>();\n        corners.add(new ResultPoint(10, 20));\n        corners.add(new ResultPoint(30, 20));\n        corners.add(new ResultPoint(40, 60));\n        corners.add(new ResultPoint(30, 80));\n        AztecDetectorResult result = new AztecDetectorResult();\n        result.setCorners(corners);\n        \n        // Act\n        Point center = Detector.getMatrixCenter(result);\n        \n        // Assert\n        assertEquals(25, center.x);\n        assertEquals(70, center.y);\n    }\n}\n",
        "python\nimport cv2\nimg = cv2.imread('aztec_image.png')\n",
        "\npackage com.google.zxing.aztec.detector;\n\nimport com.google.zxing.ResultPoint;\n\n/**\n * Detects an Aztec code in an image.\n */\npublic final class Detector {\n    private static final int MAX = 32;\n\n    private final BitMatrix image;\n    private final ResultPoint center;\n\n    /**\n     * <p>Creates a new instance.</p>\n     * @param image image to detect Aztec code in\n     * @param center center of the image\n     */\n    public Detector(BitMatrix image, ResultPoint center) {\n        this.image = image;\n        this.center = center;\n    }\n\n    /**\n     * <p>Detects an Aztec code in an image.</p>\n     * @param image image to detect Aztec code in\n     * @return {@link DetectorResult} encapsulating results of detecting an Aztec code or null if an Aztec code cannot be found.\n     */\n    public static DetectorResult detect(BitMatrix image) {\n        ResultPoint center = getMatrixCenter(image);\n        return new Detector(image, center).detect();\n    }\n\n    /**\n     * <p>Detects an Aztec code in a subset of an image.</p>\n     * @param image image to detect Aztec code in\n     * @return {@link DetectorResult} encapsulating results of detecting an Aztec code or null if an Aztec code cannot be found.\n     */\n    public static DetectorResult detect(BitMatrix image, int minSize) {\n        ResultPoint center = getMatrixCenter(image);\n        return new Detector(image, center).detect();\n    }\n\n    /**\n     * <p>Detects an Aztec code in a subset of an image.</p>\n     * @param image image to detect Aztec code in\n     * @return {@link DetectorResult} encapsulating results of detecting an Aztec code or null if an Aztec code cannot be found.\n     */\n    public static DetectorResult detect(BitMatrix image, int minSize, float centerX, float centerY) {\n        return new Detector(image, new ResultPoint(centerX, centerY)).detect();\n    }\n\n    /**\n     * <p>Detects an Aztec code in a subset of an image.</p>\n     * @param image image to detect Aztec code in\n     * @return {@link DetectorResult} encapsulating results of detecting an Aztec code or null if an Aztec code cannot be found.\n     */\n    public static DetectorResult detect(BitMatrix image, int minSize, float centerX, float centerY, boolean compact) {\n        return new Detector(image, new ResultPoint(centerX, centerY)).detect();\n    }\n\n    private DetectorResult detect() {\n        if (center == null || image.getWidth() < 4 * getDimension()) {\n            return null;\n        }\n\n        int size = getDimension();\n\n        float matrixCenterX = center.getX();\n        float matrixCenterY = center.getY();\n\n        boolean tryHarder = true;\n        for (int i = 0; i < MAX && tryHarder; i++) {\n            ResultPoint point = getMatrixCorner(matrixCenterX, matrixCenterY);\n            if (point == null) {\n                return null;\n            } else {\n                center = new ResultPoint(matrixCenterX = point.getX(), matrixCenterY = point.getY());\n            }\n        }\n\n        return new DetectorResult(center, size, tryHarder);\n    }\n\n    private static float distance(float aX, float aY, float bX, float bY) {\n        float xDiff = aX - bX;\n        float yDiff = aY - bY;\n        return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n    }\n\n    private static ResultPoint getMatrixCorner(float matrixCenterX, float matrixCenterY) {\n        int size = 1;\n        for (int i = 0; i < MAX && distance(matrixCenterX, matrixCenterY, size, size / 2f) > size * 3.5f; i++) {\n            size++;\n        }\n        return new ResultPoint(size + 7, size + 7);\n    }\n\n    private static float centerDistance(float x1, float y1, float x2, float y2) {\n        return distance(x1, y1, x2, y2);\n    }\n\n    private static ResultPoint getMatrixCenter(BitMatrix image) {\n        int[] found = new int[3];\n\n        float max = Float.MIN_VALUE;\n        for (int y = 0; y < image.getHeight(); y++) {\n            for (int x = 0; x < image.getWidth(); x++) {\n                if (!image.get(x, y)) {\n                    continue;\n                }\n\n                float centerX = x + 0.5f;\n                float centerY = y + 0.5f;\n                int count = 0;\n\n                for (int i = 0; i < found.length; i++) {\n                    if (!found[i] != -1 && centerDistance(centerX, centerY, x, y) <= found[i]) {\n                        count++;\n                    }\n                }\n\n                if (count == found.length) {\n                    float d = distance(centerX, centerY, x, y);\n                    if (d > max) {\n                        return new ResultPoint(x + 0.5f, y + 0.5f);\n                    } else if ((d == max) && distance(matrixCenterX, matrixCenterY, x, y) < d) {\n                        // Found another one at almost the same distance as this one.\n                        return new ResultPoint(x + 0.5f, y + 0.5f);\n                    }\n                }\n            }\n        }\n\n        throw new IllegalArgumentException(\"Couldn't find center of matrix\");\n    }\n\n    private static int getDimension() {\n        return 1;\n    }\n}\n",
        "package com.google.zxing.aztec.detector;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DetectorTest {\n    @Test\n    public void getMatrixCenterTest() {\n        int matrixSize = 128; // The size of the aztec matrix\n        Point expectedCenterPoint = new Point(matrixSize / 2, matrixSize / 2);\n\n        float squareSize = 10.5f;\n        boolean compact = false;\n        Detector detector = new Detector(expectedCenterPoint, squareSize, compact);\n        \n        // Actual center point returned by the getMatrixCenter() method\n        Point actualCenterPoint = detector.getMatrixCenter();\n\n        assertEquals(expectedCenterPoint, actualCenterPoint, \"The matrix center should match\");\n    }\n}",
        "\npublic Point getMatrixCenter() {\n    int width = points[0].x - points[2].x;\n    int height = points[0].y - points[2].y;\n    return new Point(points[0].x + (width / 2), points[0].y + (height / 2));\n}\n",
        "package com.google.zxing.aztec.detector;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class DetectorTest {\n    @Test\n    public void getMatrixCenterTest() {\n        ResultPoint[] points = new ResultPoint[]{\n                new ResultPoint(0, 0), // Top-left corner\n                new ResultPoint(3, 2), // Top-right corner\n                new ResultPoint(1, 4), // Bottom-left corner\n                new ResultPoint(5, 6)   // Bottom-right corner\n        };\n        Point center = Detector.getMatrixCenter(points);\n        Assertions.assertEquals(2, center.x);\n        Assertions.assertEquals(3, center.y);\n    }\n}",
        "package com.google.zxing.aztec.detector;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic final class Detector {\n  private static final float MAX_AVG_VARIANCE = .12f;\n  private static final float MAX_INDIVIDUAL_VARIANCE = .24f;\n  public ResultPoint resultPointCallback;\n  public boolean compact;\n  public int nbLayers;\n  public int dimensionMax;\n  public AztecDetectorResult pointsOnly;\n  public Bounds bounds;\n  private final BitMatrix image;\n  \n  /**\n   * <p>Creates a new instance.</p>\n   */\n  public Detector(BitMatrix image) {\n    this.image = image;\n  }\n  \n  /**\n   * Locate the Aztec code in an image.\n   *\n   * @param hints optional hints to detector\n   * @return {@link AztecDetectorResult} encapsulating results of detecting Aztec code\n   */\n  public AztecDetectorResult detect(Map<DecodeHintType,?> hints) throws NotFoundException {\n    if (pointsOnly != null) {\n      return pointsOnly;\n    }\n    \n    ResultPoint callback = resultPointCallback;\n    boolean compact = true;\n    int nbLayers = 0;\n    int dimensionMax = Integer.MAX_VALUE;\n    \n    // Look for an alignment pattern in a 32\u00d732 area around the center of the image, which should be\n    // aligned with any Aztec code\n    float size = MathUtils.max(image.getWidth(), image.getHeight()) / 10f;\n    \n    ResultPoint point = findAlignmentInRegion(null, new Bounds((int) (image.getWidth() - size) / 2, (int) (image.getHeight() - size) / 2), (int) size);\n    if (point != null) {\n      // If we found an alignment pattern, use it to locate the center of the code and the center of the alignment pattern\n      float cx = point.getX();\n      float cy = point.getY();\n      \n      bounds = Bounds.centerAt(cx, cy);\n    } else {\n      // If we didn't find an alignment pattern, we don't know which way is up; guess left-right and hope for the best\n      size = MathUtils.max(image.getWidth(), image.getHeight()) / 2f;\n      \n      bounds = new Bounds((int) (image.getWidth() - size), (int) (size));\n    }\n    \n    // Now just look for a corner in the general direction of where we think the center is\n    point = findCornerFromCenter(null, null, 177);\n    if (point != null) {\n      // If we found a corner that should be from an Aztec code, assume we're done\n      float cx = point.getX();\n      float cy = point.getY();\n      \n      bounds = Bounds.centerAt(cx, cy);\n    } else {\n      // Otherwise look for the corners in another 32 \u00d7 32 area around the center of the image\n      size = MathUtils.max(image.getWidth(), image.getHeight()) / 10f;\n      \n      point = findAlignmentInRegion(bounds, new Bounds((int) (image.getWidth() - size) / 2, (int) (size)), (int) size);\n    }\n    \n    float cx = point.getX();\n    float cy = point.getY();\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int dimension = getMatrixDimension(cx, cy);\n    boolean compactSize = false;\n    if ((hints == null || !hints.containsKey(DecodeHintType.TRY_HARDER)) && dimension < 32) {\n      // We got the dimension by guessing; check bounds and see if this guess was correct\n      for (int i : new int[]{1, -1}) {\n        float x = cx + i * MathUtils.distance(bounds.left, bounds.right);\n        \n        point = findCornerFromCenter(point, null, 177);\n        if (!isValid(point)) {\n          continue;\n        }\n      }\n      \n      int correctedDimension = getMatrixDimension(cx, cy);\n      if (correctedDimension > dimension) {\n        // Oh, it's bigger. Well, then.\n        dimension = correctedDimension;\n        compactSize = true;\n        \n        // But we can only do this once\n        nbLayers++;\n      } else if (correctedDimension < dimension) {\n        // Wait, it's smaller. That's weird.\n        dimension = correctedDimension;\n        compactSize = false;\n        nbLayers--;\n        \n        bounds = Bounds.centerAt(cx, cy);\n      } else {\n        // No, it was right\n        compactSize = true;\n      }\n    }\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    float ratio = MathUtils.distance(bounds.left, bounds.right) / (float) dimension;\n    int left = (int) (cx - ratio * (dimension - 1) + .5f);\n    int right = (int) (cx + ratio * (dimension - 1) + .5f);\n    \n    int ymin = bounds.top;\n    for (int i : new int[]{1, -1}) {\n      float x = cx + i * MathUtils.distance(bounds.left, bounds.right);\n      \n      ResultPoint point2 = findCornerFromCenter(null, null, 177);\n      if (!isValid(point2)) {\n        continue;\n      }\n    }\n    \n    int ymax = bounds.bottom;\n    if (ymax > image.getHeight()) {\n      ymax = image.getHeight();\n      \n      // If we go all the way to the bottom, and we're still not done...\n      if ((right & 1) == 0 && !isValid(null)) {\n        right++;\n        \n        int i;\n        for (i = ymin + 2; i <= ymax - 2 && isValid(null); i++) {\n          float x = cx + ratio * (dimension - 1) / 2f + .5f;\n          \n          findAlignmentInRegion(new Bounds(left, right), new Bounds(i - 2, i + 2));\n        }\n        \n        // If we're still not done... try once more with a projected width of dimension - 3\n      } else {\n        if (dimension > 3) {\n          compact = false;\n          \n          left -= ratio * 4f + .5f;\n          right += ratio * 4f + .5f;\n          \n          int i2;\n          for (i2 = ymin + 2; i2 <= ymax - 2 && isValid(null); i2++) {\n            float x2 = cx + ratio * (dimension - 3) / 2f + .5f;\n            \n            findAlignmentInRegion(new Bounds(left, right), new Bounds(i2 - 2, i2 + 2));\n          }\n          \n          // Try the compact size\n        } else {\n          compact = false;\n          \n          left -= ratio * (dimension - 1) / 2f + .5f;\n          right += ratio * (dimension - 1) / 2f + .5f;\n          \n          int i3;\n          for (i3 = ymin + 2; i3 <= ymax - 2 && isValid(null); i3++) {\n            float x3 = cx + ratio * (dimension - 1) / 2f + .5f;\n            \n            findAlignmentInRegion(new Bounds(left, right), new Bounds(i3 - 2, i3 + 2));\n          }\n        }\n        \n        // We found something! Return it.\n      }\n    } else {\n      ymax = ymin;\n      \n      if (compactSize) {\n        compact = false;\n      }\n    }\n    \n    int top = ymin - 2;\n    if (top < 0) {\n      top = 0;\n    }\n    \n    int bottom = ymax + 3;\n    if (bottom > image.getHeight()) {\n      bottom = image.getHeight();\n      \n      if (!compactSize && ymin - 2 >= 0) {\n        compact = false;\n        \n        left -= ratio * dimension / 2f + .5f;\n        right += ratio * dimension / 2f + .5f;\n        \n        findAlignmentInRegion(new Bounds(left, right), new Bounds(ymin - 3, ymin));\n      } else {\n        compact = true;\n      }\n    }\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int width = right - left;\n    float ratio2 = MathUtils.distance(bounds.left, bounds.right) / (float) dimension;\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int height = bottom - top;\n    float ratio3 = MathUtils.distance(bounds.top, bounds.bottom) / (float) dimension;\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    ImageTransform xform = new ImageTransform(image, left, top, width, height);\n    BufferedImage result = xform.transform();\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    left = (int) (cx - ratio2 * (dimension - 1) / 2f + .5f);\n    if (left < 0) {\n      left = 0;\n      \n      width += -left;\n    }\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    right = left + width;\n    if (right > result.getWidth()) {\n      int i4 = result.getWidth() - left;\n      \n      width -= i4;\n    } else {\n      width -= right - result.getWidth();\n    }\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    top = (int) (cy - ratio3 * (dimension - 1) / 2f + .5f);\n    if (top < 0) {\n      top = 0;\n      \n      height += -top;\n    }\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    bottom = top + height;\n    if (bottom > result.getHeight()) {\n      int i5 = result.getHeight() - top;\n      \n      height -= i5;\n    } else {\n      height -= bottom - result.getHeight();\n    }\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    BufferedImage cropped = xform.crop(left, top, width, height);\n    \n    return new ImageTransform(cropped, left, top, width, height).transform();\n  }\n  \n  // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n  private int getModuleSize(BufferedImage image) {\n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int width = image.getWidth();\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int height = image.getHeight();\n    \n    if (width == height) {\n      return width / this.moduleSize;\n      \n      // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    } else if (width < height) {\n      int i = height / width;\n      \n      return width * i / this.moduleSize;\n      \n      // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    } else {\n      int i2 = width / height;\n      \n      return height * i2 / this.moduleSize;\n    }\n  }\n  \n  // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n  private boolean isWhite(BufferedImage image, int x, int y) {\n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    Raster raster = image.getRaster();\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int width = image.getWidth();\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int height = image.getHeight();\n    \n    if ((x < 0 || x >= width) && (y < 0 || y >= height)) {\n      // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    } else if (x < 0) {\n      return isWhite(image, x + width - 1, y);\n      \n      // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    } else if (x >= width) {\n      return isWhite(image, x - width + 1, y);\n      \n      // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    } else if (y < 0) {\n      return isWhite(image, x, y + height - 1);\n      \n      // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    } else if (y >= height) {\n      return isWhite(image, x, y - height + 1);\n    }\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    int[] pixels = raster.getPixels(x / this.moduleSize, y / this.moduleSize, 1, 1, (int[]) null);\n    \n    // Actually transform the image to a square with sides of size (dimension + 8 \u00d7 dimModules) and then crop it to the target size\n    return pixels[0] > 250;\n  }\n}"
    ]
}