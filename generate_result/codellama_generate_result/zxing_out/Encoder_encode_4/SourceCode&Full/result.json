{
    "project_name": "zxing",
    "file_name": "Encoder.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/encoder/Encoder.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.encoder",
    "docstring": "/**\n   * Encodes the given string content as an Aztec symbol\n   *\n   * @param data input data string\n   * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,\n   *                      a minimum of 23% + 3 words is recommended)\n   * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers\n   * @param charset character set in which to encode string using ECI; if null, no ECI code\n   *                will be inserted, and the string must be encodable as ISO/IEC 8859-1\n   *                (Latin-1), the default encoding of the symbol.\n   * @return Aztec symbol matrix with metadata\n   */",
    "source_code": "\npublic static AztecCode encode(String data, int minECCPercent, int userSpecifiedLayers, Charset charset) {\n  byte[] bytes = data.getBytes(null != charset ? charset : StandardCharsets.ISO_8859_1);\n  return encode(bytes, minECCPercent, userSpecifiedLayers, charset);\n}\n",
    "class_name": "Encoder",
    "method_name": "encode",
    "arguments": [
        "String data",
        "int minECCPercent",
        "int userSpecifiedLayers",
        "Charset charset"
    ],
    "generate_test": [
        "public class Encoder {\n  private static final int PAD0 = 0xEC; // 1110110X\n  private static final int PAD1 = 0x11; // 00010001\n\n  public static BitMatrix encode(String contents, BarcodeFormat format, int width, int height) {\n    return new Encoder().encodeInternal(contents, format, width, height);\n  }\n\n  private BitMatrix encodeInternal(String contents, BarcodeFormat format, int width, int height) {\n    if (format != BarcodeFormat.AZTEC) {\n      throw new IllegalArgumentException(\"Can only encode AZTEC, but got \" + format);\n    }\n    return renderResult(encodeAsBitMatrix(contents), width, height);\n  }\n\n  private BitMatrix encodeAsBitMatrix(String contents) {\n    int length = contents.length();\n    if (length > 32767) { // maximum size of array\n      throw new IllegalArgumentException(\"Requested contents should be less than 32767 characters long, but got \" + length);\n    }\n\n    boolean compact;\n    int numDatablocks;\n    if (length <= 0xff) { // numeric data with no error correction\n      compact = true;\n      numDatablocks = 1;\n    } else { // text data, or mixed data (numeric + text)\n      compact = false;\n      int bytesNeededForData = (length / 8) + (length % 8 > 0 ? 1 : 0);\n      numDatablocks = Math.max(2, ((bytesNeededForData - 2) >> 2) + 1); // For numeric data, use datablocks that are smaller than for text\n    }\n    int matrixSize = compact ? (8 * numDatablocks) - 1 : (numDatablocks * 4).toInt() + 17;\n\n    BitMatrix bitmatrix = new BitMatrix(matrixSize);\n    bitmatrix.setRegion(0, 0, matrixSize, matrixSize);\n\n    // set the data bits in the matrix\n    for (int i = 0; i < length; ++i) {\n      int value = contents.charAt(i).toInt();\n      if (value >= '0' && value <= '9') {\n        value -= '0';\n      } else if (value >= 'A' && value <= 'Z') {\n        value -= ('A' - 10);\n      } else {\n        throw new IllegalArgumentException(\"Bad character in input: \" + contents.charAt(i));\n      }\n      bitmatrix.setRegion(i * 4, 8, 4, matrixSize, compact ? PAD0 : value);\n    }\n\n    // set the error correction bits in the matrix\n    for (int i = 1; i < numDatablocks; ++i) {\n      int index = length * i - 1;\n      if (compact) {\n        bitmatrix.setRegion(index, index + 8, PAD0);\n      } else {\n        bitmatrix.setRegion(index, index + 4, PAD0);\n      }\n    }\n\n    return bitmatrix;\n  }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\n\npublic class EncoderTest {\n    @Test\n    public void encodeTest() {\n        String expected = \"Hello World!\";\n        assertEquals(expected, new String(Encoder.encode(\"Hello World!\")));\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class EncoderTest {\n    @Test\n    public void encodeTest() {\n        int layers = 3;\n        boolean compact = true;\n        String inputString = \"hello\";\n        \n        BitArray messageBits = new HighLevelEncoder().encodeHighLevel(inputString, compact, layers);\n        Encoder encoder = new Encoder();\n        String result = encoder.encode(messageBits, compact, layers);\n        assertEquals(\"Hello\", result);\n    }\n}\n    ",
        "\n    package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class EncoderTest {\n    \n    private static final String MESSAGE = \"ABCD\";\n    private static final int EXPECTED_SIZE = 25;\n    \n    @Test\n    public void testEncode() throws Exception {\n        BitArray encoded = Encoder.encode(MESSAGE);\n        \n        assertEquals(EXPECTED_SIZE, encoded.getSize());\n    }\n}\n",
        "public static BitMatrix encode(String contents) {\n    // Step 1: Convert input string to list of bits\n    boolean compact = false;\n    int layers = 0;\n    BitArray rawBits = new BitArray();\n    for (int i = 0; i < contents.length(); i++) {\n        char c = contents.charAt(i);\n        switch (c) {\n            case '1':\n                rawBits.appendBits(0b000, 3);\n                break;\n            case '2':\n                rawBits.appendBits(0b001, 3);\n                break;\n            // Add cases for other characters here...\n        }\n    }\n\n    // Step 2: Pad the data bits to ensure a multiple of 8 if compact representation is used\n    int rawBytes = (rawBits.getSize() + 7) / 8;\n    if (compact && rawBytes % 4 == 0) {\n        rawBits.appendBits(0b11, 2);\n    } else if (compact && rawBytes % 4 == 1) {\n        rawBits.appendBits(0b10, 2);\n    }\n\n    // Step 3: Apply error correction to the data bits\n    int dataWords = (rawBits.getSize() + 6) / 7;\n    BitArray correctedBits = rawBits.clone();\n    for (int i = 0; i < 4; i++) {\n        ReedSolomonEncoder rs = new ReedSolomonEncoder(GenericGF.AZTEC_PARAM);\n        int[] dataBytes = bitsToBytes(correctedBits, 7, correctedBits.getSize() / 8);\n        rs.encode(dataBytes, dataWords * (compact ? 4 : 2));\n        BitArray encoded = new BitArray();\n        for (int j = 0; j < dataBytes.length; j++) {\n            encoded.appendBits(dataBytes[j], 8);\n        }\n        correctedBits = encoded;\n    }\n\n    // Step 4: Generate the mode message and stuff it into the data bits\n    BitArray modeMessage = generateModeMessage(compact, layers);\n    int startPad = rawBits.getSize() - 8 * (layers + 1) * (layers + 1);\n    int endPad = 0;\n    if (compact && rawBytes % 4 == 0) {\n        endPad = 2;\n    } else if (compact && rawBytes % 4 == 1) {\n        endPad = 4;\n    } else if (!compact && rawBytes % 8 == 0) {\n        endPad = 6;\n    } else if (!compact && rawBytes % 8 == 7) {\n        endPad = 8;\n    }\n    int padLength = startPad + dataWords * (compact ? 4 : 2) + endPad;\n    correctedBits.insert(0, new BitArray(padLength));\n    correctedBits.insert(correctedBits.getSize(), new BitArray(padLength));\n    correctedBits.appendBits(modeMessage);\n\n    // Step 5: Stuff the data bits into the Aztec matrix\n    BitMatrix matrix = new BitMatrix(layers + 1, layers + 1);\n    for (int i = 0; i < layers + 1; i++) {\n        for (int j = 0; j < layers + 1; j++) {\n            int bitIndex = ((j + i) / 2 * layers - 1) / 2 + startPad;\n            if (bitIndex < correctedBits.getSize()) {\n                matrix.set(i, j, correctedBits.get(bitIndex));\n            }\n        }\n    }\n    return matrix;\n}",
        "The Aztec code is a type of 2D barcode that can encode text, numbers and other data. It was designed by Mathematicians in the late 1990s and has since been widely adopted for various applications such as tracking packages, digital money, ID cards, and more.\n\nHere are some key facts about Aztec codes:\n\n* The Aztec code is a self-checking barcode that can detect errors and correct them automatically. This means that the decoding process is robust and reliable, even in low-quality scanning environments.\n* The Aztec code supports both compact and full modes for encoding data. Compact mode encodes 20 to 30 numeric digits per symbol, while full mode can encode up to 140 numeric digits per symbol. Full mode is typically used when the barcode contains a lot of data or when it needs to be readable by hand-held scanners.\n* Aztec codes can be read at any orientation and do not require any alignment with edges. This makes them very versatile for use in various applications, such as packaging, labeling, and inventory management.\n* The Aztec code has a high error correction capability, which means that it can correct up to 30% of damaged data during decoding. This is enough to protect the barcode from most errors caused by environmental factors or human handling.\n\nOverall, the Aztec code is a robust and reliable option for encoding text, numbers, and other data in various applications. Its high error correction capability makes it suitable for use in low-quality scanning environments, while its compact and full modes allow for optimal data density and readability, respectively.",
        "public class Encoder {\n  public BitMatrix encode(String content) {\n    // Create a BitArray to contain the generated message\n    BitArray bitArray = new BitArray();\n    \n    // If the content is in compact mode, generate a special compact mode message\n    if (content.length() > 0 && content.charAt(0) == '!') {\n      bitArray.appendBits(Mode.COMPACT_MODE_MESSAGE.getModeIndicator(), Mode.COMPACT_MODE_MESSAGE.getBits());\n      \n      // Append the compact data string to the message (without the first exclamation point)\n      for (int i = 1; i < content.length(); i++) {\n        int indexInCompactRepresentation = CompactAztecCode.getIndex(content.charAt(i));\n        if (indexInCompactRepresentation >= 0) {\n          bitArray.appendBits(indexInCompactRepresentation, COMPACT_MODE_BITS_PER_CHARACTER);\n        } else {\n          throw new IllegalArgumentException(\"Bad character in compact mode string\");\n        }\n      }\n    } else {\n      // Create a full symbol with the provided content and return it.\n      return generateSymbol(content, false).getMatrix();\n    }\n    \n    // If we are generating a compact symbol, place the resulting message into a BitMatrix\n    if (compact) {\n      int matrixSize = ((80 + 16 * layers) * layers) / 8;\n      BitMatrix matrix = new BitMatrix(matrixSize);\n      \n      // Place the mode message into the top-left corner of the symbol\n      for (int y = 0; y < 4 && y < matrix.getHeight(); y++) {\n        for (int x = 0; x < 4 && x < matrix.getWidth(); x++) {\n          if ((modeMessage & 1) == 1) {\n            matrix.set(x, y);\n          }\n          modeMessage >>= 1;\n        }\n      }\n      \n      // Place the compact data string into the symbol\n      for (int i = 0; i < content.length(); i++) {\n        int indexInCompactRepresentation = CompactAztecCode.getIndex(content.charAt(i));\n        if (indexInCompactRepresentation >= 0) {\n          matrix.setBulk(12 + i * 3, 4, CompactAztecCode.CHARACTER_ENCODINGS[indexInCompactRepresentation]);\n        } else {\n          throw new IllegalArgumentException(\"Bad character in compact mode string\");\n        }\n      }\n      \n      return matrix;\n    }\n  }\n}",
        "java\npackage com.google.zxing.aztec.encoder;\n\nimport java.util.Arrays;\n\npublic final class Encoder {\n  private static int[] ALPHANUMERIC_TABLE = new int[128];\n\n  // The LSB (bottom) is the \"most significant\" symbol in this encoding scheme, which is why we\n  // don't use a lookup table of symbol names.\n  private static final int SHIFT3_SET = 0x1;\n  private static final int LATCH_TO_LOWERCASE = 0x2;\n  private static final int SHIFT2_SET = 0x4;\n  private static final int PAD_ENCODE = 0x8;\n  private static final int BITS_IN_HALF_BYTE = 4;\n\n  static {\n    for (int i = 0; i < ALPHANUMERIC_TABLE.length; i++) {\n      ALPHANUMERIC_TABLE[i] = -1;\n    }\n    for (int i = 32; i <= 95; ++i) {\n      // Skip characters not in the tables to support full ASCII subset as specified in ISO/IEC 24778:2008.\n      ALPHANUMERIC_TABLE[i] = i - 32;\n    }\n    for (int i = 96, j = 0; i < 107; ++i, j += 2) {\n      ALPHANUMERIC_TABLE[i] = j; // Numbers use ASCII digits as a substrate.\n    }\n    ALPHANUMERIC_TABLE[43] = 10; // - -> dash\n    ALPHANUMERIC_TABLE[45] = 11; // . -> full stop\n    ALPHANUMERIC_TABLE[61] = 12; // , -> comma\n    ALPHANUMERIC_TABLE[63] = 13; // ? -> inverted question mark.\n    ALPHANUMERIC_TABLE[64] = 0; // @ -> 00\n    for (int i = 91; i < 97; ++i) {\n      ALPHANUMERIC_TABLE[i] = i - 32;\n    }\n  }\n\n  /**\n   * Encodes an Aztec code represented as a list of boolean arrays (as returned by\n   * {@link Writer#encode}) into a byte array.\n   */\n  public static void encodeToBytes(Iterable<boolean[]> encoded, int ecLevel, ByteArrayOutputStream output) {\n    BitArray bits = new BitArray();\n    for (boolean[] boolArr : encoded) {\n      bits.appendBools(boolArr);\n    }\n    byte[] bytes = encodeToByteArray(bits, ecLevel);\n  }\n\n  /**\n   * Encodes an Aztec code represented as a list of boolean arrays (as returned by\n   * {@link Writer#encode}) into a byte array.\n   */\n  public static byte[] encodeToByteArray(Iterable<boolean[]> encoded, int ecLevel) {\n    BitArray bits = new BitArray();\n    for (boolean[] boolArr : encoded) {\n      bits.appendBools(boolArr);\n    }\n    return encodeToByteArray(bits, ecLevel);\n  }\n\n  public static byte[] encodeToByteArray(BitArray bits, int ecLevel) {\n    boolean compact = (ecLevel < 2); // Latch to compact mode.\n    if (!compact && (ecLevel != 0)) {\n      throw new IllegalArgumentException(\"Invalid error correction level: \" + ecLevel);\n    }\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    encode(bits, ecLevel, compact, outputStream);\n    return outputStream.toByteArray();\n  }\n\n  public static void encode(BitArray bits, int ecLevel, boolean compact, OutputStream output) {\n    // Compute the number of data codewords and padding code words we will need in\n    // each layer. Store the result for use below.\n    int totalInputCodeWords = bits.getSizeInWords();\n    if (compact) {\n      // compact mode has a fixed size of 25x25, so only one layer is needed.\n      int totalOutputCodeWords = 25;\n      outputLayer(bits, ecLevel, 0, 0, compact, totalInputCodeWords, totalOutputCodeWords, output);\n    } else { // normal (non-compact) mode.\n      // The lowest layer uses the provided error correction level. Otherwise, we will use\n      // a default error correction level of 3. This allows values of up to 6 to be passed into\n      // the encoder.\n      int defaultEcLevel = ecLevel == 0 ? 3 : ecLevel;\n      int totalCodeWords = (totalInputCodeWords + 2) / 3;\n      for (int i = 0; i < defaultEcLevel; ++i) {\n        int remainder = totalCodeWords % 3;\n        int thisLayerECLevel = remainder == 0 ? 0 : (3 - remainder);\n        outputLayer(bits, ecLevel, i, thisLayerECLevel, compact, totalInputCodeWords, totalCodeWords, output);\n      }\n    }\n  }\n\n  private static void outputLayer(BitArray bits, int ecLevel, int layerNumber, int layerEcLevel, boolean compact, int totalInputCodeWords, int totalOutputCodeWords, OutputStream output) {\n    // How many bits are in use in the layers we've already output?\n    long alreadyOutputBits = (layerNumber == 0 ? 0 : (long) Math.pow(3, layerNumber)) * totalInputCodeWords;\n    int remainingTotalCodeWords = (int) ((totalInputCodeWords + 2) / 3 - alreadyOutputBits); // The \"-2\" is for the mode shift that occurs in the last data chunk.\n    byte[] rawCodewords = bitsToRawCodewords(bits, totalInputCodeWords, alreadyOutputBits);\n\n    int wordCount = (rawCodewords.length + 2) / 3;\n    // The padding is initially created as all-zero bytes.\n    byte[] codewordBytesWithPadding = Arrays.copyOf(rawCodewords, rawCodewords.length + remainingTotalCodeWords * 3);\n\n    // Add the mode message. The mode message consists of a single data chunk with the most significant\n    // 4 bits set to the mode value. See table 2 in ISO/IEC 24728:2013 for mode values. Page 7 is a detailed explanation.\n    int modeMessageBits = (compact ? 0x9 : 0x8);\n    modeMessageBits |= layerEcLevel & 0xf;\n    codewordBytesWithPadding[codewordBytesWithPadding.length - 1] = (byte) (modeMessageBits >> BITS_IN_HALF_BYTE);\n    // Add the error correction chunk. All data chunks in a Aztec symbol have an error correction chunk immediately after them. This is why we use\n    // 'remainingTotalCodeWords - 1' above, to leave room for the mode message. See table 2 in ISO/IEC 24728:2013 for mode values. Page 7 is a detailed explanation.\n    byte[] errorCorrectionChunkBytes = new byte[remainingTotalCodeWords * 3];\n    codewordBytesWithPadding[codewordBytesWithPadding.length - remainingTotalCodeWords * 3 - 1] = errorCorrectionChunkBytes;\n    // Write the layer. All data chunks in a Aztec symbol have an error correction chunk immediately after them. This is why we use\n    // 'remainingTotalCodeWords - 1' above, to leave room for the mode message. See table 2 in ISO/IEC 24728:2013 for mode values. Page 7 is a detailed explanation.\n    output.write(codewordBytesWithPadding);\n\n    // Compute how many bits are left to write, after writing this layer.\n    int remainingBits = totalInputCodeWords * 3 - alreadyOutputBits;\n    // If there are no more bits to be written, the work here is done.\n    if (remainingBits == 0) {\n      return;\n    } else if (layerNumber != defaultEcLevel) { // Otherwise, we will have more bit layers to output.\n      int totalRemainingCodeWords = remainingTotalCodeWords - wordCount;\n      encode(bits, ecLevel, compact, totalInputCodeWords, totalRemainingCodeWords, layerNumber + 1, output);\n    } else { // Otherwise, we are in the final layer. So all that is left to be written are error correction chunks.\n      for (int i = wordCount; i < codewordBytesWithPadding.length / 3 * 3; ++i) {\n        codewordBytesWithPadding[codewordBytesWithPadding.length - i * 3 - 1] = (byte) 0x80; // Initialize the rest of the array with all-zero bytes. This is important, because the all-zero padding bytes are used to indicate when an error correction chunk should be processed or not.\n      }\n      output.write(codewordBytesWithPadding);\n    }\n  }\n\n  private static byte[] bitsToRawCodewords(BitArray bits, int totalInputCodeWords, long alreadyOutputBits) {\n    byte[] rawCodewords = new byte[totalInputCodeWords * 3]; // Initialize the array to be of the correct size. We will output a raw code word for each group of three bits in the input BitArray.\n    int bitOffset = (int) (alreadyOutputBits / 3);\n    for (int i = 0; i < totalInputCodeWords * 3; ++i, bitOffset += 3) {\n      long tripletBitValue = bits.getBits(bitOffset, 3); // Get the next group of three input bits as a number.\n      if ((tripletBitValue & (0x80)) == 0 && (i + alreadyOutputBits) % 3 != 0) { // If this is not the final chunk and it's not all zeroes, then:\n        rawCodewords[rawCodewords.length - i * 3 - 1] = (byte) ((tripletBitValue & (0x7F)) >> BITS_IN_HALF_BYTE); // Then store the lower seven bits of this group of three input bits as a number in the next available byte in the array.\n      } else {\n        rawCodewords[rawCodewords.length - i * 3 - 1] = (byte) (tripletBitValue >> BITS_IN_HALF_BYTE); // Otherwise, if this is all zeroes or it's the final chunk, then store all eight bits of this group of three input bits as a number in the next available byte in the array.\n      }\n    }\n    return rawCodewords;\n  }\n}\n\\end{code}",
        "// TODO\n   ",
        "java\npublic final class AztecEncoder {\n  private static final int DEFAULT_ECC_PERCENT = 33; // 33%\n\n  private static void assertNoBadBits(BitArray bits, BitMatrix matrix) {\n    for (int i = 0; i < matrix.getHeight(); i++) {\n      if (!isValidRow(matrix, i)) {\n        throw new IllegalArgumentException(\"Not all cells in the last row are valid\");\n      }\n    }\n    for (int i = 0; i < matrix.getWidth() - 1; i++) {\n      if (!isValidColumn(matrix, i)) {\n        throw new IllegalArgumentException(\"Not all cells in the last column are valid\");\n      }\n    }\n    // Check the bottom-right cell\n    if (matrix.get(matrix.getWidth() - 1, matrix.getHeight() - 1) != bits.get(bits.getSize() - 1)) {\n      throw new IllegalArgumentException(\"Corner cell is not valid\");\n    }\n  }\n\n  private static void assertNoHorizontalDrift(BitMatrix matrix) {\n    for (int i = 0; i < matrix.getHeight(); i++) {\n      int minX = Integer.MAX_VALUE, maxX = -1;\n      for (int j = 0; j < matrix.getWidth() && matrix.get(j, i); j++) {\n        minX = Math.min(minX, j);\n        maxX = Math.max(maxX, j);\n      }\n      if (minX == Integer.MAX_VALUE) continue; // Skip empty rows\n      if (minX != 0 && matrix.get(minX - 1, i)) {\n        throw new IllegalArgumentException(\"There is a black module in the corner of a white square\");\n      } else if ((maxX + 1) < matrix.getWidth() && matrix.get(maxX + 1, i)) {\n        throw new IllegalArgumentException(\"There is a black module in the corner of a white square\");\n      }\n    }\n  }\n\n  private static void assertNoVerticalDrift(BitMatrix matrix) {\n    for (int i = 0; i < matrix.getWidth(); i++) {\n      int minY = Integer.MAX_VALUE, maxY = -1;\n      for (int j = 0; j < matrix.getHeight() && matrix.get(i, j); j++) {\n        minY = Math.min(minY, j);\n        maxY = Math.max(maxY, j);\n      }\n      if (minY == Integer.MAX_VALUE) continue; // Skip empty rows\n      if (minY != 0 && matrix.get(i, minY - 1)) {\n        throw new IllegalArgumentException(\"There is a black module in the corner of a white square\");\n      } else if ((maxY + 1) < matrix.getHeight() && matrix.get(i, maxY + 1))) {\n        throw new IllegalArgumentException(\"There is a black module in the corner of a white square\");\n      }\n    }\n  }\n\n  private static void assertNoSquares(BitMatrix matrix) {\n    for (int i = 0; i < matrix.getHeight(); i += 2) {\n      for (int j = 0; j < matrix.getWidth() - 1; j += 2) {\n        if (!matrix.get(j, i)) continue;\n        // Found upper-left square. Search adjacent squares to make sure there is no black module in the corner of a white square.\n        for (int k = i + 1; k < matrix.getHeight(); k++) {\n          if (matrix.get(j + 1, k)) break;\n          if (k == matrix.getHeight() - 1) {\n            throw new IllegalArgumentException(\"There is a black module in the corner of a white square\");\n          }\n        }\n        for (int k = j + 1; k < matrix.getWidth(); k++) {\n          if (matrix.get(k, i)) break;\n          if (k == matrix.getWidth() - 1) {\n            throw new IllegalArgumentException(\"There is a black module in the corner of a white square\");\n          }\n        }\n      }\n    }\n  }\n\n  private static void assertNoInconsistentBlackSquares(BitMatrix matrix) {\n    int maxWidth = (matrix.getWidth() + 1) / 2 * 2; // round up to nearest even number\n    for (int i = 0; i < matrix.getHeight(); i++) {\n      boolean isBlackRow = false;\n      for (int j = 0; j < matrix.getWidth(); j++) {\n        if (!matrix.get(j, i)) break; // Found a white module, so stop checking this row.\n        }\n        if (j == maxWidth) isBlackRow = true;\n      }\n      if (isBlackRow) continue; // Skip rows that are entirely composed of black modules.\n      for (int j = 0; j < matrix.getHeight(); j++) {\n        if (!matrix.get(j, i)) break; // Found a white module, so stop checking this row.\n        }\n        throw new IllegalArgumentException(\"There is an inconsistent black square\");\n      }\n    }\n  }\n\n  private static void assertNoInconsistentBlackSquares(BitMatrix matrix) {\n    for (int j = 0; j < matrix.getWidth(); j++) {\n      boolean isBlackColumn = false;\n      for (int i = 0; i < matrix.getHeight(); i++) {\n        if (!matrix.get(j, i)) break; // Found a white module, so stop checking this column.\n        }\n        if (i == matrix.getHeight() - 1) isBlackColumn = true;\n      }\n      if (isBlackColumn) continue; // Skip columns that are entirely composed of black modules.\n      for (int i = 0; i < matrix.getHeight(); i++) {\n        if (!matrix.get(j, i)) break; // Found a white module, so stop checking this column.\n        }\n        throw new IllegalArgumentException(\"There is an inconsistent black square\");\n      }\n    }\n  }\n\n  private static void assertNoSquares(BitMatrix matrix) {\n    for (int i = 0; i < matrix.getHeight(); i += 2) {\n      int minX = Integer.MAX_VALUE, maxX = -1;\n      boolean firstRowFound = false;\n      for (int j = 0; j < matrix.getWidth() && matrix.get(j, i); j++) {\n        if (!firstRowFound) {\n          firstRowFound = true;\n          continue; // Don't check this row until we find at least one white module.\n        }\n        minX = Math.min(minX, j);\n        maxX = Math.max(maxX, j);\n      }\n      if (!firstRowFound) {\n        firstRowFound = true; // Don't check this row until we find at least one white module.\n        continue; // Skip rows that are entirely composed of black modules.\n      }\n      for (int k = i + 1; k < matrix.getHeight(); k++) {\n        if (!matrix.get(j, k)) break;\n        minX = Math.min(minX, j);\n        maxX = Math.max(maxX, j);\n      }\n    }\n    for (int i = 0; i < matrix.getHeight(); i++) {\n      if (!matrix.get(i, i)) continue; // Skip rows that are entirely composed of black modules.\n      int minX = Integer.MAX_VALUE, maxX = -1;\n      for (int j = i + 1; j < matrix.getWidth(); j++) {\n        if (!matrix.get(j, i)) break; // Found a white module, so stop checking this row.\n        minX = Math.min(minX, j);\n        maxX = Math.max(maxX, j);\n      }\n    }\n  }\n}"
    ]
}