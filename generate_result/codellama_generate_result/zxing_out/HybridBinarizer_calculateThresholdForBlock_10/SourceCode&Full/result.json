{
    "project_name": "zxing",
    "file_name": "HybridBinarizer.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/HybridBinarizer.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.common",
    "docstring": "/**\n   * For each block in the image, calculate the average black point using a 5x5 grid\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n   * on the last pixels in the row/column which are also used in the previous block).\n   */",
    "source_code": "\nprivate static void calculateThresholdForBlock(byte[] luminances,\n                                               int subWidth,\n                                               int subHeight,\n                                               int width,\n                                               int height,\n                                               int[][] blackPoints,\n                                               BitMatrix matrix) {\n  int maxYOffset = height - BLOCK_SIZE;\n  int maxXOffset = width - BLOCK_SIZE;\n  for (int y = 0; y < subHeight; y++) {\n    int yoffset = y << BLOCK_SIZE_POWER;\n    if (yoffset > maxYOffset) {\n      yoffset = maxYOffset;\n    }\n    int top = cap(y, subHeight - 3);\n    for (int x = 0; x < subWidth; x++) {\n      int xoffset = x << BLOCK_SIZE_POWER;\n      if (xoffset > maxXOffset) {\n        xoffset = maxXOffset;\n      }\n      int left = cap(x, subWidth - 3);\n      int sum = 0;\n      for (int z = -2; z <= 2; z++) {\n        int[] blackRow = blackPoints[top + z];\n        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n      }\n      int average = sum / 25;\n      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n    }\n  }\n}\n",
    "class_name": "HybridBinarizer",
    "method_name": "calculateThresholdForBlock",
    "arguments": [
        "byte[] luminances",
        "int subWidth",
        "int subHeight",
        "int width",
        "int height",
        "int[][] blackPoints",
        "BitMatrix matrix"
    ],
    "generate_test": [
        "package com.google.zxing;\n\nimport org.junit.jupiter.api.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[5 * 5];\n        for (int y = 0; y < 5; y++) {\n            for (int x = 0; x < 5; x++) {\n                luminances[(y * 5) + x] = (byte) ((x % 2 == 0 ? 1 : -1) * (y % 3 == 0 ? 1 : -1));\n            }\n        }\n        \n        HybridBinarizer binarizer = new HybridBinarizer(new GlobalHistogramBinarizer(luminances, 5, 5));\n        int threshold = binarizer.calculateThresholdForBlock(0, 0, luminances);\n    \n        assertEquals(128, threshold);\n    }\n}",
        "package com.google.zxing.common;\nimport java.util.Arrays;\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[25];\n        Arrays.fill(luminances, (byte)0xFF);\n        assertEquals(0, HybridBinarizer.calculateThresholdForBlock(luminances, 1, 3), \"All white\");\n    }\n}",
        "package com.google.zxing;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.FileOutputStream;\n\n/**\n * This class is used to perform binarization of images based on the Hybrid binarization algorithm\n */\npublic final class HybridBinarizer extends Binarizer {\n    private static final int PIXEL_GRAY_LEVEL = 0xFF;\n\n    public HybridBinarizer(BufferedImage image) {\n        super(image);\n    }\n\n    @Override\n    public BitMatrix toBinary() {\n        // Get the BufferedImage matrix as an array of ints\n        var luminances = new int[width * height];\n        var pixelReader = image.getData().getPixelReader();\n        for (var y = 0; y < height; y++) {\n            for (var x = 0; x < width; x++) {\n                // Use the setRGB function to extract the luminance from the RGB pixels and store it in the array\n                var pixelColor = pixelReader.getArgb(x, y);\n                var grayLevel = (int) ((pixelColor >> 16 & 0xFF) * 0.299 + (pixelColor >> 8 & 0xFF) * 0.587 + (pixelColor & 0xFF) * 0.114);\n                luminances[y * width + x] = grayLevel;\n            }\n        }\n\n        var blackPoints = calculateThresholdForBlock(luminances, subWidth, subHeight, width, height);\n        var matrix = new BitMatrix(width, height);\n\n        // Iterate through the luminance values and assign a bit value for each pixel based on whether it is above or below the calculated threshold\n        for (var y = 0; y < height; y++) {\n            for (var x = 0; x < width; x++) {\n                if ((luminances[y * width + x] & 0xFF) <= blackPoints[y / BLOCK_SIZE][x / BLOCK_SIZE]) {\n                    matrix.set(x, y);\n                }\n            }\n        }\n\n        return matrix;\n    }\n\n    /**\n     * Calculates a single threshold for a block of pixels based on the Hybrid binarization algorithm\n     */\n    private static int[] calculateThresholdForBlock(int[] luminances,\n                                                    int subWidth,\n                                                    int subHeight,\n                                                    int width,\n                                                    int height) {\n        var maxYOffset = height - BLOCK_SIZE;\n        var maxXOffset = width - BLOCK_SIZE;\n        var blackPoints = new int[subHeight][subWidth];\n        for (var y = 0; y < subHeight; y++) {\n            var yoffset = y << BLOCK_SIZE_POWER;\n            if (yoffset > maxYOffset) {\n                continue;\n            }\n\n            for (var x = 0; x < subWidth; x++) {\n                var xoffset = x << BLOCK_SIZE_POWER;\n                if (xoffset > maxXOffset) {\n                    break;\n                }\n\n                var sum = 0;\n                var numSamples = 0;\n                for (var iy = yoffset; iy < yoffset + BLOCK_SIZE && iy < height - 1; iy++) {\n                    if ((iy & 1) == 0) {\n                        // Every second line, sample the luminance value and add to sum\n                        for (var ix = xoffset; ix < xoffset + BLOCK_SIZE && ix < width - 1; ix++) {\n                            if ((ix & 1) == 0) {\n                                // Add the luminance value to sum and increment numSamples\n                                sum += (luminances[iy * width + ix] & PIXEL_GRAY_LEVEL);\n                                numSamples++;\n                            }\n                        }\n                    } else {\n                        // Sample the luminance value and add to sum without incrementing numSamples\n                        for (var ix = xoffset; ix < xoffset + BLOCK_SIZE && ix < width - 1; ix++) {\n                            if ((ix & 1) == 0) {\n                                // Add the luminance value to sum\n                                sum += (luminances[iy * width + ix] & PIXEL_GRAY_LEVEL);\n                            }\n                        }\n                    }\n                }\n\n                var average = sum / numSamples;\n\n                // Calculate the threshold value using the average luminance value\n                blackPoints[y][x] = calculateThreshold(average, 250);\n            }\n        }\n\n        return blackPoints;\n    }\n\n    /**\n     * Calculates a single threshold value based on the input parameters\n     */\n    private static int calculateThreshold(int averageLuminanceValue, int minThreshold) {\n        var threshold = (averageLuminanceValue >> 8); // shift right 8 bits to divide by 256\n        if (threshold < minThreshold) {\n            threshold = minThreshold;\n        } else if (threshold > MAX_THRESHOLD) {\n            threshold = MAX_THRESHOLD;\n        }\n\n        return threshold;\n    }\n}",
        "\npublic static int calculateThresholdForBlock(byte[] luminances,\n                                             int xoffset,\n                                             int yoffset,\n                                             BitMatrix matrix) {\n    // Calculate the sum of the pixels in the 3x3 area around this pixel.\n    int sum = 0;\n    for (int dy = -1; dy <= 1; dy++) {\n        int iy = yoffset + dy;\n        if (iy < 0 || iy >= matrix.getHeight()) {\n            continue;\n        }\n        for (int dx = -1; dx <= 1; dx++) {\n            int ix = xoffset + dx;\n            if (ix < 0 || ix >= matrix.getWidth()) {\n                continue;\n            }\n            sum += luminances[iy * matrix.getWidth() + ix];\n        }\n    }\n    \n    // Calculate the average and standard deviation of the pixel values in this block.\n    int average = sum / 9;\n    int stDev = (int) Math.sqrt((sum - 9 * average) / 81);\n    \n    // The threshold for a block is based on the average, plus or minus three times the standard\n    // deviation. This is needed to catch 1D barcodes that do not have well-defined black and white\n    // pixels. See JIRA issue ZXING-324 for details.\n    return average + (stDev * 3);\n}\n",
        "import org.junit.jupiter.api.*;\n\nclass HybridBinarizerTest {\n  @Test\n  public void calculateThresholdForBlock() {\n    int[] luminances = new int[10]; // Initialize with your test values\n    int xoffset = 0; // Set to the horizontal coordinate of the block in the image\n    int yoffset = 0; // Set to the vertical coordinate of the block in the image\n    int width = 10; // Set to the width of the image\n    int height = 5; // Set to the height of the image\n    \n    int[] expectedThreshold = new int[2]; // Initialize with your expected output\n    \n    int[] actualThreshold = HybridBinarizer.calculateThresholdForBlock(luminances, xoffset, yoffset, width, height);\n    Assertions.assertArrayEquals(expectedThreshold, actualThreshold);\n  }\n}",
        "\n\npackage com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        HybridBinarizer binarizer = new HybridBinarizer(null);\n        int width = 20;\n        int height = 15;\n        byte[] matrix = {<FILL>};\n        int subWidth = width / BLOCK_SIZE;\n        int subHeight = height / BLOCK_SIZE;\n        int top = 0;\n        int left = 0;\n        int bottom = (subHeight * BLOCK_SIZE) + 1;\n        int right = (subWidth * BLOCK_SIZE) + 1;\n        int matrixY = height - 1;\n        int matrixX = width - 1;\n        \n        // Test case 1: top-left corner, white block\n        for (int y = 0; y < BLOCK_SIZE; y++) {\n            for (int x = 0; x < BLOCK_SIZE; x++) {\n                matrix[y * width + x] = 255; // Fill top-left corner with white pixels\n            }\n        }\n        \n        int threshold = binarizer.calculateThresholdForBlock(matrix, subWidth, subHeight, left, right, top, bottom, matrixY, matrixX);\n        assertEquals(255, threshold); // Expected: White block with highest luminance value 255\n        \n        // Test case 2: middle of image, black block\n        for (int y = 0; y < BLOCK_SIZE; y++) {\n            for (int x = 0; x < BLOCK_SIZE; x++) {\n                matrix[y * width + x] = 0; // Fill middle with black pixels\n            }\n        }\n        \n        threshold = binarizer.calculateThresholdForBlock(matrix, subWidth, subHeight, left, right, top, bottom, matrixY, matrixX);\n        assertEquals(0, threshold); // Expected: Black block with lowest luminance value 0\n    }\n}",
        "package com.google.zxing.common;\n\nimport java.util.Arrays;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    private HybridBinarizer binarizer = new HybridBinarizer(null);\n    \n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] matrix = new byte[25];\n        Arrays.fill(matrix, (byte) 100);\n        assertEquals(100, binarizer.calculateThresholdForBlock(matrix, 0, 0));\n        \n        matrix = new byte[] { 1 };\n        assertEquals(1, binarizer.calculateThresholdForBlock(matrix, 0, 0));\n    }\n}",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\n\npublic class HybridBinarizerTest {\n\n  @Test\n  public void calculateThresholdForBlockTest() {\n    byte[] luminances = new byte[256]; // 1 byte per pixel\n    int subWidth = 10;   // Number of pixels in a block horizontally.\n    int subHeight = 10;  // Number of pixels in a block vertically.\n    int width = 100;     // Total number of pixels in the image.\n    int height = 100;    // Total number of pixels in the image.\n\n    HybridBinarizer binarizer = new HybridBinarizer(luminances);\n    int[][] blackPoints = binarizer.calculateBlackPoints(subWidth, subHeight, width, height);\n\n    assertEquals(10, blackPoints.length); // Number of blocks vertically.\n    for (int y = 0; y < blackPoints.length; y++) {\n      assertEquals(10, blackPoints[y].length); // Number of blocks horizontally.\n    }\n\n    int[] histogram = new int[256]; // 256 possible pixel values.\n    for (int i = 0; i < luminances.length; i++) {\n      histogram[luminances[i] & 0xFF]++;\n    }\n\n    int average = calculateAverage(histogram); // Average of all pixel values in the image.\n    for (int y = 0; y < blackPoints.length; y++) {\n      for (int x = 0; x < blackPoints[y].length; x++) {\n        int threshold = binarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, x, y);\n        assertTrue(threshold > average / 2 && threshold < average * 2); // Threshold should be close to the average of all pixel values in the image.\n      }\n    }\n  }\n}",
        "<#assign threshold = 255 - (2 * average) + min>\nreturn cap(${threshold}, max);\n",
        "package com.google.zxing;\n\nimport java.nio.charset.StandardCharsets;\n\n/**\n * Common string-related functions.\n */\npublic final class StringUtils {\n\n  private static final String SHIFT_JIS_CHARSET = \"SJIS\";\n  private static final String EUC_JP_CHARSET = \"EUC_JP\";\n\n  /**\n   * See \"Character Set Identification\" by David Morton:\n   * http://www.autosoftpro.com/cBloGS/blog/post/2007/10/Character-Set-Identification.aspx\n   */\n  public static String guessEncoding(byte[] bytes) {\n    // First two bytes should be ASCII, which encodes to ISO-8859-1. Check if this is true, and if\n    // the characters are within a valid ASCII range.\n    if (bytes[0] < 0x20 || bytes[0] > 0x7F) {\n      return null;\n    }\n    int length = bytes.length;\n    for (int i = 1; i < length && i <= 5 && bytes[i] >= 0; i++) {\n      if ((bytes[i] & 0x80) != 0) { // not ASCII\n        return SHIFT_JIS_CHARSET;\n      } else if (bytes[i] < 0x20 || bytes[i] > 0x7F) {\n        break;\n      }\n    }\n    int lengthMinusOne = length - 1;\n    for (int i = 1; i < lengthMinusOne && i <= 3 && bytes[i] >= 0; i++) {\n      if ((bytes[i] & 0x80) != 0 || (bytes[i + 1] & 0x80) != 0) { // not ASCII\n        return EUC_JP_CHARSET;\n      } else if (bytes[i] < 0x20 || bytes[i] > 0x7F) {\n        break;\n      }\n    }\n    return StandardCharsets.ISO_8859_1;\n  }\n}"
    ]
}