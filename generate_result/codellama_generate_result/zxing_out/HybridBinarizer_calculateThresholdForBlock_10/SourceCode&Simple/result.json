{
    "project_name": "zxing",
    "file_name": "HybridBinarizer.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/HybridBinarizer.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.common",
    "docstring": "/**\n   * For each block in the image, calculate the average black point using a 5x5 grid\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n   * on the last pixels in the row/column which are also used in the previous block).\n   */",
    "source_code": "\nprivate static void calculateThresholdForBlock(byte[] luminances,\n                                               int subWidth,\n                                               int subHeight,\n                                               int width,\n                                               int height,\n                                               int[][] blackPoints,\n                                               BitMatrix matrix) {\n  int maxYOffset = height - BLOCK_SIZE;\n  int maxXOffset = width - BLOCK_SIZE;\n  for (int y = 0; y < subHeight; y++) {\n    int yoffset = y << BLOCK_SIZE_POWER;\n    if (yoffset > maxYOffset) {\n      yoffset = maxYOffset;\n    }\n    int top = cap(y, subHeight - 3);\n    for (int x = 0; x < subWidth; x++) {\n      int xoffset = x << BLOCK_SIZE_POWER;\n      if (xoffset > maxXOffset) {\n        xoffset = maxXOffset;\n      }\n      int left = cap(x, subWidth - 3);\n      int sum = 0;\n      for (int z = -2; z <= 2; z++) {\n        int[] blackRow = blackPoints[top + z];\n        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n      }\n      int average = sum / 25;\n      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n    }\n  }\n}\n",
    "class_name": "HybridBinarizer",
    "method_name": "calculateThresholdForBlock",
    "arguments": [
        "byte[] luminances",
        "int subWidth",
        "int subHeight",
        "int width",
        "int height",
        "int[][] blackPoints",
        "BitMatrix matrix"
    ],
    "generate_test": [
        "private static int calculateThresholdForBlock(byte[] luminances, int subWidth, int subHeight, int width, int height, int[][] blackPoints, BitMatrix matrix) {\n    int maxYOffset = height - BLOCK_SIZE;\n    int maxXOffset = width - BLOCK_SIZE;\n    for (int y = 0; y < subHeight; y++) {\n        int yoffset = y << BLOCK_SIZE_POWER;\n        if (yoffset > maxYOffset) {\n            yoffset = maxYOffset;\n        }\n        int top = cap(y, subHeight - 3);\n        for (int x = 0; x < subWidth; x++) {\n            int xoffset = x << BLOCK_SIZE_POWER;\n            if (xoffset > maxXOffset) {\n                xoffset = maxXOffset;\n            }\n            int left = cap(x, subWidth - 3);\n            int sum = 0;\n            for (int z = -2; z <= 2; z++) {\n                int[] blackRow = blackPoints[top + z];\n                sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n            }\n            int average = sum / 25;\n            thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n        }\n    }\n}",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Set up test data\n        byte[] luminances = new byte[256];\n        int subWidth = 10;\n        int subHeight = 8;\n        int width = 32;\n        int height = 24;\n        int[][] blackPoints = calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n        BitMatrix matrix = new BitMatrix(width, height);\n        \n        // Set up expected output\n        int maxYOffset = height - BLOCK_SIZE;\n        int maxXOffset = width - BLOCK_SIZE;\n        int sum = 0;\n        for (int z = -2; z <= 2; z++) {\n            int[] blackRow = blackPoints[cap(y, subHeight - 3)];\n            sum += blackRow[cap(x, subWidth - 3) + 1] + blackRow[cap(x, subWidth - 3)] + blackRow[cap(x, subWidth - 3) - 1];\n        }\n        int average = sum / 25;\n        \n        // Perform test\n        int threshold = calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n        \n        // Check output\n        assertEquals(average, threshold);\n    }\n}",
        "\npackage com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Create a mock luminance source with known values\n        LuminanceSource source = new MockLuminanceSource(new byte[] { 1, 2, 3 });\n        HybridBinarizer binarizer = new HybridBinarizer(source);\n\n        // Set up the test data\n        int subWidth = 1;\n        int subHeight = 2;\n        int width = 4;\n        int height = 6;\n        int[][] blackPoints = { { 0, 0 }, { 1, 2 }, { 3, 4 } };\n        BitMatrix matrix = new BitMatrix(width, height);\n\n        // Call the method under test\n        binarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n\n        // Verify that the threshold was calculated correctly\n        assertEquals(12, matrix.get(0, 0));\n    }\n}\n",
        "@Test\npublic void calculateThresholdForBlockTest() {\n    byte[] luminances = new byte[256];\n    int subWidth = 4;\n    int subHeight = 4;\n    int width = 16;\n    int height = 16;\n    int[][] blackPoints = calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n    BitMatrix matrix = new BitMatrix(width, height);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            blackPoints[i][j] = 128;\n        }\n    }\n    calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            int threshold = calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n            assertEquals(128, threshold);\n        }\n    }\n}",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Arrange\n        byte[] luminances = new byte[10];\n        int subWidth = 2;\n        int subHeight = 3;\n        int width = 5;\n        int height = 4;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        BitMatrix matrix = new BitMatrix(width, height);\n        \n        // Act\n        HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n        \n        // Assert\n        assertEquals(10, matrix.getWidth());\n        assertEquals(4, matrix.getHeight());\n    }\n}",
        "@Test\npublic void calculateThresholdForBlockTest() {\n    int[][] blackPoints = new int[4][5];\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 5; j++) {\n            blackPoints[i][j] = 128;\n        }\n    }\n\n    byte[] luminances = new byte[16];\n    Arrays.fill(luminances, (byte) 0xFF);\n\n    int width = 4;\n    int height = 4;\n\n    BitMatrix matrix = new BitMatrix(width, height);\n\n    HybridBinarizer.calculateThresholdForBlock(luminances, 2, 2, width, height, blackPoints, matrix);\n\n    assertEquals(matrix.get(0, 0), true);\n    assertEquals(matrix.get(0, 1), false);\n    assertEquals(matrix.get(1, 0), false);\n    assertEquals(matrix.get(1, 1), true);\n}",
        "The `calculateThresholdForBlock` method is called by the `HybridBinarizer` class to determine the threshold value for a block of pixels. The method takes in a 2D array of luminance values, as well as other parameters related to the size and position of the block within the image.\n\nThe method first computes the maximum y offset based on the height parameter, and then iterates over each row in the block using a for loop. For each row, it computes the y offset based on the current row number and the block size power. If the computed y offset is greater than the maximum y offset, it sets it to the maximum y offset.\n\nNext, the method iterates over each column in the block using another for loop. For each column, it computes the x offset based on the current column number and the block size power. If the computed x offset is greater than the maximum x offset, it sets it to the maximum x offset.\n\nThe method then calculates the sum of the luminance values in a 5x5 window around each pixel in the block using a nested for loop. It first initializes an array of 10 elements to store the luminance values in the horizontal direction, and then iterates over each row in the window using another for loop. For each row, it computes the luminance value at that position by adding up the values of the pixels in that row.\n\nFinally, the method calculates the average luminance value for the block using the `calculateAverage` method and the sum of the luminance values. It then calls the `thresholdBlock` method to apply the threshold value to the block.\n\nOverall, this method is used to determine the threshold value for a block of pixels in an image, which is necessary for binary image processing tasks such as barcode scanning.",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[25];\n        int subWidth = 3;\n        int subHeight = 4;\n        int width = 10;\n        int height = 8;\n        int[][] blackPoints = calculateBlackPoints(luminances, subWidth, subHeight, width, height);\n        BitMatrix matrix = new BitMatrix(width, height);\n        \n        // Test for normal case with no offset\n        assertEquals(375, calculateThresholdForBlock(luminances, 0, 0, subWidth, subHeight, blackPoints, matrix));\n        \n        // Test for case with x-axis offset\n        assertEquals(294, calculateThresholdForBlock(luminances, 1, 0, subWidth, subHeight, blackPoints, matrix));\n        \n        // Test for case with y-axis offset\n        assertEquals(352, calculateThresholdForBlock(luminances, 0, 1, subWidth, subHeight, blackPoints, matrix));\n    }\n}",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Arrange\n        byte[] luminances = new byte[100];\n        int subWidth = 10;\n        int subHeight = 20;\n        int width = 30;\n        int height = 40;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        BitMatrix matrix = new BitMatrix(width, height);\n        \n        // Act\n        HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n        \n        // Assert\n        assertEquals(30, matrix.getWidth());\n        assertEquals(40, matrix.getHeight());\n    }\n}",
        "package com.google.zxing.common;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Arrange\n        byte[] luminances = new byte[256];\n        int subWidth = 8;\n        int subHeight = 4;\n        int width = 32;\n        int height = 16;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        BitMatrix matrix = new BitMatrix(width, height);\n        \n        // Act\n        calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n        \n        // Assert\n        assertEquals(32768, luminances[0]);\n    }\n}"
    ]
}