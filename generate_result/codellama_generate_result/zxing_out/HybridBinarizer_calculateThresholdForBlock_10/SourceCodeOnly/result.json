{
    "project_name": "zxing",
    "file_name": "HybridBinarizer.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/HybridBinarizer.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.common",
    "docstring": "/**\n   * For each block in the image, calculate the average black point using a 5x5 grid\n   * of the blocks around it. Also handles the corner cases (fractional blocks are computed based\n   * on the last pixels in the row/column which are also used in the previous block).\n   */",
    "source_code": "\nprivate static void calculateThresholdForBlock(byte[] luminances,\n                                               int subWidth,\n                                               int subHeight,\n                                               int width,\n                                               int height,\n                                               int[][] blackPoints,\n                                               BitMatrix matrix) {\n  int maxYOffset = height - BLOCK_SIZE;\n  int maxXOffset = width - BLOCK_SIZE;\n  for (int y = 0; y < subHeight; y++) {\n    int yoffset = y << BLOCK_SIZE_POWER;\n    if (yoffset > maxYOffset) {\n      yoffset = maxYOffset;\n    }\n    int top = cap(y, subHeight - 3);\n    for (int x = 0; x < subWidth; x++) {\n      int xoffset = x << BLOCK_SIZE_POWER;\n      if (xoffset > maxXOffset) {\n        xoffset = maxXOffset;\n      }\n      int left = cap(x, subWidth - 3);\n      int sum = 0;\n      for (int z = -2; z <= 2; z++) {\n        int[] blackRow = blackPoints[top + z];\n        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n      }\n      int average = sum / 25;\n      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n    }\n  }\n}\n",
    "class_name": "HybridBinarizer",
    "method_name": "calculateThresholdForBlock",
    "arguments": [
        "byte[] luminances",
        "int subWidth",
        "int subHeight",
        "int width",
        "int height",
        "int[][] blackPoints",
        "BitMatrix matrix"
    ],
    "generate_test": [
        "\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Create a mocked luminance array\n        byte[] luminances = new byte[100];\n        Arrays.fill(luminances, (byte) 128);\n\n        // Calculate the threshold for each block in the image\n        int subWidth = 5;\n        int subHeight = 3;\n        int width = luminances.length / subHeight;\n        int height = subHeight;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        for (int y = 0; y < subHeight; y++) {\n            for (int x = 0; x < subWidth; x++) {\n                blackPoints[y][x] = 128;\n            }\n        }\n        int[] thresholdBlocks = new int[subHeight * subWidth];\n        HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, thresholdBlocks);\n\n        // Verify that the calculated threshold values match the expected values\n        for (int i = 0; i < thresholdBlocks.length; i++) {\n            assertEquals(128, thresholdBlocks[i]);\n        }\n    }\n}\n",
        "\npackage com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };\n        int subWidth = 2;\n        int subHeight = 2;\n        int width = 4;\n        int height = 4;\n        int[][] blackPoints = new int[][] {\n                new int[] { 10, 10 },\n                new int[] { 10, 10 }\n        };\n        BitMatrix matrix = new BitMatrix(width, height);\n        HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n\n        assertEquals(matrix.get(0, 0), true);\n        assertEquals(matrix.get(0, 1), false);\n        assertEquals(matrix.get(1, 0), true);\n        assertEquals(matrix.get(1, 1), false);\n    }\n}",
        "package com.google.zxing.common;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8};\n        int subWidth = 3;\n        int subHeight = 3;\n        int width = 9;\n        int height = 9;\n        int[][] blackPoints = new int[subHeight][];\n        for (int i = 0; i < subHeight; i++) {\n            blackPoints[i] = new int[]{1, 2, 3};\n        }\n        BitMatrix matrix = new BitMatrix(width, height);\n        calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n        assertEquals(matrix.get(0, 0), 1);\n        assertEquals(matrix.get(1, 1), 1);\n    }\n}",
        "\npackage com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[1024]; // assume 1024 is the size of luminance array\n        int subWidth = 16; // assume 16 is the sub width\n        int subHeight = 16; // assume 16 is the sub height\n        int width = 32; // assume 32 is the width of the image\n        int height = 32; // assume 32 is the height of the image\n        int[][] blackPoints = new int[3][]; // assume 3 is the size of the black points array\n        for (int i = 0; i < 3; i++) {\n            blackPoints[i] = new int[16]; // assume 16 is the sub width\n        }\n        BitMatrix matrix = new BitMatrix(width, height); // assume the bit matrix has already been initialized\n        \n        HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n    }\n}",
        "\npackage com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[256];\n        int subWidth = 4;\n        int subHeight = 4;\n        int width = 10;\n        int height = 10;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        BitMatrix matrix = new BitMatrix(width, height);\n\n        calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n\n        assertEquals(matrix.get(0, 0), 1);\n        assertEquals(matrix.get(1, 1), 1);\n    }\n}",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Create a new instance of the HybridBinarizer class\n        HybridBinarizer binarizer = new HybridBinarizer();\n\n        // Set up some sample input parameters\n        byte[] luminances = new byte[10];\n        int subWidth = 2;\n        int subHeight = 3;\n        int width = 5;\n        int height = 7;\n        int[][] blackPoints = new int[height][width];\n        BitMatrix matrix = new BitMatrix(width, height);\n\n        // Call the calculateThresholdForBlock method with the sample input parameters\n        int[] thresholds = binarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n\n        // Check that the returned value is what we expect it to be based on the input parameters\n        assertEquals(2, thresholds[0]);\n        assertEquals(3, thresholds[1]);\n    }\n}",
        "package com.google.zxing.common;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        // Arrange\n        byte[] luminances = new byte[25];\n        int subWidth = 3;\n        int subHeight = 4;\n        int width = 8;\n        int height = 16;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        BitMatrix matrix = new BitMatrix(width, height);\n\n        // Act\n        calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n\n        // Assert\n        assertThat(matrix.get(2, 2)).isEqualTo(true);\n    }\n}",
        "\npackage com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        byte[] luminances = new byte[256];\n        for (int i = 0; i < 256; i++) {\n            luminances[i] = (byte) i;\n        }\n        int subWidth = 4;\n        int subHeight = 4;\n        int width = 16;\n        int height = 16;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        for (int y = 0; y < subHeight; y++) {\n            for (int x = 0; x < subWidth; x++) {\n                blackPoints[y][x] = 128;\n            }\n        }\n        BitMatrix matrix = new BitMatrix(width, height);\n        HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n        assertEquals(matrix.get(0, 0), true);\n    }\n}",
        "int sum = 0;\nfor (int z = -2; z <= 2; z++) {\n    int[] blackRow = blackPoints[top + z];\n    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n}\nint average = sum / 25;",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class HybridBinarizerTest {\n    @Test\n    public void calculateThresholdForBlockTest() {\n        int[] luminances = new int[25];\n        for (int i = 0; i < 25; i++) {\n            luminances[i] = 10 + i * 5; // create a list of luminosity values with increasing difference\n        }\n        int subWidth = 4;\n        int subHeight = 4;\n        int width = 16;\n        int height = 16;\n        int[][] blackPoints = new int[subHeight][subWidth];\n        for (int i = 0; i < subHeight; i++) {\n            for (int j = 0; j < subWidth; j++) {\n                blackPoints[i][j] = 128 - i * 5; // create a list of average luminosity values with decreasing difference\n            }\n        }\n        BitMatrix matrix = new BitMatrix(width, height);\n        HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix);\n        int[][] expectedMatrix = {\n                {1, 0, 0, 0},\n                {1, 1, 0, 0},\n                {1, 1, 1, 0},\n                {1, 1, 1, 1}\n        };\n        assertArrayEquals(expectedMatrix, matrix.getMatrix()); // verify that the threshold value is correctly calculated and applied to the bit matrix\n    }\n}"
    ]
}