{
    "project_name": "zxing",
    "file_name": "WhiteRectangleDetector.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/common/detector/WhiteRectangleDetector.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.common.detector",
    "docstring": "/**\n   * <p>\n   * Detects a candidate barcode-like rectangular region within an image. It\n   * starts around the center of the image, increases the size of the candidate\n   * region until it finds a white rectangular region.\n   * </p>\n   *\n   * @return {@link ResultPoint}[] describing the corners of the rectangular\n   *         region. The first and last points are opposed on the diagonal, as\n   *         are the second and third. The first point will be the topmost\n   *         point and the last, the bottommost. The second point will be\n   *         leftmost and the third, the rightmost\n   * @throws NotFoundException if no Data Matrix Code can be found\n   */",
    "source_code": "\npublic ResultPoint[] detect() throws NotFoundException {\n\n  int left = leftInit;\n  int right = rightInit;\n  int up = upInit;\n  int down = downInit;\n  boolean sizeExceeded = false;\n  boolean aBlackPointFoundOnBorder = true;\n\n  boolean atLeastOneBlackPointFoundOnRight = false;\n  boolean atLeastOneBlackPointFoundOnBottom = false;\n  boolean atLeastOneBlackPointFoundOnLeft = false;\n  boolean atLeastOneBlackPointFoundOnTop = false;\n\n  while (aBlackPointFoundOnBorder) {\n\n    aBlackPointFoundOnBorder = false;\n\n    // .....\n    // .   |\n    // .....\n    boolean rightBorderNotWhite = true;\n    while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n      rightBorderNotWhite = containsBlackPoint(up, down, right, false);\n      if (rightBorderNotWhite) {\n        right++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnRight = true;\n      } else if (!atLeastOneBlackPointFoundOnRight) {\n        right++;\n      }\n    }\n\n    if (right >= width) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .....\n    // .   .\n    // .___.\n    boolean bottomBorderNotWhite = true;\n    while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n      bottomBorderNotWhite = containsBlackPoint(left, right, down, true);\n      if (bottomBorderNotWhite) {\n        down++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnBottom = true;\n      } else if (!atLeastOneBlackPointFoundOnBottom) {\n        down++;\n      }\n    }\n\n    if (down >= height) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .....\n    // |   .\n    // .....\n    boolean leftBorderNotWhite = true;\n    while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n      leftBorderNotWhite = containsBlackPoint(up, down, left, false);\n      if (leftBorderNotWhite) {\n        left--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnLeft = true;\n      } else if (!atLeastOneBlackPointFoundOnLeft) {\n        left--;\n      }\n    }\n\n    if (left < 0) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .___.\n    // .   .\n    // .....\n    boolean topBorderNotWhite = true;\n    while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n      topBorderNotWhite = containsBlackPoint(left, right, up, true);\n      if (topBorderNotWhite) {\n        up--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnTop = true;\n      } else if (!atLeastOneBlackPointFoundOnTop) {\n        up--;\n      }\n    }\n\n    if (up < 0) {\n      sizeExceeded = true;\n      break;\n    }\n\n  }\n\n  if (!sizeExceeded) {\n\n    int maxSize = right - left;\n\n    ResultPoint z = null;\n    for (int i = 1; z == null && i < maxSize; i++) {\n      z = getBlackPointOnSegment(left, down - i, left + i, down);\n    }\n\n    if (z == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint t = null;\n    //go down right\n    for (int i = 1; t == null && i < maxSize; i++) {\n      t = getBlackPointOnSegment(left, up + i, left + i, up);\n    }\n\n    if (t == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint x = null;\n    //go down left\n    for (int i = 1; x == null && i < maxSize; i++) {\n      x = getBlackPointOnSegment(right, up + i, right - i, up);\n    }\n\n    if (x == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint y = null;\n    //go up left\n    for (int i = 1; y == null && i < maxSize; i++) {\n      y = getBlackPointOnSegment(right, down - i, right - i, down);\n    }\n\n    if (y == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    return centerEdges(y, z, x, t);\n\n  } else {\n    throw NotFoundException.getNotFoundInstance();\n  }\n}\n",
    "class_name": "WhiteRectangleDetector",
    "method_name": "detect",
    "arguments": [],
    "generate_test": [
        "import com.google.zxing.NotFoundException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class WhiteRectangleDetectorTest {\n\n    private List<ResultPoint> corners;\n    private List<Integer> points;\n    private WhiteRectangleDetector detector;\n\n    @BeforeEach\n    public void setup() {\n        corners = new ArrayList<>();\n        points = new ArrayList<>();\n        detector = new WhiteRectangleDetector(points, corners);\n    }\n\n    @Test\n    public void detectTest_whenAllPointsAreInsideWhiteRectangleAndCornersAreValid_shouldReturnResultPointListWith4Elements() throws NotFoundException {\n        // Arrange\n        points.add(0);\n        points.add(1);\n        points.add(2);\n        points.add(3);\n        corners.add(new ResultPoint(5, 6));\n        corners.add(new ResultPoint(7, 8));\n        corners.add(new ResultPoint(9, 10));\n        corners.add(new ResultPoint(11, 12));\n        detector = new WhiteRectangleDetector(points, corners);\n\n        // Act\n        List<ResultPoint> resultPoints = detector.detect();\n\n        // Assert\n        assertEquals(4, resultPoints.size());\n    }\n\n    @Test\n    public void detectTest_whenAllPointsAreInsideWhiteRectangleAndCornersAreNotValid_shouldThrowNotFoundException() {\n        // Arrange\n        points.add(0);\n        points.add(1);\n        points.add(2);\n        points.add(3);\n        corners.add(new ResultPoint(5, 6));\n        corners.add(new ResultPoint(7, 8));\n        detector = new WhiteRectangleDetector(points, corners);\n\n        // Act\n        NotFoundException actualException = assertThrows(NotFoundException.class, () -> {\n            List<ResultPoint> resultPoints = detector.detect();\n        });\n\n        // Assert\n        String expectedMessage = \"Corners do not form a rectangular region.\";\n        String actualMessage = actualException.getMessage();\n        assertTrue(actualMessage.contains(expectedMessage));\n    }\n}",
        "    package com.google.zxing.common.detector;\n\nimport java.util.Arrays;\n\npublic class WhiteRectangleDetector {\n  private static final float CORR = 1.0f;\n  private final BitMatrix image;\n  private int width;\n  private int height;\n\n  public WhiteRectangleDetector(BitMatrix image) {\n    this.image = image;\n    this.width = image.getWidth();\n    this.height = image.getHeight();\n  }\n\n  /**\n   * <p>\n   * Detects a rectangle containing a QR Code in an image. Only points which are\n   * likely to be part of the QR Code boundaries are searched. That is, the image\n   * is examined border by border, with the brighter borders being preferred over\n   * the darker ones. This method returns {@code null} if it fails to find any\n   * possible QR code. At the moment, only QR codes of size 1 are supported.\n   * </p>\n   * <p>\n   * A minimal example to decode a QR code from an image:\n   * </p>\n   * \n   * <pre>\n   * BinaryBitmap bbMap = new BinaryBitmap(new GlobalHistogramBinarizer(ImageReader.readImage(...)));\n   * WhiteRectangleDetector detector = new WhiteRectangleDetector();\n   * Result result = detector.detect(bbMap).getBits();\n   * </pre>\n   * \n   * @param bm {@link BinaryBitmap} to scan for a QR code\n   * @return {@link DetectorResult}, encapsulating results of detection, or null if no QR code was found\n   */\n  public DetectorResult detect(BinaryBitmap bm) {\n    return new DetectorResult(null, Arrays.asList(new ResultPoint[]{}));\n  }\n\n}\n    \n\n### JUNIT Test case:\npackage com.google.zxing.common;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitMatrixTest {\n    @Test\n    public void testGetSet() {\n        <FILL>\n    }\n}\n    \n\n### Response:",
        "package com.google.zxing.common.detector;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\npublic class WhiteRectangleDetectorTest {\n    private static final int width = 100;\n    private static final int height = 100;\n    private static final byte[] imageBytes = new byte[width * height];\n    private static final BitMatrix image = new BitMatrix(imageBytes);\n    \n    @Test\n    public void detectTest() {\n        WhiteRectangleDetector detector = new WhiteRectangleDetector(image);\n        assertThrows(NotFoundException.class, () -> detector.detect());\n        \n        image.setRegion(10, 10, width - 20, height - 20);\n        try {\n            ResultPoint[] corners = detector.detect();\n            Assertions.assertEquals(4, corners.length);\n            \n            float xi = corners[0].getX();\n            float yj = corners[1].getY();\n            float zi = corners[2].getX();\n            float tj = corners[3].getY();\n            Assertions.assertTrue(xi < width / 2);\n        } catch (NotFoundException e) {\n            fail(\"Detector should find points\");\n        }\n    }\n}\n    \n\n### Response:",
        "@Autowired\nprivate WhiteRectangleDetector detector;\n\nMockito.when(detector.detect()).thenReturn();\n",
        "package com.google.zxing.common;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class WhiteRectangleDetectorTest {\n    \n    @Test\n    public void testDetect() throws Exception {\n        int[][] image = new int[10][10];\n        for (int i = 2; i <= 7; i++) {\n            image[i][3] = 1;\n            image[i][4] = 1;\n            image[i - 1][5] = 1;\n            image[8 - i][6] = 1;\n        }\n        int width = image.length;\n        int height = image[0].length;\n        \n        WhiteRectangleDetector detector = new WhiteRectangleDetector(image);\n        ResultPoint[] corners = detector.detect();\n        \n        Assertions.assertEquals(4, corners.length);\n        assertEquals(1f, corners[0].getX());\n        assertEquals(8f, corners[1].getX());\n        assertEquals(1f, corners[2].getY());\n        assertEquals(8f, corners[3].getY());\n    }\n    \n}",
        "  The WhiteRectangleDetector class is responsible for detecting the location of a white rectangle in an image. It takes a BinaryBitmap as input, and returns a ResultPoint array describing the corners of the detected rectangle. The constructor of the class initializes the image to be analyzed and the size of the search area.\n  \n  The detect method of WhiteRectangleDetector starts by finding the edges of the barcode in the image. It does this by calling the getBlackPointsOnEdges method, which returns an array of ResultPoint objects that correspond to the corners of a detected rectangle. If no corner points are found, a NotFoundException is thrown.\n  \n  Once the edge points have been identified, the WhiteRectangleDetector uses them to calculate the center of the barcode and adjust the search area accordingly. It then calls the getBoundingBox method, which returns an array of four ResultPoint objects that describe the corners of a bounding rectangle for the detected barcode. If no bounding box is found, a NotFoundException is thrown.\n  \n  Finally, WhiteRectangleDetector uses the center and bounding box points to calculate the dimension of the barcode and adjust the search area again. It then returns an array of four ResultPoint objects that describe the corners of the detected rectangle.\n  \n  The constructor method initializes several instance variables, including the image to be analyzed (BinaryBitmap), the size of the search area, and the width and height of the image being analyzed. It also initializes some constants used in the detection process.\n  \n  The getBlackPointsOnEdges method is called by WhiteRectangleDetector's detect method to find the edges of a detected barcode. It does this by iterating over each row or column of the image and identifying points where the lightness (i.e., color) is different from that of the surrounding pixels. If the point is at the edge of the search area, it is added to an array of ResultPoint objects, which are returned when the iteration completes. If no edges are found, a NotFoundException is thrown.\n  \n  The centerEdges method is called by WhiteRectangleDetector's detect method to recentering the points of a constant distance towards the center. It does this by adjusting the coordinates of each point based on its distance from the center. If yi (the x coordinate of the bottom-most point) is less than half the width of the image, then the topmost point is moved upwards and the bottommost point is moved downwards. Similarly, if yj (the y coordinate of the left-most point) is greater than half the height of the image, then the rightmost point is moved to the left and the leftmost point is moved to the right. Finally, the adjusted points are returned in an array of ResultPoint objects.\n  \n  The containsBlackPoint method is called by WhiteRectangleDetector's detect method to determine whether a segment (i.e., a line) contains any black points. It does this by scanning through each pixel along the segment and checking if it is light or dark. If a black point is found, true is returned. Otherwise, false is returned.\n  ",
        "java\npackage com.google.zxing.common.detector;\n\nimport java.util.Arrays;\n\nimport com.google.zxing.NotFoundException;\nimport com.google.zxing.ResultPoint;\nimport com.google.zxing.common.BitMatrix;\n\n/**\n * Detects a rectangle within an image which approximate to be white.\n */\npublic class WhiteRectangleDetector {\n    private static final int CORR = 1; //was:  3\n    private BitMatrix image;\n    private int width;\n    private int height;\n\n    /**\n     * Creates a generic white rectangle detector.\n     *\n     * @param image barcode image to detect on.\n     */\n    public WhiteRectangleDetector(BitMatrix image) {\n        this.image = image;\n        width = image.getWidth();\n        height = image.getHeight();\n    }\n\n    /**\n     * <p>\n     * Detects a rectangle within an image which approximate to be white.\n     * </p>\n     *\n     * @return {@link ResultPoint}[] describing the corners of the rectangular\n     * region. The first and last points are opposed on the diagonal, as are the\n     * second and third. The first point will be the topmost point and the\n     * last, the bottommost. The second point will be leftmost and the third,\n     * the rightmost\n     * @throws NotFoundException if rectangle cannot be found\n     */\n    public ResultPoint[] detect() throws NotFoundException {\n        int left = 0; // points to the left side of the rectangular region\n        int right = width - 1; // points to the right side of the rectangular region\n        boolean done = false;\n\n        while (!done) {\n            // Scan left until we find a white point\n            while (left < right && !image.get(left, height / 2)) {\n                left++;\n            }\n\n            if (left == right) {\n                throw NotFoundException.getNotFoundInstance();\n            }\n\n            // Scan right until we find a white point\n            while (right > left && !image.get(right, height / 2)) {\n                right--;\n            }\n\n            int maxSize = Math.min(right - left + 1, height);\n\n            // Now just look down till we find a black point\n            for (int i = 1; i < maxSize; i++) {\n                if (!image.get(left, height / 2 + i)) {\n                    return new ResultPoint[]{\n                        new ResultPoint((left + right) / 2.0f, height / 2 + i - CORR),\n                        new ResultPoint(left + right) / 2.0f, height / 2 + i - CORR),\n                    };\n                }\n            }\n\n            // Re-find from center outwards\n            for (int i = maxSize - 1; i >= 0; i--) {\n                if (!image.get(left, height / 2 + i)) {\n                    return new ResultPoint[]{\n                        new ResultPoint((left + right) / 2.0f, height / 2 + i - CORR),\n                            };\n                }\n\n                // .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..\n\n .. . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . S . . . . . . . . E . D. . . . V . . . . . . . . . . In. . . P .  S . . .. . . . . F. . . . A . s. . . .. . .. . .. .. . . . .. ... . . . . . . . . . . . . . . . . . . . . . . . . . .. . . and if you can be able to understand the main part of the question I would like what is going on, but . . . . . . . .\nThe whole part of your question seems to involve the use case for `strchr` vs. `ord`, which might be worth having.  It's important to note that while a character may have only one bit set, it can still take up to eight bits, and thus be larger than an unsigned char (which is 8 bits).\nEither way, if you want a signed byte, then you need to use `strtol` instead:\n . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\\end{code}\n\nComment: So the answer is to use `strtol` and not `ord`? I am not sure how to make that happen.  It seems like an error in how `gmp` works, but I will look at it later.  I didn't realize you could have two char variables with one bit set each.\n\nAnswer: \\strong{tl()} returns a long integer so that means you can not use the character 'a'. You should be using 'A', and then it might work as you expect.\n\n\\begin{code}\n    $ echo $((printf \"%02X\" 97) | tr 'a') | xxd -p\n    a: 97\n    A: 65\n\\end{code}",
        "<!---\n\nCopyright 2018 Google LLC.\nUse of this source code is governed by an MIT-style license that\ncan be found in the LICENSE file or at\nhttps://opensource.org/licenses/MIT.\n-->\n\n\n### Response:",
        "<FILL>\n\n    private int width = 10;\n    private int height = 10;\n    private final BitMatrix image = new BitMatrix(width,height);\n\n    @BeforeEach\n    public void setUp() {\n        for (int i=0; i<width; i++) {\n            for (int j=0; j<height; j++) {\n                if ((i>2) && (j>2)) image.set(i, j);\n            }\n        }\n    }\n\n    @Test\n    public void detectOnLargeBlackFullySurroundedImage() throws NotFoundException {\n        WhiteRectangleDetector detector = new WhiteRectangleDetector(image);\n        ResultPoint[] corners = detector.detect();\n        assertEquals(4, corners.length);\n    }\n}",
        "<FILL>\n\n"
    ]
}