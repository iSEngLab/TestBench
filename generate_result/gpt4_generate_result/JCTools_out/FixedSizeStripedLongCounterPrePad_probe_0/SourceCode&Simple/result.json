{
    "project_name": "JCTools",
    "file_name": "FixedSizeStripedLongCounter.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/counters/FixedSizeStripedLongCounter.java",
    "execute_path": "JCTools",
    "package": "org.jctools.counters",
    "docstring": "/**\n     * Returns the probe value for the current thread.\n     * If target JDK version is 7 or higher, than ThreadLocalRandom-specific\n     * value will be used, xorshift with thread id otherwise.\n     */",
    "source_code": "\nprivate int probe() {\n    // Fast path for reliable well-distributed probe, available from JDK 7+.\n    // As long as PROBE is final static this branch will be constant folded\n    // (i.e removed).\n    if (PROBE != -1) {\n        int probe;\n        if ((probe = UNSAFE.getInt(Thread.currentThread(), PROBE)) == 0) {\n            ThreadLocalRandom.current(); // force initialization\n            probe = UNSAFE.getInt(Thread.currentThread(), PROBE);\n        }\n        return probe;\n    }\n\n    /*\n     * Else use much worse (for values distribution) method:\n     * Mix thread id with golden ratio and then xorshift it\n     * to spread consecutive ids (see Knuth multiplicative method as reference).\n     */\n    int probe = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n    // xorshift\n    probe ^= probe << 13;\n    probe ^= probe >>> 17;\n    probe ^= probe << 5;\n    return probe;\n}\n\n",
    "class_name": "FixedSizeStripedLongCounterPrePad",
    "method_name": "probe",
    "arguments": [],
    "generate_test": [
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    @Test\n    public void probeTest() throws Exception {\n        // mock a FixedSizeStripedLongCounter instance to test the private 'probe' method\n        FixedSizeStripedLongCounter counter = mock(FixedSizeStripedLongCounter.class, CALLS_REAL_METHODS);\n\n        // Access the probe method using reflection as it is private\n        Method probeMethod = FixedSizeStripedLongCounter.class.getDeclaredMethod(\"probe\");\n        probeMethod.setAccessible(true);\n\n        // Test with a probe value that is set to '0' \n        long PROBE_OFFSET = (long) UNSEFE.getStatic(new Field[]{asList(FixedSizeStripedLongCounter.class.getDeclaredFields()).stream().filter(f -> f.getName().equals(\"PROBE\")).findFirst().get()});\n        UNSAFE.putInt(Thread.currentThread(), PROBE_OFFSET, 0);\n        \n        // The probe value should not be 0 after calling probe, because of the ThreadLocalRandom initialization\n        int result = (int) probeMethod.invoke(counter);\n        assertNotEquals(0, result, \"Probe value should not be zero after initialization\");\n\n        // Now set the probe to a non-zero value and verify it doesn't change\n        int expectedProbeValue = 123456;\n        UNSAFE.putInt(Thread.currentThread(), PROBE_OFFSET, expectedProbeValue);\n        result = (int) probeMethod.invoke(counter);\n        assertEquals(expectedProbeValue, result, \"Probe value should remain unchanged if already initialized\");\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.jctools.util.UnsafeAccess.*;\nimport java.lang.reflect.Field;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    // Reflection is needed to access the private static final field 'PROBE'\n    static {\n        try {\n            Field probeField = FixedSizeStripedLongCounter.class.getDeclaredField(\"PROBE\");\n            probeField.setAccessible(true);\n            UNSAFE.putLong(probeField, UNSAFE.staticFieldOffset(probeField), -1L);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n    \n    // Helper method to call the private probe() method using reflection\n    private int callProbeMethod(FixedSizeStripedLongCounter counter) {\n        try {\n            Method probeMethod = FixedSizeStripedLongCounter.class.getDeclaredMethod(\"probe\");\n            probeMethod.setAccessible(true);\n            return (int) probeMethod.invoke(counter);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Test\n    public void probeTest() {\n        FixedSizeStripedLongCounter counter = new FixedSizeStripedLongCounter(2);\n        int probeValue = callProbeMethod(counter);\n\n        // Tests to validate probe values are derived appropriately\n        // Confirm the value follows the expected bit manipulations for the worse path\n        // The worse path is used when PROBE is set to -1. Here we confirm the xorshift logic.\n        long threadId = Thread.currentThread().getId();\n        int expectedProbe = (int) ((threadId * 0x9e3779b9) & Integer.MAX_VALUE);\n        expectedProbe ^= expectedProbe << 13;\n        expectedProbe ^= expectedProbe >>> 17;\n        expectedProbe ^= expectedProbe << 5;\n\n        assertEquals(expectedProbe, probeValue, \"The probe value does not match the expected outcome.\");\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\n\nimport java.util.concurrent.ThreadLocalRandom;\n\n@TestInstance(TestInstance.Lifecycle.PER_CLASS) // Ensures that we use the same instance across tests if needed.\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    private FixedSizeStripedLongCounterPrePad instance;\n\n    // Since the PROBE field and the probe() method are private, we have to use reflection to access them\n    @BeforeAll\n    void setUp() throws Exception {\n        instance = new FixedSizeStripedLongCounterPrePad() {\n            // implement abstract methods if any are present in FixedSizeStripedLongCounterPrePad\n        };\n        // Initialize ThreadLocalRandom current to make sure PROBE gets a non-zero value\n        ThreadLocalRandom.current();\n    }\n\n    @Test\n    public void probeTest() throws Exception {\n        // Reflectively obtain the method to be tested\n        java.lang.reflect.Method probeMethod = FixedSizeStripedLongCounterPrePad.class.getDeclaredMethod(\"probe\");\n        probeMethod.setAccessible(true);\n\n        // Execute the method on the test instance.\n        int probeValue = (int) probeMethod.invoke(instance);\n\n        // The returned probe value should not be -1, which is the value of uninitialized PROBE.\n        assertNotEquals(-1, probeValue, \"The probe value should not be -1\");\n\n        // Since the implementation of `probe` involves native threading behavior and bitwise operations,\n        // it is non-deterministic and we cannot assert for a specific value. However, we can run the probe\n        // method multiple times to ensure it does not return a constant value such as -1. Additionally,\n        // we can check that the returned value is positive due to the `& Integer.MAX_VALUE` operation.\n\n        // Additional checks can include:\n        assertTrue(probeValue >= 0, \"The probe value should be non-negative due to masking with Integer.MAX_VALUE\");\n        // More in-depth checks could involve inspecting behavior when threads change or if probe value alters as expected.\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\nimport java.lang.reflect.Field;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    @Test\n    public void probeTest() throws Exception {\n        // Arrange: Create a spy instance of FixedSizeStripedLongCounter to access probe method\n        FixedSizeStripedLongCounter counterSpy = spy(FixedSizeStripedLongCounter.class);\n\n        // Mock the static fields in FixedSizeStripedLongCounterFields using reflection\n        Field probeField = FixedSizeStripedLongCounter.class.getDeclaredField(\"PROBE\");\n        probeField.setAccessible(true);\n        Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n        modifiersField.setAccessible(true);\n        modifiersField.setInt(probeField, probeField.getModifiers() & ~java.lang.reflect.Modifier.FINAL);\n        \n        // Set PROBE to a non-default value to test the fast path\n        long originalProbeValue = probeField.getLong(null);\n        probeField.setLong(null, 42L); // you may set this to a value that suits your test case\n\n        // Act: Call probe method to get result\n        int resultFastPath = counterSpy.probe();\n\n        // Assert: Verify if the result is non-zero (value would depend on the internal state of Unsafe)\n        assertNotEquals(0, resultFastPath, \"probe should return a non-zero value in the fast path\");\n\n        // Set PROBE back to default value to test the slow path\n        probeField.setLong(null, originalProbeValue);\n        \n        // Act: Call probe method to get result\n        int resultSlowPath = counterSpy.probe();\n        \n        // Assert: Verify if the slow path result is correctly calculated\n        int expectedSlowPath = (int) ((Thread.currentThread().getId() * 0x9e3779b9) & Integer.MAX_VALUE);\n        expectedSlowPath ^= expectedSlowPath << 13;\n        expectedSlowPath ^= expectedSlowPath >>> 17;\n        expectedSlowPath ^= expectedSlowPath << 5;\n\n        assertEquals(expectedSlowPath, resultSlowPath, \"probe should return correct value for the slow path calculation\");\n\n        // Reset the PROBE field to its original state for other tests\n        probeField.setLong(null, originalProbeValue);\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.jctools.util.UnsafeAccess.UNSAFE;\nimport java.lang.reflect.Field;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    static final long PROBE_OFFSET;\n\n    static {\n        try {\n            Field f = Thread.class.getDeclaredField(\"threadLocalRandomProbe\");\n            f.setAccessible(true);\n            PROBE_OFFSET = UNSAFE.objectFieldOffset(f);\n        } catch (Exception ex) {\n            throw new Error(ex);\n        }\n    }\n\n    private int forceSetProbe(Thread thread, int value) throws Exception {\n        UNSAFE.putInt(thread, PROBE_OFFSET, value);\n        return value;\n    }\n\n    @Test\n    public void probeTest() throws Exception {\n        FixedSizeStripedLongCounterPrePad counterPrePad = new FixedSizeStripedLongCounterPrePad() {\n            // Override probe to make it accessible for testing\n            @Override\n            public int probe() {\n                return super.probe();\n            }\n        };\n        \n        Thread current = Thread.currentThread();\n        \n        // Clear the probe first\n        forceSetProbe(current, 0);\n        \n        // First call should initialize the probe with a nonzero value\n        int initialProbe = counterPrePad.probe();\n        assertNotEquals(0, initialProbe, \"probe should not return zero after initialization\");\n        \n        // Subsequent calls should return the same probe value\n        assertEquals(initialProbe, counterPrePad.probe(), \"probe should return the same value on subsequent calls\");\n\n        // Set the probe to a known non-zero value and test\n        int testVal = 12345;\n        forceSetProbe(current, testVal);\n        assertEquals(testVal, counterPrePad.probe(), \"probe should return the test value set manually\");\n        \n        // Test the branch where PROBE is not available\n        // Assuming PROBE is a static final field, it might be impractical to simulate its unavailability\n        // in realistic scenarios since it would be a constant in the compiled code.\n        // Thus, testing the else branch might require changes in the source code to simulate,\n        // such as introducing a package-private setter for testing or refactoring the condition.\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport java.lang.reflect.Method;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n    private Method probeMethod;\n    private FixedSizeStripedLongCounter counter;\n\n    @BeforeEach\n    public void setUp() throws Exception {\n        // Prepare reflection to access the private method `probe`\n        counter = new FixedSizeStripedLongCounter(16) {  // Assuming there's a valid constructor\n            @Override\n            protected void inc(long[] cells, long offset, long value) {\n                // Mock method for testing purposes\n            }\n\n            @Override\n            protected long getAndReset(long[] cells, long offset) {\n                // Mock method for testing purposes\n                return 0;\n            }\n        };\n        probeMethod = FixedSizeStripedLongCounter.class.getDeclaredMethod(\"probe\");\n        probeMethod.setAccessible(true);\n    }\n\n    @Test\n    public void probeTest() throws Exception {\n        // Call the private `probe` method\n        int result = (int) probeMethod.invoke(counter);\n\n        // Assertions\n        assertTrue(result >= 0, \"Probe should always return a non-negative value\");\n        // Optionally test if probe values differ for multiple threads, but this can be non-deterministic\n        // For example, create a few threads and check their probe values\n        \n        Thread.currentThread().setName(\"TestThread-1\");\n        int resultInFirstThread = (int) probeMethod.invoke(counter);\n        \n        Thread newThread = new Thread(() -> {\n            try {\n                // Changing the thread name as probe might factor in thread-specific properties\n                Thread.currentThread().setName(\"TestThread-2\");\n                int resultInNewThread = (int) probeMethod.invoke(counter);\n                \n                // Assertions that would suit multi-threading can be placed here, if necessary\n                // Bear in mind that due to the internal implementation, this assertion can be flaky.\n                assertNotEquals(resultInFirstThread, resultInNewThread, \"Probe values should differ across threads\");\n                \n            } catch (Exception e) {\n                fail(\"Failed to invoke probe method in a new thread\");\n            }\n        });\n        \n        newThread.start();\n        newThread.join(); // Make sure to join the thread so the test waits for its completion\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    private FixedSizeStripedLongCounter counter;\n\n    @BeforeEach\n    public void setUp() {\n        // Assuming 16 stripes as an arbitrary choice for the test.\n        counter = new FixedSizeStripedLongCounter(16);\n    }\n\n    @Test\n    public void probeTest() {\n        long threadId = Thread.currentThread().getId();\n        int probeValue = counter.probe();\n\n        // The probe value should be non-negative\n        assertTrue(probeValue >= 0);\n\n        // To test against the golden ratio method, this test assumes that \n        // PROBE is not available and the threadId is used to compute the\n        // probe value.\n        if (FixedSizeStripedLongCounter.PROBE == -1) {\n            int computedProbe = (int) ((threadId * 0x9e3779b9) & Integer.MAX_VALUE);\n            computedProbe ^= computedProbe << 13;\n            computedProbe ^= computedProbe >>> 17;\n            computedProbe ^= computedProbe << 5;\n            \n            // The computed probe value should be the same as the method's return value\n            assertEquals(computedProbe, probeValue);\n        }\n\n        // It's difficult to test the behavior when PROBE is available and UNSAFE is used to\n        // fetch the value because UNSAFE.getInt involves native calls and peculiarities of \n        // underlying JVM implementations that aren't easy to mock or expect a deterministic \n        // behavior from. Moreover, UNSAFE is intended for JVM internal use and not part of \n        // public API, so it may not be correct to assume or mimic its behavior here.\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\nimport org.mockito.MockedStatic;\nimport org.mockito.Mockito;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    @Test\n    public void probeTest() {\n        try (MockedStatic<ThreadLocalRandom> mockThreadLocalRandom = Mockito.mockStatic(ThreadLocalRandom.class);\n             MockedStatic<UnsafeAccess> mockUnsafeAccess = Mockito.mockStatic(UnsafeAccess.class)) {\n             \n            Thread currentThread = Thread.currentThread();\n            Unsafe mockUnsafe = mock(Unsafe.class);\n            \n            // Assuming PROBE static field is accessible for tests\n            final long PROBE = -1; // Simulate constant not being defined\n            final long PROBE_OFFSET = 0L; // Fake offset for the test\n            when(UnsafeAccess.UNSAFE).thenReturn(mockUnsafe);\n            when(mockUnsafe.getInt(currentThread, PROBE_OFFSET))\n                .thenReturn(0) // First time, probe is not available, triggers initialization\n                .thenReturn(123); // Second call returns a probe value\n            \n            // Simulating ThreadLocalRandom.current() to initialize probe value\n            mockThreadLocalRandom.when(ThreadLocalRandom::current).thenReturn(null);\n\n            // Mocking instance to call the actual probe() method\n            FixedSizeStripedLongCounter counter = Mockito.mock(FixedSizeStripedLongCounter.class, Mockito.CALLS_REAL_METHODS);\n            \n            int probe = counter.probe();\n            \n            assertEquals(123, probe);\n\n        }\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.*;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n\n    private static class TestCounter extends FixedSizeStripedLongCounter {\n        public TestCounter(int stripesCount) {\n            super(stripesCount);\n        }\n\n        public int callProbe() {\n            return probe();\n        }\n    }\n\n    @Test\n    public void probeTest() throws Exception {\n        TestCounter counter = new TestCounter(16);\n\n        Field probeField = FixedSizeStripedLongCounter.class.getDeclaredField(\"PROBE\");\n        probeField.setAccessible(true);\n\n        // Normally, we wouldn't change private final fields, but for the sake of testing, we're assuming we want to simulate the case where PROBE is -1.\n        // This is NOT advisable in regular testing scenarios as it can lead to unpredictable behavior and breaks encapsulation.\n        probeField.setLong(null, -1L);\n\n        int result = counter.callProbe();\n\n        // Assuming the Thread ID can be 1 (for simplification) and the 'worse' calculation method is used.\n        long expected = 1L * 0x9e3779b9;\n        expected &= Integer.MAX_VALUE;\n        expected ^= expected << 13;\n        expected ^= expected >>> 17;\n        expected ^= expected << 5;\n\n        assertEquals((int) expected, result);\n    }\n}",
        "package org.jctools.counters;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FixedSizeStripedLongCounterPrePadTest {\n    // As a mock test, we would need to simulate UNSAFE since it is not accessible.\n    // Additionally, the `probe` method is private, it should be tested through public methods which use it.\n    // However, for the purpose of the exercise, let's assume we can make the probe method package-private or use reflection.\n\n    @Test\n    public void probeTest() {\n        FixedSizeStripedLongCounter counter = new FixedSizeStripedLongCounter(16);\n\n        // We will use multiple threads, since the method relies on ThreadLocalRandom and Thread ID.\n        Thread[] threads = new Thread[10];\n        int[] probes = new int[threads.length];\n\n        for (int i = 0; i < threads.length; i++) {\n            final int threadIndex = i;\n            threads[i] = new Thread(() -> {\n                // Setting up a unique place for each thread to store their probe value.\n                probes[threadIndex] = counter.probe();\n            });\n        }\n\n        for (Thread thread : threads) {\n            thread.start();\n        }\n\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                fail(\"Thread interrupted: \" + e.getMessage());\n            }\n        }\n\n        // Check if each thread's probe is unique (collision is possible but unlikely).\n        for (int i = 0; i < probes.length; i++) {\n            for (int j = i + 1; j < probes.length; j++) {\n                assertNotEquals(probes[i], probes[j], \"Probes should be unique across threads.\");\n            }\n        }\n\n        // Further checks can be performed to ensure that the values are within the expected range, but\n        // there need to be proper public methods for accessing probe values if `probe` is private.\n    }\n}"
    ]
}