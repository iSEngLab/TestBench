{
    "project_name": "JCTools",
    "file_name": "NonBlockingHashMap.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingHashMap.java",
    "execute_path": "JCTools",
    "package": "org.jctools.maps",
    "docstring": "/**\n   * Returns a string representation of this map.  The string representation\n   * consists of a list of key-value mappings in the order returned by the\n   * map's <tt>entrySet</tt> view's iterator, enclosed in braces\n   * (<tt>\"{}\"</tt>).  Adjacent mappings are separated by the characters\n   * <tt>\", \"</tt> (comma and space).  Each key-value mapping is rendered as\n   * the key followed by an equals sign (<tt>\"=\"</tt>) followed by the\n   * associated value.  Keys and values are converted to strings as by\n   * {@link String#valueOf(Object)}.\n   *\n   * @return a string representation of this map\n   */",
    "source_code": "\n@Override\npublic String toString() {\n  Iterator<Entry<TypeK,TypeV>> i = entrySet().iterator();\n  if( !i.hasNext())\n    return \"{}\";\n\n  StringBuilder sb = new StringBuilder();\n  sb.append('{');\n  for (;;) {\n    Entry<TypeK,TypeV> e = i.next();\n    TypeK key = e.getKey();\n    TypeV value = e.getValue();\n    sb.append(key   == this ? \"(this Map)\" : key);\n    sb.append('=');\n    sb.append(value == this ? \"(this Map)\" : value);\n    if( !i.hasNext())\n      return sb.append('}').toString();\n    sb.append(\", \");\n  }\n}\n",
    "class_name": "NonBlockingHashMap",
    "method_name": "toString",
    "arguments": [],
    "generate_test": [
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        NonBlockingHashMap<String, String> nbhm = new NonBlockingHashMap<>();\n        nbhm.put(\"1\", \"one\");\n        nbhm.put(\"2\", \"two\");\n        nbhm.put(\"3\", \"three\");\n\n        String resultMapString = nbhm.toString();\n\n        assertTrue(resultMapString.contains(\"{1=one, 2=two, 3=three}\") ||\n                   resultMapString.contains(\"{1=one, 3=three, 2=two}\") ||\n                   resultMapString.contains(\"{2=two, 1=one, 3=three}\") ||\n                   resultMapString.contains(\"{2=two, 3=three, 1=one}\") ||\n                   resultMapString.contains(\"{3=three, 1=one, 2=two}\") ||\n                   resultMapString.contains(\"{3=three, 2=two, 1=one}\"),\n                   \"Map toString does not match expected format.\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n    private NonBlockingHashMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new NonBlockingHashMap<>();\n    }\n\n    @Test\n    public void toStringTest() {\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n\n        String expected = \"{key1=value1, key2=value2, key3=value3}\";\n        String actual = map.toString();\n        \n        // Because the output ordering is not guaranteed, \n        // we use contains to validate each entry instead.\n        assertTrue(actual.startsWith(\"{\") && actual.endsWith(\"}\"), \"toString should start with { and end with }\");\n        assertTrue(actual.contains(\"key1=value1\"), \"toString should contain 'key1=value1'\");\n        assertTrue(actual.contains(\"key2=value2\"), \"toString should contain 'key2=value2'\");\n        assertTrue(actual.contains(\"key3=value3\"), \"toString should contain 'key3=value3'\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n\n    private NonBlockingHashMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new NonBlockingHashMap<>();\n    }\n\n    @Test\n    public void toStringTest() {\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n\n        String expectedPattern = \"\\\\{key\\\\d=value\\\\d, key\\\\d=value\\\\d, key\\\\d=value\\\\d\\\\}\";\n        assertTrue(map.toString().matches(expectedPattern));\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n    private NonBlockingHashMap<String, String> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new NonBlockingHashMap<>();\n    }\n\n    @Test\n    public void toStringTest() {\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n\n        String expected = \"{key1=value1, key2=value2, key3=value3}\";\n        String str = map.toString();\n\n        // Since the order of entries in the map is not guaranteed, we convert \n        // the strings to character arrays and sort them before comparing.\n        char[] actualArray = str.replace(\"{\", \"\").replace(\"}\", \"\").replace(\", \", \"\").toCharArray();\n        char[] expectedArray = expected.replace(\"{\", \"\").replace(\"}\", \"\").replace(\", \", \"\").toCharArray();\n        \n        Arrays.sort(actualArray);\n        Arrays.sort(expectedArray);\n        \n        assertArrayEquals(expectedArray, actualArray, \"The expected string representation does not match the actual.\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n    private NonBlockingHashMap<String, String> map;\n\n    @BeforeEach\n    public void setup() {\n        map = new NonBlockingHashMap<>();\n    }\n\n    @Test\n    public void toStringEmptyMap() {\n        assertEquals(\"{}\", map.toString(), \"An empty map should return {}\");\n    }\n\n    @Test\n    public void toStringOneElementMap() {\n        map.put(\"key1\", \"value1\");\n        assertEquals(\"{key1=value1}\", map.toString(), \"A single element map should return {key1=value1}\");\n    }\n\n    @Test\n    public void toStringMultipleElementsMap() {\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n        String result = map.toString();\n        assertTrue(result.startsWith(\"{\") && result.endsWith(\"}\"), \"A multiple element map should start with { and end with }\");\n        assertTrue(result.contains(\"key1=value1\"), \"toString should contain key1=value1\");\n        assertTrue(result.contains(\"key2=value2\"), \"toString should contain key2=value2\");\n        assertTrue(result.contains(\"key3=value3\"), \"toString should contain key3=value3\");\n        assertTrue(result.indexOf(\"key1=value1\") < result.indexOf(\"key2=value2\"), \"Elements should appear in insertion order for key1 and key2\");\n        assertTrue(result.indexOf(\"key2=value2\") < result.indexOf(\"key3=value3\"), \"Elements should appear in insertion order for key2 and key3\");\n    }\n\n    @Test\n    public void toStringAfterRemove() {\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.remove(\"key1\");\n        assertEquals(\"{key2=value2}\", map.toString(), \"toString should reflect the map after removing an element\");\n    }\n\n    @Test\n    public void toStringWithMapReference() {\n        map.put(\"key1\", map);\n        assertEquals(\"{key1=(this Map)}\", map.toString(), \"toString should handle a map reference as a key\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n\n    @Test\n    public void toStringTest() {\n        NonBlockingHashMap<String, Integer> map = new NonBlockingHashMap<>();\n        \n        // Test with empty map\n        assertEquals(\"{}\", map.toString(), \"Empty map toString should return {}\");\n\n        // Test with one element\n        map.put(\"one\", 1);\n        assertEquals(\"{one=1}\", map.toString(), \"Map with one element toString should return {one=1}\");\n\n        // Test with multiple elements\n        map.put(\"two\", 2);\n        map.put(\"three\", 3);\n        String resultToString = map.toString();\n        assertTrue(resultToString.startsWith(\"{\") && resultToString.endsWith(\"}\"),\n                \"toString should be enclosed with {}\");\n        assertTrue(resultToString.contains(\"one=1\"), \"toString should contain one=1\");\n        assertTrue(resultToString.contains(\"two=2\"), \"toString should contain two=2\");\n        assertTrue(resultToString.contains(\"three=3\"), \"toString should contain three=3\");\n        assertTrue(resultToString.contains(\", \"), \"toString should contain elements separator\");\n        assertEquals(3, resultToString.split(\", \").length, \n                \"toString should contain the right amount of elements\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        NonBlockingHashMap<String, String> map = new NonBlockingHashMap<>();\n        map.put(\"key1\", \"value1\");\n        map.put(\"key2\", \"value2\");\n        map.put(\"key3\", \"value3\");\n\n        String result = map.toString();\n        assertTrue(result.contains(\"key1=value1\"));\n        assertTrue(result.contains(\"key2=value2\"));\n        assertTrue(result.contains(\"key3=value3\"));\n        assertTrue(result.startsWith(\"{\"));\n        assertTrue(result.endsWith(\"}\"));\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        NonBlockingHashMap<Integer, String> map = new NonBlockingHashMap<>();\n        assertEquals(\"{}\", map.toString(), \"Empty map should return {}\");\n\n        map.put(1, \"one\");\n        assertEquals(\"{1=one}\", map.toString(), \"Map with one element should return proper string representation\");\n\n        map.put(2, \"two\");\n        String result = map.toString();\n        boolean condition = \"{1=one, 2=two}\".equals(result) || \"{2=two, 1=one}\".equals(result);\n        assertTrue(condition, \"Map with two elements should return correct string representation regardless of order\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n\n    @Test\n    public void toStringTest() {\n        NonBlockingHashMap<Integer, String> map = new NonBlockingHashMap<>();\n        map.put(1, \"One\");\n        map.put(2, \"Two\");\n        map.put(3, \"Three\");\n        \n        String expected = \"{1=One, 2=Two, 3=Three}\";\n        String actual = map.toString();\n\n        // Strict ordering is not guaranteed, so we must test for each entry\n        assertTrue(actual.startsWith(\"{\") && actual.endsWith(\"}\"), \"String should start with '{' and end with '}'\");\n        assertTrue(actual.contains(\"1=One\"), \"String should contain '1=One'\");\n        assertTrue(actual.contains(\"2=Two\"), \"String should contain '2=Two'\");\n        assertTrue(actual.contains(\"3=Three\"), \"String should contain '3=Three'\");\n        assertEquals(3, actual.split(\", \").length, \"String should contain three entries\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingHashMapTest {\n    @Test\n    public void toStringTest() {\n        NonBlockingHashMap<String, String> map = new NonBlockingHashMap<>();\n        assertEquals(\"{}\", map.toString(), \"Empty map should return {}\");\n\n        map.put(\"key1\", \"value1\");\n        assertEquals(\"{key1=value1}\", map.toString(), \"Map with one element should return {key1=value1}\");\n\n        map.put(\"key2\", \"value2\");\n        String result = map.toString();\n        assertTrue(result.equals(\"{key1=value1, key2=value2}\") || result.equals(\"{key2=value2, key1=value1}\"), \n                   \"Map with two elements should return {key1=value1, key2=value2} or {key2=value2, key1=value1}\");\n        \n        map.put(\"(this Map)\", \"self reference\");\n        result = map.toString();\n        assertTrue(result.contains(\"(this Map)=(this Map)\"), \"Map containing self reference should show (this Map)\");\n    }\n}"
    ]
}