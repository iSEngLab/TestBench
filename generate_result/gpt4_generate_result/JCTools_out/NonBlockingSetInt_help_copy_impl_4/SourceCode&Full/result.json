{
    "project_name": "JCTools",
    "file_name": "NonBlockingSetInt.java",
    "relative_path": "JCTools/jctools-core/src/main/java/org/jctools/maps/NonBlockingSetInt.java",
    "execute_path": "JCTools",
    "package": "org.jctools.maps",
    "docstring": null,
    "source_code": "// Help copy this one word.  State Machine.\n// (1) If not \"made immutable\" in the old array, set the sign bit to make\n//     it immutable.\n// (2) If non-zero in old array & zero in new, CAS new from 0 to copy-of-old\n// (3) If non-zero in old array & non-zero in new, CAS old to zero\n// (4) Zero in old, new is valid\n// At this point, old should be immutable-zero & new has a copy of bits\nprivate NBSI help_copy_impl( int i ) {\n  // Handle every 64th bit via using a nested array\n  NBSI old = this;          // The bit array being copied from\n  NBSI nnn = _new;          // The bit array being copied to\n  if( nnn == null ) return this; // Promoted already\n  int j = i;                // The bit index being added\n  while( (j&63) == 63 ) {   // Bit 64? (low 6 bits are all set)\n    old = old._nbsi64;      // Recurse\n    nnn = nnn._nbsi64;      // Recurse\n    j = j>>6;               // Strip off low 6 bits (all set)\n  }\n\n  // Transit from state 1: word is not immutable yet\n  // Immutable is in bit 63, the sign bit.\n  long bits = old._bits[j>>6];\n  while( bits >= 0 ) {      // Still in state (1)?\n    long oldbits = bits;\n    bits |= mask(63);       // Target state of bits: sign-bit means immutable\n    if( old.CAS( j>>6, oldbits, bits ) ) {\n      if( oldbits == 0 ) _copyDone.addAndGet(1);\n      break;                // Success - old array word is now immutable\n    }\n    bits = old._bits[j>>6]; // Retry if CAS failed\n  }\n\n  // Transit from state 2: non-zero in old and zero in new\n  if( bits != mask(63) ) {  // Non-zero in old?\n    long new_bits = nnn._bits[j>>6];\n    if( new_bits == 0 ) {   // New array is still zero\n      new_bits = bits & ~mask(63); // Desired new value: a mutable copy of bits\n      // One-shot CAS attempt, no loop, from 0 to non-zero.\n      // If it fails, somebody else did the copy for us\n      if( !nnn.CAS( j>>6, 0, new_bits ) )\n        new_bits = nnn._bits[j>>6]; // Since it failed, get the new value\n      assert new_bits != 0;\n    }\n\n    // Transit from state 3: non-zero in old and non-zero in new\n    // One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)\n    if( old.CAS( j>>6, bits, mask(63) ) )\n      _copyDone.addAndGet(1); // One more word finished copying\n  }\n\n  // Now in state 4: zero (and immutable) in old\n\n  // Return the self bitvector for 'fluid' programming style\n  return this;\n}\n",
    "class_name": "NonBlockingSetInt",
    "method_name": "help_copy_impl",
    "arguments": [
        "int i"
    ],
    "generate_test": [
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.lang.reflect.Method;\n\npublic class NonBlockingSetIntTest {\n\n    private NonBlockingSetInt.NonBlockingSetIntHelper helper;\n\n    @BeforeEach\n    public void setup() {\n        helper = new NonBlockingSetInt.NonBlockingSetIntHelper();\n    }\n\n    @Test\n    public void help_copy_implTest() throws Exception {\n        // Setup helper class to access the package-private NBSI class\n        NonBlockingSetInt nbsi = new NonBlockingSetInt();\n        NonBlockingSetInt.NBSI oldNBSI = helper.initNBSI(nbsi, 64);\n        NonBlockingSetInt.NBSI newNBSI = helper.initNBSI(nbsi, 128);\n\n        // Assume the NBSI instances are setup and mutable\n        long initialBits = oldNBSI._help_getBits()[0];\n        helper.makeImmutable(oldNBSI, initialBits, 0);\n        \n        // newNBSI is zero-initialized\n        \n        // Perform the cop_possibley on index 0\n        helper.help_copy_impl(oldNBSI, newNBSI, 0);\n        \n        // Assertions\n        long oldBits = oldNBSI._help_getBits()[0];\n        long newBits = newNBSI._help_getBits()[0];\n        \n        // (1) Check sign bit set for immutable\n        assertEquals(Long.MIN_VALUE, oldBits & Long.MIN_VALUE);\n        // (2) Check that the bits were copied\n        assertEquals(initialBits & Long.MAX_VALUE, newBits & Long.MAX_VALUE);\n        // (3) Assert old bits set to zero if non-zero and new is non-zero\n        helper.makeNonZero(oldNBSI, oldBits, 0);\n        long modifiedOldBits = oldNBSI._help_getBits()[0];\n        assertTrue(modifiedOldBits != Long.MIN_VALUE && modifiedOldBits != 0);\n        helper.help_copy_impl(oldNBSI, newNBSI, 0);\n        oldBits = oldNBSI._help_getBits()[0];\n        assertEquals(Long.MIN_VALUE, oldBits);\n        \n        // (4) Now, any add/rm to the new NBSI should interact with non-zero bits\n        assertTrue(newNBSI.add(1)); // Add a bit in the new NBSI\n        assertFalse(oldNBSI.contains(1)); // Ensure the old NBSI is not affected.\n    }\n    \n    // Helper method to set up a new NBSI with a specific bit set\n    static NonBlockingSetInt.NBSI setupNBSIWithBitSet(NonBlockingSetInt nbsi, int i, long value) throws Exception {\n        // Assuming that NBSI class has a public constructor for testing purposes\n        NonBlockingSetInt.NBSI internalNBSI = nbsi.new NBSI(i, null, nbsi);\n        internalNBSI._help_setBits(value);\n        return internalNBSI;\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nclass NonBlockingSetIntTest {\n    @Test\n    public void help_copy_implTest() {\n        NonBlockingSetInt set = new NonBlockingSetInt();\n        NonBlockingSetInt.NBSI nbsi = set._nbsi;\n        \n        // call help_copy_impl to simulate copy process\n        \n        // check if _new field is null, indicating no promotion yet\n        assertNull(nbsi._new, \"New NBSI should initially be null\");\n\n        // artificially initiate a resize by setting the _new field to a new NBSI instance\n        nbsi._new = new NonBlockingSetInt.NBSI(127, new ConcurrentAutoTable(), set);\n        \n        // ensure that the new NBSI is not null (resize has occurred)\n        assertNotNull(nbsi._new, \"New NBSI should not be null after resize\");\n\n        // manually set the original bits to a non-zero value and make it immutable\n        nbsi.CAS(0, 0, -1);\n\n        // help copy a bit that's not already copied\n        int i = 0;\n        nbsi.help_copy_impl(i);\n\n        // after helping copy, ensure the old bits were made immutable\n        assertTrue(nbsi._bits[0] < 0, \"Old bits should be made immutable after copying\");\n\n        // ensure that the new bits have been copied over from old bits\n        long newBits = nbsi._new._bits[0];\n        boolean notCopied = (newBits == 0);\n        assertFalse(notCopied, \"New bits should be non-zero after copying\");\n\n        // Confirm count is correctly incremented\n        AtomicInteger copyDone = nbsi._copyDone;\n        assertEquals(1, copyDone.get(), \"Counter for copied bits should increment\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.Field;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NonBlockingSetIntTest {\n\n    // Set up reflection to access private fields for the test\n    private static Field getPrivateField(Class<?> clazz, String fieldName) throws NoSuchFieldException {\n        Field field = clazz.getDeclaredField(fieldName);\n        field.setAccessible(true);\n        return field;\n    }\n\n    // Utility function to inject values in private fields\n    private static void setPrivateField(Object obj, Field field, Object value) throws IllegalAccessException {\n        field.set(obj, value);\n    }\n\n    // To access and control concurrent counters\n    private static void setAtomicIntegerField(AtomicInteger atomicField, int value) {\n        atomicField.set(value);\n    }\n\n    // Method to initialize the test conditions for NBSI object\n    private NonBlockingSetInt.NBSI initializeForTest(int bitSize) {\n        NonBlockingSetInt nonBlockingSetInt = new NonBlockingSetInt();\n        NonBlockingSetInt.NBSI nbsiOld = new NonBlockingSetInt.NBSI(bitSize, new ConcurrentAutoTable(), nonBlockingSetInt);\n        NonBlockingSetInt.NBSI nbsiNew = new NonBlockingSetInt.NBSI(bitSize, new ConcurrentAutoTable(), nonBlockingSetInt);\n        nbsiOld._new = nbsiNew; // Link old NBSI to the new one for copying\n        return nbsiOld;\n    }\n\n    @Test\n    public void help_copy_implTest() throws NoSuchFieldException, IllegalAccessException {\n        // Bit size chosen to allow easy testing\n        int bitSize = 64;\n        // Initialize an NBSI object for testing\n        NonBlockingSetInt.NBSI nbsiOld = initializeForTest(bitSize);\n\n        // Set private fields to test various conditions\n        Field copyDoneField = getPrivateField(NonBlockingSetInt.NBSI.class, \"_copyDone\");\n        Field bitsField = getPrivateField(NonBlockingSetInt.NBSI.class, \"_bits\");\n        long[] bits = new long[bitSize / Long.SIZE];\n\n        // Replace bits and copy counters in old and new NBSIs\n        for (int i = 0; i < bits.length; i++) {\n            bits[i] = i % 2 == 0 ? i : 0; // Alternate bit patterns for test\n        }\n        setPrivateField(nbsiOld, bitsField, bits.clone());\n        setPrivateField(nbsiOld._new, bitsField, bits.clone());\n        setAtomicIntegerField((AtomicInteger) copyDoneField.get(nbsiOld), 0);\n\n        // Test the copying process\n        for (int i = 0; i < bitSize; i++) {\n            NonBlockingSetInt.NBSI resultNbsi = nbsiOld.help_copy_impl(i);\n\n            // Assertions\n            long expectedBits = bits[i / Long.SIZE] | (1L << 63); // The sign bit should be set\n            long[] actualOldBits = (long[]) bitsField.get(resultNbsi);\n            long[] actualNewBits = (long[]) bitsField.get(resultNbsi._new);\n            assertNotNull(resultNbsi._new, \"New NBSI should not be null after copying\");\n            assertEquals(expectedBits, actualOldBits[i / Long.SIZE], \"Old bits should have the sign bit set at index \" + i);\n            // New bits can either be same as old (if non-zero) or having only sign bit set (if initial bit was zero)\n            assertTrue((actualNewBits[i / Long.SIZE] == expectedBits && (bits[i / Long.SIZE] != 0)) || (actualNewBits[i / Long.SIZE] == (1L << 63) && bits[i / Long.SIZE] == 0),\n                      \"New bits should be properly copied from old bits at index \" + i);\n        }\n\n        // Assert that the entire bit set is copied\n        int copyDone = ((AtomicInteger) copyDoneField.get(nbsiOld)).get();\n        assertEquals(bitSize, copyDone, \"All the bits should be copied\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n\n    // A helper method to create a NonBlockingSetInt with a known state for testing\n    private NonBlockingSetInt createNonBlockingSetIntWithState(int containedValue) {\n        NonBlockingSetInt set = new NonBlockingSetInt();\n        set.add(containedValue);\n        return set;\n    }\n\n    @Test\n    public void help_copy_implTest() {\n        // Setup initial conditions for the test\n        NonBlockingSetInt set = createNonBlockingSetIntWithState(42); // Contains the value 42\n        NonBlockingSetInt.NBSI nbsi = set._nbsi;\n\n        // Invoke the method under test\n        nbsi.help_copy_impl(42);\n\n        // This specific test case can be improved. Full and accurate tests would require\n        // reflecting into NonBlockingSetInt/NBSI internals, which are private,\n        // so this snippet is to also indicate this limitation.\n\n        // Due to the complexity and the nature of concurrent behavior in the help_copy_impl method,\n        // ensuring the state of the array would require accessing private members of NBSI.\n        // Assumptions can be made that if no exception was thrown the basic behavior is correct.\n        // Further behavioral testing would typically involve checking the internal states after the copy,\n        // which is not directly accessible here.\n\n        // Validate outcomes (expected results), normally you would test for specific outcomes,\n        // but without proper access, we are limited to not encountering exceptions, implying a successful run.\n        assertDoesNotThrow(() -> nbsi.help_copy_impl(42));\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n    @Test\n    public void help_copy_implTest() {\n        NonBlockingSetInt nbsi = new NonBlockingSetInt();\n\n        // Simulate condition (1) where the word is not immutable\n        // and expectation is to set the sign bit to make it immutable.\n        int testIndexImmutable = 0; // Use the first index (0) for test\n        NBSI privateNbsi = nbsi._nbsi; // Accessing private field for testing purposes\n        NBSI result = privateNbsi.help_copy_impl(testIndexImmutable);\n        assertTrue(result == privateNbsi, \"Method should return 'this' after making word immutable\");\n\n        // Make sure sign bit is set (bit is immutable)\n        long word = privateNbsi._bits[testIndexImmutable >> 6];\n        assertTrue(word < 0, \"Sign bit should be set to make the word immutable\");\n\n        // Simulate condition (2) where new array is zero and old array is non-zero.\n        // create new instance to have a clean '._new' field\n        NonBlockingSetInt nbsiCondition2 = new NonBlockingSetInt();\n        privateNbsi = nbsiCondition2._nbsi;\n        privateNbsi._bits[testIndexImmutable >> 6] |= 1; // Set a non-zero bit in old\n        privateNbsi.CAS_new(new NBSI(privateNbsi._bits.length, new ConcurrentAutoTable(), nbsiCondition2)); // Set a new NBSI array\n        result = privateNbsi.help_copy_impl(testIndexImmutable);\n        assertTrue(result == privateNbsi, \"Method should return 'this' after successful copy\");\n\n        // Simulate condition (3) where both old and new arrays are non-zero.\n        // Expectation is to CAS the old to 0 but immutable.\n        // Not easily testable without exposing more internal state or concurrency\n\n        // Test condition (4), where the old is immutable and zero.\n        // The copy should already be done and immediate return of 'this' expected.\n        NonBlockingSetInt nbsiCondition4 = new NonBlockingSetInt();\n        privateNbsi = nbsiCondition4._nbsi;\n        NBSI newNbsiCondition4 = new NBSI(privateNbsi._bits.length, new ConcurrentAutoTable(), nbsiCondition4);\n        privateNbsi._bits[testIndexImmutable >> 6] = Long.MIN_VALUE; // Set old array bit to immutable zero\n        privateNbsi.CAS_new(newNbsiCondition4); // Set a new NBSI array\n        result = privateNbsi.help_copy_impl(testIndexImmutable);\n        assertTrue(result == privateNbsi, \"Expected 'this' return since the old is immutable and zero\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n\n    @Test\n    public void help_copy_implTest() {\n        NonBlockingSetInt set = new NonBlockingSetInt();\n        int indexToCopy = 42; // Example index to copy\n\n        // Add an entry to the set to simulate that there is something to copy\n        set.add(indexToCopy);\n\n        // Accessing private inner class, we need to work around it\n        // If NBSI class is not visible, you should create an instance some way,\n        // e.g. via reflection or a factory method provided by NonBlockingSetInt\n        NonBlockingSetInt.NBSI original = set._nbsi;\n        \n        // Simulate a resize event to have a new NBSI instance\n        original.CAS_new(new NonBlockingSetInt.NBSI(original._bits.length * 2, original._size, set));\n        \n        // Check the presence of the entry in the original\n        assertTrue(original.contains(indexToCopy));\n\n        // Perform the help_copy operation\n        NonBlockingSetInt.NBSI copyResult = original.help_copy_impl(indexToCopy);\n\n        // The copy operation should return the same set instance (i.e., this) for fluid style\n        assertSame(original, copyResult);\n\n        // Check if the entry is now present in the new NBSI instance\n        assertTrue(original._new.contains(indexToCopy));\n\n        // Check if the entry has been marked immutable in the original after copying\n        int bitIndex = (indexToCopy >> 6);\n        long bitMask = 1L << (indexToCopy & 63);\n        assertTrue((original._bits[bitIndex] & bitMask) == 0, \"Should be zero as the bit should be copied already and set mutable in the new instance.\");\n\n        // Check the immutability flag of the bit in old array (it should be set)\n        assertTrue(original._bits[bitIndex] < 0, \"The bit should be immutable in the old array.\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n\n    private final int TEST_INDEX = 64; // Test index (64 should invoke nested array handling)\n\n    @Test\n    public void help_copy_implTest() {\n        NonBlockingSetInt nbsi = new NonBlockingSetInt();\n        NBSI privateNbsi = nbsi.new NBSI(TEST_INDEX, new ConcurrentAutoTable(), nbsi);\n\n        // Set up initial conditions for helpCopyImpl\n        // Making sure the bit at TEST_INDEX is not set initially\n        assertFalse(privateNbsi.contains(TEST_INDEX), \"Bit should not be set initially\");\n\n        // Add the bit, which should internally trigger the help_copy_impl process\n        privateNbsi.add(TEST_INDEX);\n\n        // Check if the bit is now set\n        assertTrue(privateNbsi.contains(TEST_INDEX), \"Bit should be set after calling add\");\n\n        // Set new NBSI to non-null to simulate copying process\n        NBSI newNbsi = privateNbsi.new NBSI(TEST_INDEX, new ConcurrentAutoTable(), nbsi);\n        privateNbsi.CAS_new(newNbsi);\n\n        // Carry out the help copying step, which should not affect the bit's presence\n        privateNbsi.help_copy_impl(TEST_INDEX);\n\n        // Check if the bit is still set after help copying\n        assertTrue(privateNbsi.contains(TEST_INDEX), \"Bit should still be set after help copying\");\n\n        // Invoke the help_copy_impl directly which should now affect the new NBSI\n        privateNbsi.help_copy_impl(TEST_INDEX);\n        // The bit should be copied to the new NBSI, so it must be present there\n        assertTrue(newNbsi.contains(TEST_INDEX), \"Bit should be copied to new NBSI after help copy impl\");\n\n        // Check if size is incremented correctly - it should be 1 as we only added one bit\n        assertEquals(1, privateNbsi.size(), \"Size should be incremented to 1 after adding a bit\");\n\n        // Clean up by making the new NBSI active\n        nbsi.CAS_nbsi(privateNbsi, newNbsi);\n\n        // After clean up, ensure the current active NBSI contains the test bit\n        assertTrue(nbsi.contains(TEST_INDEX), \"Active NBSI should contain the test bit after clean up\");\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class NonBlockingSetIntTest {\n    @Test\n    public void help_copy_implTest() {\n        // Initialize an instance of NonBlockingSetInt\n        NonBlockingSetInt set = new NonBlockingSetInt();\n        \n        // Use reflection to access and manipulate private members of NonBlockingSetInt\n        NBSI oldNBSI = set._nbsi;\n        oldNBSI._bits[0] = 0b001; // Set some initial state for testing\n        \n        // Create a new NBSI instance to simulate the \"_new\" array during copying\n        NBSI newNBSI = new NBSI(oldNBSI._bits.length * 2, new ConcurrentAutoTable(), set);\n        \n        // Atomically set the \"_new\" field to simulate the resize event\n        oldNBSI.CAS_new(newNBSI);\n        \n        // Simulate a situation where oldNBSI needs to help with the copy to newNBSI\n        int bitIndex = 0; // We'll work with the first bit for this simple case\n        \n        // Call the method under test\n        NBSI result = oldNBSI.help_copy_impl(bitIndex);\n        \n        // Assertions:\n        // (1) The result should point to the oldNBSI after helping with the copy,\n        //     as per the 'fluid' programming style mentioned in the comments.\n        assertSame(oldNBSI, result);\n\n        // (2) The old bits should now be immutable (sign bit should be set)\n        assertTrue((oldNBSI._bits[0] & NBSI.mask(63)) != 0);\n\n        // (3) The new NBSI should have copied the initial state minus the immutability bit\n        assertEquals(oldNBSI._bits[0] & ~NBSI.mask(63), newNBSI._bits[0]);\n\n        // (4) If old was non-zero and new became non-zero, old should have been CAS to zero\n        if ((oldNBSI._bits[0] & ~NBSI.mask(63)) != 0) {\n            assertEquals(NBSI.mask(63), oldNBSI._bits[0]);\n        }\n\n        // (5) The `_copyDone` counter should have been incremented adequately\n        assertEquals(1, oldNBSI._copyDone.get());\n        \n        // Additional checks for complete state transitions can go here\n        // ... Additional test cases to cover all paths within `help_copy_impl` should follow\n    }\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class NonBlockingSetIntTest {\n    private NonBlockingSetInt nbSet;\n    private NonBlockingSetInt.NBSI nbsi;\n    private final int initialCapacity = 64; // Initial capacity should be a power of 2\n\n    @BeforeEach\n    public void setUp() {\n        nbSet = new NonBlockingSetInt();\n        nbsi = nbSet._nbsi;\n    }\n\n    @Test\n    public void help_copy_implMakesWordImmutableWhenMutable() {\n        // Starting with a \"mutable\" word, ensure it becomes immutable\n        nbsi._bits[0] = 0; // Assume 0 is a mutable word\n        nbsi._new = nbsi; // Simulate a new array being present\n        NBSI updatedNbsi = nbsi.help_copy_impl(0);\n        long expectedImmutableFlag = 1L << 63; // Immutable flag mask\n        assertTrue((updatedNbsi._bits[0] & expectedImmutableFlag) != 0, \"Word should be made immutable\");\n    }\n\n    @Test\n    public void help_copy_implCopiesNonZeroWord() {\n        // Work with non-zero word; copy to new when new is zero\n        long nonZero = 42; // Some arbitrary non-zero value\n        nbsi._bits[0] = nonZero;\n        NBSI newNbsi = new NonBlockingSetInt.NBSI(initialCapacity, new ConcurrentAutoTable(), nbSet);\n        nbsi._new = newNbsi;\n        NBSI updatedNbsi = nbsi.help_copy_impl(0);\n        assertEquals(nonZero & ~NonBlockingSetInt.NBSI.mask(63), newNbsi._bits[0], \"Non-zero word should be copied to new\");\n    }\n\n    @Test\n    public void help_copy_implHandlesZeroInOld() {\n        // Handle zero in old; new is valid (unchanged)\n        nbsi._bits[0] = 0; // Zero in old\n        NBSI newNbsi = new NonBlockingSetInt.NBSI(initialCapacity, new ConcurrentAutoTable(), nbSet);\n        long newBits = 123; // Some non-zero bits to simulate \"new state is valid\"\n        newNbsi._bits[0] = newBits;\n        nbsi._new = newNbsi;\n        nbsi._bits[0] = NonBlockingSetInt.NBSI.mask(63); // Immutable zero in old\n        NBSI updatedNbsi = nbsi.help_copy_impl(0);\n        assertEquals(newBits, newNbsi._bits[0], \"New bits should remain unchanged when old is zero\");\n    }\n\n    @Test\n    public void help_copy_implHandlesNonZeroInOldAndNew() {\n        // Handle non-zero in both old and new\n        long oldBits = 0b101;\n        long newBits = 0b010;\n        nbsi._bits[0] = oldBits;\n        NBSI newNbsi = new NonBlockingSetInt.NBSI(initialCapacity, new ConcurrentAutoTable(), nbSet);\n        newNbsi._bits[0] = newBits;\n        nbsi._new = newNbsi;\n        nbsi.help_copy_impl(0);\n        assertTrue((nbsi._bits[0] & NonBlockingSetInt.NBSI.mask(63)) != 0, \"Old bits should have become immutable\");\n        assertEquals(newBits, newNbsi._bits[0], \"New bits should not be changed\");\n    }\n\n    // Additional tests would be needed to thoroughly test the concurrency aspects,\n    // and to verify that the _copyDone counter is incremented correctly, etc.\n}",
        "package org.jctools.maps;\n\nimport org.junit.jupiter.api.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass NBSIHelper {\n    static NBSI createNBSIWithMockedBits(NonBlockingSetInt parent) {\n        int max_elem = 63;\n        ConcurrentAutoTable ctr = new ConcurrentAutoTable();\n        NBSI nbsi = new NBSI(max_elem, ctr, parent);\n        nbsi._bits[0] = 0;\n        return nbsi;\n    }\n}\n\npublic class NonBlockingSetIntTest {\n    private NonBlockingSetInt set;\n    private NBSI nbsi;\n\n    @BeforeEach\n    public void setUp() {\n        set = new NonBlockingSetInt();\n        nbsi = NBSIHelper.createNBSIWithMockedBits(set);\n    }\n    \n    @Test\n    public void help_copy_implTest() {\n        // Set up a fresh bit array to copy from\n        NBSI old = nbsi;\n\n        // Initialize _new with a shallow copy of the old NBSI\n        NBSI nnn = new NBSI(63, old._size, set);\n        old._new = nnn;\n        \n        // Initialize the copy counters\n        old._copyIdx = new AtomicInteger();\n        old._copyDone = new AtomicInteger();\n\n        // Test the copy of a non-zero bit from old to new\n        old._bits[0] = 42; // arbitrary non-zero value\n        nnn.help_copy_impl(0);\n\n        // Expect new bits to be the same, old bits to be immutable\n        assertEquals(old._bits[0] | NBSI.mask(63), old._bits[0], \"Old bits should be made immutable\");\n        assertEquals(old._bits[0] & ~NBSI.mask(63), nnn._bits[0], \"New bits should be a copy of old bits without immutability\");\n\n        // Test that immutable bits are not copied but just marked done\n        int beforeCount = old._copyDone.get();\n        nnn.help_copy_impl(0);\n        int afterCount = old._copyDone.get();\n        assertEquals(beforeCount + 1, afterCount, \"Copy done should be incremented for immutable old bits\");\n    }\n}"
    ]
}