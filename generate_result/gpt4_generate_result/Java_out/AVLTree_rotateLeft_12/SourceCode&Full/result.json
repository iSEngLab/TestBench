{
    "project_name": "Java",
    "file_name": "AVLTree.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/AVLTree.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.trees",
    "docstring": null,
    "source_code": "private Node rotateLeft(Node a) {\n    Node b = a.right;\n    b.parent = a.parent;\n\n    a.right = b.left;\n\n    if (a.right != null) {\n        a.right.parent = a;\n    }\n\n    b.left = a;\n    a.parent = b;\n\n    if (b.parent != null) {\n        if (b.parent.right == a) {\n            b.parent.right = b;\n        } else {\n            b.parent.left = b;\n        }\n    }\n\n    setBalance(a, b);\n\n    return b;\n}\n",
    "class_name": "AVLTree",
    "method_name": "rotateLeft",
    "arguments": [
        "Node a"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree avlTree;\n    private AVLTree.Node parent;\n\n    @BeforeEach\n    public void setUp() {\n        avlTree = new AVLTree();\n        parent = avlTree.new Node(1, null); // Assuming this constructor is accessible\n        parent.left = avlTree.new Node(2, parent);\n        parent.right = avlTree.new Node(3, parent);\n        parent.right.right = avlTree.new Node(4, parent.right);\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        AVLTree.Node oldRight = parent.right;\n        AVLTree.Node rotated = avlTree.rotateLeft(parent);\n\n        assertEquals(oldRight, rotated, \"The right child must become new parent after left rotation.\");\n        assertEquals(parent, rotated.left, \"Original parent must become left child of new parent after left rotation.\");\n        assertNull(parent.right, \"Original parent's right child must be null after left rotation.\");\n        assertEquals(oldRight.right, rotated.right, \"Right child of new parent should remain the same.\");\n\n        // If rotateLeft has to handle balance correction and parent connection, we can test those as well.\n        assertNull(rotated.parent, \"After rotation, new root should not have a parent\");\n        assertNotNull(rotated.left.parent, \"Rotated left child should have the new parent set correctly\");\n        assertEquals(rotated, rotated.left.parent, \"Rotated left child's parent should be the new root node\");\n\n        // Check balance and parent-child consistency\n        assertEquals(0, rotated.balance, \"The balance of the new root should be corrected to 0.\");\n        assertEquals(-1, parent.balance, \"The balance of the old root (now left child) should be corrected to -1.\");\n        assertEquals(parent, rotated.left, \"The parent of the left child should be the new root node after rotation.\");\n        assertEquals(3, rotated.key, \"Check the key of the new root node after rotation.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    @Test\n    public void rotateLeftTest() {\n        AVLTree tree = new AVLTree();\n\n        // manually constructing a simple tree\n        AVLTree.Node root = tree.new Node(1, null);\n        AVLTree.Node node2 = tree.new Node(2, root);\n        root.right = node2;\n        AVLTree.Node node3 = tree.new Node(3, node2);\n        node2.right = node3;\n\n        // Set up initial heights and balances, as they are normally maintained during insertion\n        tree.reheight(root);\n        tree.setBalance(root, node2, node3);\n        \n        // Perform the rotateLeft operation on the root (1) which should result in node (2) being the new root.\n        AVLTree.Node newRoot = tree.rotateLeft(root);\n\n        // newRoot should be node2\n        assertNotNull(newRoot);\n        assertEquals(node2, newRoot);\n        \n        // newRoot's left child should now be the old root\n        assertEquals(root, newRoot.left);\n        \n        // The root's right child should now be null after rotation\n        assertNull(root.right);\n        \n        // The new root's parent should be null after rotation\n        assertNull(newRoot.parent);\n        \n        // The root's new parent should be the new root after rotation\n        assertEquals(newRoot, root.parent);\n        \n        // node3 should remain the right child of the new root\n        assertEquals(node3, newRoot.right);\n        \n        // Check balances and heights to make sure they've been updated properly\n        tree.reheight(root);  // as rotateLeft doesn't update heights\n        tree.setBalance(root, newRoot);\n        assertEquals(0, newRoot.balance);\n        assertEquals(-1, root.balance);  // assuming height of null is -1 and node3 is still here so root's balance should be -1\n        assertEquals(0, newRoot.height); // wherever it is in the tree it is the local root so its height is 0\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n    @Test\n    public void rotateLeftTest() {\n        AVLTree tree = new AVLTree();\n        tree.insert(1);\n        tree.insert(2);\n        tree.insert(3); // This should cause a left rotation on the root\n\n        AVLTree.Node root = tree.root; \n\n        assertEquals(2, root.key, \"Root key after rotation should be 2\");\n        assertNotNull(root.left, \"Left child of root should not be null after rotation\");\n        assertEquals(1, root.left.key, \"Left child of root should have key of 1\");\n        assertNotNull(root.right, \"Right child of root should not be null after rotation\");\n        assertEquals(3, root.right.key, \"Right child of root should have key of 3\");\n\n        assertNull(root.parent, \"Root should not have a parent after rotation\");\n        assertEquals(root, root.left.parent, \"Left child's parent should be the root after rotation\");\n        assertEquals(root, root.right.parent, \"Right child's parent should be the root after rotation\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    @Test\n    public void rotateLeftTest() {\n        AVLTree tree = new AVLTree();\n\n        // Inserting nodes\n        tree.insert(1);\n        tree.insert(2);\n        tree.insert(3); // This should trigger a rotateLeft due to insertion of a right-heavy situation\n\n        // Getting reference to root before rotation\n        AVLTree.Node root = tree.searchHelper(tree.getRoot(), 1);\n\n        // root should now be 2 and the root's left child should be 1\n        assertEquals(2, root.key);\n        assertNotNull(root.left);\n        assertEquals(1, root.left.key);\n\n        // Verification that the old root (1) is now the left child of new root (2)\n        AVLTree.Node leftChild = root.left;\n        assertEquals(root, leftChild.parent);\n\n        // The left child should not have a left child of its own since it's a leaf node after rotation\n        assertNull(leftChild.left);\n\n        // Left child's right child should be the previous right child of old root before rotation\n        assertNotNull(leftChild.right);\n        assertEquals(3, leftChild.right.key);\n\n        // Verification that the old root's right child is now handling the new right child correctly\n        AVLTree.Node rightChildOfLeftChild = leftChild.right;\n        assertEquals(leftChild, rightChildOfLeftChild.parent);\n        assertNull(rightChildOfLeftChild.left);\n        assertNull(rightChildOfLeftChild.right);\n    }\n\n    // Dummy method to expose the root for testing purposes\n    // Note: This should ideally be in the AVLTree class\n    public AVLTree.Node getRoot() {\n        return this.root;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    @Test\n    public void rotateLeftTest() {\n        // Set up the structure\n        AVLTree tree = new AVLTree();\n        tree.insert(1);\n        tree.insert(2); // This will be our node 'a'\n        tree.insert(4); // Node that will be 'b'\n\n        // Search the nodes \n        AVLTree.Node nodeA = tree.searchHelper(tree.root, 2);\n        AVLTree.Node nodeB = tree.searchHelper(tree.root, 4);\n\n        // Rotate Left\n        AVLTree.Node result = tree.rotateLeft(nodeA);\n\n        // Validate the structure is correctly rotated\n        assertEquals(nodeB, result, \"The returned node must be the new root after rotation.\");\n        assertEquals(nodeA, result.left, \"Node A must be the left child of Node B after rotation.\");\n\n        // Validate new parent relationships\n        assertNull(nodeB.parent, \"Parent of new root Node B should be null.\");\n        assertEquals(nodeB, nodeA.parent, \"Parent of Node A must be Node B after rotation.\");\n\n        // Validate no change in subtree nodes other than right child of original node A (which is now Node B)\n        assertNull(nodeA.right, \"Right child of node A must be null after its right child is promoted.\");\n        assertNull(nodeA.left, \"Left child of node A must still be null.\");\n        \n        // If tree structure had more nodes in the original right sub-tree of Node A (node that becomes B),\n        // those should remain unchanged. This code section assumes we had a right child for Node B (originally Node A's right),\n        // which would now need to be Node A's right child after rotation.\n        //Example:\n        //tree.insert(5);\n        //assertEquals(nodeX, nodeA.right, \"Right child of node A should be nodeX after rotation.\")\n        \n        //Returning the whole test case to show up in an IDE \n        assertEquals(\"package com.thealgorithms.datastructures.trees;\\n\\nimport org.junit.jupiter.api.*;\\nimport static org.junit.jupiter.api.Assertions.*;\\n\\npublic class AVLTreeTest {\\n\\n    @Test\\n    public void rotateLeftTest() {\\n        // Set up the structure\\n        AVLTree tree = new AVLTree();\\n        tree.insert(1);\\n        tree.insert(2); // This will be our node 'a'\\n        tree.insert(4); // Node that will be 'b'\\n\\n        // Search the nodes\\n        AVLTree.Node nodeA = tree.searchHelper(tree.root, 2);\\n        AVLTree.Node nodeB = tree.searchHelper(tree.root, 4);\\n\\n        // Rotate Left\\n        AVLTree.Node result = tree.rotateLeft(nodeA);\\n\\n        // Validate the structure is correctly rotated\\n        assertEquals(nodeB, result);\\n        assertEquals(nodeA, result.left);\\n\\n        // Validate new parent relationships\\n        assertNull(nodeB.parent);\\n        assertEquals(nodeB, nodeA.parent);\\n\\n        // Validate no change in subtree nodes\\n        assertNull(nodeA.right);\\n        assertNull(nodeA.left);\\n    }\\n}\\n\", \"Checking the test\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    @Test\n    public void rotateLeftTest() {\n        // Setup AVL tree with a simple structure where rotateLeft will occur\n        AVLTree tree = new AVLTree();\n        tree.insert(1); // root\n        tree.insert(2); // right child of root, causes imbalance\n\n        // Perform rotateLeft on root node\n        AVLTree.Node newRoot = tree.rotateLeft(tree.root);\n\n        // Validate new structure of the tree\n        assertNotNull(newRoot);\n        assertEquals(2, newRoot.key, \"The new root should have the key of the previously right child.\");\n        assertNotNull(newRoot.left);\n        assertEquals(1, newRoot.left.key, \"The left child of the new root should have the key of the previously root.\");\n\n        // Check parent relationships are correctly updated\n        assertEquals(newRoot, newRoot.left.parent, \"The left child's parent should now be the new root.\");\n\n        // Check the balance factors are set correctly\n        assertEquals(0, newRoot.balance, \"After rotation, the new root balance should be 0.\");\n        assertEquals(0, newRoot.left.balance, \"After rotation, the left child balance should be 0.\");\n\n        // Validate left (previously root) node does not have any children, since it was a leaf before rotation\n        assertNull(newRoot.left.left, \"The left child of the left child (previously root) should be null.\");\n        assertNull(newRoot.left.right, \"The right child of the left child (previously root) should be null.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.AVLTree tree;\n    private Method rotateLeft;\n\n    @BeforeEach\n    public void setUp() throws NoSuchMethodException {\n        tree = new AVLTree.AVLTree();\n\n        rotateLeft = AVLTree.AVLTree.class.getDeclaredMethod(\"rotateLeft\", AVLTree.Node.class);\n        rotateLeft.setAccessible(true);\n    }\n\n    @Test\n    public void rotateLeftTest() throws Exception {\n        // Create the following BST\n        //       4\n        //        \\\n        //         5\n        //          \\\n        //           6\n        // The expected AVL tree after rotateLeft will be\n        //       5\n        //      / \\\n        //     4   6\n\n        tree.insert(4);\n        tree.insert(5);\n        tree.insert(6);\n\n        AVLTree.Node root = tree.getRoot();\n        AVLTree.Node rotatedRoot = (AVLTree.Node) rotateLeft.invoke(tree, root);\n\n        assertEquals(5, rotatedRoot.getKey());\n        assertEquals(4, rotatedRoot.getLeft().getKey());\n        assertEquals(6, rotatedRoot.getRight().getKey());\n        assertNull(rotatedRoot.getParent());\n\n        AVLTree.Node leftChild = rotatedRoot.getLeft();\n        assertEquals(root, leftChild);\n        assertEquals(rotatedRoot, leftChild.getParent());\n        assertNull(leftChild.getLeft());\n        assertNull(leftChild.getRight());\n\n        AVLTree.Node rightChild = rotatedRoot.getRight();\n        assertEquals(6, rightChild.getKey());\n        assertNull(rightChild.getLeft());\n        assertNull(rightChild.getRight());\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.AVLTree tree;\n    \n    @BeforeEach\n    public void setup() {\n        tree = new AVLTree.AVLTree();\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Setting up the tree\n        tree.insert(1);\n        tree.insert(2);\n        tree.insert(3); // This should cause a rotateLeft at node 1\n\n        // Accessing the private root field, assuming we can use reflection or make root package-private for testing.\n        AVLTree.AVLTree.Node root = tree.root;\n\n        // Checks if rotation happened correctly\n        assertEquals(2, root.key, \"Root key should be 2 after left rotation.\");\n        assertNotNull(root.left, \"Left child should not be null after left rotation.\");\n        assertEquals(1, root.left.key, \"Left child key should be 1 after left rotation.\");\n        assertNotNull(root.right, \"Right child should not be null after left rotation.\");\n        assertEquals(3, root.right.key, \"Right child key should be 3 after left rotation.\");\n\n        // Checking parents\n        assertNull(root.parent, \"Root parent should be null.\");\n        assertEquals(root, root.left.parent, \"Left child parent should be new root.\");\n        assertEquals(root, root.right.parent, \"Right child parent should be new root.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.AVLTree tree;\n    private AVLTree.Node root;\n\n    @BeforeEach\n    public void setUp() {\n        tree = new AVLTree();\n        root = tree.new Node(1, null);\n        tree.root = root;  // Let's say 1 is the root node\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Initial tree:\n        //       1\n        //         \\\n        //          2\n        AVLTree.Node node2 = tree.new Node(2, root);\n        root.right = node2;\n\n        // Performing a left rotation on root/node 1.\n        AVLTree.Node newRoot = tree.rotateLeft(root);\n\n        // After rotation, new root should be node 2, and node 1 should be left child of node 2.\n        assertEquals(node2, newRoot, \"Node 2 should be new root after left rotation.\");\n        assertEquals(root, node2.left, \"Node 1 should be left child of new root after left rotation.\");\n        assertNull(newRoot.parent, \"New root should not have a parent after rotation.\");\n        assertEquals(newRoot, root.parent, \"Parent of Node 1 should be new root after rotation.\");\n\n        // Check if rebalancing happened correctly.\n        int balanceRoot = root.balance;\n        int balanceNewRoot = newRoot.balance;\n        assertTrue(Math.abs(balanceRoot) <= 1, \"Balance factor of old root should be not be more than 1.\");\n        assertTrue(Math.abs(balanceNewRoot) <= 1, \"Balance factor of new root should be not be more than 1.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n    @Test\n    public void rotateLeftTest() {\n        AVLTree avlTree = new AVLTree();\n        avlTree.insert(1);\n        avlTree.insert(2); // This will be node 'a' in the rotateLeft.\n        avlTree.insert(3); // This will be node 'b' after rotateLeft.\n\n        // Apply rotateLeft directly as it's a private method (in the example,\n        // let's assume the visibility of rotateLeft has been changed to package-private for testing).\n        // Or we could use Reflection to access it if we need to test private method.\n        AVLTree.Node root = avlTree.root; // This is node 'a', which has key = 2.\n        assertNull(root.left); // Before rotation, root.left should be null.\n        AVLTree.Node rotatedRoot = avlTree.rotateLeft(root); // Perform the rotation.\n        \n        assertEquals(3, rotatedRoot.key); // After rotation, the root should be node 'b' which has key = 3.\n        assertEquals(root, rotatedRoot.left); // After rotation, root becomes the left child of rotatedRoot.\n        assertEquals(1, rotatedRoot.left.key); // Check the left child of original root to verify rotation.\n        assertNull(rotatedRoot.right); // After rotation, rotatedRoot.right should be null.\n        \n        // Check the parent linkage after rotation.\n        assertEquals(rotatedRoot, root.parent); // root's parent should now be the rotated root.\n        assertNull(rotatedRoot.parent); // The new root's parent should be null as it's the root of the tree.\n    }\n}"
    ]
}