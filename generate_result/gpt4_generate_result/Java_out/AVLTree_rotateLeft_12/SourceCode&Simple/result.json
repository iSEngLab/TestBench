{
    "project_name": "Java",
    "file_name": "AVLTree.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/AVLTree.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.trees",
    "docstring": null,
    "source_code": "private Node rotateLeft(Node a) {\n    Node b = a.right;\n    b.parent = a.parent;\n\n    a.right = b.left;\n\n    if (a.right != null) {\n        a.right.parent = a;\n    }\n\n    b.left = a;\n    a.parent = b;\n\n    if (b.parent != null) {\n        if (b.parent.right == a) {\n            b.parent.right = b;\n        } else {\n            b.parent.left = b;\n        }\n    }\n\n    setBalance(a, b);\n\n    return b;\n}\n",
    "class_name": "AVLTree",
    "method_name": "rotateLeft",
    "arguments": [
        "Node a"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.AVLTreeTestHelper avlTreeHelper;\n\n    @BeforeEach\n    public void setUp() {\n        avlTreeHelper = new AVLTree.AVLTreeTestHelper();\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Setup a minimal tree with a root and a right child\n        AVLTree.Node root = avlTreeHelper.new Node(1, null);\n        AVLTree.Node rightChild = avlTreeHelper.new Node(2, root);\n        root.right = rightChild;\n\n        // Perform the rotation\n        AVLTree.Node newRoot = avlTreeHelper.rotateLeft(root);\n\n        // Check the result of the rotation\n        assertEquals(rightChild, newRoot);\n        assertEquals(root, newRoot.left);\n        assertNull(newRoot.right);\n        assertEquals(newRoot, root.parent);\n        assertNull(newRoot.parent);\n    }\n\n    // Helper class to access the private methods of AVLTree for testing\n    public class AVLTreeTestHelper extends AVLTree {\n        public AVLTreeTestHelper() {\n            super();\n        }\n\n        public Node new Node(int k, Node p) {\n            return new Node(k, p);\n        }\n\n        public Node rotateLeft(Node n) {\n            return super.rotateLeft(n);\n        }\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.Node createNode(int key, AVLTree.Node parent) {\n        AVLTree.Node node = new AVLTree().new Node(key, parent);\n        return node;\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        AVLTree avlTree = new AVLTree();\n\n        // Creating nodes to set up the initial tree state.\n        AVLTree.Node parent = createNode(10, null);\n        AVLTree.Node a = createNode(5, parent);\n        AVLTree.Node b = createNode(15, a);\n        AVLTree.Node c = createNode(12, b);\n        AVLTree.Node d = createNode(18, b);\n\n        // Setting children to resemble a right-heavy tree that requires a left rotation.\n        a.right = b;\n        b.left = c;\n        b.right = d;\n        a.parent = parent; // To simulate that 'a' has a parent.\n        parent.right = a; // Assuming that 'parent' had 'a' as its right child.\n\n        // Performing the left rotation.\n        AVLTree.Node result = avlTree.rotateLeft(a);\n\n        // Assertions to verify the new tree structure is correct after rotation.\n        assertSame(b, result, \"The returned node should be the new root after rotation.\");\n        assertSame(a, b.left, \"'a' should now be the left child of 'b'.\");\n        assertSame(c, result.left.right, \"'c' should remain the left child of 'b'.\");\n        assertNull(a.right, \"'a' should now have no right child.\");\n        assertSame(a, c.parent, \"'c' should have 'a' as its new parent.\");\n        assertSame(parent, b.parent, \"'b' should have the same parent as 'a' had before rotation.\");\n\n        // Balance and height checks could be added if the 'setBalance' and respective fields are implemented.\n        // Example (depends on setBalance implementation):\n        // assertEquals(expectedBalanceA, a.balance, \"Balance of node 'a' should be updated.\");\n        // assertEquals(expectedBalanceB, b.balance, \"Balance of node 'b' should be updated.\");\n    }\n}\n",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n    private AVLTree avlTree;\n\n    @BeforeEach\n    public void setUp() {\n        avlTree = new AVLTree();\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Setting up the scenario: Creating a simple tree where node 'a' has right child 'b'\n        // and 'b' has no children. This is a situation where rotateLeft should be applied.\n\n        // Insert nodes to create a skewed tree which will force a left rotation.\n        avlTree.insert(1); // 'a' node\n        avlTree.insert(2); // 'b' node that will cause the left rotation of 'a'\n\n        // Accessing the private root of AVLTree using reflection to simulate the test\n        // conditions, as root is private and the rotateLeft method is also private.\n        Node root = null;\n        try {\n            java.lang.reflect.Field field = avlTree.getClass().getDeclaredField(\"root\");\n            field.setAccessible(true);\n            root = (Node) field.get(avlTree);\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            e.printStackTrace();\n        }\n\n        // Assuming the tree is built with the logic requiring a left rotation,\n        // 'a' is root and its right child is 'b'.\n        Node a = root;\n        Node b = a.right;\n\n        // Perform the rotation\n        avlTree.rotateLeft(a);\n\n        // Now, b should be the new root of the subtree.\n        assertEquals(b, a.parent);\n        assertEquals(a, b.left);\n\n        // The parent of b should still be null since it was the root's right child before rotation\n        assertNull(b.parent);\n\n        // Assert the children of a and b are correctly assigned\n        assertNull(b.right);\n        assertNull(a.right); // a.right was initially b.left, which was null\n\n        // If there are additional conditions or bookkeeping (like balance)\n        // needed by AVLTree, these should be tested as well.\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree avlTree;\n\n    @BeforeEach\n    public void setUp() {\n        avlTree = new AVLTree();\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Create nodes for test\n        AVLTree.Node parent = avlTree.new Node(3, null);\n        AVLTree.Node a = avlTree.new Node(1, parent);\n        AVLTree.Node b = avlTree.new Node(2, a);\n        AVLTree.Node c = avlTree.new Node(4, b);\n\n        // Manually link nodes to form the tree:\n        parent.left = a; \n        a.right = b;\n        b.left = c;\n\n        // Before rotation: Parent(3) <- a(1) -> b(2) <- c(4)\n\n        // Perform the rotation\n        AVLTree.Node result = avlTree.rotateLeft(a);\n\n        // Validate the structure after rotation\n        assertEquals(b, result, \"b should be the new root after rotation\");\n        assertEquals(c, b.left, \"c should be the left child of b\");\n        assertEquals(a, b.right, \"a should be the right child of b\");\n        assertNull(a.right, \"a should not have a right child after rotation\");\n        assertEquals(parent, result.parent, \"b's parent should be the same as a's old parent\");\n        assertEquals(b, parent.left, \"parent's left child should now be b\");\n        assertEquals(a, c.parent, \"c's new parent should be a\");\n\n        // Validate that the parent's child pointers are correctly updated\n        if (parent.right == a) {\n            fail(\"Parent's right child reference should not point to a\");\n        }\n        if (parent.left != b) {\n            fail(\"Parent's left child reference should point to b\");\n        }\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.Node createNode(int key, AVLTree.Node parent) {\n        return new AVLTree.Node(key, parent);\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Create nodes for the test\n        AVLTree avlTree = new AVLTree();\n        AVLTree.Node parent = createNode(1, null);\n        AVLTree.Node a = createNode(2, parent);\n        AVLTree.Node b = createNode(3, a);\n        AVLTree.Node c = createNode(4, b);\n\n        // Set up initial tree connections\n        parent.right = a;\n        a.right = b;\n        b.left = c;\n\n        // Execute rotateLeft operation\n        AVLTree.Node result = avlTree.rotateLeft(a);\n\n        // Assertions to verify the correct structure after rotation\n        // rootNode should now be node b\n        assertEquals(b, result);\n        \n        // a should become the left child of b\n        assertEquals(a, result.left);\n        assertEquals(result, a.parent);\n        \n        // c should remain the left child of b\n        assertEquals(c, result.left.right);\n        assertEquals(a, c.parent);\n        \n        // a's right child should be null \n        assertNull(a.right);\n\n        // b's parent should be parent\n        assertEquals(parent, b.parent);\n        \n        // parent's right child should now be b\n        assertEquals(b, parent.right);\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree tree;\n\n    @BeforeEach\n    public void setUp() {\n        tree = new AVLTree();\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Set up the context for the test\n        AVLTree.Node parent = tree.new Node(1, null);\n        AVLTree.Node a = tree.new Node(2, parent);\n        AVLTree.Node b = tree.new Node(3, a);\n        AVLTree.Node c = tree.new Node(4, b);\n        \n        // Setting up the specific case for left rotation\n        parent.right = a;\n        a.right = b;\n        b.left = c;\n        c.parent = b;\n\n        // Performing the left rotation\n        AVLTree.Node result = tree.rotateLeft(a);\n\n        // Assertions to verify the left rotation\n        assertEquals(b, result, \"After rotation, 'b' should become the new root node.\");\n        assertEquals(a, result.left, \"After rotation, 'a' should become the left child of 'b'.\");\n        assertEquals(c, a.right, \"After rotation, 'c' should become the right child of 'a'.\");\n        assertNull(a.left, \"'a' should have no left child after rotation.\");\n        assertEquals(parent, result.parent, \"The parent of 'b' should remain the same after rotation.\");\n        \n        // If your AVLTree class has a method to check balances, use it here\n        // assertEquals(expectedBalance, tree.getBalance(result), \"The balance should be updated correctly.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.AVLTree.Node createNode(int key, AVLTree.AVLTree.Node parent) {\n        return new AVLTree().new Node(key, parent);\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        AVLTree tree = new AVLTree();\n        AVLTree.AVLTree.Node root = createNode(1, null);\n        AVLTree.AVLTree.Node nodeA = createNode(2, root);\n        AVLTree.AVLTree.Node nodeB = createNode(3, nodeA);\n\n        root.right = nodeA;\n        nodeA.parent = root;\n        nodeA.left = null;\n        nodeA.right = nodeB;\n        nodeB.parent = nodeA;\n\n        AVLTree.AVLTree.Node result = tree.rotateLeft(nodeA);\n\n        // Check new root\n        assertEquals(nodeB, result, \"Node B should be new root after rotate left\");\n        \n        // Check parent links\n        assertNull(result.parent, \"New root should not have a parent\");\n        assertEquals(root.right, result, \"Root's right child should be Node B after rotate left\");\n        assertEquals(result.left, nodeA, \"Node A should be left child of Node B after rotate left\");\n        \n        // Check children links\n        assertEquals(nodeA.parent, result, \"Node A should have Node B as parent after rotate left\");\n        \n        // If more properties / balancing is set inside setBalance(), additional assertions may be needed here\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    private AVLTree.Node createTestNode(int key, AVLTree.Node parent) {\n        return new AVLTree.Node(key, parent);\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        AVLTree avlTree = new AVLTree();\n        \n        // Manually create nodes to simulate a small part of the tree\n        AVLTree.Node parent = createTestNode(1, null);\n        AVLTree.Node a = createTestNode(2, parent);\n        AVLTree.Node b = createTestNode(3, a);\n        \n        // Setup initial links\n        parent.right = a;\n        a.parent = parent;\n        a.right = b;\n        b.parent = a;\n\n        // Simulate a tree before rotation\n        b.left = null;\n        b.right = null;\n\n        // Perform the rotation\n        AVLTree.Node newSubRoot = avlTree.rotateLeft(a);\n\n        // Assertions to confirm that the rotation occured correctly\n        assertEquals(b, newSubRoot);\n        assertEquals(a, b.left);\n        assertEquals(a.parent, b);\n        assertEquals(parent.right, b);\n        assertNull(b.left.right);\n        assertNull(b.right);\n\n        // Optionally assert the new balance factors if they are set by 'setBalance' method\n        // assertEquals(expectedBalanceForA, a.balance);\n        // assertEquals(expectedBalanceForB, b.balance);\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n\n    @Test\n    public void rotateLeftTest() {\n        AVLTree avlTree = new AVLTree();\n\n        // Setup the tree structure\n        AVLTree.Node root = avlTree.new Node(1, null);\n        AVLTree.Node rightChild = avlTree.new Node(2, root);\n        AVLTree.Node rightLeftChild = avlTree.new Node(3, rightChild);\n        AVLTree.Node rightRightChild = avlTree.new Node(4, rightChild);\n        \n        // Build the tree\n        root.right = rightChild;\n        rightChild.parent = root;\n        rightChild.left = rightLeftChild;\n        rightLeftChild.parent = rightChild;\n        rightChild.right = rightRightChild;\n        rightRightChild.parent = rightChild;\n        \n        // Perform the rotation\n        AVLTree.Node result = avlTree.rotateLeft(root);\n        \n        // Check the results\n        assertNotNull(result);\n        assertEquals(rightChild, result);\n        assertEquals(root, result.left);\n        assertEquals(rightLeftChild, result.left.right);\n        assertEquals(rightRightChild, result.right);\n        \n        // Confirm the parent-child relationships are set correctly after rotation\n        assertNull(result.parent);\n        assertEquals(result, result.left.parent);\n        assertEquals(result.left, result.left.right.parent);\n        assertEquals(result, result.right.parent);\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AVLTreeTest {\n    \n    private AVLTree avlTree;\n\n    class Node extends AVLTree.Node {\n        public Node(int k, Node p) {\n            super(k, p);\n        }\n    }\n    \n    // Helper method to set up a Node with child nodes, for testing.\n    private Node setupNodes() {\n        Node parent = new Node(1, null);\n        Node leftChild = new Node(-1, parent);\n        Node rightChild = new Node(2, parent);\n        \n        parent.left = leftChild;\n        parent.right = rightChild;\n        \n        return parent;\n    }\n\n    @BeforeEach\n    public void setUp() {\n        avlTree = new AVLTree();\n    }\n\n    @Test\n    public void rotateLeftTest() {\n        // Set up the nodes\n        Node parent = setupNodes();\n\n        // Assume the rotateLeft method is visible for testing or mock it if needed\n        Node newRoot = avlTree.rotateLeft(parent);\n\n        // Check the results of the rotation\n        assertAll(\"rotateLeft\",\n            () -> assertNotNull(newRoot, \"Returned node should not be null\"),\n            () -> assertEquals(parent.key, newRoot.left.key, \"Left child of the new root should be the old root\"),\n            () -> assertEquals(2, newRoot.key, \"New root should have the key of the old right child\"),\n            () -> assertEquals(-1, newRoot.left.left.key, \"Left child of the old root should remain unchanged\"),\n            () -> assertNull(newRoot.right, \"Right child of the new root should be null since original right child had no right subtree\"),\n            // Verify the parent linkages\n            () -> assertNull(newRoot.parent, \"The new root should have no parent\"),\n            () -> assertEquals(newRoot, parent.parent, \"The old root's parent should be updated to the new root\"),\n            () -> assertEquals(parent, newRoot.left, \"The new root's left child should be the old root\"),\n            // Validate balance (depends on the setBalance method which is assumed to exist)\n            () -> assertEquals(parent.balance, newRoot.left.balance, \"Balance of the old root should persist after the rotation\"),\n            () -> assertEquals(newRoot.balance, 0, \"Balance of the new root should be correct considering a rotation\")\n        );\n    }\n}"
    ]
}