{
    "project_name": "Java",
    "file_name": "ArrayCombination.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Find all combinations of 1..n by creating an array and using backtracking in Combination.java\n     * @param n max value of the array.\n     * @param k length of combination\n     * @return a list of all combinations of length k. If k == 0, return null.\n     */",
    "source_code": "\npublic static List<TreeSet<Integer>> combination(int n, int k) {\n    if (n <= 0) {\n        return null;\n    }\n    length = k;\n    Integer[] arr = new Integer[n];\n    for (int i = 1; i <= n; i++) {\n        arr[i - 1] = i;\n    }\n    return Combination.combination(arr, length);\n}\n",
    "class_name": "ArrayCombination",
    "method_name": "combination",
    "arguments": [
        "int n",
        "int k"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n\n    @Test\n    public void combinationTest() {\n        // Test for n = 5, k = 3\n        List<TreeSet<Integer>> result = ArrayCombination.combination(5, 3);\n        assertNotNull(result, \"The result should not be null for n > 0\");\n        assertEquals(10, result.size(), \"Expected number of combinations for n=5, k=3 is 10\");\n\n        // Test for n = 0 (expected null result)\n        assertNull(ArrayCombination.combination(0, 3), \"The result should be null for n <= 0\");\n\n        // Test for n = 3, k = 1 (expected 3 combinations)\n        List<TreeSet<Integer>> smallResult = ArrayCombination.combination(3, 1);\n        assertNotNull(smallResult, \"The result should not be null for n > 0\");\n        assertEquals(3, smallResult.size(), \"Expected number of combinations for n=3, k=1 is 3\");\n\n        // Validate the contents of one combination set (e.g. for n=3, k=1)\n        assertTrue(smallResult.contains(new TreeSet<>(List.of(1))),\n                \"Result should contain combination [1]\");\n        assertTrue(smallResult.contains(new TreeSet<>(List.of(2))),\n                \"Result should contain combination [2]\");\n        assertTrue(smallResult.contains(new TreeSet<>(List.of(3))),\n                \"Result should contain combination [3]\");\n\n        // Further test cases can be added to verify the accuracy of the combination method\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.List;\nimport java.util.TreeSet;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n\n    @Test\n    public void combinationTest() {\n        // Test for an invalid case where n is non-positive\n        assertNull(ArrayCombination.combination(0, 2), \"Expect null for n <= 0\");\n\n        // Test for a valid case\n        List<TreeSet<Integer>> result = ArrayCombination.combination(5, 3);\n        \n        // expected combinations: [1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]\n        assertEquals(10, result.size(), \"Expect 10 combinations for 5 choose 3\");\n\n        // Explicitly check one of the combinations\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 2, 3))), \"Result should contain [1, 2, 3]\");\n\n        // Test for k larger than n\n        List<TreeSet<Integer>> invalidResult = ArrayCombination.combination(3, 5);\n        // The behavior here is not defined in the provided code, but assuming it should return an empty list or handle gracefully.\n        assertNotNull(invalidResult, \"Expect valid (but empty) list or handled result for k > n\");\n        assertTrue(invalidResult.isEmpty(), \"Expect no combinations for 3 choose 5\");\n\n        // Test for k equal to n, should result in one combination with all elements\n        List<TreeSet<Integer>> oneResult = ArrayCombination.combination(3, 3);\n        assertNotNull(oneResult, \"Expect valid list for k = n\");\n        assertEquals(1, oneResult.size(), \"Expect 1 combination for 3 choose 3\");\n        assertTrue(oneResult.contains(new TreeSet<>(List.of(1, 2, 3))), \"Result should contain [1, 2, 3]\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        // Check the method with valid inputs\n        List<TreeSet<Integer>> result = ArrayCombination.combination(5, 3);\n        assertNotNull(result);\n        assertEquals(10, result.size()); // Because C(5, 3) should give us 10 combinations\n\n        // The actual combinations are tested for correctness if needed:\n        assertTrue(result.contains(new TreeSet<>(Arrays.asList(1, 2, 3))));\n        assertTrue(result.contains(new TreeSet<>(Arrays.asList(1, 2, 4))));\n        // Additional combinations would be listed and asserted similarly...\n\n        // Check the method returns null when n <= 0\n        assertNull(ArrayCombination.combination(0, 3));\n        assertNull(ArrayCombination.combination(-5, 3));\n\n        // Check the method with k > n scenario\n        List<TreeSet<Integer>> result2 = ArrayCombination.combination(3, 5);\n        assertNotNull(result2);\n        assertTrue(result2.isEmpty()); // Because we cannot choose 5 items out of 3, we should get an empty list\n\n        // Check the method with n == k scenario\n        List<TreeSet<Integer>> result3 = ArrayCombination.combination(4, 4);\n        assertNotNull(result3);\n        assertEquals(1, result3.size()); // There is only one way to choose all items\n        assertTrue(result3.contains(new TreeSet<>(Arrays.asList(1, 2, 3, 4))));\n\n        // Check the method with k == 0 scenario\n        List<TreeSet<Integer>> result4 = ArrayCombination.combination(4, 0);\n        assertNotNull(result4);\n        assertEquals(1, result4.size()); // There is only one way to choose none of the items\n        assertTrue(result4.contains(new TreeSet<>())); // It should be an empty set\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n\n    @Test\n    public void combinationTest() {\n        // Test with n = 4, k = 2, expecting combinations of [1,2], [1,3], [1,4], [2,3], [2,4], and [3,4]\n        List<TreeSet<Integer>> result = ArrayCombination.combination(4, 2);\n        assertNotNull(result, \"Result should not be null\");\n        assertEquals(6, result.size(), \"There should be 6 combinations\");\n\n        // Create expected combinations\n        TreeSet<Integer> expected1 = new TreeSet<>(List.of(1, 2));\n        TreeSet<Integer> expected2 = new TreeSet<>(List.of(1, 3));\n        TreeSet<Integer> expected3 = new TreeSet<>(List.of(1, 4));\n        TreeSet<Integer> expected4 = new TreeSet<>(List.of(2, 3));\n        TreeSet<Integer> expected5 = new TreeSet<>(List.of(2, 4));\n        TreeSet<Integer> expected6 = new TreeSet<>(List.of(3, 4));\n\n        // Assert that the result contains all expected combinations\n        assertTrue(result.contains(expected1), \"Result should contain [1, 2]\");\n        assertTrue(result.contains(expected2), \"Result should contain [1, 3]\");\n        assertTrue(result.contains(expected3), \"Result should contain [1, 4]\");\n        assertTrue(result.contains(expected4), \"Result should contain [2, 3]\");\n        assertTrue(result.contains(expected5), \"Result should contain [2, 4]\");\n        assertTrue(result.contains(expected6), \"Result should contain [3, 4]\");\n\n        // Test for edge case with n <= 0, expecting null\n        assertNull(ArrayCombination.combination(0, 2), \"Result should be null for n <= 0\");\n\n        // Test different values of k (e.g., k > n), expecting empty list\n        List<TreeSet<Integer>> resultEdgeCase = ArrayCombination.combination(3, 4);\n        assertTrue(resultEdgeCase.isEmpty(), \"Result should be empty if k > n\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    \n    @Test\n    public void combinationTest() {\n        // Test for positive n and k where n > k\n        List<TreeSet<Integer>> result1 = ArrayCombination.combination(5, 3);\n        assertNotNull(result1, \"The combination result should not be null\");\n        assertEquals(10, result1.size(), \"There should be 10 combinations for n=5 and k=3\");\n\n        // Test for positive n and k where n == k\n        List<TreeSet<Integer>> result2 = ArrayCombination.combination(3, 3);\n        assertNotNull(result2, \"The combination result should not be null\");\n        assertEquals(1, result2.size(), \"There should be 1 combination for n=3 and k=3\");\n        assertTrue(result2.get(0).equals(new TreeSet<>(List.of(1,2,3))), \n                   \"The only combination should contain 1, 2, and 3\");\n\n        // Test for n == 0 (should return null as per source code)\n        List<TreeSet<Integer>> result3 = ArrayCombination.combination(0, 1);\n        assertNull(result3, \"The combination result should be null when n is 0\");\n\n        // Test for n < 0 (should return null as per source code)\n        List<TreeSet<Integer>> result4 = ArrayCombination.combination(-1, 2);\n        assertNull(result4, \"The combination result should be null when n is negative\");\n\n        // Test for positive n and k == 0 (assuming it should return an empty list of combinations)\n        List<TreeSet<Integer>> result5 = ArrayCombination.combination(5, 0);\n        assertNotNull(result5, \"The combination result should not be null when k is 0\");\n        assertTrue(result5.isEmpty(), \"The combination list should be empty when k is 0\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.List;\nimport java.util.TreeSet;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        // Test case with valid input\n        List<TreeSet<Integer>> result = ArrayCombination.combination(5, 3);\n        assertNotNull(result, \"The result should not be null for valid input\");\n        assertEquals(10, result.size(), \"There should be 10 combinations of 3 out of 5\");\n\n        // Test each combination is of size 'k'\n        result.forEach(combination -> assertEquals(3, combination.size(), \"Each combination should have 3 elements\"));\n\n        // Test elements are within range 1 to 'n'\n        result.forEach(combination -> combination.forEach(number ->\n            assertTrue(number >= 1 && number <= 5 , \"Each number should be in the range 1 to 5\")));\n\n        // Test case with n less than 0\n        assertNull(ArrayCombination.combination(-1, 2), \"The result should be null for n <= 0\");\n\n        // Test case with n equals 0\n        assertNull(ArrayCombination.combination(0, 3), \"The result should be null for n <= 0\");\n        \n        // Test case with k greater than n\n        List<TreeSet<Integer>> emptyResult = ArrayCombination.combination(3, 5);\n        assertNotNull(emptyResult, \"The result should not be null even when k > n\");\n        assertTrue(emptyResult.isEmpty(), \"The list should be empty when k > n\");\n        \n        // Test case when k is zero\n        List<TreeSet<Integer>> singleEmptySet = ArrayCombination.combination(5, 0);\n        assertNotNull(singleEmptySet, \"The result should not be null even when k is 0\");\n        assertEquals(1, singleEmptySet.size(), \"There should be one combination when k is 0\");\n        assertTrue(singleEmptySet.get(0).isEmpty(), \"The combination should be an empty set when k is 0\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n\n    @Test\n    public void combinationTest() {\n        // Test for n = 4 and k = 2\n        List<TreeSet<Integer>> result = ArrayCombination.combination(4, 2);\n        \n        assertNotNull(result, \"The result should not be null\");\n        assertEquals(6, result.size(), \"There should be 6 combinations for 4 choose 2\");\n\n        // Expected combinations are: [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 2))), \"Should contain [1, 2]\");\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 3))), \"Should contain [1, 3]\");\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 4))), \"Should contain [1, 4]\");\n        assertTrue(result.contains(new TreeSet<>(List.of(2, 3))), \"Should contain [2, 3]\");\n        assertTrue(result.contains(new TreeSet<>(List.of(2, 4))), \"Should contain [2, 4]\");\n        assertTrue(result.contains(new TreeSet<>(List.of(3, 4))), \"Should contain [3, 4]\");\n\n        // Test for n <= 0 which should return null\n        assertNull(ArrayCombination.combination(-1, 2), \"Combination with negative n should return null\");\n        assertNull(ArrayCombination.combination(0, 2), \"Combination with zero n should return null\");\n\n        // Test for n = 4 and k = 0, should return empty combinations\n        List<TreeSet<Integer>> resultEmpty = ArrayCombination.combination(4, 0);\n        assertNotNull(resultEmpty, \"Result should not be null\");\n        assertEquals(1, resultEmpty.size(), \"There should be 1 combination for 4 choose 0\");\n        assertEquals(new TreeSet<Integer>(), resultEmpty.get(0), \"The only combination should be empty for k = 0\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        // Test with valid inputs.\n        List<TreeSet<Integer>> result = ArrayCombination.combination(5, 3);\n\n        // Assert that the result is not null\n        assertNotNull(result, \"The result should not be null\");\n\n        // Assert that the result contains the correct number of combinations\n        int expectedNumberOfCombinations = 10; // This is C(5, 3), or 5 choose 3.\n        assertEquals(expectedNumberOfCombinations, result.size(), \"The result should contain the correct number of combinations\");\n\n        // Check some expected values (assuming the combination method is implemented correctly)\n        // The actual values will depend on how the combination method generates the combinations\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 2, 3))), \"The result should contain {1, 2, 3}\");\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 2, 4))), \"The result should contain {1, 2, 4}\");\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 2, 5))), \"The result should contain {1, 2, 5}\");\n        // ...additional checks as needed for full coverage...\n\n        // Test with n <= 0, expecting null\n        assertNull(ArrayCombination.combination(-1, 3), \"The result should be null for n <= 0\");\n\n        // Test with k greater than n, expecting empty list\n        List<TreeSet<Integer>> emptyResult = ArrayCombination.combination(3, 5);\n        assertNotNull(emptyResult, \"The result should not be null even for k > n\");\n        assertTrue(emptyResult.isEmpty(), \"The result should be an empty list for k > n\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.List;\nimport java.util.TreeSet;\n\npublic class ArrayCombinationTest {\n    @Test\n    public void combinationTest() {\n        // Scenario with valid parameters n = 5 and k = 3\n        List<TreeSet<Integer>> result = ArrayCombination.combination(5, 3);\n        assertNotNull(result, \"The result should not be null when valid parameters are passed.\");\n        assertEquals(10, result.size(), \"There should be 10 combinations when choosing 3 out of 5.\");\n        \n        // Validating one of the combinations\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 2, 3))), \"The list of combinations should include the combination [1, 2, 3].\");\n\n        // Boundary case with n = k\n        result = ArrayCombination.combination(3, 3);\n        assertNotNull(result, \"The result should not be null for n = k.\");\n        assertEquals(1, result.size(), \"There should be 1 combination when n = k\");\n        assertTrue(result.contains(new TreeSet<>(List.of(1, 2, 3))), \"The list should include the combination [1, 2, 3].\");\n\n        // Edge case where n < k\n        result = ArrayCombination.combination(2, 3);\n        assertNotNull(result, \"The result should not be null even if n < k.\");\n        assertTrue(result.isEmpty(), \"There should be no combinations when n < k.\");\n\n        // Edge case where n is invalid (n <= 0)\n        result = ArrayCombination.combination(-1, 3);\n        assertNull(result, \"The result should be null when n is not positive.\");\n\n        // Edge case where k is invalid (k <= 0)\n        result = ArrayCombination.combination(3, -1);\n        assertNotNull(result, \"The result should not be null for negative k.\");\n        assertTrue(result.isEmpty(), \"There should be no combinations when k is not positive.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ArrayCombinationTest {\n    \n    @Test\n    public void combinationTest() {\n        assertNull(ArrayCombination.combination(0, 3), \"Combination with n <= 0 should return null\");\n\n        assertNull(ArrayCombination.combination(-1, 3), \"Combination with n <= 0 should return null\");\n\n        List<TreeSet<Integer>> result = ArrayCombination.combination(5, 3);\n        assertNotNull(result, \"Combination should not return null for n > 0\");\n        assertEquals(10, result.size(), \"There should be 10 combinations for 5 choose 3\");\n\n        List<TreeSet<Integer>> expected = List.of(\n            new TreeSet<>(List.of(1, 2, 3)),\n            new TreeSet<>(List.of(1, 2, 4)),\n            new TreeSet<>(List.of(1, 2, 5)),\n            new TreeSet<>(List.of(1, 3, 4)),\n            new TreeSet<>(List.of(1, 3, 5)),\n            new TreeSet<>(List.of(1, 4, 5)),\n            new TreeSet<>(List.of(2, 3, 4)),\n            new TreeSet<>(List.of(2, 3, 5)),\n            new TreeSet<>(List.of(2, 4, 5)),\n            new TreeSet<>(List.of(3, 4, 5))\n        );\n        assertTrue(result.containsAll(expected), \"The combinations generated should match the expected combinations\");\n\n        // Test with k greater than n\n        List<TreeSet<Integer>> invalidResult = ArrayCombination.combination(3, 5);\n        assertNull(invalidResult, \"Combination with k > n should return null\");\n\n        // Test with k equal to n\n        List<TreeSet<Integer>> fullSetResult = ArrayCombination.combination(4, 4);\n        assertNotNull(fullSetResult, \"Combination should not return null for n = k\");\n        assertEquals(1, fullSetResult.size(), \"There should be 1 combination for 4 choose 4\");\n        assertEquals(new TreeSet<>(List.of(1, 2, 3, 4)), fullSetResult.get(0), \"The only combination should be the full set\");\n    }\n}"
    ]
}