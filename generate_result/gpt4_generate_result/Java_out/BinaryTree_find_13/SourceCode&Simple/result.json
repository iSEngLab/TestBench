{
    "project_name": "Java",
    "file_name": "BinaryTree.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.trees",
    "docstring": "/**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */",
    "source_code": "\npublic Node find(int key) {\n    Node current = root;\n    while (current != null) {\n        if (key < current.data) {\n            if (current.left == null) {\n                return current; // The key isn't exist, returns the parent\n            }\n            current = current.left;\n        } else if (key > current.data) {\n            if (current.right == null) {\n                return current;\n            }\n            current = current.right;\n        } else { // If you find the value return it\n            return current;\n        }\n    }\n    return null;\n}\n",
    "class_name": "BinaryTree",
    "method_name": "find",
    "arguments": [
        "int key"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    @Test\n    public void findTest() {\n        // Create a binary tree and insert some nodes\n        BinaryTree bt = new BinaryTree();\n        bt.put(10);\n        bt.put(5);\n        bt.put(15);\n        bt.put(3);\n        bt.put(7);\n        bt.put(12);\n        bt.put(18);\n\n        // Test finding existing nodes\n        assertEquals(10, bt.find(10).data);\n        assertEquals(5, bt.find(5).data);\n        assertEquals(15, bt.find(15).data);\n\n        // Test finding non-existing node that has a parent in the tree\n        Node resultNode = bt.find(6);\n        assertNotNull(resultNode); // Ensure a node is returned, not null\n        assertEquals(5, resultNode.data); // Parent node of the non-existing node\n\n        // Test finding a non-existing node with no possible parent (out of range)\n        assertNull(bt.find(20)); // Key is greater than any present node\n\n        // Test finding a node that would be a left child of the smallest node\n        resultNode = bt.find(2);\n        assertNotNull(resultNode); // Ensure a node is returned, not null\n        assertEquals(3, resultNode.data); // Parent node of the non-existing node\n\n        // Test finding a node in an empty tree\n        BinaryTree emptyTree = new BinaryTree();\n        assertNull(emptyTree.find(1)); // Should be null, as tree is empty\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    private BinaryTree binaryTree;\n    \n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n        binaryTree.put(10);\n        binaryTree.put(5);\n        binaryTree.put(15);\n        binaryTree.put(3);\n        binaryTree.put(7);\n        binaryTree.put(12);\n    }\n\n    @Test\n    public void findTest() {\n        // Test finding an existing node\n        BinaryTree.Node existingNode = binaryTree.find(5);\n        assertNotNull(existingNode);\n        assertEquals(5, existingNode.data);\n\n        // Test finding a non-existing node and returning the would-be parent\n        BinaryTree.Node parentNode = binaryTree.find(6);\n        assertNotNull(parentNode);\n        assertEquals(5, parentNode.data);\n\n        // Test finding the root node\n        BinaryTree.Node rootNode = binaryTree.find(10);\n        assertNotNull(rootNode);\n        assertEquals(10, rootNode.data);\n\n        // Test searching for a value not in tree and getting null\n        assertNull(binaryTree.find(20));\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    \n    private BinaryTree binaryTree;\n    \n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(70);\n        binaryTree.put(60);\n        binaryTree.put(80);\n    }\n    \n    @Test\n    public void findTest() {\n        // Test to find an existing node\n        BinaryTree.Node foundNode = binaryTree.find(30);\n        assertNotNull(foundNode);\n        assertEquals(30, foundNode.data);\n\n        // Test to find a non-existing node, should return parent of where it would be\n        BinaryTree.Node nonExistingNode = binaryTree.find(25);\n        assertNotNull(nonExistingNode);\n        assertEquals(30, nonExistingNode.data); // Assuming binary tree returns closest parent\n\n        // Test to find a non-existing node that would have been the root\n        nonExistingNode = binaryTree.find(1000);\n        assertNull(nonExistingNode); // As there would be no parent if the node was at the root\n        \n        // Test to find the root\n        BinaryTree.Node rootNode = binaryTree.find(50);\n        assertNotNull(rootNode);\n        assertEquals(50, rootNode.data);\n        \n        // Test to find a node that has both children\n        BinaryTree.Node twoChildrenNode = binaryTree.find(70);\n        assertNotNull(twoChildrenNode);\n        assertEquals(70, twoChildrenNode.data);\n    }\n    \n    // Optional clean up after tests\n    @AfterEach\n    public void tearDown() {\n        binaryTree = null;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass BinaryTreeTest {\n    private BinaryTree tree;\n\n    @BeforeEach\n    public void setUp() {\n        tree = new BinaryTree();\n        tree.put(50);\n        tree.put(30);\n        tree.put(70);\n        tree.put(20);\n        tree.put(40);\n        tree.put(60);\n        tree.put(80);\n    }\n\n    @Test\n    public void findTest() {\n        // Check for exact match\n        assertNotNull(tree.find(50));\n        assertEquals(50, tree.find(50).data);\n        \n        // Check for non-existing smaller value\n        assertNotNull(tree.find(10));\n        assertEquals(20, tree.find(10).data);  // Should return the parent (20)\n        \n        // Check for non-existing larger value\n        assertNotNull(tree.find(75));\n        assertEquals(70, tree.find(75).data);  // Should return the parent (70)\n        \n        // Check for non-existing value with no children\n        assertNull(tree.find(100));\n\n        // Check for finding left child \n        assertNotNull(tree.find(30));\n        assertEquals(30, tree.find(30).data);\n\n        // Check for finding right child\n        assertNotNull(tree.find(70));\n        assertEquals(70, tree.find(70).data);\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    private BinaryTree testTree;\n\n    @BeforeEach\n    public void setUp() {\n        testTree = new BinaryTree();\n        testTree.put(20);\n        testTree.put(10);\n        testTree.put(30);\n        testTree.put(5);\n        testTree.put(15);\n        testTree.put(25);\n        testTree.put(35);\n    }\n\n    @Test\n    public void findTest() {\n        // Attempt to find a node that does exist\n        Node found = testTree.find(15);\n        assertNotNull(found, \"The node with value 15 should exist.\");\n        assertEquals(15, found.data, \"The data of the found node should be 15.\");\n\n        // Attempt to find a node that does not exist, expect parent node\n        Node notFound = testTree.find(17);\n        assertNotNull(notFound, \"The node with value 17 does not exist, expected parent node.\");\n        assertEquals(15, notFound.data, \"Should return the parent node with closest lower value\");\n\n        // Attempt to find a node that does not exist and has no parent (key < root.data)\n        Node notFoundAtRootLevel = testTree.find(2);\n        assertNotNull(notFoundAtRootLevel, \"The node with value 2 does not exist, expected root or child of root.\");\n        assertEquals(5, notFoundAtRootLevel.data, \"Should return the child of root that would be the parent of the node.\");\n\n        // Attempt to find a node with a value greater than any value in the tree\n        Node notFoundBeyondMax = testTree.find(40);\n        assertNotNull(notFoundBeyondMax, \"The node with value 40 does not exist, expected parent node.\");\n        assertEquals(35, notFoundBeyondMax.data, \"Should return the node with the maximum value in the tree.\");\n\n        // Attempt to find a node in an empty tree\n        testTree = new BinaryTree(); // Reset the tree to an empty tree\n        Node emptyTreeFind = testTree.find(100);\n        assertNull(emptyTreeFind, \"Finding a node in an empty tree should return null.\");\n\n        // Check the root node\n        Node rootNode = testTree.find(20);\n        assertNotNull(rootNode, \"Finding the root node should not return null.\");\n        assertEquals(20, rootNode.data, \"The root node data should be 20.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    \n    @Test\n    public void findTest() {\n        // Initialize BinaryTree and nodes\n        BinaryTree binaryTree = new BinaryTree();\n        binaryTree.put(10);\n        binaryTree.put(5);\n        binaryTree.put(15);\n        binaryTree.put(3);\n        binaryTree.put(7);\n        \n        // Test the find method for an existing node\n        Node foundNode = binaryTree.find(7);\n        assertNotNull(foundNode, \"The node should exist.\");\n        assertEquals(7, foundNode.data, \"The found node data should be 7.\");\n        \n        // Test the find method for a non-existent node which would end up on the left of node with data 5\n        Node nonExistentLeft = binaryTree.find(4);\n        assertNotNull(nonExistentLeft, \"The parent node should be returned if the key does not exist.\");\n        assertEquals(5, nonExistentLeft.data, \"The returned node when finding non-existing key should be its immediate parent if key is less.\");\n        \n        // Test the find method for a non-existent node which would end up on right of node with data 15\n        Node nonExistentRight = binaryTree.find(17);\n        assertNotNull(nonExistentRight, \"The parent node should be returned if the key does not exist.\");\n        assertEquals(15, nonExistentRight.data, \"The returned node when finding non-existing key should be its immediate parent if key is greater.\");\n        \n        // Test the find method for null return when tree is completely traversed without finding the key.\n        binaryTree = new BinaryTree(); // Reset to an empty tree.\n        Node shouldBeNull = binaryTree.find(100);\n        assertNull(shouldBeNull, \"The find method should return null when searching in an empty tree.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    private BinaryTree binaryTree;\n    \n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n        // Below is an example. You might set up the tree as required for the test.\n        // Let\u2019s assume the tree is as follows:   10\n        //                                        /    \\\n        //                                      5      15\n        // If your BinaryTree implementation accepts values upon insertion directly then:\n        binaryTree.put(10);\n        binaryTree.put(5);\n        binaryTree.put(15);\n    }\n    \n    @Test\n    public void findTest() {\n        assertEquals(10, binaryTree.find(10).data, \"Searching for existing root node should return the node itself.\");\n        assertEquals(5, binaryTree.find(5).data, \"Searching for existing left node should return the node itself.\");\n        assertEquals(15, binaryTree.find(15).data, \"Searching for existing right node should return the node itself.\");\n        \n        assertNull(binaryTree.find(100), \"Searching for non-existing node should return null.\");\n        assertEquals(5, binaryTree.find(3).data, \"Searching for a value less than a left node should return that node.\");\n        assertEquals(15, binaryTree.find(20).data, \"Searching for a value greater than a right node should return that node.\");\n    }\n\n    // Other tests for the BinaryTree, such as put, remove, etc.\n    // ...\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    @Test\n    public void findTest() {\n        BinaryTree binaryTree = new BinaryTree();\n        binaryTree.put(10);\n        binaryTree.put(5);\n        binaryTree.put(15);\n        binaryTree.put(3);\n        binaryTree.put(7);\n        binaryTree.put(12);\n        binaryTree.put(17);\n        \n        // Test find existing nodes\n        Node foundNode = binaryTree.find(3);\n        assertNotNull(foundNode, \"The find method should return a non-null node for existing keys\");\n        assertEquals(3, foundNode.data, \"The find method should return the correct node data for the given key\");\n        \n        // Test find non-existing nodes\n        Node parentForNonExisting = binaryTree.find(16);\n        assertNotNull(parentForNonExisting, \"The find method should return the parent node for non-existing keys\");\n        assertEquals(15, parentForNonExisting.data, \"The find method should return the parent node where non-existing key would be inserted\");\n        \n        // Test find on an empty tree\n        BinaryTree emptyTree = new BinaryTree();\n        assertNull(emptyTree.find(100), \"The find method should return null when called on an empty tree\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    private BinaryTree binaryTree;\n\n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n        binaryTree.put(20); // assuming 'put' method adds the value to the tree\n        binaryTree.put(10);\n        binaryTree.put(30);\n        binaryTree.put(5);\n        binaryTree.put(15);\n        binaryTree.put(25);\n        binaryTree.put(35);\n    }\n  \n    @Test\n    public void findTestExistingNode() {\n        Node foundNode = binaryTree.find(15);\n        assertNotNull(foundNode);\n        assertEquals(15, foundNode.data);\n    }\n\n    @Test\n    public void findTestNonExistingNodeLessThan() {\n        Node foundNode = binaryTree.find(8);\n        assertNotNull(foundNode);\n        assertEquals(10, foundNode.data); // 8 is less than 10, closest existing node in the tree\n    }\n\n    @Test\n    public void findTestNonExistingNodeGreaterThan() {\n        Node foundNode = binaryTree.find(40);\n        assertNotNull(foundNode);\n        assertEquals(35, foundNode.data); // 40 is greater than 35, closest existing node in the tree\n    }\n\n    @Test\n    public void findTestRootNode() {\n        Node foundNode = binaryTree.find(20);\n        assertNotNull(foundNode);\n        assertEquals(20, foundNode.data);\n    }\n\n    @Test\n    public void findTestEmptyTree() {\n        binaryTree = new BinaryTree(); // Reinitializing to an empty tree\n        Node foundNode = binaryTree.find(10);\n        assertNull(foundNode); // When the tree is empty, should return null\n    }\n\n    @AfterEach\n    public void tearDown() {\n        binaryTree = null;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    @Test\n    public void findTest() {\n        BinaryTree tree = new BinaryTree();\n        \n        // Assume BinaryTree.put(int value) adds elements into the tree.\n        // Let's construct the following tree as a test case:\n        //      5\n        //     / \\\n        //    3   7\n        //   / \\   \\\n        //  2   4   9\n        \n        tree.put(5);\n        tree.put(3);\n        tree.put(7);\n        tree.put(2);\n        tree.put(4);\n        tree.put(9);\n        \n        // Test finding existing nodes\n        assertNotNull(tree.find(5), \"Node with key 5 should be found\");\n        assertNotNull(tree.find(3), \"Node with key 3 should be found\");\n        assertNotNull(tree.find(9), \"Node with key 9 should be found\");\n\n        // Test the case where node should be present and check if correct node is returned\n        assertEquals(5, tree.find(5).data, \"Incorrect node returned for key 5\");\n        assertEquals(3, tree.find(3).data, \"Incorrect node returned for key 3\");\n        assertEquals(9, tree.find(9).data, \"Incorrect node returned for key 9\");\n\n        // Test finding non-existing nodes\n        assertNotNull(tree.find(6), \"Should return parent of where a node with key 6 would be inserted\");\n        assertEquals(7, tree.find(6).data, \"Parent node should have data 7\");\n\n        assertNotNull(tree.find(1), \"Should return parent of where a node with key 1 would be inserted\");\n        assertEquals(2, tree.find(1).data, \"Parent node should have data 2\"); \n\n        // Test finding a node in an empty tree\n        BinaryTree emptyTree = new BinaryTree();\n        assertNull(emptyTree.find(5), \"Finding in an empty tree should return null\");\n    }\n}"
    ]
}