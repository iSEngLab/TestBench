{
    "project_name": "Java",
    "file_name": "BinaryTree.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.trees",
    "docstring": "/**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */",
    "source_code": "\npublic boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n\n            temp.right.parent = temp.parent;\n\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n\n            temp.left.parent = temp.parent;\n\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}\n",
    "class_name": "BinaryTree",
    "method_name": "remove",
    "arguments": [
        "int value"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    private BinaryTree tree;\n\n    @BeforeEach\n    public void setUp() {\n        tree = new BinaryTree();\n        tree.put(40);\n        tree.put(20);\n        tree.put(10);\n        tree.put(30);\n        tree.put(60);\n        tree.put(50);\n        tree.put(70);\n    }\n\n    // Test removal of a node with no children\n    @Test\n    public void testRemoveLeafNode() {\n        assertTrue(tree.remove(10)); // 10 is a leaf node\n        assertNull(tree.find(10).left);\n        assertNull(tree.find(10).right);\n        assertFalse(tree.remove(10)); // Try to remove again, should be false\n    }\n\n    // Test removal of a node with one child\n    @Test\n    public void testRemoveNodeWithOneChild() {\n        assertTrue(tree.remove(30)); // 30 has no right child\n        assertNull(tree.find(20).right); // 20's right should now be null\n        tree.put(25);\n        assertTrue(tree.remove(20)); // 20 has a left child only\n        assertNotNull(tree.find(40).left); // 40's left should now be the child of 20\n        assertEquals(tree.find(40).left.data, 25); // The child should be 25\n    }\n\n    // Test removal of a node with two children\n    @Test\n    public void testRemoveNodeWithTwoChildren() {\n        assertTrue(tree.remove(40)); // 40 is the root with two children\n        Node newRoot = tree.getRoot();\n        assertNotNull(newRoot); // new root should not be null\n        assertEquals(newRoot.data, 50); // new root should be successor of 40, which is 50\n        assertNotNull(newRoot.left);\n        assertNotNull(newRoot.right);\n        assertEquals(newRoot.left.data, 20); // left child of root\n        assertEquals(newRoot.right.data, 60); // right child of root\n    }\n\n    // Test removal of the root\n    @Test\n    public void testRemoveRootNode() {\n        assertTrue(tree.remove(40)); // Remove the root\n        Node newRoot = tree.getRoot();\n        assertNotEquals(newRoot.data, 40); // new root should no longer be 40\n    }\n\n    // Test removal of non-existent node\n    @Test\n    public void testRemoveNonExistentNode() {\n        assertFalse(tree.remove(100)); // Node doesn't exist, cannot be removed\n    }\n\n    @AfterEach\n    public void tearDown() {\n        tree = null;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    private BinaryTree binaryTree;\n\n    @BeforeEach\n    public void setup() {\n        binaryTree = new BinaryTree();\n    }\n\n    @Test\n    public void removeLeafNodeTest() {\n        // Insert nodes into the binary tree\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(70);\n        binaryTree.put(60);\n        binaryTree.put(80);\n        \n        // Remove leaf node\n        assertTrue(binaryTree.remove(20), \"Leaf node was not removed.\");\n        \n        // Assert the node is removed by checking its absence in the tree\n        assertNull(binaryTree.find(20));\n    }\n    \n    @Test\n    public void removeNodeWithOneChildTest() {\n        // Insert nodes into the binary tree with a specific structure\n        // that ensures node 30 will have only one child\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(40);\n        \n        // Remove node with one child\n        assertTrue(binaryTree.remove(30), \"Node with one child was not removed.\");\n        \n        // Assert the node is removed and child is now in its place\n        BinaryTree.Node rootChild = binaryTree.getRoot().left;\n        assertEquals(40, rootChild.data, \"The child node did not replace the removed node correctly.\");\n    }\n    \n    @Test\n    public void removeNodeWithTwoChildrenTest() {\n        // Insert nodes into the binary tree \n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(70);\n        binaryTree.put(60);\n        binaryTree.put(80);\n        \n        // Remove node with two children\n        assertTrue(binaryTree.remove(50), \"Node with two children was not removed.\");\n        \n        // Assert the root is replaced by the successor (60 in this case)\n        assertEquals(60, binaryTree.getRoot().data, \"The successor did not replace the removed node correctly.\");\n    }\n    \n    @Test\n    public void removeRootNodeNoChildrenTest() {\n        // Insert only a root node\n        binaryTree.put(10);\n        \n        // Remove the root node, which has no children\n        assertTrue(binaryTree.remove(10), \"Root node was not removed.\");\n        \n        // Assert the tree is empty after removing the root\n        assertNull(binaryTree.getRoot(), \"The root node was not removed correctly - tree should be empty.\");\n    }\n    \n    @Test\n    public void removeNonExistingNodeTest() {\n        // Insert nodes into the binary tree\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(70);\n        \n        // Attempt to remove a non-existing node\n        assertFalse(binaryTree.remove(20), \"Removal should have failed for non-existing node.\");\n        \n        // Assert the tree structure remains unchanged\n        assertNotNull(binaryTree.find(50));\n        assertNotNull(binaryTree.find(30));\n        assertNotNull(binaryTree.find(70));\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    \n    @Test\n    public void removeTest() {\n        BinaryTree tree = new BinaryTree();\n        \n        // Add elements\n        tree.put(50);\n        tree.put(30);\n        tree.put(20);\n        tree.put(40);\n        tree.put(70);\n        tree.put(60);\n        tree.put(80);\n        \n        // Test removing leaf node\n        assertTrue(tree.remove(20), \"Should return true when removing existing leaf node\");\n        assertNull(tree.find(20), \"Node with value 20 should be removed\");\n        \n        // Test removing node with single child\n        assertTrue(tree.remove(30), \"Should return true when removing node with a single child\");\n        assertNull(tree.find(30), \"Node with value 30 should be removed\");\n        assertEquals(40, tree.find(40).data, \"Child node should replace removed node with value 40\");\n        \n        // Test removing node with two children\n        assertTrue(tree.remove(70), \"Should return true when removing node with two children\");\n        assertNull(tree.find(70), \"Node with value 70 should be removed\");\n        assertNotNull(tree.find(60), \"Successor should be in place of removed node with value 60\");\n        assertNotNull(tree.find(80), \"Subtree of removed node should be maintained with value 80\");\n        \n        // Test removing root\n        assertTrue(tree.remove(50), \"Should return true when removing the root\");\n        assertNull(tree.find(50), \"Root node with value 50 should be removed\");\n        assertNotNull(tree.find(60), \"New root should be present with value 60\");\n        \n        // Test removing non-existent node\n        assertFalse(tree.remove(100), \"Should return false when removing non-existent node\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    @Test\n    public void removeTest() {\n        BinaryTree binaryTree = new BinaryTree();\n\n        // Let's create a tree\n        /*\n                  10\n                /    \\\n               5     15\n              / \\    / \\\n             2   8  12  20\n                           \\\n                           25\n        */\n        \n        binaryTree.put(10);\n        binaryTree.put(5);\n        binaryTree.put(15);\n        binaryTree.put(2);\n        binaryTree.put(8);\n        binaryTree.put(12);\n        binaryTree.put(20);\n        binaryTree.put(25);\n\n        // Test removal of leaf node\n        assertTrue(binaryTree.remove(2), \"Leaf node should be removed\");\n        assertNull(binaryTree.find(2), \"Node with value 2 should not be found after removal\");\n\n        // Test removal of node with single child\n        assertTrue(binaryTree.remove(20), \"Node with single child should be removed\");\n        assertNull(binaryTree.find(20), \"Node with value 20 should not be found after removal\");\n\n        // Test removal of node with two children\n        assertTrue(binaryTree.remove(15), \"Node with two children should be removed\");\n        assertNull(binaryTree.find(15), \"Node with value 15 should not be found after removal\");\n\n        // Confirm that successor node has taken the correct place\n        BinaryTree.Node successor = binaryTree.find(12);\n        assertNotNull(successor, \"Successor Node should be found\");\n        assertEquals(10, successor.parent.data, \"Successor should have correct parent\");\n\n        // Confirm that removal of root works\n        assertTrue(binaryTree.remove(10), \"Root node should be removed\");\n        assertNotEquals(10, binaryTree.getRoot().data, \"New root should not have the value 10\");\n        \n        // Test removal of non-existent node\n        assertFalse(binaryTree.remove(50), \"Removing non-existent node should return false\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    private BinaryTree binaryTree;\n\n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n\n        // Setup a binary tree with a known structure\n        binaryTree.put(10);\n        binaryTree.put(5);\n        binaryTree.put(15);\n        binaryTree.put(3);\n        binaryTree.put(7);\n        binaryTree.put(18);\n    }\n\n    @Test\n    public void removeLeafNodeTest() {\n        assertTrue(binaryTree.remove(3), \"Should return true when leaf node is removed\");\n        assertNull(binaryTree.find(3), \"Node with data 3 should be removed and hence not found\");\n        assertNotNull(binaryTree.find(5), \"Parent node with data 5 should not be removed\");\n    }\n\n    @Test\n    public void removeNodeWithOneChildTest() {\n        assertTrue(binaryTree.remove(15), \"Should return true when node with one child is removed\");\n        assertNull(binaryTree.find(15), \"Node with data 15 should be removed and hence not found\");\n        assertNotNull(binaryTree.find(18), \"Child node with data 18 should not be removed\");\n        assertEquals(binaryTree.getRoot().right.data, 18, \"Child node with data 18 should become right child of root\");\n    }\n\n    @Test\n    public void removeNodeWithTwoChildrenTest() {\n        assertTrue(binaryTree.remove(10), \"Should return true when node with two children is removed\");\n        assertNull(binaryTree.find(10), \"Node with data 10 should be removed and hence not found\");\n        assertNotNull(binaryTree.find(7), \"Successor node with data 7 should not be removed\");\n        assertEquals(binaryTree.getRoot().data, 7, \"Successor node with data 7 should become new root\");\n    }\n\n    @Test\n    public void removeRootNodeTest() {\n        assertTrue(binaryTree.remove(10), \"Should return true when root node is removed\");\n        assertEquals(binaryTree.find(7).data, 7, \"Root should be replaced with next higher value node\");\n        assertEquals(binaryTree.getRoot().data, 7, \"New root should be the successor of removed root\");\n    }\n\n    @Test\n    public void removeNonExistentNodeTest() {\n        assertFalse(binaryTree.remove(100), \"Should return false when trying to remove non-existent node\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        binaryTree = null;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    @Test\n    public void removeTest() {\n        BinaryTree bt = new BinaryTree();\n\n        // Insert elements\n        int[] elements = {50, 30, 20, 40, 70, 60, 80};\n        for (int element : elements) {\n            bt.put(element);\n        }\n\n        // Remove leaf node\n        assertTrue(bt.remove(20), \"Should return true when removing existing leaf node.\");\n        assertNull(bt.find(20).left, \"The node with value 20 should no longer exist.\");\n\n        // Remove node with one child\n        assertTrue(bt.remove(30), \"Should return true when removing existing node with one child.\");\n        assertNull(bt.find(40).left, \"The node with value 30 should have been replaced by its right child (40).\");\n\n        // Remove node with two children\n        assertTrue(bt.remove(50), \"Should return true when removing existing node with two children.\");\n        assertEquals(60, bt.getRoot().data, \"The node with value 50 should have been replaced by its successor (60).\");\n\n        // Try to remove a non-existing node\n        assertFalse(bt.remove(100), \"Should return false when trying to remove non-existing node.\");\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    private BinaryTree binaryTree;\n\n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(70);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(60);\n        binaryTree.put(80);\n    }\n\n    @Test\n    public void removeLeafNodeTest() {\n        // Remove leaf node\n        assertTrue(binaryTree.remove(20));\n        assertNull(binaryTree.find(20));\n\n        // Confirm that removing a non-existent number returns false\n        assertFalse(binaryTree.remove(99));\n    }\n\n    @Test\n    public void removeNodeWithOneChildTest() {\n        // Remove node with only one child\n        assertTrue(binaryTree.remove(30));\n        assertNull(binaryTree.find(30));\n        \n        // Check if the child node is now directly connected to the parent of the removed node\n        assertEquals(40, binaryTree.find(50).left.data);\n    }\n\n    @Test\n    public void removeNodeWithTwoChildrenTest() {\n        // Remove node with two children\n        assertTrue(binaryTree.remove(50));\n        assertNull(binaryTree.find(50));\n\n        // Check if the successor of the removed node is now the root\n        assertEquals(60, binaryTree.getRoot().data);\n    }\n\n    @Test\n    public void removeRootNodeTest() {\n        // Remove root node when it is the only node\n        binaryTree = new BinaryTree(new BinaryTree.Node(50));\n        assertTrue(binaryTree.remove(50));\n        assertNull(binaryTree.getRoot());\n    }\n\n    @AfterEach\n    public void tearDown() {\n        binaryTree = null;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n    \n    private BinaryTree binaryTree;\n    \n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n    }\n\n    @Test\n    public void removeLeafTest() {\n        // Add elements\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(70);\n        binaryTree.put(60);\n        binaryTree.put(80);\n\n        // Remove leaf\n        assertTrue(binaryTree.remove(20), \"Leaf node should be removed\");\n\n        // Attempt to remove non-existing leaf\n        assertFalse(binaryTree.remove(100), \"Non-existing node removal should return false\");\n    }\n\n    @Test\n    public void removeNodeWithOneChildTest() {\n        // Add elements\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(70);\n        binaryTree.put(60);\n\n        // Remove node with one child (right child)\n        assertTrue(binaryTree.remove(60), \"Node with one child should be removed\");\n\n        // Now remove node with one child (left child)\n        assertTrue(binaryTree.remove(30), \"Node with one child should be removed\");\n    }\n    \n    @Test\n    public void removeNodeWithTwoChildrenTest() {\n        // Add elements\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(70);\n        binaryTree.put(60);\n        binaryTree.put(80);\n\n        // Remove node with two children\n        assertTrue(binaryTree.remove(70), \"Node with two children should be removed\");\n    }\n\n    @Test\n    public void removeRootTest() {\n        // Add elements\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(70);\n\n        // Remove root\n        assertTrue(binaryTree.remove(50), \"Root should be removed\");\n\n        // Confirm the new root is one of the children (in this case, it should be 70)\n        assertEquals(70, binaryTree.getRoot().data, \"New root should be 70 after removal\");\n    }\n\n    @Test\n    public void removeNonExistentValueTest() {\n        // Add elements\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(70);\n\n        // Attempt to remove non-existing value\n        assertFalse(binaryTree.remove(10), \"Removing non-existent value should return false\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        binaryTree = null;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    private BinaryTree binaryTree;\n\n    @BeforeEach\n    public void setup() {\n        binaryTree = new BinaryTree();\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(70);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(60);\n        binaryTree.put(80);\n    }\n\n    @Test\n    public void removeLeafNodeTest() {\n        // Initially node with value 20 as leaf node\n        assertTrue(binaryTree.remove(20));\n        assertNull(binaryTree.find(20));\n    }\n\n    @Test\n    public void removeNodeWithSingleChildTest() {\n        // Node with value 30 has one child (40)\n        assertTrue(binaryTree.remove(30));\n        assertNull(binaryTree.find(30));\n        assertNotNull(binaryTree.find(40));\n    }\n\n    @Test\n    public void removeNodeWithTwoChildrenTest() {\n        // Node with value 50 has two children (30 and 70)\n        assertTrue(binaryTree.remove(50));\n        assertNull(binaryTree.find(50));\n        \n        BinaryTree.Node newRootNode = binaryTree.getRoot();\n        assertNotNull(newRootNode);\n        assertEquals(60, newRootNode.data); // Assuming 'findSuccessor' would give successor as 60\n        assertNotNull(binaryTree.find(30));\n        assertNotNull(binaryTree.find(70));\n    }\n\n    @Test\n    public void removeNonExistentNodeTest() {\n        // Node with value 100 does not exist\n        assertFalse(binaryTree.remove(100));\n    }\n\n    @Test\n    public void removeRootNodeTest() {\n        // Root node with value 50\n        assertTrue(binaryTree.remove(50));\n        BinaryTree.Node newRootNode = binaryTree.getRoot();\n        assertNotNull(newRootNode);\n        assertEquals(60, newRootNode.data); // Assuming 'findSuccessor' would give successor as 60\n    }\n\n    @AfterEach\n    public void tearDown() {\n        binaryTree = null;\n    }\n}",
        "package com.thealgorithms.datastructures.trees;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BinaryTreeTest {\n\n    private BinaryTree binaryTree;\n\n    @BeforeEach\n    public void setUp() {\n        binaryTree = new BinaryTree();\n        binaryTree.put(50);\n        binaryTree.put(30);\n        binaryTree.put(70);\n        binaryTree.put(20);\n        binaryTree.put(40);\n        binaryTree.put(60);\n        binaryTree.put(80);\n    }\n\n    @Test\n    public void removeTest() {\n        // Test removing leaf node\n        assertTrue(binaryTree.remove(20), \"Should return true when removing a leaf node.\");\n        assertNull(binaryTree.find(20).left, \"Leaf node should be removed from parent's left.\");\n        assertNull(binaryTree.find(20).right, \"Leaf node should be removed from parent's right.\");\n        \n        // Test removing node with one child\n        assertTrue(binaryTree.remove(30), \"Should return true when removing a node with one child.\");\n        assertEquals(40, binaryTree.find(50).left.data, \"The child node should replace the removed node.\");\n        \n        // Test removing node with two children\n        assertTrue(binaryTree.remove(70), \"Should return true when removing a node with two children.\");\n        assertNotNull(binaryTree.find(60), \"Successor node should be in the place of removed node.\");\n        \n        // Test removing root\n        assertTrue(binaryTree.remove(50), \"Should return true when removing the root node.\");\n        assertNotNull(binaryTree.getRoot(), \"There should be a new root after old root is removed.\");\n        \n        // Test removing non-existent node\n        assertFalse(binaryTree.remove(100), \"Should return false when removing a non-existent node.\");\n    }\n}"
    ]
}