{
    "project_name": "Java",
    "file_name": "BitSwap.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/bitmanipulation/BitSwap.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.bitmanipulation",
    "docstring": null,
    "source_code": "/*\n * @brief Swaps the bits at the position posA and posB from data\n */\npublic static int bitSwap(int data, final int posA, final int posB) {\n    if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n        data ^= (1 << posA) ^ (1 << posB);\n    }\n    return data;\n}\n",
    "class_name": "BitSwap",
    "method_name": "bitSwap",
    "arguments": [
        "int data",
        "int posA",
        "int posB"
    ],
    "generate_test": [
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Test with bits at same position not swapped\n        int data = 0b101010; // 42 in binary\n        int expected = 0b101010; // Should be the same as initial\n        assertEquals(expected, BitSwap.bitSwap(data, 2, 2), \"Bits at the same position should not be swapped.\");\n\n        // Test with swapping bits that are different\n        data = 0b101010; // 42 in binary\n        expected = 0b100110; // 38 in binary, bits 1 and 4 are swapped\n        assertEquals(expected, BitSwap.bitSwap(data, 1, 4), \"Bits at position 1 and 4 should be swapped.\");\n\n        // Test with swapping bits that are the same\n        data = 0b101010; // 42 in binary\n        expected = 0b101010; // Should be the same as initial\n        assertEquals(expected, BitSwap.bitSwap(data, 1, 3), \"Bits at position 1 and 3 are the same and should not be swapped.\");\n\n        // Test with bits at zero position swapped\n        data = 0b101010; // 42 in binary\n        expected = 0b101011; // 43 in binary, bits 0 and 1 are swapped\n        assertEquals(expected, BitSwap.bitSwap(data, 0, 1), \"Bits at position 0 and 1 should be swapped.\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Test swapping different bits\n        int result = BitSwap.bitSwap(0b1011, 0, 1);\n        assertEquals(0b1001, result, \"Swapping bit 0 and bit 1 of 0b1011 should result in 0b1001.\");\n\n        // Test swapping the same bit (no change expected)\n        result = BitSwap.bitSwap(0b1011, 2, 2);\n        assertEquals(0b1011, result, \"Swapping the same bit position should result in no changes.\");\n\n        // Test swapping bits that are already the same (no change expected)\n        result = BitSwap.bitSwap(0b1100, 2, 3);\n        assertEquals(0b1100, result, \"Swapping bit 2 and bit 3 of 0b1100 should result in no changes.\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Test with same bit positions - no change expected\n        assertEquals(0b10110, BitSwap.bitSwap(0b10110, 2, 2));\n\n        // Test with different bit positions - swap expected\n        assertEquals(0b00110, BitSwap.bitSwap(0b10100, 2, 4));\n\n        // Test with leading and trailing bits - swap expected\n        assertEquals(0b10001, BitSwap.bitSwap(0b00010, 0, 4));\n\n        // Test with all bits different - full swap expected\n        assertEquals(0b11110000, BitSwap.bitSwap(0b00001111, 0, 7));\n\n        // Test with negative data value\n        assertEquals(-0b10111, BitSwap.bitSwap(-0b10101, 0, 1));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    \n    @Test\n    public void bitSwapTest() {\n        // Test case where bits differ and should be swapped\n        assertEquals(0b101, BitSwap.bitSwap(0b001, 0, 2)); // swapping the least and most significant bit of 0b001\n\n        // Test case where bits are the same and no swap should occur\n        assertEquals(0b101, BitSwap.bitSwap(0b101, 0, 2)); // both bits at position 0 and 2 are 1\n        \n        // Test case with negative number\n        int data = -0b101001; // negative binary number\n        int expected = -0b100101; // expected after swap between positions 0 and 2\n        assertEquals(expected, BitSwap.bitSwap(data, 0, 2));\n        \n        // Test swapping with itself should give the same number\n        assertEquals(0b1101, BitSwap.bitSwap(0b1101, 2, 2));\n        \n        // Test swapping the most significant bit (MSB) with a bit at a different position\n        assertEquals(0b0100, BitSwap.bitSwap(0b1000, 3, 2));\n        \n        // Test case to swap bit 1 and bit 3\n        assertEquals(0b0110, BitSwap.bitSwap(0b1001, 1, 3));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Test case where bits are the same and therefore, no change should happen\n        assertEquals(5, BitSwap.bitSwap(5, 0, 2)); // 5 in binary is 101, swapping the 0th and 2nd bits changes nothing\n\n        // Test case where bits are different and should be swapped\n        assertEquals(1, BitSwap.bitSwap(2, 0, 1)); // 2 in binary is 10, swapping the 0th and 1st bits should yield 01\n        \n        // Test case on a large number and distant bit positions\n        assertEquals(0b1001000, BitSwap.bitSwap(0b1010000, 3, 6)); // Swap bit 3 and 6 of 0b1010000 -> should result in 0b1001000\n\n        // Test case to ensure no change when swapping the same bit position\n        assertEquals(0b1101, BitSwap.bitSwap(0b1101, 2, 2)); // Swapping the same bit position should result in no change\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Case 1: Swapping different bits\n        int result1 = BitSwap.bitSwap(0b1010, 1, 3); // Swap bits at positions 1 and 3\n        assertEquals(0b0010, result1, \"Bits at positions 1 and 3 should be swapped.\");\n\n        // Case 2: Swapping same bits, no change should happen\n        int result2 = BitSwap.bitSwap(0b1010, 2, 3); // Swap bits at positions 2 and 3\n        assertEquals(0b1010, result2, \"Swapping identical bits should not change the data.\");\n\n        // Case 3: Edge Case - Swapping the least-significant and most-significant bit\n        int result3 = BitSwap.bitSwap(0b1001, 0, 3); // Swap bits at positions 0 and 3\n        assertEquals(0b0001, result3, \"Bits at positions 0 and 3 should be swapped.\");\n\n        // Case 4: Swapping bits with negative position (invalid case)\n        // Since the method doesn't handle negative positions, we assume this as an invalid case\n        // We could either expect an exception or, no change in data if exception handling not done\n        // Uncomment the following lines if exceptions are expected/handled\n        // assertThrows(IndexOutOfBoundsException.class, () -> BitSwap.bitSwap(0b0101, -1, 2), \"Negative index should throw an exception.\");\n        \n        // Case 5: Swapping bits with position outside the integer range (invalid case)\n        // Similarly, we assume this as an invalid scenario, expecting either no change or exception\n        // Uncomment the following line if exceptions are expected/handled\n        // assertThrows(IndexOutOfBoundsException.class, () -> BitSwap.bitSwap(0b0101, 32, 2), \"Index out of bound should throw an exception.\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Swap bits 0 and 1 (0b01 --> 0b10 which is 2 in decimal)\n        assertEquals(2, BitSwap.bitSwap(1, 0, 1));\n\n        // Swap bits 0 and 2 (0b101 --> 0b001 which is 1 in decimal)\n        assertEquals(1, BitSwap.bitSwap(5, 0, 2));\n        \n        // Swap bits that are the same should result in the same number\n        assertEquals(10, BitSwap.bitSwap(10, 1, 1));\n        \n        // Test with bits at higher positions\n        assertEquals(0b101000, BitSwap.bitSwap(0b100010, 1, 5));\n        \n        // Test with negative number\n        int result = BitSwap.bitSwap(-3, 0, 1); // Swap LSBs: 0b...11111101 to 0b...11111110\n        assertTrue(Integer.bitCount(result) == Integer.bitCount(-3)); // Sanity check (same number of bits)\n        \n        // Make sure that the method doesn't modify the bits if posA and posB are equal\n        assertEquals(7, BitSwap.bitSwap(7, 2, 2));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n       // Test cases for bitSwap method\n       int testData = 0b101;\n       int posA = 0; // bit position (starting from 0)\n       int posB = 2; // bit position (starting from 0)\n       int expected = 0b010; // Expecting to swap the bits: 101 -> 010\n       assertEquals(expected, BitSwap.bitSwap(testData, posA, posB), \"Bits were not swapped correctly\");\n\n       testData = 0b111000;\n       posA = 2;\n       posB = 5;\n       expected = 0b101010; // Expecting to swap bits: 111000 -> 101010\n       assertEquals(expected, BitSwap.bitSwap(testData, posA, posB), \"Bits were not swapped correctly\");\n\n       // Test where bits at posA and posB are the same; no change expected\n       testData = 0b111000;\n       posA = 1;\n       posB = 4;\n       expected = testData; // As bits are the same, expect no change\n       assertEquals(expected, BitSwap.bitSwap(testData, posA, posB), \"Bits should not have been swapped\");\n       \n       // Test swapping bits back to their original position\n       testData = 0b010; // Starting with bits swapped\n       posA = 0; // bit position (starting from 0)\n       posB = 2; // bit position (starting from 0)\n       expected = 0b101; // Expect to swap bits back: 010 -> 101\n       assertEquals(expected, BitSwap.bitSwap(testData, posA, posB), \"Bits were not swapped back correctly\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Test swapping different bits\n        assertEquals(0b0110, BitSwap.bitSwap(0b1010, 1, 2));\n        assertEquals(0b1001, BitSwap.bitSwap(0b0110, 0, 3));\n\n        // Test swapping bits that are the same (no change expected)\n        assertEquals(0b1010, BitSwap.bitSwap(0b1010, 1, 3));\n        assertEquals(0b0101, BitSwap.bitSwap(0b0101, 1, 3));\n\n        // Test swapping bits at edge positions\n        assertEquals(0b1000_0000_0000_0000_0000_0000_0000_0011,\n                     BitSwap.bitSwap(0b0000_0000_0000_0000_0000_0000_0000_1011, 0, 31));\n        \n        // Test swapping bits for maximum integer value\n        assertEquals(Integer.MAX_VALUE - 1, BitSwap.bitSwap(Integer.MAX_VALUE, 0, 1));\n        \n        // Test swapping the same bit position (no change expected)\n        assertEquals(0b1010, BitSwap.bitSwap(0b1010, 2, 2));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        assertEquals(10, BitSwap.bitSwap(2, 1, 3)); // 0010 -> 1010\n        \n        assertEquals(2, BitSwap.bitSwap(10, 1, 3)); // 1010 -> 0010\n        \n        assertEquals(0b11001, BitSwap.bitSwap(0b10011, 0, 4)); // 10011 -> 11001\n        \n        assertEquals(0b10011, BitSwap.bitSwap(0b11001, 0, 4)); // 11001 -> 10011\n        \n        assertEquals(0b11110000, BitSwap.bitSwap(0b11110000, 2, 6)); // no change because bits are the same\n        \n        assertEquals(-1, BitSwap.bitSwap(-1, 0, 31)); // no change because bits are the same\n        \n        assertEquals(0x7FFFFFFE, BitSwap.bitSwap(0x80000001, 0, 31)); // 100...1 -> 011...0\n        \n        assertEquals(0x80000001, BitSwap.bitSwap(0x7FFFFFFE, 0, 31)); // 011...0 -> 100...1\n    }\n}"
    ]
}