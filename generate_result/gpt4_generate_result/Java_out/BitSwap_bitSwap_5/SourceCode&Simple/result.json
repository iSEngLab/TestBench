{
    "project_name": "Java",
    "file_name": "BitSwap.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/bitmanipulation/BitSwap.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.bitmanipulation",
    "docstring": null,
    "source_code": "/*\n * @brief Swaps the bits at the position posA and posB from data\n */\npublic static int bitSwap(int data, final int posA, final int posB) {\n    if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n        data ^= (1 << posA) ^ (1 << posB);\n    }\n    return data;\n}\n",
    "class_name": "BitSwap",
    "method_name": "bitSwap",
    "arguments": [
        "int data",
        "int posA",
        "int posB"
    ],
    "generate_test": [
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Initial data with the bit patterns. Example: int 2 is 0010 in binary.\n        int initialData1 = 0b0010; // bit at position 1 is 1, and at position 2 is 0\n        int initialData2 = 0b1010; // bit at position 1 is 1, and at position 3 is 0\n\n        // Expected results after swapping bits.\n        int expectedData1 = 0b0100; // expected result after swapping bits at positions 1 and 2\n        int expectedData2 = 0b0010; // expected result after swapping bits at positions 1 and 3\n\n        // Perform the actual bit swapping.\n        int resultData1 = BitSwap.bitSwap(initialData1, 1, 2);\n        int resultData2 = BitSwap.bitSwap(initialData2, 1, 3);\n\n        // Assert that the expected outcomes are correct.\n        assertEquals(expectedData1, resultData1, \"Bits at positions 1 and 2 should be swapped.\");\n        assertEquals(expectedData2, resultData2, \"Bits at positions 1 and 3 should be swapped.\");\n        \n        // Test with the same position, the data should remain unchanged\n        int resultData3 = BitSwap.bitSwap(initialData1, 1, 1);\n        assertEquals(initialData1, resultData3, \"Bits at the same position should result in no change.\");\n\n        // Test with an edge case of zero data, swap should have no effect\n        int resultData4 = BitSwap.bitSwap(0, 1, 2);\n        assertEquals(0, resultData4, \"Bits swap on zero data should result in zero.\");\n\n        // Test with an edge case of all bits as ones, swap should have no effect\n        int resultData5 = BitSwap.bitSwap(~0, 1, 2);\n        assertEquals(~0, resultData5, \"Bits swap with all ones should remain unchanged.\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Assuming we have a class SingleBitOperations with a method getBit for the sake of this task\n        assertEquals(BitSwap.bitSwap(0b1010, 1, 3), 0b0101); // Swaps 0 with 1\n        assertEquals(BitSwap.bitSwap(0b1001, 0, 3), 0b0010); // Swaps 1 with 0\n        assertEquals(BitSwap.bitSwap(0b1010, 2, 3), 0b1010); // Bits are the same, no swap needed\n        assertEquals(BitSwap.bitSwap(0b1111, 0, 3), 0b1111); // Bits are the same, no swap needed\n        assertEquals(BitSwap.bitSwap(0b0000, 1, 2), 0b0000); // Bits are the same, no swap needed\n        assertEquals(BitSwap.bitSwap(0xFFFFFFFF, 31, 0), 0xFFFFFFFF); // Bits are the same (all 1s), no swap needed\n        assertEquals(BitSwap.bitSwap(0xAAAAAAAA, 31, 0), 0x55555555); // Swaps a pair of bits in a pattern\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Test with no actual swap needed (bits at posA and posB are the same)\n        assertEquals(BitSwap.bitSwap(0b1010, 1, 3), 0b1010, \"No swap: bits are equal\");\n\n        // Test with swap needed (bits at posA and posB are different)\n        assertEquals(BitSwap.bitSwap(0b1010, 0, 1), 0b1001, \"Swap: bits at position 0 and 1 are different\");\n\n        // Test with swap needed with different positions \n        assertEquals(BitSwap.bitSwap(0b1110, 2, 3), 0b1011, \"Swap: bits at position 2 and 3 are different\");\n\n        // Edge cases: swapping the same position should not alter the data\n        assertEquals(BitSwap.bitSwap(0xFFFFFFFF, 0, 0), 0xFFFFFFFF, \"Swap: same positions should not alter the data\");\n\n        // Test with different large value and swapping the least and most significant bits\n        assertEquals(BitSwap.bitSwap(0xA5A5A5A5, 0, 31), 0x5A5A5A5A, \"Swap: least and most significant bits are different\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Test bit swapping of data if bits are different\n        int data = 0b1010; // binary representation: 10 in decimal\n        int posA = 1;\n        int posB = 3;\n        int expectedResult = 0b0101; // After swapping bit at position 1 and 3, it should be 5 in decimal\n        assertEquals(expectedResult, BitSwap.bitSwap(data, posA, posB));\n        \n        // Test bit swapping of data if bits are the same\n        data = 0b1010; // binary representation: 10 in decimal\n        posA = 1;\n        posB = 2;\n        expectedResult = data; // Since bits at position 1 and 2 are same, data should remain unchanged (10 in decimal)\n        assertEquals(expectedResult, BitSwap.bitSwap(data, posA, posB));\n\n        // Test with negative numbers and different positions\n        data = -0b1010; // binary representation: -10 in decimal, in two's complement\n        posA = 0;\n        posB = 3;\n        // Expected to swap the least significant bit with a bit at position 3\n        expectedResult = -0b0111; // Should be -7 in decimal after swapping\n        assertEquals(expectedResult, BitSwap.bitSwap(data, posA, posB));\n        \n        // Test bit swapping with large numbers\n        data = 0b10000000000000000000000000001111; // large number with some bit set\n        posA = 0;\n        posB = 31;\n        expectedResult = 0b01111000000000000000000000000001; // Expected to swap highest bit with the lowest bit\n        assertEquals(expectedResult, BitSwap.bitSwap(data, posA, posB));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Case 1: Swap bits that are different\n        int originalData = 0b1010; // binary representation: 10 in decimal\n        int swappedData = BitSwap.bitSwap(originalData, 1, 3);\n        assertEquals(0b0101, swappedData); // expected result after swapping is 5 in decimal\n        \n        // Case 2: Swap bits that are the same\n        originalData = 0b1001; // binary representation: 9 in decimal\n        swappedData = BitSwap.bitSwap(originalData, 0, 3);\n        assertEquals(0b1001, swappedData); // expected result is the same since bits are identical\n        \n        // Case 3: Test with swapping bits at the boundaries of an integer\n        originalData = 0b1000_0000_0000_0000_0000_0000_0000_0001; // -2147483648 (Integer.MIN_VALUE) with a flipped LSB\n        swappedData = BitSwap.bitSwap(originalData, 0, 31);\n        assertEquals(0b0000_0000_0000_0000_0000_0000_0000_0010, swappedData); // expected is 2 in decimal\n        \n        // Add more cases as necessary to fully test the method\n        // ...\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Case where bits are different and should be swapped\n        assertEquals(11, BitSwap.bitSwap(9, 0, 3), \"Bits at position 0 and 3 should be swapped.\");\n        \n        // Case where bits are the same and no swap should happen\n        assertEquals(10, BitSwap.bitSwap(10, 1, 2), \"Bits at position 1 and 2 are the same. No swap.\");\n        \n        // Case where posA and posB are the same\n        assertEquals(8, BitSwap.bitSwap(8, 2, 2), \"Swapping the same bit position should result in no change.\");\n        \n        // Case where bit positions are out of bounds for the data size (assumes int size of 32 bits)\n        assertThrows(IndexOutOfBoundsException.class, () -> {\n            BitSwap.bitSwap(5, 32, 33);\n        }, \"Should throw IndexOutOfBoundsException for bit positions beyond data size.\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n  \n    @Test\n    public void bitSwapTest() {\n        assertEquals(10, BitSwap.bitSwap(2, 1, 3)); // Case where the bits are different and should be swapped\n        assertEquals(2, BitSwap.bitSwap(2, 1, 1)); // Case where same bits are to be swapped, should remain unchanged\n        assertEquals(0, BitSwap.bitSwap(0, 1, 3)); // Swap on all zeros should result in zero\n        assertEquals(-1, BitSwap.bitSwap(-1, 1, 3)); // Swap on all ones (or -1 in two's complement) should result in -1\n        assertEquals(6, BitSwap.bitSwap(5, 2, 1)); // Swapping bits in positions 2 and 1 in 5 (binary 101) should result in 6 (binary 110)\n        assertThrows(IllegalArgumentException.class, () -> BitSwap.bitSwap(5, 32, 1)); // Should throw an exception for invalid bit position > 31\n        assertThrows(IllegalArgumentException.class, () -> BitSwap.bitSwap(5, -1, 1)); // Should throw an exception for negative bit position\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    \n    @Test\n    public void bitSwapTest() {\n        // Test swapping different bits\n        int dataOriginal = 0b1010; // binary representation: 10 in decimal\n        int posA = 1; // second bit from right\n        int posB = 3; // fourth bit from right\n        int expected = 0b0101; // after swapping, should be 5 in decimal\n        assertEquals(expected, BitSwap.bitSwap(dataOriginal, posA, posB));\n\n        // Test swapping the same bit, should not affect the data\n        dataOriginal = 0b1010; // binary representation: 10 in decimal\n        posA = 2; // third bit from right\n        posB = 2; // third bit from right\n        expected = 0b1010; // after \"swapping\", should remain same\n        assertEquals(expected, BitSwap.bitSwap(dataOriginal, posA, posB));\n        \n        // Test swapping bits at positions with the same bit value; no change expected\n        dataOriginal = 0b1010; // binary representation: 10 in decimal\n        posA = 0; // first bit from right\n        posB = 2; // third bit from right\n        expected = 0b1010; // after swapping same bits, should remain same\n        assertEquals(expected, BitSwap.bitSwap(dataOriginal, posA, posB));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Test swapping different bits\n        assertEquals(0b10110, BitSwap.bitSwap(0b10011, 1, 4)); // swaps bits at 1 and 4 position (0-based)\n        \n        // Test swapping the same bit: no change expected\n        assertEquals(0b10101, BitSwap.bitSwap(0b10101, 2, 2)); // swapping the same bit position should result in the same number\n        \n        // Additional test cases\n        assertEquals(0b11101, BitSwap.bitSwap(0b11011, 0, 2)); // swaps bits at 0 and 2 position (0-based)\n        assertEquals(0b11001, BitSwap.bitSwap(0b11001, 0, 5)); // swapping with a bit outside of the number's range should result in no change\n        assertEquals(0xFFFFFFFF, BitSwap.bitSwap(0xFFFFFFFF, 16, 31)); // swapping bits in a number where all bits are set should result in no change\n\n        // Test with 0 data input\n        assertEquals(0, BitSwap.bitSwap(0, 0, 31)); // swapping bits in a 0 number should result in no change\n\n        // Test with negative numbers\n        assertEquals(-1073741825, BitSwap.bitSwap(-1073741823, 0, 31)); // swaps MSB and LSB of Integer.MAX_VALUE + 2\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Test case when the bits at posA and posB are the same - no change expected\n        assertEquals(0b1010, BitSwap.bitSwap(0b1010, 1, 3));\n\n        // Test case when bits are different - swap should change the positions\n        assertEquals(0b1110, BitSwap.bitSwap(0b1101, 2, 0));\n        \n        // Test case with swapping the same position - no change expected\n        assertEquals(0b1001, BitSwap.bitSwap(0b1001, 0, 0));\n        \n        // Test for large data values\n        assertEquals(0b10010010010010010010010010010010, BitSwap.bitSwap(0b10010010010010010010010010010010, 16, 16));\n        \n        // Test case with negative data\n        assertEquals(-0b10010010010010010010010010010010, BitSwap.bitSwap(-0b10010010010010010010010010010011, 1, 0));\n        \n        // Test case with posA and posB out of range, assuming that they should not modify the data\n        // This assumes the SingleBitOperations.getBit method handles out of range values without error.\n        // If SingleBitOperations.getBit may throw an exception for out of range values, exception handling should be tested instead.\n        assertEquals(0b1001, BitSwap.bitSwap(0b1001, 32, 32));\n        assertEquals(0b1001, BitSwap.bitSwap(0b1001, -1, -1));\n    }\n}"
    ]
}