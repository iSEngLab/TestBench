{
    "project_name": "Java",
    "file_name": "BitSwap.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/bitmanipulation/BitSwap.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.bitmanipulation",
    "docstring": null,
    "source_code": "/*\n * @brief Swaps the bits at the position posA and posB from data\n */\npublic static int bitSwap(int data, final int posA, final int posB) {\n    if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n        data ^= (1 << posA) ^ (1 << posB);\n    }\n    return data;\n}\n",
    "class_name": "BitSwap",
    "method_name": "bitSwap",
    "arguments": [
        "int data",
        "int posA",
        "int posB"
    ],
    "generate_test": [
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    \n    @Test\n    public void bitSwapTest() {\n        // Let's test with a number where binary representation\n        // is '1010' (10 in decimal), and we swap the bits at position 1 and 3.\n        // After swapping the binary representation should be '0101' (5 in decimal).\n        int data = 10; // binary: 1010\n        int posA = 1;\n        int posB = 3;\n        int expected = 5; // binary: 0101\n        int result = BitSwap.bitSwap(data, posA, posB);\n        assertEquals(expected, result, \"Bits at positions 1 and 3 should be swapped.\");\n\n        // Test where swapping does not alter the number\n        // For example, '1010' swapping positions 2 and 2 (same position) should result in '1010'.\n        data = 10; // binary: 1010\n        posA = 2;\n        posB = 2;\n        expected = 10; // binary: 1010 (no change expected)\n        result = BitSwap.bitSwap(data, posA, posB);\n        assertEquals(expected, result, \"Swapping bits at the same position should not change the data.\");\n\n        // Test with another number where we swap end bits (positions 0 and 3)\n        // For '1001' (9 in decimal), swapping should result in '0110' (6 in decimal).\n        data = 9; // binary: 1001\n        posA = 0;\n        posB = 3;\n        expected = 6; // binary: 0110\n        result = BitSwap.bitSwap(data, posA, posB);\n        assertEquals(expected, result, \"Bits at positions 0 and 3 should be swapped.\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        assertEquals(0b1010, BitSwap.bitSwap(0b1001, 1, 3));\n        assertEquals(0b1001, BitSwap.bitSwap(0b1010, 1, 3));\n        assertEquals(-1, BitSwap.bitSwap(-1, 1, 3)); // Assuming -1 in bits is all bits set due to two's complement.\n        assertEquals(0, BitSwap.bitSwap(0, 1, 3));\n        assertEquals(0b1110, BitSwap.bitSwap(0b0111, 0, 3));\n        assertEquals(0b1001000, BitSwap.bitSwap(0b1000100, 2, 5));\n        assertEquals(0b10000000, BitSwap.bitSwap(0b00000001, 7, 0));\n        // Test the same bit position should not change the data\n        assertEquals(0b1001, BitSwap.bitSwap(0b1001, 2, 2));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Test swapping bits that are different\n        int inputData = 0b1010; // binary representation is 1010 (10 in decimal)\n        int expectedData = 0b0101; // expected after swap is 0101 (5 in decimal)\n        int posA = 0; // position of the first bit (counting from 0)\n        int posB = 2; // position of the second bit (counting from 0)\n        int resultData = BitSwap.bitSwap(inputData, posA, posB);\n        assertEquals(expectedData, resultData, \"The bits were not swapped correctly.\");\n\n        // Test swapping bits that are the same\n        inputData = 0b1110; // binary representation is 1110 (14 in decimal)\n        expectedData = 0b1110; // expected after swap is 1110 (14 in decimal, no change)\n        posA = 1; // position of the first bit (counting from 0)\n        posB = 3; // position of the second bit (counting from 0)\n        resultData = BitSwap.bitSwap(inputData, posA, posB);\n        assertEquals(expectedData, resultData, \"The bits were swapped incorrectly (should be no change).\");\n\n        // Test swap between the same position (should have no effect)\n        inputData = 0b1001; // binary representation is 1001 (9 in decimal)\n        expectedData = 0b1001; // expected after swap is 1001 (9 in decimal, no change)\n        posA = 0; // both positions are the same\n        posB = 0; // both positions are the same\n        resultData = BitSwap.bitSwap(inputData, posA, posB);\n        assertEquals(expectedData, resultData, \"The bits were swapped incorrectly (should be no change).\");\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Example usage of the bitSwap method\n        // Let's say we swap bits at position 2 and 5 in the number 42 (binary 00101010)\n        // Expected result is binary 10000010 which is 130 in decimal\n        assertEquals(130, BitManipulation.bitSwap(42, 2, 5));\n        \n        // Testing with the same bit position should return the same data\n        assertEquals(42, BitManipulation.bitSwap(42, 2, 2));\n        \n        // Testing with zero should return zero\n        assertEquals(0, BitManipulation.bitSwap(0, 1, 3));\n        \n        // Testing with the highest and lowest bit positions swapped\n        int data = 0b10000000000000000000000000000001; // This is -2147483647 in two's complement\n        int expected = 0b00000000000000000000000000000010; // This is 2 in decimal\n        assertEquals(expected, BitManipulation.bitSwap(data, 0, 31));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Test swapping different bits\n        int originalData = 0b101010; // binary representation of 42\n        int posA = 1; // second bit from the right\n        int posB = 5; // sixth bit from the right\n        int expectedOutput = 0b001011; // binary representation of 11\n        assertEquals(expectedOutput, BitManipulation.bitSwap(originalData, posA, posB));\n\n        // Test swapping the same bit (should result in the same data)\n        originalData = 0b101010; // binary representation of 42\n        posA = 2;\n        posB = 2; // Same position\n        expectedOutput = originalData; // Should remain unchanged\n        assertEquals(expectedOutput, BitManipulation.bitSwap(originalData, posA, posB));\n\n        // Test swapping bits that are already the same (should result in the same data)\n        originalData = 0b111000; // binary representation of 56\n        posA = 4;\n        posB = 5;\n        expectedOutput = originalData; // Since bits at position 4 and 5 are the same, there's no change\n        assertEquals(expectedOutput, BitManipulation.bitSwap(originalData, posA, posB));\n    }\n}\n\n// Note: You should assume that a class named BitManipulation exists and that it contains the static method bitSwap. \n// The test class is named BitSwapTest accordingly.",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Case 1: Swapping different bits\n        int data1 = 0b1010; // Binary representation of 10\n        int result1 = BitSwap.bitSwap(data1, 1, 3); // Should swap bits at positions 1 and 3\n        assertEquals(0b0101, result1); // Expected result is 5\n\n        // Case 2: Swapping the same bit - should yield the same number\n        int data2 = 0b1010; // Binary representation of 10\n        int result2 = BitSwap.bitSwap(data2, 2, 2); // Swapping the same bit should result in no change\n        assertEquals(data2, result2);\n\n        // Case 3: Swapping bits that are already the same - should yield same number\n        int data3 = 0b1110; // Binary representation of 14\n        int result3 = BitSwap.bitSwap(data3, 1, 2); // Bits at positions 1 and 2 are the same\n        assertEquals(data3, result3);\n\n        // Case 4: Swapping bits with zero - should toggle bits\n        int data4 = 0b1001; // Binary representation of 9\n        int result4 = BitSwap.bitSwap(data4, 0, 3); // Should swap bits at positions 0 and 3\n        assertEquals(0b0010, result4); // Expected result is 2\n\n        // Add more cases if needed to test additional scenarios\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Test swapping different bits\n        assertEquals(10, BitManipulation.bitSwap(8, 0, 1));\n\n        // Test swapping the same bit, the value should not change\n        assertEquals(8, BitManipulation.bitSwap(8, 1, 1));\n\n        // Test with negative numbers\n        assertEquals(-2147483648, BitManipulation.bitSwap(-1, 31, 0));\n\n        // Test with zero, no bits to swap, the value should not change\n        assertEquals(0, BitManipulation.bitSwap(0, 2, 5));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n\n    @Test\n    public void bitSwapTest() {\n        // Let's create a scenario where we know what the output should be  \n        // For example, swap bits at positions 1 and 3 (zero-based) in the binary number 00010110 (22 in decimal)\n        // After the swap, it should become 00100100 (36 in decimal)\n\n        int originalData = 22; // binary: 00010110\n        int expectedData = 36; // binary: 00100100\n        int posA = 1;\n        int posB = 3;\n\n        // Let's test with a known example\n        assertEquals(expectedData, BitSwap.bitSwap(originalData, posA, posB));\n\n        // Test if swapping the same position results in the same number\n        assertEquals(originalData, BitSwap.bitSwap(originalData, posA, posA));\n\n        // Test with different numbers, posA, and posB \n        originalData = 57; // binary: 00111001\n        expectedData = 49;  // binary: 00110001\n        posA = 0; \n        posB = 3;\n\n        assertEquals(expectedData, BitSwap.bitSwap(originalData, posA, posB));\n\n        // Test with a case where bits are already the same and should not change\n        originalData = 10; // binary: 00001010\n        expectedData = originalData; // should remain unchanged\n        posA = 1;\n        posB = 3;\n\n        assertEquals(expectedData, BitSwap.bitSwap(originalData, posA, posB));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        assertEquals(10, SingleBitOperations.bitSwap(12, 1, 2));\n        assertEquals(12, SingleBitOperations.bitSwap(10, 1, 2));\n        assertEquals(1, SingleBitOperations.bitSwap(1, 0, 2));\n        assertEquals(5, SingleBitOperations.bitSwap(5, 3, 7));\n        assertEquals(0b10101, SingleBitOperations.bitSwap(0b10011, 0, 2));\n        assertEquals(-1, SingleBitOperations.bitSwap(-1, 1, 30));\n        assertEquals(0, SingleBitOperations.bitSwap(0, 1, 2));\n    }\n}",
        "package com.thealgorithms.bitmanipulation;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BitSwapTest {\n    @Test\n    public void bitSwapTest() {\n        // Test case where bits are different and should be swapped\n        int data = 0b1010; // binary representation of 10\n        int posA = 1;\n        int posB = 3;\n        int expectedResult = 0b0101; // binary representation of 5 after swap\n        assertEquals(expectedResult, SingleBitOperations.bitSwap(data, posA, posB));\n\n        // Test case where bits are the same and data should remain unchanged\n        data = 0b10101; // binary representation of 21\n        posA = 2;\n        posB = 0;\n        expectedResult = 0b10101; // binary representation remains 21\n        assertEquals(expectedResult, SingleBitOperations.bitSwap(data, posA, posB));\n\n        // Test with another set where bits are different\n        data = 0b1111; // binary representation of 15\n        posA = 3;\n        posB = 0;\n        expectedResult = 0b10001; // binary representation of 17 after swap\n        assertEquals(expectedResult, SingleBitOperations.bitSwap(data, posA, posB));\n        \n        // Test swapping bits in the same position should result in the same number\n        data = 0b1001; // binary representation of 9\n        posA = 2;\n        posB = 2;\n        expectedResult = 0b1001; // binary representation remains 9\n        assertEquals(expectedResult, SingleBitOperations.bitSwap(data, posA, posB));\n        \n        // Test invalid positions, expecting original data as positions are out of bounds\n        data = 0b0010; // binary representation of 2\n        posA = 32;     // out of bound position\n        posB = 1;\n        expectedResult = data; // Should remain unchanged\n        assertEquals(expectedResult, SingleBitOperations.bitSwap(data, posA, posB));\n\n        data = 0b0110; // binary representation of 6\n        posA = 1;\n        posB = -1;    // negative position\n        expectedResult = data; // Should remain unchanged\n        assertEquals(expectedResult, SingleBitOperations.bitSwap(data, posA, posB));\n    }\n}"
    ]
}