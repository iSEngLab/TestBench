{
    "project_name": "Java",
    "file_name": "FFT.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.maths",
    "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
    "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
    "class_name": "FFT",
    "method_name": "fft",
    "arguments": [
        "ArrayList<Complex> x",
        "boolean inverse"
    ],
    "generate_test": [
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    private static final double DELTA = 1e-8;\n\n    @Test\n    public void fftTest() {\n        // Input signal (real part only)\n        ArrayList<FFT.Complex> inputSignal = new ArrayList<>();\n        inputSignal.add(new FFT.Complex(1.0, 0.0));\n        inputSignal.add(new FFT.Complex(2.0, 0.0));\n        inputSignal.add(new FFT.Complex(3.0, 0.0));\n        inputSignal.add(new FFT.Complex(4.0, 0.0));\n\n        // Expected output FFT coefficients (hardcoded or from known result)\n        ArrayList<FFT.Complex> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new FFT.Complex(10.0, 0.0));\n        expectedOutput.add(new FFT.Complex(-2.0, 2.0));\n        expectedOutput.add(new FFT.Complex(-2.0, 0.0));\n        expectedOutput.add(new FFT.Complex(-2.0, -2.0));\n\n        // Perform FFT on the input signal\n        ArrayList<FFT.Complex> actualOutput = FFT.fft(inputSignal, false);\n\n        // Assert the size of the result array matches the expected size\n        assertEquals(expectedOutput.size(), actualOutput.size(), \"The actual output size should match the expected output size.\");\n\n        // Assert each value of FFT output matches the expected value within a tolerance (DELTA)\n        for (int i = 0; i < expectedOutput.size(); i++) {\n            assertEquals(expectedOutput.get(i).getReal(), actualOutput.get(i).getReal(), DELTA, \"Real part of FFT output should match.\");\n            assertEquals(expectedOutput.get(i).getImaginary(), actualOutput.get(i).getImaginary(), DELTA, \"Imaginary part of FFT output should match.\");\n        }\n\n        // Test the inverse FFT which should return the original input signal.\n        ArrayList<FFT.Complex> recoveredSignal = FFT.fft(actualOutput, true);\n\n        // Assert the size of the recovered signal matches the input size\n        assertEquals(inputSignal.size(), recoveredSignal.size(), \"The size of the recovered signal should match the input signal size.\");\n\n        // Assert each value of the recovered signal matches the original input signal within a tolerance\n        for (int i = 0; i < inputSignal.size(); i++) {\n            assertEquals(inputSignal.get(i).getReal(), recoveredSignal.get(i).getReal(), DELTA, \"Real part of the recovered signal should match the input signal.\");\n            assertEquals(inputSignal.get(i).getImaginary(), recoveredSignal.get(i).getImaginary(), DELTA, \"Imaginary part of the recovered signal should match the input signal.\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    private final double tolerance = 1e-9; // for double comparison in Assertions\n\n    @Test\n    public void fftTest() {\n        FFT fft = new FFT();\n        ArrayList<FFT.Complex> input = new ArrayList<>();\n        \n        // Adding simple inputs to the array\n        input.add(fft.new Complex(0, 0));\n        input.add(fft.new Complex(1, 1));\n        input.add(fft.new Complex(3, 3));\n        input.add(fft.new Complex(4, 4));\n        // FFT expects the number of samples to be a power of two, if not it pads with zero\n        // which is the default constructor of Complex class in this case\n\n        // Expected output after applying FFT manually calculated or obtained from a reliable source\n        ArrayList<FFT.Complex> expectedOutput = new ArrayList<>();\n        expectedOutput.add(fft.new Complex(8, 8));\n        expectedOutput.add(fft.new Complex(-2, -2));\n        expectedOutput.add(fft.new Complex(-4, -4));\n        expectedOutput.add(fft.new Complex(-2, -2));\n\n        ArrayList<FFT.Complex> result = FFT.fft(input, false); // false for forward FFT\n\n        // Check if the result size matches the expected output size\n        assertEquals(expectedOutput.size(), result.size(), \"FFT result array size should match expected output size.\");\n        \n        // Check if the result and expected output match within the allowed tolerance\n        for (int i = 0; i < result.size(); i++) {\n            assertEquals(expectedOutput.get(i).getReal(), result.get(i).getReal(), tolerance, \"Real part of complex number at index \" + i + \" should match.\");\n            assertEquals(expectedOutput.get(i).getImaginary(), result.get(i).getImaginary(), tolerance, \"Imaginary part of complex number at index \" + i + \" should match.\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Creating a discrete signal in time domain\n        ArrayList<FFT.Complex> signal = new ArrayList<>();\n        signal.add(new FFT.Complex(0, 0));\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(0, 0));\n        signal.add(new FFT.Complex(-1, 0));\n\n        // Apply FFT\n        ArrayList<FFT.Complex> fourierTransform = FFT.fft(signal, false);\n\n        // Expected values after FFT calculation (DFT of the given signal)\n        ArrayList<FFT.Complex> expectedFourier = new ArrayList<>();\n        expectedFourier.add(new FFT.Complex(0, 0));\n        expectedFourier.add(new FFT.Complex(0, -2));\n        expectedFourier.add(new FFT.Complex(0, 0));\n        expectedFourier.add(new FFT.Complex(0, 2));\n        \n        // Compare expected values with actual values\n        // Allow a small error margin\n        double delta = 1e-10;\n        for (int i = 0; i < fourierTransform.size(); i++) {\n            assertEquals(expectedFourier.get(i).getReal(), fourierTransform.get(i).getReal(), delta);\n            assertEquals(expectedFourier.get(i).getImaginary(), fourierTransform.get(i).getImaginary(), delta);\n        }\n\n        // Test inverse FFT\n        ArrayList<FFT.Complex> inverseFFT = FFT.fft(fourierTransform, true);\n\n        // The inverse FFT should give back the original time domain signal\n        // Compare expected signal with actual values (resulted from inverse FFT)\n        for (int i = 0; i < signal.size(); i++) {\n            assertEquals(signal.get(i).getReal(), inverseFFT.get(i).getReal(), delta);\n            assertEquals(signal.get(i).getImaginary(), inverseFFT.get(i).getImaginary(), delta);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Create a test signal as a list of complex numbers\n        ArrayList<FFT.Complex> signal = new ArrayList<>();\n        signal.add(new FFT.Complex(0.0, 0.0));\n        signal.add(new FFT.Complex(1.0, 0.0));\n        signal.add(new FFT.Complex(0.0, 0.0));\n        signal.add(new FFT.Complex(-1.0, 0.0));\n        // Pad the signal to a power of two length\n        FFT.paddingPowerOfTwo(signal);\n\n        // Perform FFT\n        ArrayList<FFT.Complex> fftResult = FFT.fft(signal, false);\n\n        // Expected FFT result (assuming known expected values)\n        ArrayList<FFT.Complex> expectedFFTResult = new ArrayList<>();\n        expectedFFTResult.add(new FFT.Complex(0.0, 0.0));\n        expectedFFTResult.add(new FFT.Complex(2.0, -2.0));\n        expectedFFTResult.add(new FFT.Complex(0.0, 0.0));\n        expectedFFTResult.add(new FFT.Complex(0.0, 0.0));\n        expectedFFTResult.add(new FFT.Complex(0.0, 0.0));\n        expectedFFTResult.add(new FFT.Complex(-2.0, -2.0));\n        expectedFFTResult.add(new FFT.Complex(0.0, 0.0));\n        expectedFFTResult.add(new FFT.Complex(0.0, 0.0));\n\n        // Verify the FFT result matches the expected result\n        for (int i = 0; i < fftResult.size(); i++) {\n            assertEquals(expectedFFTResult.get(i).getReal(), fftResult.get(i).getReal(), 1E-9);\n            assertEquals(expectedFFTResult.get(i).getImaginary(), fftResult.get(i).getImaginary(), 1E-9);\n        }\n    }\n\n    @Test\n    public void inverseFftTest() {\n        // Prepare an FFT result (here we use the same signal for simplicity)\n        ArrayList<FFT.Complex> fftResult = new ArrayList<>();\n        fftResult.add(new FFT.Complex(0.0, 0.0));\n        fftResult.add(new FFT.Complex(2.0, -2.0));\n        fftResult.add(new FFT.Complex(0.0, 0.0));\n        fftResult.add(new FFT.Complex(0.0, 0.0));\n        fftResult.add(new FFT.Complex(0.0, 0.0));\n        fftResult.add(new FFT.Complex(-2.0, -2.0));\n        fftResult.add(new FFT.Complex(0.0, 0.0));\n        fftResult.add(new FFT.Complex(0.0, 0.0));\n        // Pad the signal to a power of two length\n        FFT.paddingPowerOfTwo(fftResult);\n\n        // Perform inverse FFT\n        ArrayList<FFT.Complex> originalSignal = FFT.fft(fftResult, true);\n\n        // Expected original signal (assuming known expected values)\n        ArrayList<FFT.Complex> expectedOriginalSignal = new ArrayList<>();\n        expectedOriginalSignal.add(new FFT.Complex(0.0, 0.0));\n        expectedOriginalSignal.add(new FFT.Complex(1.0, 0.0));\n        expectedOriginalSignal.add(new FFT.Complex(0.0, 0.0));\n        expectedOriginalSignal.add(new FFT.Complex(-1.0, 0.0));\n        expectedOriginalSignal.add(new FFT.Complex(0.0, 0.0));\n        expectedOriginalSignal.add(new FFT.Complex(0.0, 0.0));\n        expectedOriginalSignal.add(new FFT.Complex(0.0, 0.0));\n        expectedOriginalSignal.add(new FFT.Complex(0.0, 0.0));\n\n        // Verify inverse FFT result returns the original signal\n        for (int i = 0; i < originalSignal.size(); i++) {\n            assertEquals(expectedOriginalSignal.get(i).getReal(), originalSignal.get(i).getReal(), 1E-9);\n            assertEquals(expectedOriginalSignal.get(i).getImaginary(), originalSignal.get(i).getImaginary(), 1E-9);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Create a test signal\n        ArrayList<Complex> x = new ArrayList<>();\n        x.add(new Complex(1,0));\n        x.add(new Complex(1,0));\n        x.add(new Complex(1,0));\n        x.add(new Complex(1,0));\n        x.add(new Complex(0,0));\n        x.add(new Complex(0,0));\n        x.add(new Complex(0,0));\n        x.add(new Complex(0,0));\n\n        // Expected FFT of the test signal\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(4,0));\n        expected.add(new Complex(1,-2.4142));\n        expected.add(new Complex(0,0));\n        expected.add(new Complex(1,-0.4142));\n        expected.add(new Complex(0,0));\n        expected.add(new Complex(1,0.4142));\n        expected.add(new Complex(0,0));\n        expected.add(new Complex(1,2.4142));\n\n        // Calculate FFT\n        ArrayList<Complex> fftResult = FFT.fft(x, false);\n\n        // Verify each element of the FFT result against expected values\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(expected.get(i).getReal(), fftResult.get(i).getReal(), 0.001, \"Real part doesn't match for index \" + i);\n            assertEquals(expected.get(i).getImaginary(), fftResult.get(i).getImaginary(), 0.001, \"Imaginary part doesn't match for index \" + i);\n        }\n\n        // Inverse FFT to get original signal\n        ArrayList<Complex> ifftResult = FFT.fft(fftResult, true);\n\n        // Verify the inverse FFT result against original signal\n        for (int i = 0; i < x.size(); i++) {\n            assertEquals(x.get(i).getReal(), ifftResult.get(i).getReal(), 0.001, \"Real part doesn't match for index \" + i);\n            assertEquals(x.get(i).getImaginary(), ifftResult.get(i).getImaginary(), 0.001, \"Imaginary part doesn't match for index \" + i);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        ArrayList<FFT.Complex> x = new ArrayList<>();\n        x.add(new FFT.Complex(0, 0));\n        x.add(new FFT.Complex(2, 0));\n        x.add(new FFT.Complex(0, 0));\n        x.add(new FFT.Complex(-2, 0));\n\n        ArrayList<FFT.Complex> expected = new ArrayList<>();\n        expected.add(new FFT.Complex(0 / 4.0, 0));\n        expected.add(new FFT.Complex(1, -1));\n        expected.add(new FFT.Complex(2 / 4.0, 0));\n        expected.add(new FFT.Complex(1, 1));\n\n        ArrayList<FFT.Complex> result = FFT.fft(x, false);\n\n        assertEquals(expected.size(), result.size());\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(expected.get(i).getReal(), result.get(i).getReal(), 1e-9);\n            assertEquals(expected.get(i).getImaginary(), result.get(i).getImaginary(), 1e-9);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<FFT.Complex> input = new ArrayList<>();\n        input.add(new FFT.Complex(0.0, 0.0));\n        input.add(new FFT.Complex(1.0, 1.0));\n        input.add(new FFT.Complex(3.0, 3.0));\n        input.add(new FFT.Complex(4.0, 4.0));\n        input.add(new FFT.Complex(2.0, 2.0));\n        input.add(new FFT.Complex(2.0, 2.0));\n        FFT.paddingPowerOfTwo(input); // Ensure input length is a power of 2\n        \n        ArrayList<FFT.Complex> forwardFFT = FFT.fft(input, false);\n        \n        // Check if the size of the result is a power of two\n        assertTrue((forwardFFT.size() & (forwardFFT.size() - 1)) == 0);\n        \n        // Check if inverse FFT results in original time-domain signal\n        ArrayList<FFT.Complex> inverseFFT = FFT.fft(forwardFFT, true);\n        \n        for (int i = 0; i < input.size(); ++i) {\n            assertEquals(input.get(i).getReal(), inverseFFT.get(i).getReal(), 1E-9);\n            assertEquals(input.get(i).getImaginary(), inverseFFT.get(i).getImaginary(), 1E-9);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Initialize an ArrayList with some test values\n        ArrayList<FFT.Complex> signal = new ArrayList<>();\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(1, 0));\n        signal.add(new FFT.Complex(0, 0));\n        signal.add(new FFT.Complex(0, 0));\n        signal.add(new FFT.Complex(0, 0));\n        signal.add(new FFT.Complex(0, 0));\n\n        // Expected result after applying FFT\n        ArrayList<FFT.Complex> expected = new ArrayList<>();\n        expected.add(new FFT.Complex(4, 0));\n        expected.add(new FFT.Complex(1, -2.414213562373095));\n        expected.add(new FFT.Complex(0, 0));\n        expected.add(new FFT.Complex(1, -0.4142135623730949));\n        expected.add(new FFT.Complex(0, 0));\n        expected.add(new FFT.Complex(1, 0.4142135623730949));\n        expected.add(new FFT.Complex(0, 0));\n        expected.add(new FFT.Complex(1, 2.414213562373095));\n\n        // Perform the FFT on the test values\n        ArrayList<FFT.Complex> result = FFT.fft(signal, false);\n\n        // Verify the size of the result is equal to the expected size\n        assertEquals(expected.size(), result.size(), \"The result size should match the expected size.\");\n\n        // Verify that each element of the result matches the expected element\n        for (int i = 0; i < result.size(); i++) {\n            FFT.Complex expectedComplex = expected.get(i);\n            FFT.Complex resultComplex = result.get(i);\n            assertEquals(expectedComplex.getReal(), resultComplex.getReal(), 1e-9, \"Real part does not match at index \" + i);\n            assertEquals(expectedComplex.getImaginary(), resultComplex.getImaginary(), 1e-9, \"Imaginary part does not match at index \" + i);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Create an array list of complex numbers for testing\n        ArrayList<FFT.Complex> input = new ArrayList<>();\n        input.add(new FFT.Complex(1, 0));\n        input.add(new FFT.Complex(1, 0));\n        input.add(new FFT.Complex(1, 0));\n        input.add(new FFT.Complex(1, 0));\n        input.add(new FFT.Complex(0, 0));\n        input.add(new FFT.Complex(0, 0));\n        input.add(new FFT.Complex(0, 0));\n        input.add(new FFT.Complex(0, 0));\n\n        // Perform FFT on the input data\n        ArrayList<FFT.Complex> output = FFT.fft(input, false);\n\n        // Validate the size of the output\n        assertEquals(input.size(), output.size(), \"Output size should match input size.\");\n\n        // Expected results for the provided input (based on a DFT calculation)\n        double[][] expected = {\n                {4, 0},\n                {1, -2.414213562373095},\n                {0, 0},\n                {1, -0.4142135623730949},\n                {0, 0},\n                {1, 0.4142135623730949},\n                {0, 0},\n                {1, 2.414213562373095}\n        };\n\n        // Check if the output from FFT matches the expected results\n        for (int i = 0; i < output.size(); i++) {\n            assertEquals(expected[i][0], output.get(i).getReal(), 1e-9, \"Real part doesn't match for index \" + i);\n            assertEquals(expected[i][1], output.get(i).getImaginary(), 1e-9, \"Imaginary part doesn't match for index \" + i);\n        }\n\n        // Perform inverse FFT\n        ArrayList<FFT.Complex> inverseOutput = FFT.fft(output, true);\n\n        // Check if the inverse FFT restores the original input\n        for (int i = 0; i < inverseOutput.size(); i++) {\n            assertEquals(input.get(i).getReal(), inverseOutput.get(i).getReal(), 1e-9, \"Real part doesn't match for inverse FFT at index \" + i);\n            assertEquals(input.get(i).getImaginary(), inverseOutput.get(i).getImaginary(), 1e-9, \"Imaginary part doesn't match for inverse FFT at index \" + i);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Create a sample signal consisting of 4 complex numbers\n        ArrayList<Complex> inputSignal = new ArrayList<>();\n        inputSignal.add(new FFT.Complex(1, 0));\n        inputSignal.add(new FFT.Complex(1, 0));\n        inputSignal.add(new FFT.Complex(1, 0));\n        inputSignal.add(new FFT.Complex(1, 0));\n\n        // Perform FFT on the input signal\n        ArrayList<Complex> outputSignal = FFT.fft(inputSignal, false);\n\n        // Assert output signal size is the same as input signal\n        assertEquals(inputSignal.size(), outputSignal.size());\n\n        // Perform IFFT on the FFT result to obtain the original signal\n        ArrayList<Complex> reconstructedSignal = FFT.fft(outputSignal, true);\n\n        // Tolerance for floating-point comparison\n        double tolerance = 1e-9;\n\n        // Assert the original signal is reconstructed correctly\n        for (int i = 0; i < reconstructedSignal.size(); i++) {\n            assertEquals(inputSignal.get(i).getReal(), reconstructedSignal.get(i).getReal(), tolerance);\n            assertEquals(inputSignal.get(i).getImaginary(), reconstructedSignal.get(i).getImaginary(), tolerance);\n        }\n    }\n}"
    ]
}