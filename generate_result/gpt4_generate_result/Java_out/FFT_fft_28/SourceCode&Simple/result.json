{
    "project_name": "Java",
    "file_name": "FFT.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.maths",
    "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
    "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
    "class_name": "FFT",
    "method_name": "fft",
    "arguments": [
        "ArrayList<Complex> x",
        "boolean inverse"
    ],
    "generate_test": [
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Create a signal of size 4 (which is power of two)\n        ArrayList<Complex> signal = new ArrayList<Complex>();\n        signal.add(new Complex(4, 0));\n        signal.add(new Complex(1, 0));\n        signal.add(new Complex(3, 0));\n        signal.add(new Complex(2, 0));\n\n        // Perform FFT on the signal\n        ArrayList<Complex> transformed = FFT.fft(signal, false);\n\n        // Check the size of the transformed signal\n        assertEquals(4, transformed.size(), \"Transformed signal should be of the same size.\");\n\n        // Perform FFT on the same signal but now for inverse transformation\n        ArrayList<Complex> inverseTransformed = FFT.fft(transformed, true);\n\n        // Check whether the inverse FFT provides the original signal\n        for (int i = 0; i < signal.size(); i++) {\n            assertEquals(signal.get(i).getReal(), inverseTransformed.get(i).getReal(), 1E-9,\n                    \"Real part of the original signal and the inverse transformed signal should match.\");\n            assertEquals(signal.get(i).getImaginary(), inverseTransformed.get(i).getImaginary(), 1E-9,\n                    \"Imaginary part of the original signal and the inverse transformed signal should match.\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Preparing input\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new FFT.Complex(0.0, 0.0));\n        input.add(new FFT.Complex(1.0, 1.0));\n        input.add(new FFT.Complex(2.0, 2.0));\n        input.add(new FFT.Complex(3.0, 3.0));\n        \n        // Expected FFT result (Placeholder values, should be computed based on the FFT definition and input)\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new FFT.Complex(/* real part */, /* imaginary part */));\n        // Add the rest of the expected complex numbers as per the FFT definition and input\n\n        // Perform FFT\n        ArrayList<Complex> result = FFT.fft(input, false); // false for forward FFT\n\n        // Assert that the expected and actual result have same size\n        assertNotNull(result);\n        assertEquals(expected.size(), result.size());\n\n        // Check individual elements, with a tolerance for floating point comparisons\n        double tolerance = 1E-6;\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(expected.get(i).getReal(), result.get(i).getReal(), tolerance);\n            assertEquals(expected.get(i).getImaginary(), result.get(i).getImaginary(), tolerance);\n        }\n        \n        // Check inverse FFT restores the original input\n        ArrayList<Complex> inverseResult = FFT.fft(result, true); // true for inverse FFT\n        for (int i = 0; i < input.size(); i++) {\n            assertEquals(input.get(i).getReal(), inverseResult.get(i).getReal(), tolerance);\n            assertEquals(input.get(i).getImaginary(), inverseResult.get(i).getImaginary(), tolerance);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n    \n    private static final double EPSILON = 1e-9;\n    \n    @Test\n    public void fftTest() {\n        ArrayList<Complex> signal = new ArrayList<>();\n        // Create a dummy signal with at least 1 non-zero element to avoid all zeroes in FFT\n        signal.add(new Complex(0.0, 0.0));\n        signal.add(new Complex(1.0, 0.0));\n        signal.add(new Complex(1.0, 0.0));\n        signal.add(new Complex(0.0, 0.0));\n        \n        // Perform FFT on the signal\n        ArrayList<Complex> result = FFT.fft(signal, false);\n\n        // Assuming there is a defined FFT result from the given input, replace with expected output\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(2.0, 0.0)); // Expected values based on the FFT of the input\n        expected.add(new Complex(-1.0, 1.0));\n        expected.add(new Complex(0.0, 0.0));\n        expected.add(new Complex(-1.0, -1.0));\n        \n        // Check if the size is the same\n        assertEquals(expected.size(), result.size(), \"FFT result should have the same size as expected output.\");\n\n        // Verify the FFT result against the expected values\n        for (int i = 0; i < result.size(); i++) {\n            assertEquals(expected.get(i).getReal(), result.get(i).getReal(), EPSILON, \"Real part of FFT result should match the expected values.\");\n            assertEquals(expected.get(i).getImaginary(), result.get(i).getImaginary(), EPSILON, \"Imaginary part of FFT result should match the expected values.\");\n        }\n        \n        // Check inverse\n        ArrayList<Complex> inverseResult = FFT.fft(result, true);\n        \n        // Verify the inverse FFT to recover the original signal\n        for (int i = 0; i < inverseResult.size(); i++) {\n            assertEquals(signal.get(i).getReal(), inverseResult.get(i).getReal(), EPSILON, \"Real part of inverse FFT result should match the original signal.\");\n            assertEquals(signal.get(i).getImaginary(), inverseResult.get(i).getImaginary(), EPSILON, \"Imaginary part of inverse FFT result should match the original signal.\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Setup an input for the FFT\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(0, 0));\n        input.add(new Complex(1, 0));\n        input.add(new Complex(0, 0));\n        input.add(new Complex(0, 0));\n\n        // Perform FFT on the input\n        ArrayList<Complex> result = FFT.fft(input, false);\n\n        // Check if the size of the result is correct\n        assertEquals(input.size(), result.size());\n\n        // Expected result assuming that FFT is correctly implemented\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(1, 0)); // Assuming these values based on FFT computation\n        expected.add(new Complex(0.5, -0.5));\n        expected.add(new Complex(0, 0));\n        expected.add(new Complex(0.5, 0.5));\n\n        // Check each element of the FFT result against the expected result\n        for (int i = 0; i < result.size(); i++) {\n            assertEquals(expected.get(i).getReal(), result.get(i).getReal(), 0.0001, \"Real part does not match at index \" + i);\n            assertEquals(expected.get(i).getImaginary(), result.get(i).getImaginary(), 0.0001, \"Imaginary part does not match at index \" + i);\n        }\n\n        // Now, test inverse FFT\n        ArrayList<Complex> inverseResult = FFT.fft(result, true);\n\n        // Check each element of the inverse FFT result against the original input\n        for (int i = 0; i < inverseResult.size(); i++) {\n            assertEquals(input.get(i).getReal(), inverseResult.get(i).getReal(), 0.0001, \"Real part does not match after inverse FFT at index \" + i);\n            assertEquals(input.get(i).getImaginary(), inverseResult.get(i).getImaginary(), 0.0001, \"Imaginary part does not match after inverse FFT at index \" + i);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(0.0, 0.0));\n        input.add(new Complex(1.0, 0.0));\n        input.add(new Complex(0.0, 0.0));\n        input.add(new Complex(-1.0, 0.0));\n\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(0.0, 0.0));\n        expected.add(new Complex(1.0, -1.0));\n        expected.add(new Complex(0.0, 0.0));\n        expected.add(new Complex(1.0, 1.0));\n\n        ArrayList<Complex> result = FFT.fft(input, false);\n\n        assertEquals(expected.size(), result.size(), \"FFT result should have the same size as input.\");\n\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(expected.get(i).getReal(), result.get(i).getReal(), 0.001,\n                    \"Real part of FFT output not as expected at index \" + i);\n            assertEquals(expected.get(i).getImaginary(), result.get(i).getImaginary(), 0.001,\n                    \"Imaginary part of FFT output not as expected at index \" + i);\n        }\n\n        ArrayList<Complex> inverseResult = FFT.fft(result, true);\n        for (int i = 0; i < input.size(); i++) {\n            assertEquals(input.get(i).getReal(), inverseResult.get(i).getReal(), 0.001,\n                    \"Real part of inverse FFT output not as expected at index \" + i);\n            assertEquals(input.get(i).getImaginary(), inverseResult.get(i).getImaginary(), 0.001,\n                    \"Imaginary part of inverse FFT output not as expected at index \" + i);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Prepare input data\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(0, 0));\n        input.add(new Complex(1, 0));\n        input.add(new Complex(3, 0));\n        input.add(new Complex(4, 0));\n        \n        // Expected output for forward FFT (you would normally calculate this beforehand)\n        ArrayList<Complex> expectedOutput = new ArrayList<>();\n        expectedOutput.add(new Complex(8, 0)); // Replace with the actual expected values\n        expectedOutput.add(new Complex(-2, 2));\n        expectedOutput.add(new Complex(-4, 0));\n        expectedOutput.add(new Complex(-2, -2));\n        \n        // Invoke FFT\n        ArrayList<Complex> output = FFT.fft(input, false);\n        \n        // Check if the size is correct\n        assertEquals(expectedOutput.size(), output.size(), \"FFT output size should match expected size.\");\n        \n        // Check if each element is close enough to the expected result\n        for (int i = 0; i < output.size(); i++) {\n            assertEquals(expectedOutput.get(i).getReal(), output.get(i).getReal(), 0.0001, \"Real part should match\");\n            assertEquals(expectedOutput.get(i).getImaginary(), output.get(i).getImaginary(), 0.0001, \"Imaginary part should match\");\n        }\n    }\n    \n    // Additional utility methods and tests for findLog2, fftBitReversal, inverseFFT, etc. could be placed here.\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Set up the input for testing FFT algorithm\n        ArrayList<Complex> input = new ArrayList<>();\n        // Input signal: sine wave samples or other simple waveform\n        // For simplicity, assuming these are the samples\n        input.add(new Complex(0, 0));\n        input.add(new Complex(1, 0));\n        input.add(new Complex(0, 0));\n        input.add(new Complex(-1, 0));\n        \n        // Expected output: precomputed FFT of the input signal\n        // This would typically be computed by a known correct method\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(0, 0));  // Assuming these are the FFT results\n        expected.add(new Complex(2, -2));\n        expected.add(new Complex(0, 0));\n        expected.add(new Complex(0, 2));\n        \n        // Perform the actual FFT\n        ArrayList<Complex> actual = FFT.fft(input, false);\n        \n        // Assert that the expected and actual output are equal with a tolerance\n        double delta = 1e-9;  // Tolerance for floating point comparisons\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(expected.get(i).getReal(), actual.get(i).getReal(), delta, \"Real parts differ\");\n            assertEquals(expected.get(i).getImaginary(), actual.get(i).getImaginary(), delta, \"Imaginary parts differ\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        FFT fft = new FFT();\n        ArrayList<Complex> input = new ArrayList<>();\n        \n        // Populate the array with some complex numbers\n        input.add(new FFT.Complex(0, 0));\n        input.add(new FFT.Complex(1, 1));\n        input.add(new FFT.Complex(3, 3));\n        input.add(new FFT.Complex(4, 4));\n        input.add(new FFT.Complex(5, 5));\n        \n        // Use paddingPowerOfTwo to ensure input size is a power of two\n        fft.paddingPowerOfTwo(input);\n\n        // Test both forward and inverse FFT\n        ArrayList<Complex> forwardFft = fft.fft(input, false);\n        ArrayList<Complex> inverseFft = fft.fft(forwardFft, true);\n\n        // Size of the array should remain the same after the transformation\n        assertEquals(input.size(), forwardFft.size(), \"Forward FFT should not change the size of the array.\");\n        assertEquals(input.size(), inverseFft.size(), \"Inverse FFT should not change the size of the array.\");\n\n        // Check that the forward and then inverse FFT gives back the original array\n        double tolerance = 1e-9; // some small number due to floating point errors\n        for (int i = 0; i < input.size(); i++) {\n            assertEquals(input.get(i).getReal(), inverseFft.get(i).getReal(), tolerance,\n                    \"The real component should match the original after forward and inverse FFT\");\n            assertEquals(input.get(i).getImaginary(), inverseFft.get(i).getImaginary(), tolerance,\n                    \"The imaginary component should match the original after forward and inverse FFT\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Let's prepare a simple input array of 4 Complex numbers\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(0.0, 0.0));\n        input.add(new Complex(1.0, 1.0));\n        input.add(new Complex(0.5, -0.5));\n        input.add(new Complex(-1.0, 0.0));\n\n        // Then let's pad the input to be a power of two size if necessary\n        FFT.paddingPowerOfTwo(input);\n\n        // Calling the actual fft method\n        ArrayList<Complex> result = FFT.fft(input, false);\n\n        // Define an expected result array for comparison\n        ArrayList<Complex> expected = new ArrayList<>();\n        // These expected values are just placeholders and should be replaced with\n        // the calculated expected results of the fft function for a given input\n        expected.add(new Complex(0.5, 0.0)); // Expected results need to be calculated\n        expected.add(new Complex(-0.5, -1.0));\n        expected.add(new Complex(0.0, 0.5));\n        expected.add(new Complex(-0.5, 1.0));\n\n        assertEquals(expected.size(), result.size(), \"Resulting FFT size mismatch.\");\n\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(expected.get(i).getReal(), result.get(i).getReal(), 1e-9, \"Real part mismatch at index \" + i);\n            assertEquals(expected.get(i).getImaginary(), result.get(i).getImaginary(), 1e-9, \"Imaginary part mismatch at index \" + i);\n        }\n\n        // If inverse FFT test is also desired, it can go here\n        // ...\n\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    private static final double DELTA = 1e-9; // acceptable delta for floating point comparisons\n\n    @Test\n    public void fftTest() {\n        // Create a sample input for the FFT (a simple sine wave for example)\n        int sampleSize = 8; // ensure the sample size is a power of two for FFT\n        ArrayList<Complex> input = new ArrayList<>();\n        for (int i = 0; i < sampleSize; i++) {\n            // Generating a sine wave dummy data for testing\n            input.add(new Complex(Math.sin(2 * Math.PI * i / sampleSize), 0));\n        }\n\n        // Perform FFT\n        ArrayList<Complex> result = FFT.fft(input, false);\n\n        // Verify the size of the output is the same as the input\n        assertEquals(sampleSize, result.size());\n\n        // Verify the output - this is a very basic verification, in real cases, we should check if FFT was computed correctly\n        for (Complex c : result) {\n            assertNotNull(c);\n        }\n\n        // Optionally, verify certain properties of the FFT result such as the sum of squares (Parseval's theorem) remains the same\n        // Feel free to write additional checks for the transformation depending on the mathematical properties you expected to verify\n    }\n\n    // Optionally, add more tests for edge cases, inverse FFT, etc.\n    // ...\n}"
    ]
}