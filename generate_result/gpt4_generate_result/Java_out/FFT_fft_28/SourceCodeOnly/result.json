{
    "project_name": "Java",
    "file_name": "FFT.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.maths",
    "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
    "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
    "class_name": "FFT",
    "method_name": "fft",
    "arguments": [
        "ArrayList<Complex> x",
        "boolean inverse"
    ],
    "generate_test": [
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> input = new ArrayList<>();\n        // Adding 4 sample complex numbers (Assuming Complex class has a constructor taking real and imaginary parts)\n        input.add(new Complex(0, 0));\n        input.add(new Complex(1, 1));\n        input.add(new Complex(3, 3));\n        input.add(new Complex(4, 4));\n        \n        // Perform FFT\n        ArrayList<Complex> forwardTransformed = FFT.fft(input, false);\n        \n        // Check the size is the same\n        assertEquals(input.size(), forwardTransformed.size());\n        \n        // Perform inverse FFT\n        ArrayList<Complex> inverseTransformed = FFT.fft(forwardTransformed, true);\n        \n        // Check that the original array is recovered after the inverse transform\n        for (int i = 0; i < input.size(); i++) {\n            assertEquals(input.get(i).getReal(), inverseTransformed.get(i).getReal(), 1e-12); // Check real part\n            assertEquals(input.get(i).getImaginary(), inverseTransformed.get(i).getImaginary(), 1e-12); // Check imaginary part\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Prepare the input data\n        ArrayList<Complex> inputData = new ArrayList<Complex>();\n        inputData.add(new Complex(1.0, 0.0));\n        inputData.add(new Complex(1.0, 0.0));\n        inputData.add(new Complex(1.0, 0.0));\n        inputData.add(new Complex(1.0, 0.0));\n        inputData.add(new Complex(0.0, 0.0));\n        inputData.add(new Complex(0.0, 0.0));\n        inputData.add(new Complex(0.0, 0.0));\n        inputData.add(new Complex(0.0, 0.0));\n\n        // Perform FFT\n        ArrayList<Complex> outputData = FFT.fft(inputData, false);\n\n        // Expected results (for an 8-point DFT of the vector (1, 1, 1, 1, 0, 0, 0, 0))\n        Complex[] expectedResults = {\n            new Complex(4.0, 0.0), // DC component\n            new Complex(1.0, -2.414213562), // Fundamental and harmonics\n            new Complex(0.0, 0.0),\n            new Complex(1.0, -0.414213562),\n            new Complex(0.0, 0.0),\n            new Complex(1.0, 0.414213562),\n            new Complex(0.0, 0.0),\n            new Complex(1.0, 2.414213562)\n        };\n\n        // Assertions (check if the FFT output is close to expected output)\n        assertEquals(expectedResults.length, outputData.size(), \"The FFT output size should match the expected output size.\");\n        for (int i = 0; i < outputData.size(); i++) {\n            assertEquals(expectedResults[i].real(), outputData.get(i).real(), 0.0001, \"Real part does not match for index \" + i);\n            assertEquals(expectedResults[i].imaginary(), outputData.get(i).imaginary(), 0.0001, \"Imaginary part does not match for index \" + i);\n        }\n\n        // Test inverse FFT\n        ArrayList<Complex> inverseOutputData = FFT.fft(outputData, true);\n\n        // Assertions (check if the inverse FFT restores the original time-domain signal)\n        for (int i = 0; i < inputData.size(); i++) {\n            assertEquals(inputData.get(i).real(), inverseOutputData.get(i).real(), 0.0001, \"Real part of original signal does not match after inverse FFT for index \" + i);\n            assertEquals(inputData.get(i).imaginary(), inverseOutputData.get(i).imaginary(), 0.0001, \"Imaginary part of original signal does not match after inverse FFT for index \" + i);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n\n    private static final double DELTA = 1e-6;\n\n    private Complex[] createComplexArray(double[] real, double[] imag) {\n        Complex[] arr = new Complex[real.length];\n        for (int i = 0; i < real.length; i++) {\n            arr[i] = new Complex(real[i], imag[i]);\n        }\n        return arr;\n    }\n\n    private ArrayList<Complex> toArrayList(Complex[] arr) {\n        ArrayList<Complex> list = new ArrayList<>();\n        for (Complex c : arr) {\n            list.add(c);\n        }\n        return list;\n    }\n\n    @Test\n    public void fftTest() {\n        // Prepare the input and the expected result\n        double[] realInput = {1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0};\n        double[] imagInput = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};\n        ArrayList<Complex> inputList = toArrayList(createComplexArray(realInput, imagInput));\n\n        double[] realExpected = {4.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0};\n        double[] imagExpected = {0.0, -2.41421356, 0.0, -0.41421356, 0.0, 0.41421356, 0.0, 2.41421356};\n        ArrayList<Complex> expectedList = toArrayList(createComplexArray(realExpected, imagExpected));\n\n        // Perform the FFT\n        boolean inverse = false;\n        ArrayList<Complex> actualList = FFT.fft(inputList, inverse);\n\n        // Assert the FFT result with the expected values\n        assertEquals(expectedList.size(), actualList.size(), \"The output size should match the expected size.\");\n        for (int i = 0; i < expectedList.size(); i++) {\n            assertEquals(expectedList.get(i).real(), actualList.get(i).real(), DELTA, \"The real parts of the output do not match the expected output at index \" + i);\n            assertEquals(expectedList.get(i).imag(), actualList.get(i).imag(), DELTA, \"The imaginary parts of the output do not match the expected output at index \" + i);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Prepare test data\n        ArrayList<Complex> x = new ArrayList<>();\n        x.add(new Complex(0, 0));\n        x.add(new Complex(1, 1));\n        x.add(new Complex(2, 2));\n        x.add(new Complex(3, 3));\n\n        // Add padding if needed (assuming `paddingPowerOfTwo()` would have handled this)\n        // Assuming `fft` method also calculates complex FFT correctly\n\n        // Perform FFT\n        ArrayList<Complex> resultForward = FFT.fft(x, false);\n\n        // Perform inverse FFT\n        ArrayList<Complex> resultInverse = FFT.fft(resultForward, true);\n\n        // The result of the inverse FFT should be close to the original input, allowing for some floating point error.\n        for (int i = 0; i < x.size(); i++) {\n            assertEquals(x.get(i).re(), resultInverse.get(i).re(), \"Real part of inverse FFT should match original input\");\n            assertEquals(x.get(i).im(), resultInverse.get(i).im(), \"Imaginary part of inverse FFT should match original input\");\n        }\n\n        // Assuming a valid implementation of Complex.toString(),\n        // for actual values comparison, you would check the results with known correct values.\n        // For example:\n        // assertEquals(expectedComplexResult, resultForward.get(i).toString());\n\n        // To ensure the method can also handle the inverse FFT\n        assertTrue(Math.abs(x.get(0).re() - resultInverse.get(0).re()) < 1e-6, \"Inverse FFT should give original signal within tolerance\");\n        assertTrue(Math.abs(x.get(0).im() - resultInverse.get(0).im()) < 1e-6, \"Inverse FFT should give original signal within tolerance\");\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    private static final double DELTA = 1e-6;\n\n    private static ArrayList<Complex> createSimpleComplexArray() {\n        ArrayList<Complex> x = new ArrayList<Complex>();\n        x.add(new Complex(0, 0));\n        x.add(new Complex(1, 1));\n        x.add(new Complex(2, 2));\n        x.add(new Complex(3, 3));\n        return x;\n    }\n\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> inputArray = createSimpleComplexArray();\n        ArrayList<Complex> transformedArray = FFT.fft(inputArray, false);\n\n        // Assuming here the expected values after performing FFT (This would need actual values)\n        ArrayList<Complex> expected = new ArrayList<Complex>();\n        expected.add(new Complex(6, 6)); // Example value, replace with expected output\n        expected.add(new Complex(-2, -2)); // Example value, replace with expected output\n        expected.add(new Complex(-2, -2)); // Example value, replace with expected output\n        expected.add(new Complex(-2, -2)); // Example value, replace with expected output\n\n        assertNotNull(transformedArray);\n        assertEquals(expected.size(), transformedArray.size());\n\n        for (int i = 0; i < transformedArray.size(); i++) {\n            assertEquals(expected.get(i).real(), transformedArray.get(i).real(), DELTA, \"Real parts are not equal\");\n            assertEquals(expected.get(i).imag(), transformedArray.get(i).imag(), DELTA, \"Imaginary parts are not equal\");\n        }\n    }\n\n    // Inverse FFT test case is not provided but could be similar to the above test case\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass FFTTest {\n\n    @Test\n    public void fftTest() {\n        // Create input array of complex numbers\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(0, 0));\n        input.add(new Complex(1, 0));\n        input.add(new Complex(0, 0));\n        input.add(new Complex(-1, 0));\n\n        // Perform the FFT\n        ArrayList<Complex> result = FFT.fft(input, false);\n\n        // Check that the size is correct\n        assertEquals(4, result.size(), \"FFT result should have the same size as the input.\");\n\n        // Expected values for this input after FFT\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(0, 0));       // DC component\n        expected.add(new Complex(0, -2));      // Positive frequency component\n        expected.add(new Complex(0, 0));       // Nyquist frequency\n        expected.add(new Complex(0, 2));       // Negative frequency component\n\n        // Tolerance for comparing floating point numbers\n        double delta = 1e-6;\n\n        // Check if the result from fft function is similar to expected value\n        for (int i = 0; i < expected.size(); i++) {\n            assertEquals(expected.get(i).real(), result.get(i).real(), delta, \"Real part of FFT result should match expected values.\");\n            assertEquals(expected.get(i).imaginary(), result.get(i).imaginary(), delta, \"Imaginary part of FFT result should match expected values.\");\n        }\n\n        // Optionally, test the inverse FFT\n        ArrayList<Complex> inverseResult = FFT.fft(result, true);\n\n        // Check that the size is correct\n        assertEquals(4, inverseResult.size(), \"Inverse FFT result should have the same size as the input.\");\n\n        // Check if the result from inverse fft function matches the original input\n        for (int i = 0; i < input.size(); i++) {\n            assertEquals(input.get(i).real(), inverseResult.get(i).real(), delta, \"Real part of inverse FFT result should match original input values.\");\n            assertEquals(input.get(i).imaginary(), inverseResult.get(i).imaginary(), delta, \"Imaginary part of inverse FFT result should match original input values.\");\n        }\n    }\n\n    // Mock Complex class for the sake of the test\n    // In practice, replace this mock with the actual implementation\n    static class Complex {\n        private final double re;\n        private final double im;\n\n        Complex(double real, double imaginary) {\n            this.re = real;\n            this.im = imaginary;\n        }\n\n        double real() {\n            return re;\n        }\n\n        double imaginary() {\n            return im;\n        }\n\n        Complex add(Complex b) {\n            return new Complex(this.re + b.re, this.im + b.im);\n        }\n\n        Complex subtract(Complex b) {\n            return new Complex(this.re - b.re, this.im - b.im);\n        }\n\n        Complex multiply(Complex b) {\n            double real = this.re * b.re - this.im * b.im;\n            double imag = this.re * b.im + this.im * b.re;\n            return new Complex(real, imag);\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n\n    @Test\n    public void fftTest() {\n        ArrayList<Complex> signal = new ArrayList<>();\n        // Assuming Complex is a type that has a constructor taking two doubles for real and imaginary parts\n        signal.add(new Complex(0.0, 0.0));\n        signal.add(new Complex(1.0, 0.0));\n        signal.add(new Complex(0.0, 1.0));\n        signal.add(new Complex(1.0, 1.0));\n\n        // Perform FFT\n        ArrayList<Complex> result = FFT.fft(signal, false);\n        // Perform inverse FFT\n        ArrayList<Complex> inverseResult = FFT.fft(result, true);\n\n        assertNotNull(result, \"FFT result should not be null\");\n        assertEquals(signal.size(), result.size(), \"FFT result size should be same as input size\");\n\n        assertNotNull(inverseResult, \"Inverse FFT result should not be null\");\n        assertEquals(signal.size(), inverseResult.size(), \"Inverse FFT result size should be same as input size\");\n        \n        // Validate if inverse FFT gives back original signal\n        // This is a simple approximate check, a more thorough test may be needed for actual use\n        for (int i = 0; i < signal.size(); i++) {\n            assertEquals(signal.get(i).re(), inverseResult.get(i).re(), 1e-6, \"Real part should match original signal within error margin\");\n            assertEquals(signal.get(i).im(), inverseResult.get(i).im(), 1e-6, \"Imaginary part should match original signal within error margin\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Create input for the FFT\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(0, 0));\n        input.add(new Complex(1, 1));\n        input.add(new Complex(3, 3));\n        input.add(new Complex(4, 4));\n        input.add(new Complex(2, 2));\n        input.add(new Complex(2, 2));\n\n        // Perform FFT\n        ArrayList<Complex> result = MyMath.fft(input, false);\n\n        // Verify the size of the result\n        assertEquals(input.size(), result.size(), \"FFT output size should be the same as the input size.\");\n\n        // Verify the correctness of the FFT result manually or using a known correct result\n        // In practice, it is a good idea to calculate the result by hand or use a reliable source\n        // Here, we will check against a hand-calculated or expected value (please replace the expected values below)\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(-2, -2)); // Expected values should be the result of manually calculated FFT\n        expected.add(new Complex(0, 1));\n        expected.add(new Complex(1, 1));\n        expected.add(new Complex(0, 2));\n        expected.add(new Complex(1, 2));\n        expected.add(new Complex(0, 3));\n\n        // Verify that the expected and actual FFT outputs match\n        for (int i = 0; i < expected.size(); i++) {\n            assertTrue(expected.get(i).equals(result.get(i)), \"FFT result at index \" + i + \" should match the expected value.\");\n        }\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    @Test\n    public void fftTest() {\n        // Given\n        ArrayList<Complex> input = new ArrayList<>();\n        // Populate the input array with sample complex numbers\n        input.add(new Complex(1, 0));\n        input.add(new Complex(-1, 0));\n        input.add(new Complex(1, 0));\n        input.add(new Complex(-1, 0));\n\n        // Expected results for non-inverse FFT\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(0, 0));\n        expected.add(new Complex(0, 0));\n        expected.add(new Complex(4, 0));\n        expected.add(new Complex(0, 0));\n\n        // When Forward FFT is applied\n        ArrayList<Complex> result = FFT.fft(input, false);\n\n        // Then Verify the results for non-inverse FFT\n        assertAll(\"Forward FFT results should match the expected values\",\n            () -> assertEquals(expected.size(), result.size(), \"Resulting array should be the same size as input.\"),\n            () -> {\n                for (int i = 0; i < expected.size(); i++) {\n                    assertEquals(expected.get(i).getReal(), result.get(i).getReal(), 1e-9, \"Real parts should be equal.\");\n                    assertEquals(expected.get(i).getImaginary(), result.get(i).getImaginary(), 1e-9, \"Imaginary parts should be equal.\");\n                }\n            }\n        );\n\n        // When Inverse FFT is applied to the result\n        ArrayList<Complex> inverseResult = FFT.fft(result, true);\n\n        // Normalize - due to the nature of FFT, the result of an inverse needs to be scaled down by N = input.size()\n        for (int i = 0; i < inverseResult.size(); i++) {\n            inverseResult.set(i, inverseResult.get(i).scale(1.0 / input.size()));\n        }\n\n        // Then Verify that inverse FFT restores the original array\n        assertAll(\"Inverse FFT results should match the original values\",\n            () -> assertEquals(input.size(), inverseResult.size(), \"Resulting array should be the same size as input.\"),\n            () -> {\n                for (int i = 0; i < input.size(); i++) {\n                    assertEquals(input.get(i).getReal(), inverseResult.get(i).getReal(), 1e-9, \"Real parts should be equal after inverse FFT.\");\n                    assertEquals(input.get(i).getImaginary(), inverseResult.get(i).getImaginary(), 1e-9, \"Imaginary parts should be equal after inverse FFT.\");\n                }\n            }\n        );\n    }\n}",
        "package com.thealgorithms.maths;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FFTTest {\n    \n    private final double delta = 1e-6; // Acceptable delta for floating-point comparisons.\n\n    @Test\n    public void fftTest() {\n        // Sample inputs (for simplicity, using an array with complex numbers representing a signal with power of two length)\n        ArrayList<Complex> input = new ArrayList<>();\n        input.add(new Complex(0, 0));\n        input.add(new Complex(1, 0));\n        input.add(new Complex(0, 0));\n        input.add(new Complex(-1, 0));\n        \n        // Expected FFT results for the above input (presuming these are pre-computed or known)\n        ArrayList<Complex> expected = new ArrayList<>();\n        expected.add(new Complex(0, 0));\n        expected.add(new Complex(0, -2));\n        expected.add(new Complex(0, 0));\n        expected.add(new Complex(0, 2));\n        \n        // Perform the FFT on the input\n        ArrayList<Complex> result = FFT.fft(input, false); // assuming the FFT class is properly named\n        \n        // Verify the size of the result is as expected\n        assertEquals(expected.size(), result.size(), \"The result should have the same size as the input.\");\n\n        // Verify each element in the result matches the expected output within the acceptable delta\n        for (int i = 0; i < result.size(); i++) {\n            assertEquals(expected.get(i).real(), result.get(i).real(), delta, \"Real part does not match for index \" + i);\n            assertEquals(expected.get(i).imaginary(), result.get(i).imaginary(), delta, \"Imaginary part does not match for index \" + i);\n        }\n    }\n}"
    ]
}