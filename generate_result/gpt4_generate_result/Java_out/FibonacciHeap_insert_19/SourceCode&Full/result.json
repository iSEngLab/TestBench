{
    "project_name": "Java",
    "file_name": "FibonacciHeap.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.heaps",
    "docstring": "/**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */",
    "source_code": "\npublic HeapNode insert(int key) {\n    HeapNode toInsert = new HeapNode(key); // creates the node\n    if (this.empty()) {\n        this.min = toInsert;\n    } else { // tree is not empty\n        min.setNext(toInsert);\n        this.updateMin(toInsert);\n    }\n    this.numOfHeapNodes++;\n    this.numOfTrees++;\n    return toInsert;\n}\n",
    "class_name": "FibonacciHeap",
    "method_name": "insert",
    "arguments": [
        "int key"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    @Test\n    public void insertTest() {\n        FibonacciHeap heap = new FibonacciHeap();\n\n        // Verify heap is initially empty\n        assertTrue(heap.empty(), \"Heap should be empty initially\");\n\n        // Insert a single element and verify\n        FibonacciHeap.HeapNode node = heap.insert(10);\n        assertNotNull(node, \"Insert should return a non-null HeapNode object\");\n        assertEquals(10, node.getKey(), \"Inserted node should have key equal to 10\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insert\");\n        assertEquals(node, heap.findMin(), \"Inserted node should be the minimum in the heap\");\n        assertEquals(1, heap.size(), \"Heap size should be 1 after insert\");\n        \n        // Insert another element and verify\n        FibonacciHeap.HeapNode secondNode = heap.insert(5);\n        assertNotNull(secondNode, \"Second insert should return a non-null HeapNode object\");\n        assertEquals(5, secondNode.getKey(), \"Second inserted node should have key equal to 5\");\n        assertEquals(secondNode, heap.findMin(), \"Second inserted node should now be the minimum in the heap\");\n        assertEquals(2, heap.size(), \"Heap size should be 2 after second insert\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    @Test\n    public void insertTest() {\n        FibonacciHeap heap = new FibonacciHeap();\n        \n        // Test 1: Insert into an empty heap\n        FibonacciHeap.HeapNode insertNode1 = heap.insert(10);\n        assertEquals(10, heap.findMin().getKey(), \"Insert into an empty heap should set the new node as min.\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insert.\");\n        assertEquals(1, heap.size(), \"Heap size should be 1 after first insert.\");\n        \n        // Test 2: Insert into a non-empty heap with higher key value\n        FibonacciHeap.HeapNode insertNode2 = heap.insert(20);\n        assertEquals(10, heap.findMin().getKey(), \"Insert of larger key should not change the min.\");\n        assertEquals(2, heap.size(), \"Heap size should be 2 after second insert.\");\n        \n        // Test 3: Insert into a non-empty heap with lower key value\n        FibonacciHeap.HeapNode insertNode3 = heap.insert(5);\n        assertEquals(5, heap.findMin().getKey(), \"Insert of smaller key should change the min.\");\n        assertEquals(3, heap.size(), \"Heap size should be 3 after third insert.\");\n        \n        // Test 4: Verify the inserted nodes\n        assertNotNull(insertNode1, \"Inserted node should not be null.\");\n        assertEquals(10, insertNode1.getKey(), \"Inserted node should have the correct key value.\");\n        assertNotNull(insertNode2, \"Inserted node should not be null.\");\n        assertEquals(20, insertNode2.getKey(), \"Inserted node should have the correct key value.\");\n        assertNotNull(insertNode3, \"Inserted node should not be null.\");\n        assertEquals(5, insertNode3.getKey(), \"Inserted node should have the correct key value.\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    @Test\n    public void insertTest() {\n        FibonacciHeap heap = new FibonacciHeap();\n\n        // Test that the heap is initially empty\n        assertTrue(heap.empty(), \"Heap should initially be empty.\");\n\n        // Insert an element and test the heap is no longer empty\n        int keyToInsert = 10;\n        FibonacciHeap.HeapNode nodeInserted = heap.insert(keyToInsert);\n        assertFalse(heap.empty(), \"Heap should not be empty after insertion.\");\n\n        // Check the inserted node's key matches the expected value\n        assertEquals(keyToInsert, nodeInserted.getKey(), \"The key of the inserted node should equal the key that was inserted.\");\n\n        // Check if the minimum element is the one we just inserted\n        assertEquals(nodeInserted, heap.findMin(), \"The inserted node should be the minimum after inserting into an empty heap.\");\n\n        // Check if the size of the heap is 1 after insertion\n        assertEquals(1, heap.size(), \"Heap size should be 1 after one insertion.\");\n\n        // Check if the number of trees in the heap is 1 after insertion\n        assertEquals(1, heap.numOfTrees, \"Number of trees should be 1 after one insertion.\");\n\n        // Insert another element and test if the size updates accordingly\n        int secondKeyToInsert = 5;\n        FibonacciHeap.HeapNode secondNodeInserted = heap.insert(secondKeyToInsert);\n        assertEquals(2, heap.size(), \"Heap size should be 2 after two insertions.\");\n\n        // Check if the minimum element is updated correctly after second insertion\n        assertEquals(secondNodeInserted, heap.findMin(), \"The second inserted node should be the new minimum.\");\n\n        // Check if the number of trees is now 2\n        assertEquals(2, heap.numOfTrees, \"Number of trees should be 2 after two insertions.\");\n\n        // Insert another element with a higher key and check if min remains unchanged\n        int thirdKeyToInsert = 20;\n        heap.insert(thirdKeyToInsert);\n        assertEquals(secondNodeInserted, heap.findMin(), \"The minimum should remain unchanged after inserting a higher key.\");\n\n        // Check if the size of the heap is 3 after third insertion\n        assertEquals(3, heap.size(), \"Heap size should be 3 after three insertions.\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    @Test\n    public void insertTest() {\n        FibonacciHeap heap = new FibonacciHeap();\n        assertTrue(heap.empty(), \"Heap should be empty initially.\");\n\n        // Insert first element and check if it becomes the min\n        HeapNode firstNode = heap.insert(10);\n        assertEquals(10, heap.findMin().getKey(), \"The min should be the first element inserted.\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insert.\");\n        assertEquals(1, heap.size(), \"Heap size should be 1 after first insertion.\");\n\n        // Insert a larger number and check if the min remains the same\n        heap.insert(20);\n        assertEquals(10, heap.findMin().getKey(), \"The min should not change when larger element is inserted.\");\n        assertEquals(2, heap.size(), \"Heap size should be 2 after second insertion.\");\n\n        // Insert a smaller number and check if it becomes the new min\n        heap.insert(5);\n        assertEquals(5, heap.findMin().getKey(), \"The min should be the new smaller element inserted.\");\n        assertEquals(3, heap.size(), \"Heap size should be 3 after third insertion.\");\n\n        // Insert an element equal to current min and check min consistency\n        heap.insert(5);\n        assertEquals(5, heap.findMin().getKey(), \"Inserting element equal to current min should keep the min unchanged.\");\n        assertEquals(4, heap.size(), \"Heap size should be 4 after fourth insertion.\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    @Test\n    public void insertTest() {\n        FibonacciHeap heap = new FibonacciHeap();\n        \n        assertTrue(heap.empty(), \"Heap should be empty initially.\");\n\n        int key = 5;\n        HeapNode insertedNode = heap.insert(key);\n\n        assertNotNull(insertedNode, \"Inserted node should not be null.\");\n        assertEquals(key, insertedNode.getKey(), \"Inserted node key should match the key.\");\n        assertEquals(1, heap.size(), \"Heap should have one node after insertion.\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insertion.\");\n        assertEquals(insertedNode, heap.findMin(), \"Inserted node should be the minimum in the heap.\");\n\n        int newKey = 2;\n        HeapNode newNode = heap.insert(newKey);\n\n        assertEquals(newKey, heap.findMin().getKey(), \"New node should be the new minimum in the heap.\");\n        assertEquals(2, heap.size(), \"Heap should have two nodes after second insertion.\");\n        assertEquals(newNode, heap.findMin(), \"findMin should return the new node with the smaller key.\");\n\n        int keyToTestExistingMin = 10;\n        heap.insert(keyToTestExistingMin);\n\n        assertNotEquals(keyToTestExistingMin, heap.findMin().getKey(), \"findMin should still return the previous minimum node.\");\n        assertEquals(3, heap.size(), \"Heap should have three nodes after third insertion.\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    \n    private FibonacciHeap fibonacciHeap;\n    \n    @BeforeEach\n    public void setUp() {\n        fibonacciHeap = new FibonacciHeap();\n    }\n    \n    @Test\n    public void insertTest() {\n        // Initially, heap should be empty.\n        assertTrue(fibonacciHeap.empty(), \"Heap should be empty before insertions\");\n\n        // Insert first node and check size and minimum.\n        FibonacciHeap.HeapNode firstNode = fibonacciHeap.insert(10);\n        assertEquals(1, fibonacciHeap.size(), \"Heap should contain one node after first insertion\");\n        assertEquals(10, fibonacciHeap.findMin().getKey(), \"Minimum should be 10 after first insertion\");\n        assertFalse(fibonacciHeap.empty(), \"Heap should not be empty after insertion\");\n\n        // Insert a second node with a smaller key and check min again.\n        FibonacciHeap.HeapNode secondNode = fibonacciHeap.insert(5);\n        assertEquals(2, fibonacciHeap.size(), \"Heap should contain two nodes after second insertion\");\n        assertEquals(5, fibonacciHeap.findMin().getKey(), \"Minimum should be 5 after inserting node with key 5\");\n        \n        // Insert a third node with a larger key and check min does not change.\n        FibonacciHeap.HeapNode thirdNode = fibonacciHeap.insert(20);\n        assertEquals(3, fibonacciHeap.size(), \"Heap should contain three nodes after third insertion\");\n        assertEquals(5, fibonacciHeap.findMin().getKey(), \"Minimum should still be 5 after inserting node with key 20\");\n        \n        // Insert a fourth node with a key smaller than current min and check min changes.\n        FibonacciHeap.HeapNode fourthNode = fibonacciHeap.insert(3);\n        assertEquals(4, fibonacciHeap.size(), \"Heap should contain four nodes after fourth insertion\");\n        assertEquals(3, fibonacciHeap.findMin().getKey(), \"Minimum should be 3 after inserting node with key 3\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    private FibonacciHeap heap;\n\n    @BeforeEach\n    public void setUp() {\n        heap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        // Test empty heap condition\n        assertTrue(heap.empty(), \"Heap should be initially empty\");\n\n        // Insert a single node\n        FibonacciHeap.HeapNode node = heap.insert(10);\n        assertNotNull(node, \"Inserted node should not be null\");\n        assertEquals(10, heap.findMin().getKey(), \"Min should return the key of the only node in the heap\");\n        assertEquals(1, heap.size(), \"Heap size should be 1 after one insert\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insert\");\n\n        // Insert a second node with a larger key\n        FibonacciHeap.HeapNode secondNode = heap.insert(20);\n        assertNotNull(secondNode, \"Second inserted node should not be null\");\n        assertEquals(10, heap.findMin().getKey(), \"Min should still return the key of the first node\");\n        assertEquals(2, heap.size(), \"Heap size should be 2 after inserting two nodes\");\n\n        // Insert a third node with a smaller key\n        FibonacciHeap.HeapNode thirdNode = heap.insert(5);\n        assertNotNull(thirdNode, \"Third inserted node should not be null\");\n        assertEquals(5, heap.findMin().getKey(), \"Min should now return the key of the third node\");\n        assertEquals(3, heap.size(), \"Heap size should be 3 after inserting three nodes\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        heap = null;\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    @Test\n    public void insertTest() {\n        FibonacciHeap heap = new FibonacciHeap();\n        assertTrue(heap.empty(), \"Heap should be empty initially\");\n\n        FibonacciHeap.HeapNode node = heap.insert(10);\n        assertNotNull(node, \"Inserted node should not be null\");\n        assertEquals(10, node.getKey(), \"Inserted node should have key 10\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insertion\");\n        assertEquals(1, heap.size(), \"Heap should contain 1 element after insertion\");\n        assertEquals(heap.findMin(), node, \"Inserted node should be the minimum in the heap\");\n        \n        heap.insert(5);\n        assertEquals(5, heap.findMin().getKey(), \"Minimum key should now be 5 after inserting a smaller key\");\n        assertEquals(2, heap.size(), \"Heap should contain 2 elements after second insertion\");\n        \n        heap.insert(15);\n        assertEquals(5, heap.findMin().getKey(), \"Minimum key should still be 5 after inserting a larger key\");\n        assertEquals(3, heap.size(), \"Heap should contain 3 elements after third insertion\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    @Test\n    public void insertTest() {\n        FibonacciHeap heap = new FibonacciHeap();\n\n        // Test inserting into an empty heap\n        FibonacciHeap.HeapNode node1 = heap.insert(10);\n        assertNotNull(node1, \"Inserted heap node should not be null\");\n        assertEquals(10, node1.getKey(), \"Incorrect key on inserted node\");\n        assertEquals(1, heap.size(), \"Heap size should be 1 after the first insertion\");\n        assertFalse(heap.empty(), \"Heap should not be empty after an insertion\");\n\n        // Test inserting into a non-empty heap\n        FibonacciHeap.HeapNode node2 = heap.insert(5);\n        assertNotNull(node2, \"Inserted heap node should not be null\");\n        assertEquals(5, node2.getKey(), \"Incorrect key on inserted node\");\n        assertEquals(node2, heap.findMin(), \"Node with key 5 should be the new min\");\n        assertEquals(2, heap.size(), \"Heap size should be 2 after the second insertion\");\n\n        // Test inserting with a key greater than the min\n        FibonacciHeap.HeapNode node3 = heap.insert(15);\n        assertNotNull(node3, \"Inserted heap node should not be null\");\n        assertEquals(15, node3.getKey(), \"Incorrect key on inserted node\");\n        assertEquals(node2, heap.findMin(), \"Min should still be the node with key 5\");\n        assertEquals(3, heap.size(), \"Heap size should be 3 after the third insertion\");\n\n        // Test inserting with a key smaller than the min\n        FibonacciHeap.HeapNode node4 = heap.insert(3);\n        assertNotNull(node4, \"Inserted heap node should not be null\");\n        assertEquals(3, node4.getKey(), \"Incorrect key on inserted node\");\n        assertEquals(node4, heap.findMin(), \"Node with key 3 should be the new min\");\n        assertEquals(4, heap.size(), \"Heap size should be 4 after the fourth insertion\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    FibonacciHeap fibonacciHeap;\n\n    @BeforeEach\n    public void setUp() {\n        fibonacciHeap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        // Test insertion into an empty Fibonacci heap\n        HeapNode node10 = fibonacciHeap.insert(10);\n        assertFalse(fibonacciHeap.empty(), \"Heap should not be empty after insertion\");\n        assertEquals(10, fibonacciHeap.findMin().getKey(), \"The minimum value should be 10 after inserting 10 into an empty heap\");\n        assertEquals(1, fibonacciHeap.size(), \"The size should be 1 after one insertion\");\n        \n        // Test insertion into a non-empty Fibonacci heap which does not update the min\n        HeapNode node20 = fibonacciHeap.insert(20);\n        assertEquals(10, fibonacciHeap.findMin().getKey(), \"The minimum value should remain 10 after inserting 20\");\n        assertEquals(2, fibonacciHeap.size(), \"The size should be 2 after two insertions\");\n    \n        // Test insertion into a non-empty Fibonacci heap which updates the min\n        HeapNode node5 = fibonacciHeap.insert(5);\n        assertEquals(5, fibonacciHeap.findMin().getKey(), \"The minimum value should be updated to 5 after inserting 5\");\n        assertEquals(3, fibonacciHeap.size(), \"The size should be 3 after three insertions\");\n        \n        // Test the structure after insertions\n        assertNotNull(node10.getNext(), \"node10 should have a non-null next\");\n        assertNotNull(node20.getNext(), \"node20 should have a non-null next\");\n        assertNotNull(node5.getNext(), \"node5 should have a non-null next\");\n        assertEquals(node10, node5.getNext(), \"node5's next should be node10\");\n        assertEquals(node5, node20.getNext(), \"node20's next should be node5\");\n        assertEquals(node20, node10.getNext(), \"node10's next should be node20\");\n    \n        // Test insertion with a key smaller than zero\n        Exception exception = assertThrows(IllegalArgumentException.class, () -> {\n            fibonacciHeap.insert(-1);\n        }, \"Inserting a key with value less than zero should throw an IllegalArgumentException\");\n        assertEquals(\"Key must be greater than or equal to 0\", exception.getMessage(), \"Exception message should indicate the invalid key value\");\n    }\n}"
    ]
}