{
    "project_name": "Java",
    "file_name": "FibonacciHeap.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.heaps",
    "docstring": "/**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */",
    "source_code": "\npublic HeapNode insert(int key) {\n    HeapNode toInsert = new HeapNode(key); // creates the node\n    if (this.empty()) {\n        this.min = toInsert;\n    } else { // tree is not empty\n        min.setNext(toInsert);\n        this.updateMin(toInsert);\n    }\n    this.numOfHeapNodes++;\n    this.numOfTrees++;\n    return toInsert;\n}\n",
    "class_name": "FibonacciHeap",
    "method_name": "insert",
    "arguments": [
        "int key"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    private FibonacciHeap fibHeap;\n\n    @BeforeEach\n    public void setUp() {\n        fibHeap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        assertTrue(fibHeap.isEmpty(), \"Heap should be empty initially.\");\n\n        HeapNode node1 = fibHeap.insert(10);\n        assertNotNull(node1, \"Insert should return a non-null node.\");\n        assertEquals(10, node1.getKey(), \"The key of the node should match the inserted value.\");\n        assertFalse(fibHeap.isEmpty(), \"Heap should not be empty after insertion.\");\n        assertEquals(1, fibHeap.getSize(), \"Heap should have one node after insertion.\");\n\n        HeapNode node2 = fibHeap.insert(5);\n        assertNotNull(node2, \"Insert should return a non-null node.\");\n        assertEquals(5, node2.getKey(), \"The key of node should match the inserted value.\");\n        assertEquals(node2, fibHeap.getMin(), \"The minimum should be the node with the smallest key.\");\n        assertEquals(2, fibHeap.getSize(), \"Heap should have two nodes after second insertion.\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    private FibonacciHeap heap;\n\n    @BeforeEach\n    public void setUp() {\n        heap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        // Test the insert method on an empty heap\n        HeapNode insertedNode = heap.insert(10);\n        assertAll(\"Inserting into an empty heap\",\n                () -> assertNotNull(insertedNode, \"Inserted node should not be null\"),\n                () -> assertEquals(10, insertedNode.getKey(), \"Inserted node key should be 10\"),\n                () -> assertFalse(heap.empty(), \"Heap should not be empty after insertion\"),\n                () -> assertEquals(1, heap.getNumOfHeapNodes(), \"Heap should contain 1 node\"),\n                () -> assertEquals(1, heap.getNumOfTrees(), \"Heap should contain 1 tree\"),\n                () -> assertEquals(heap.getMin(), insertedNode, \"Inserted node should be min node in the heap\")\n        );\n\n        // Test the insert method on a non-empty heap\n        HeapNode secondNode = heap.insert(5);\n        assertAll(\"Inserting into a non-empty heap\",\n                () -> assertNotNull(secondNode, \"Inserted node should not be null\"),\n                () -> assertEquals(5, secondNode.getKey(), \"Inserted node key should be 5\"),\n                () -> assertEquals(2, heap.getNumOfHeapNodes(), \"Heap should contain 2 nodes after second insertion\"),\n                () -> assertEquals(2, heap.getNumOfTrees(), \"Heap should contain 2 trees after second insertion\"),\n                () -> assertEquals(heap.getMin(), secondNode, \"After inserting a smaller element, it should be new min node in the heap\")\n        );\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    private FibonacciHeap heap;\n\n    @BeforeEach\n    public void setUp() {\n        heap = new FibonacciHeap();\n    }\n    \n    @Test\n    public void insertTest() {\n        // Assume FibonacciHeap has a method empty() that tells us if the heap is empty.\n        assertTrue(heap.empty(), \"Heap should be empty initially.\");\n        \n        // Perform an insert operation\n        HeapNode insertedNode = heap.insert(10);\n        \n        // Validate that the heap is no longer empty after insertion\n        assertFalse(heap.empty(), \"Heap should not be empty after inserting an element.\");\n        \n        // Validate the returned node has the correct key value\n        assertEquals(10, insertedNode.key, \"The key of the node inserted should be 10.\");\n        \n        // Validate that minimum has been updated in the heap\n        assertEquals(heap.getMin(), insertedNode, \"The minimum should be the node that was just inserted.\");\n        \n        // Check that the size of the heap has increased\n        assertEquals(1, heap.getNumOfHeapNodes(), \"Number of heap nodes should be 1 after the insertion.\");\n        \n        // Check that the number of trees in the heap has increased\n        assertEquals(1, heap.getNumOfTrees(), \"Number of trees should be 1 after the insertion.\");\n\n        // Insert another node\n        HeapNode anotherInsertion = heap.insert(5);\n\n        // Validate min is the new node with the smaller key\n        assertEquals(heap.getMin(), anotherInsertion, \"The new minimum should be the second node with key value 5.\");\n\n        // Check updated size of the heap\n        assertEquals(2, heap.getNumOfHeapNodes(), \"Number of heap nodes should be 2 after two insertions.\");\n\n        // Check that the number of trees in the heap has increased\n        assertEquals(2, heap.getNumOfTrees(), \"Number of trees should be 2 after the second insertion.\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    @Test\n    public void insertTest() {\n        // Assume FibonacciHeap and HeapNode are valid classes\n        FibonacciHeap heap = new FibonacciHeap();\n        \n        assertTrue(heap.empty(), \"Heap should be empty initially\");\n\n        // Test insert on an empty heap\n        HeapNode firstInsertedNode = heap.insert(10);\n        assertNotNull(firstInsertedNode, \"Inserted node should not be null\");\n        assertEquals(10, firstInsertedNode.getKey(), \"Inserted node should have key 10\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insert\");\n        assertEquals(firstInsertedNode, heap.getMin(), \"Min should be the first inserted node\");\n        assertEquals(1, heap.getNumOfHeapNodes(), \"Heap should have 1 node after first insert\");\n        assertEquals(1, heap.getNumOfTrees(), \"Heap should have 1 tree after first insert\");\n\n        // Test insert on a non-empty heap\n        HeapNode secondInsertedNode = heap.insert(5);\n        assertNotNull(secondInsertedNode, \"Inserted node should not be null\");\n        assertEquals(5, secondInsertedNode.getKey(), \"Inserted node should have key 5\");\n        assertEquals(secondInsertedNode, heap.getMin(), \"Min should be the second inserted node (smaller key)\");\n        assertEquals(2, heap.getNumOfHeapNodes(), \"Heap should have 2 nodes after second insert\");\n        assertEquals(2, heap.getNumOfTrees(), \"Heap should have 2 trees after second insert\");\n        \n        // Additional case: insert a node with a key that is larger than current min\n        HeapNode thirdInsertedNode = heap.insert(15);\n        assertNotNull(thirdInsertedNode, \"Inserted node should not be null\");\n        assertEquals(15, thirdInsertedNode.getKey(), \"Inserted node should have key 15\");\n        assertEquals(secondInsertedNode, heap.getMin(), \"Min should remain the second inserted node after third insert\");\n        assertEquals(3, heap.getNumOfHeapNodes(), \"Heap should have 3 nodes after third insert\");\n        assertEquals(3, heap.getNumOfTrees(), \"Heap should have 3 trees after third insert\");\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    private FibonacciHeap heap;\n\n    @BeforeEach\n    void setUp() {\n        heap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        // Test case 1: Insert into an empty heap\n        int key1 = 10;\n        HeapNode result1 = heap.insert(key1);\n        assertNotNull(result1, \"Insert result should not be null\");\n        assertEquals(key1, result1.key, \"The key of the inserted node should be equal to the value inserted\");\n\n        // Verify that after insert, heap is no longer empty and min is updated\n        assertFalse(heap.empty(), \"Heap should not be empty after insert\");\n        assertEquals(result1, heap.getMin(), \"Inserted node should be the minimum in the heap\");\n\n        // Test case 2: Insert into a non-empty heap\n        int key2 = 5;\n        HeapNode result2 = heap.insert(key2);\n        assertNotNull(result2, \"Insert result should not be null\");\n        assertEquals(key2, result2.key, \"The key of the inserted node should be equal to the value inserted\");\n\n        // Verify that the min is updated correctly when a node with a smaller key is inserted\n        assertEquals(result2, heap.getMin(), \"New node with smaller key should be the new min in the heap\");\n\n        // Test case 3: Insert a node with a key larger than the current min\n        int key3 = 20;\n        HeapNode result3 = heap.insert(key3);\n        assertNotNull(result3, \"Insert result should not be null\");\n        assertEquals(key3, result3.key, \"The key of the inserted node should be equal to the value inserted\");\n\n        // Verify the min is still pointing to the correct node (should still be key2 since it is smaller than key3)\n        assertEquals(result2, heap.getMin(), \"After inserting a larger key, min should remain unchanged\");\n\n        // General test to verify that heap size increased\n        int expectedNumOfHeapNodes = 3; // Since three nodes have been inserted\n        assertEquals(expectedNumOfHeapNodes, heap.getNumOfHeapNodes(), \"Heap should have expected number of nodes after inserts\");\n        \n        // Check that number of trees in the heap equal to number of nodes when nodes inserted aren't combined\n        assertEquals(expectedNumOfHeapNodes, heap.getNumOfTrees(), \"Number of trees should equal to number of inserted nodes\");\n    }\n    \n    // <FILL> with additional fields and methods as necessary\n    // assuming the HeapNode class and necessary getter methods are defined in FibonacciHeap\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    private FibonacciHeap heap;\n\n    @BeforeEach\n    public void setUp() {\n        heap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        assertEquals(0, heap.getNumOfHeapNodes(), \"Heap should have 0 nodes initially\");\n        assertEquals(0, heap.getNumOfTrees(), \"Heap should have 0 trees initially\");\n        assertTrue(heap.empty(), \"Heap should be empty initially\");\n\n        // Insert a single key and test\n        int key = 5;\n        HeapNode node = heap.insert(key);\n        assertEquals(key, node.getKey(), \"Inserted key should match the key of the node\");\n        assertEquals(1, heap.getNumOfHeapNodes(), \"Heap should have 1 node after insert\");\n        assertEquals(1, heap.getNumOfTrees(), \"Heap should have 1 tree after insert\");\n        assertFalse(heap.empty(), \"Heap should not be empty after insert\");\n\n        // Insert another key and test\n        int secondKey = 3;\n        HeapNode secondNode = heap.insert(secondKey);\n        assertEquals(secondKey, secondNode.getKey(), \"Inserted key should match the key of the second node\");\n        assertEquals(2, heap.getNumOfHeapNodes(), \"Heap should have 2 nodes after second insert\");\n        assertEquals(2, heap.getNumOfTrees(), \"Heap should have 2 trees after second insert\");\n        assertFalse(heap.empty(), \"Heap should not be empty after second insert\");\n\n        // Note: In typical tests, you may also want to verify changes to internal structure,\n        // like the minimum value, next/previous node connections, etc.\n    }\n\n    // Additional helper method used in the test above\n    // These methods are assumed to exist and to be correct.\n    private class FibonacciHeap {\n        private HeapNode min;\n        private int numOfHeapNodes = 0;\n        private int numOfTrees = 0;\n\n        public boolean empty() {\n            return min == null;\n        }\n\n        public HeapNode insert(int key) {\n            HeapNode toInsert = new HeapNode(key);\n            if (this.empty()) {\n                this.min = toInsert;\n            } else {\n                min.setNext(toInsert);\n                this.updateMin(toInsert);\n            }\n            this.numOfHeapNodes++;\n            this.numOfTrees++;\n            return toInsert;\n        }\n\n        public int getNumOfHeapNodes() {\n            return numOfHeapNodes;\n        }\n\n        public int getNumOfTrees() {\n            return numOfTrees;\n        }\n\n        // Method to update the minimum node - assumed to be correctly implemented\n        private void updateMin(HeapNode toInsert) {\n            // Implementation details would go here\n        }\n    }\n\n    private class HeapNode {\n        private int key;\n        // Assuming other heap node properties and methods exist here\n\n        public HeapNode(int key) {\n            this.key = key;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        // Sets the next node in the heap - assumed to be correctly implemented\n        public void setNext(HeapNode next) {\n            // Implementation details would go here\n        }\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    private FibonacciHeap fibonacciHeap;\n\n    @BeforeEach\n    public void setUp() {\n        fibonacciHeap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        assertTrue(fibonacciHeap.empty(), \"Heap should be empty initially.\");\n\n        int keyToInsert = 10;\n        HeapNode insertedNode = fibonacciHeap.insert(keyToInsert);\n\n        assertNotNull(insertedNode, \"Inserted node should not be null.\");\n        assertEquals(keyToInsert, insertedNode.getKey(), \"Inserted node key should be equal to the key inserted.\");\n        assertFalse(fibonacciHeap.empty(), \"Heap should not be empty after insertion.\");\n        assertEquals(1, fibonacciHeap.getNumOfHeapNodes(), \"Number of heap nodes should be 1 after insertion.\");\n        assertEquals(1, fibonacciHeap.getNumOfTrees(), \"Number of trees should be 1 after insertion.\");\n        assertEquals(insertedNode, fibonacciHeap.getMin(), \"The inserted node should be the minimum node in the heap.\");\n\n        int anotherKeyToInsert = 5;\n        HeapNode anotherInsertedNode = fibonacciHeap.insert(anotherKeyToInsert);\n\n        assertNotNull(anotherInsertedNode, \"Another inserted node should not be null.\");\n        assertEquals(anotherKeyToInsert, anotherInsertedNode.getKey(), \"Another inserted node key should be equal to the key inserted.\");\n        assertEquals(2, fibonacciHeap.getNumOfHeapNodes(), \"Number of heap nodes should be 2 after second insertion.\");\n        assertEquals(2, fibonacciHeap.getNumOfTrees(), \"Number of trees should be 2 after second insertion.\");\n        assertEquals(anotherInsertedNode, fibonacciHeap.getMin(), \"The second inserted node should now be the minimum node in the heap.\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        fibonacciHeap = null;\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n\n    private FibonacciHeap heap; // Assuming FibonacciHeap is the class that includes the insert method\n\n    @BeforeEach\n    public void setUp() {\n        heap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        // Test insert on empty heap\n        HeapNode node1 = heap.insert(10);\n        assertEquals(10, node1.key);\n        assertEquals(1, heap.numOfHeapNodes);\n        assertEquals(1, heap.numOfTrees);\n        assertEquals(node1, heap.min);\n\n        // Test insert on heap with one element\n        HeapNode node2 = heap.insert(5);\n        assertEquals(5, node2.key);\n        assertEquals(2, heap.numOfHeapNodes);\n        assertEquals(2, heap.numOfTrees);\n        assertEquals(node2, heap.min); // new node with key 5 should be the new minimum\n\n        // Test insert on heap with two elements\n        HeapNode node3 = heap.insert(15);\n        assertEquals(15, node3.key);\n        assertEquals(3, heap.numOfHeapNodes);\n        // Assuming the heap implementation doesn't consolidate on insert\n        assertEquals(3, heap.numOfTrees);\n        assertEquals(node2, heap.min); // min should not change as 15 > 5\n\n        // More test scenarios could be added here to thoroughly test the insert method\n    }\n\n    // This assumes that the FibonacciHeap has a method called 'empty'\n    // that checks whether the heap is empty or not.\n    private static class FibonacciHeap {\n        private HeapNode min;\n        private int numOfHeapNodes;\n        private int numOfTrees;\n\n        public boolean empty() {\n            return min == null;\n        }\n\n        public HeapNode insert(int key) {\n            HeapNode toInsert = new HeapNode(key);\n            if (this.empty()) {\n                this.min = toInsert;\n            } else {\n                min.setNext(toInsert); // Assuming setNext() adds the new node to the root list\n                this.updateMin(toInsert);\n            }\n            this.numOfHeapNodes++;\n            this.numOfTrees++;\n            return toInsert;\n        }\n\n        private void updateMin(HeapNode node) {\n            if (node.key < min.key) {\n                this.min = node;\n            }\n        }\n    }\n\n    // Also assuming that there's a HeapNode class with a key property and a `setNext` method.\n    private static class HeapNode {\n        int key;\n        HeapNode next; // Assuming this points to the next node in the root list\n\n        public HeapNode(int key) {\n            this.key = key;\n        }\n\n        public void setNext(HeapNode nextNode) {\n            this.next = nextNode;\n        }\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    private FibonacciHeap heap;\n\n    @BeforeEach\n    void setUp() {\n        heap = new FibonacciHeap();\n    }\n\n    @Test\n    public void insertTest() {\n        // Test when the heap is initially empty\n        assertTrue(heap.empty(), \"Heap should be empty initially\");\n        HeapNode node = heap.insert(10);\n        assertNotNull(node, \"Inserted node should not be null\");\n        assertEquals(10, heap.min.key, \"Min should be the key of the inserted node when heap was empty\");\n\n        // Test inserting additional nodes\n        heap.insert(20);\n        assertEquals(10, heap.min.key, \"Min should still be the first key after inserting larger key\");\n\n        heap.insert(5);\n        assertEquals(5, heap.min.key, \"Min should update to the new smaller key\");\n        \n        // Testing the count of nodes and trees if these are available in the heap object\n        assertEquals(3, heap.numOfHeapNodes, \"Heap should contain 3 nodes after insertions\");\n        assertEquals(3, heap.numOfTrees, \"Heap should consider each new node as a separate tree\");\n\n        // Test insertion of a node with a key already present in the heap if necessary\n        // Note: The behavior on duplicates depends on the specification of the heap\n    }\n}",
        "package com.thealgorithms.datastructures.heaps;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FibonacciHeapTest {\n    \n    private FibonacciHeap heap;\n    \n    @BeforeEach\n    public void setUp() {\n        heap = new FibonacciHeap();\n    }\n    \n    @Test\n    public void insertTest() {\n        assertTrue(heap.empty(), \"Heap should be initially empty\");\n        \n        HeapNode insertedNode = heap.insert(10);\n        assertNotNull(insertedNode, \"insert() should return a non-null HeapNode\");\n        assertEquals(10, insertedNode.getKey(), \"The key of the inserted node should be equal to the key passed to insert()\");\n        \n        assertFalse(heap.empty(), \"Heap should not be empty after insert\");\n        assertEquals(1, heap.getNumOfHeapNodes(), \"Heap should have 1 node after first insert\");\n        assertEquals(1, heap.getNumOfTrees(), \"Heap should have 1 tree after first insert\");\n        \n        HeapNode secondNode = heap.insert(5);\n        assertEquals(5, heap.findMin().getKey(), \"The minimum should be updated to 5 after inserting a smaller value\");\n        \n        assertEquals(2, heap.getNumOfHeapNodes(), \"Heap should have 2 nodes after second insert\");\n        assertEquals(2, heap.getNumOfTrees(), \"Heap should have 2 trees after second insert\");\n    }\n    \n    // Helper method to verify if the heap is empty\n    // This is assumed based on the given source code, which would be part of the FibonacciHeap class\n    private class FibonacciHeap {\n        private HeapNode min = null;\n        private int numOfHeapNodes = 0;\n        private int numOfTrees = 0;\n        \n        public HeapNode insert(int key) {\n            // Implementation of the insert method based on the provided source code\n        }\n        \n        public boolean empty() {\n            return min == null;\n        }\n        \n        public int getNumOfHeapNodes() {\n            return numOfHeapNodes;\n        }\n        \n        public int getNumOfTrees() {\n            return numOfTrees;\n        }\n\n        public HeapNode findMin() {\n            return min;\n        }\n        \n        // Assuming there are methods like 'setNext', 'updateMin', etc. in the `HeapNode` class\n    }\n    \n    // Helper class to mock a HeapNode\n    // This class is assumed based on the given source code and would be part of the FibonacciHeap implementation\n    private class HeapNode {\n        private int key;\n        // Properties and methods like 'next', 'setNext', 'updateMin', etc.\n        \n        public HeapNode(int key) {\n            this.key = key;\n            // Initialization of other properties if necessary\n        }\n        \n        public int getKey() {\n            return key;\n        }\n        \n        // Other getters and setters if needed\n    }\n}"
    ]
}