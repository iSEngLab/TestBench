{
    "project_name": "Java",
    "file_name": "FloodFill.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */",
    "source_code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
    "class_name": "FloodFill",
    "method_name": "floodFill",
    "arguments": [
        "int[][] image",
        "int x",
        "int y",
        "int newColor",
        "int oldColor"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        int[][] image = {\n            {1, 1, 1, 1},\n            {1, 1, 0, 0},\n            {1, 0, 1, 1}\n        };\n\n        int newColor = 2;\n        int x = 1;\n        int y = 1;\n        int oldColor = image[x][y];\n\n        // Apply flood fill algorithm to image starting at pixel (x, y)\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        int[][] expectedImage = {\n            {1, 1, 1, 1},\n            {1, 2, 0, 0},\n            {1, 0, 1, 1}\n        };\n\n        // Check if the image array after applying flood fill matches the expected result\n        assertArrayEquals(expectedImage[0], image[0], \"First row should match\");\n        assertArrayEquals(expectedImage[1], image[1], \"Second row should match\");\n        assertArrayEquals(expectedImage[2], image[2], \"Third row should match\");\n\n        // additional checks can be added to ensure all scenarios are covered\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Prepare a sample image (2D array)\n        int[][] image = {\n            {1, 1, 1, 2, 1},\n            {1, 1, 2, 2, 1},\n            {1, 1, 1, 1, 2},\n            {2, 1, 1, 2, 1}\n        };\n\n        // Expected result after flood fill\n        int[][] expectedResult = {\n            {3, 3, 3, 2, 1},\n            {3, 3, 2, 2, 1},\n            {3, 3, 3, 3, 2},\n            {2, 3, 3, 2, 1}\n        };\n\n        // Coordinates for the start of the flood fill\n        int x = 1;\n        int y = 1;\n        // New color to be filled\n        int newColor = 3;\n        // Old color to be replaced\n        int oldColor = image[x][y];\n\n        // Perform the flood fill\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Assert that the image was filled correctly\n        assertArrayEquals(expectedResult, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Create an image represented by a 2D array\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        // Define old color that needs to be replaced\n        int oldColor = 1;\n        // Define new color to replace the old color\n        int newColor = 2;\n        // Call the floodFill method starting from coordinate (1, 1)\n        FloodFill.floodFill(image, 1, 1, newColor, oldColor);\n        // Define the expected image after the flood fill\n        int[][] expected = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n        // Assert that the flood-filled image matches the expected result\n        assertArrayEquals(expected, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Initialization of a simple image with oldColor of 1\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n\n        // The expected result after running floodFill algorithm with newColor of 2 starting at (1, 1)\n        int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n\n        int oldColor = 1;\n        int newColor = 2;\n        int x = 1; // x co-ordinate from where to start the flood fill\n        int y = 1; // y co-ordinate from where to start the flood fill\n\n        // Call the floodFill method on the image\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Assert that after calling floodFill, the image shall be modified as expected\n        assertArrayEquals(expectedImage, image, \"The image should match the expected filled image.\");\n\n        // Try another test case where newColor is same as oldColor\n        int[][] image2 = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n\n        // The expected result should not change since newColor is same as oldColor\n        int[][] expectedNoChangeImage = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n\n        // Call the floodFill method on the image2\n        FloodFill.floodFill(image2, x, y, oldColor, oldColor);\n\n        // Assert that after calling floodFill, the image2 should not change\n        assertArrayEquals(expectedNoChangeImage, image2, \"The image should not change if newColor is same as the oldColor.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Initialize an image (2D array) with a pattern\n        int[][] image = {\n            {1, 1, 1, 1},\n            {1, 1, 0, 1},\n            {1, 0, 1, 1},\n            {1, 1, 1, 1}\n        };\n\n        // Define old color to replace and new color\n        int oldColor = 1;\n        int newColor = 2;\n\n        // Call the floodFill method on a specific starting coordinate\n        FloodFill.floodFill(image, 1, 1, newColor, oldColor);\n\n        // Expected result after flood fill algorithm is applied\n        int[][] expectedImage = {\n            {2, 2, 2, 2},\n            {2, 2, 0, 2},\n            {2, 0, 2, 2},\n            {2, 2, 2, 2}\n        };\n\n        // Assert that the flood filled image matches the expected result\n        assertArrayEquals(expectedImage, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    \n    @Test\n    public void floodFillTest() {\n        // Given a 2D image array with initial colors\n        int[][] image = {\n            {1, 1, 1, 2, 1},\n            {1, 1, 2, 2, 2},\n            {1, 1, 1, 1, 1},\n            {2, 1, 2, 2, 1}\n        };\n        // Assuming 1 is the old color and we want to replace it with 3\n        int newColor = 3;\n        int oldColor = 1;\n        \n        // Coordinates to start the flood fill\n        int x = 1;\n        int y = 1;\n        \n        // Expected image after flood fill, assuming all the adjacent 1's will be filled with 3\n        int[][] expected = {\n            {3, 3, 3, 2, 1},\n            {3, 3, 2, 2, 2},\n            {3, 3, 3, 3, 3},\n            {2, 3, 2, 2, 1}\n        };\n        \n        // Perform flood fill on the image\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        // Assert that every pixel's color matches the expected color after the fill\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                assertEquals(expected[i][j], image[i][j],\n                    \"Pixel at position (\" + i + \", \" + j + \") should have color \" + expected[i][j]);\n            }\n        }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        int newColor = 2;\n        int x = 1;\n        int y = 1;\n        int oldColor = image[x][y];\n        \n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        int[][] expected = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n        \n        assertArrayEquals(expected, image, \"The flood fill algorithm did not work as expected\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Given\n        int[][] image = {\n                {1, 1, 1},\n                {1, 1, 0},\n                {1, 0, 1}\n        };\n        int newColor = 2;\n        int x = 1;\n        int y = 1;\n        int oldColor = image[x][y];\n\n        int[][] expected = {\n                {2, 2, 2},\n                {2, 2, 0},\n                {2, 0, 1}\n        };\n\n        // When\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Then\n        assertArrayEquals(expected, image);\n    }\n    \n    @Test\n    public void floodFillTestNoChange() {\n        // Test when the new color is the same as the old color\n        int[][] image = {\n                {1, 1, 1},\n                {1, 1, 0},\n                {1, 0, 1}\n        };\n        int newColor = 1; // same as old color\n        int x = 1;\n        int y = 1;\n        int oldColor = image[x][y];\n\n        int[][] expected = {\n                {1, 1, 1},\n                {1, 1, 0},\n                {1, 0, 1}\n        };\n\n        // When\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Then\n        assertArrayEquals(expected, image);\n    }\n\n    @Test\n    public void floodFillTestBoundary() {\n        // Test when the seed point is at the boundary and should not fill diagonally\n        int[][] image = {\n                {0, 0, 0},\n                {0, 1, 1},\n                {0, 1, 0}\n        };\n        int newColor = 2;\n        int x = 2;\n        int y = 2;\n        int oldColor = image[x][y];\n\n        int[][] expected = {\n                {0, 0, 0},\n                {0, 1, 1},\n                {0, 1, 2}\n        };\n\n        // When\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Then\n        assertArrayEquals(expected, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void testFloodFill() {\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        int newColor = 2;\n        int x = 1;\n        int y = 1;\n        int oldColor = image[x][y];\n        \n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        int[][] expectedImage = {\n            {1, 1, 1},\n            {1, 2, 0},\n            {1, 0, 1}\n        };\n\n        assertArrayEquals(expectedImage, image);\n    }\n\n    @Test\n    public void testFloodFillBoundaryCondition() {\n        int[][] image = {\n            {0, 0, 0},\n            {0, 0, 0}\n        };\n        int newColor = 3;\n        int x = 0;\n        int y = 0;\n        int oldColor = image[x][y];\n        \n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        int[][] expectedImage = {\n            {3, 3, 3},\n            {3, 3, 3}\n        };\n\n        assertArrayEquals(expectedImage, image);\n    }\n\n    @Test\n    public void testFloodFillNoChange() {\n        int[][] image = {\n            {2, 2},\n            {2, 2}\n        };\n        int newColor = 2;\n        int x = 0;\n        int y = 0;\n        int oldColor = image[x][y];\n        \n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        // No change expected since oldColor is same as newColor\n        int[][] expectedImage = {\n            {2, 2},\n            {2, 2}\n        };\n        \n        assertArrayEquals(expectedImage, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Initialize an image as a 2D grid\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n\n        // Call the floodFill method on the given coordinates and color\n        FloodFill.floodFill(image, 1, 1, 2, image[1][1]);\n\n        // Expected image after the floodFill operation to replace color 1 with 2\n        int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n\n        // Assert that the image is filled correctly\n        assertArrayEquals(expectedImage, image);\n\n        // Test boundary conditions where flooding should not occur\n        FloodFill.floodFill(image, 1, 1, 3, image[1][1]);\n        // Color at index (1,1) was already changed to 2, so it should not change to 3\n        assertNotEquals(3, image[1][1]);\n\n        // Test when newColor is same as oldColor, no change should happen\n        FloodFill.floodFill(image, 0, 0, 2, 2);\n        assertArrayEquals(expectedImage, image);\n\n        // Test on a non-contiguous section\n        int[][] nonContiguousImage = {\n            {1, 2, 1},\n            {2, 1, 2},\n            {1, 2, 1}\n        };\n\n        FloodFill.floodFill(nonContiguousImage, 0, 0, 3, 1);\n        int[][] expectedNonContiguousImage = {\n            {3, 2, 1},\n            {2, 1, 2},\n            {1, 2, 1}\n        };\n\n        assertArrayEquals(expectedNonContiguousImage, nonContiguousImage);\n    }\n}"
    ]
}