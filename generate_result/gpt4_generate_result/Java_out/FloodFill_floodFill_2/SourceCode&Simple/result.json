{
    "project_name": "Java",
    "file_name": "FloodFill.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */",
    "source_code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
    "class_name": "FloodFill",
    "method_name": "floodFill",
    "arguments": [
        "int[][] image",
        "int x",
        "int y",
        "int newColor",
        "int oldColor"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Initialize image with old color\n        int oldColor = 1;\n        int newColor = 2;\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n\n        // Coordinates to start the flood fill\n        int x = 1;\n        int y = 1;\n\n        // Expected output after flood fill\n        int[][] expected = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n\n        // Call the method under test\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Assert that the image is filled correctly\n        assertArrayEquals(expected, image, \"The image should be filled correctly with the new color.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Example test image matrix where 1 represents old color and 2 represents new color\n        int[][] image = {\n              {1, 1, 1, 1, 1},\n              {1, 1, 1, 1, 1},\n              {1, 1, 0, 1, 1},\n              {1, 1, 1, 1, 1}\n        };\n        int x = 2, y = 2; // Starting point for flood fill\n        int newColor = 2;\n        int oldColor = 1;\n\n        //Call method under test\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Expected image after floodFill:\n        int[][] expectedImage = {\n              {2, 2, 2, 2, 2},\n              {2, 2, 2, 2, 2},\n              {2, 2, 0, 2, 2},\n              {2, 2, 2, 2, 2}\n        };\n\n        // Check if every pixel is filled with new color where the old color was present\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                assertEquals(expectedImage[i][j], image[i][j],\n                        \"Pixel at [\" + i + \"][\" + j + \"] does not match expected value.\");\n            }\n        }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Setting up a test image with predefined pixel values\n        int[][] image = {\n                {1, 1, 1, 1},\n                {1, 2, 2, 1},\n                {1, 2, 1, 1},\n                {1, 1, 1, 1}\n        };\n        int newColor = 3;\n        int x = 1; // starting x position \n        int y = 1; // starting y position \n        int oldColor = 2; // color to be replaced\n        \n        // Expected result after flood fill\n        int[][] expected = {\n                {1, 1, 1, 1},\n                {1, 3, 3, 1},\n                {1, 3, 1, 1},\n                {1, 1, 1, 1}\n        };\n\n        // Performing flood fill operation on the test image\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Assert that the modified image matches the expected result\n        assertArrayEquals(expected, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Assume we have a canvas with some initial colors\n        int[][] image = {\n            {1, 1, 1, 1, 1},\n            {1, 1, 2, 2, 1},\n            {1, 2, 2, 1, 1},\n            {1, 1, 1, 1, 1}\n        };\n\n        // The old color we want to replace\n        int oldColor = 2;\n\n        // The new color we want to flood with\n        int newColor = 3;\n\n        // The starting point for the flood fill\n        int startX = 1;\n        int startY = 2;\n\n        // Expected image after flood fill\n        int[][] expectedImage = {\n            {1, 1, 1, 1, 1},\n            {1, 1, 3, 3, 1},\n            {1, 3, 3, 1, 1},\n            {1, 1, 1, 1, 1}\n        };\n\n        // Perform flood fill on the image starting at (startX, startY)\n        FloodFill.floodFill(image, startX, startY, newColor, oldColor);\n\n        // Assert the image has been filled correctly\n        assertArrayEquals(expectedImage, image, \"The image should have the color \" + newColor + \" correctly filled in place of \" + oldColor);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n\n        int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n\n        final int x = 0;\n        final int y = 0;\n        final int newColor = 2;\n        final int oldColor = 1;\n        \n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        assertArrayEquals(expectedImage, image, \"FloodFill did not fill the image correctly.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Arrange: Create a test image (2D array), and setup initial conditions\n        int[][] image = {\n            {1, 1, 1, 1, 1},\n            {1, 1, 2, 2, 1},\n            {1, 2, 2, 2, 1},\n            {1, 1, 1, 1, 1}\n        };\n        int startX = 2;\n        int startY = 2;\n        int newColor = 3;\n        int oldColor = 2;\n\n        // Expected image after flood fill\n        int[][] expected = {\n            {1, 1, 1, 1, 1},\n            {1, 1, 3, 3, 1},\n            {1, 3, 3, 3, 1},\n            {1, 1, 1, 1, 1}\n        };\n\n        // Act: Perform the flood fill operation\n        FloodFill.floodFill(image, startX, startY, newColor, oldColor);\n\n        // Assert: Check if image matches expected result after flood fill\n        assertArrayEquals(expected, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Assume we have a method for deep comparison of two-dimensional arrays\n        int[][] image = {\n                {1, 1, 1},\n                {1, 1, 0},\n                {1, 0, 1}\n        };\n\n        int[][] expectedImage = {\n                {2, 2, 2},\n                {2, 2, 0},\n                {2, 0, 1}\n        };\n\n        int x = 1;\n        int y = 1;\n        int newColor = 2;\n        int oldColor = 1;\n\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        assertArrayEquals(expectedImage, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Given\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        int x = 1; // Start x coordinate\n        int y = 1; // Start y coordinate\n        int newColor = 2; // New color to fill\n        int oldColor = image[x][y]; // Old color at the start coordinates\n\n        // Expected filled image\n        int[][] expectedImage = {\n            {1, 1, 1},\n            {1, 2, 0},\n            {1, 0, 1}\n        };\n\n        // When\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n\n        // Then\n        assertArrayEquals(expectedImage[0], image[0]);\n        assertArrayEquals(expectedImage[1], image[1]);\n        assertArrayEquals(expectedImage[2], image[2]);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    \n    private static final int OLD_COLOR = 0;\n    private static final int NEW_COLOR = 1;\n    \n    @Test\n    public void floodFillTest() {\n        // Initialize a sample image with old colors\n        int[][] image = {\n            {OLD_COLOR, OLD_COLOR, OLD_COLOR},\n            {OLD_COLOR, OLD_COLOR, OLD_COLOR},\n            {OLD_COLOR, OLD_COLOR, OLD_COLOR}\n        };\n\n        // Coordinate to start the flood fill\n        int x = 1;\n        int y = 1;\n\n        // Perform flood fill on the image\n        FloodFill.floodFill(image, x, y, NEW_COLOR, OLD_COLOR);\n\n        // Expected result after flood fill with new color\n        int[][] expected = {\n            {NEW_COLOR, NEW_COLOR, NEW_COLOR},\n            {NEW_COLOR, NEW_COLOR, NEW_COLOR},\n            {NEW_COLOR, NEW_COLOR, NEW_COLOR}\n        };\n        \n        // Assert that every pixel has been filled with the new color\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                assertEquals(NEW_COLOR, image[i][j], \"Pixel at [\" + i + \"][\" + j + \"] should be color \" + NEW_COLOR);\n            }\n        }\n\n        // Alternatively, compare the whole image arrays.\n        assertArrayEquals(expected, image, \"The entire image should be flood-filled with the new color.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Define the old and new colors\n        int oldColor = 1;\n        int newColor = 2;\n\n        // Initialize an image with a solid color\n        int[][] image = {\n                {oldColor, oldColor, oldColor},\n                {oldColor, oldColor, oldColor},\n                {oldColor, oldColor, oldColor}\n        };\n\n        // Choose the starting point for the flood fill\n        int startX = 0;\n        int startY = 0;\n\n        // Perform the flood fill\n        FloodFill.floodFill(image, startX, startY, newColor, oldColor);\n\n        // Construct the expected result\n        int[][] expectedImage = {\n                {newColor, newColor, newColor},\n                {newColor, newColor, newColor},\n                {newColor, newColor, newColor}\n        };\n\n        // Check each pixel to see if the flood fill worked as expected\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[i].length; j++) {\n                assertEquals(expectedImage[i][j], image[i][j], String.format(\"The pixel at (%d, %d) should be %d\", i, j, newColor));\n            }\n        }\n    }\n}"
    ]
}