{
    "project_name": "Java",
    "file_name": "FloodFill.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */",
    "source_code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
    "class_name": "FloodFill",
    "method_name": "floodFill",
    "arguments": [
        "int[][] image",
        "int x",
        "int y",
        "int newColor",
        "int oldColor"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        // Test images and expected results\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        int newColor = 2;\n        int x = 1;\n        int y = 1;\n        int oldColor = image[x][y];\n        \n        int[][] expectedResult = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n        \n        // Perform the flood fill operation\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        // Assertion\n        assertArrayEquals(expectedResult, image, \"The flood fill operation did not produce the expected image.\");\n    }\n\n    // Helper methods for the unit test\n    public static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    public static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    // Assuming the FloodFill class contains the floodFill method as provided\n    public static class FloodFill {\n        public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n            if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n                return;\n            }\n\n            putPixel(image, x, y, newColor);\n\n            /* Recursively check for horizontally & vertically adjacent coordinates */\n            floodFill(image, x + 1, y, newColor, oldColor);\n            floodFill(image, x - 1, y, newColor, oldColor);\n            floodFill(image, x, y + 1, newColor, oldColor);\n            floodFill(image, x, y - 1, newColor, oldColor);\n\n            /* Recursively check for diagonally adjacent coordinates  */\n            floodFill(image, x + 1, y - 1, newColor, oldColor);\n            floodFill(image, x - 1, y + 1, newColor, oldColor);\n            floodFill(image, x + 1, y + 1, newColor, oldColor);\n            floodFill(image, x - 1, y - 1, newColor, oldColor);\n        }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n\n        int x = 1;\n        int y = 1;\n        int newColor = 2;\n        int oldColor = image[x][y];\n        \n        FloodFillAlgorithm.floodFill(image, x, y, newColor, oldColor);\n\n        int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n\n        assertArrayEquals(expectedImage, image);\n\n        // Additional test cases could go here to check various scenarios like:\n        // - non-rectangular images\n        // - large images\n        // - edge cases with negative coordinates or coordinates out of bounds\n        // - cases where newColor is the same as oldColor\n        // - empty image case\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\n\npublic class FloodFillTest {\n\n    @Test\n    public void floodFillTest() {\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        int newColor = 2;\n        int oldColor = 1;\n        int x = 1; // Starting coordinates x position\n        int y = 1; // Starting coordinates y position\n\n        // The expected result after the floodFill function should be executed\n        int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n        \n        // Call the static method floodFill from some class where it is defined\n        SomeClass.floodFill(image, x, y, newColor, oldColor); // Assuming floodFill is a static method in SomeClass\n\n        // Verify that the floodFill method performs as expected\n        assertArrayEquals(expectedImage, image, \"The floodFill method did not produce the expected output.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    // Helper methods to mimic the ones possibly present in the source code file\n    private static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n    \n    private static void putPixel(int[][] image, int x, int y, int color) {\n        image[x][y] = color;\n    }\n\n    public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n        if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n            return;\n        }\n\n        putPixel(image, x, y, newColor);\n\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n\n    @Test\n    public void floodFillTest() {\n        // Prepare sample image\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        // Expected result after filling\n        int[][] expected = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n        // Perform flood fill\n        floodFill(image, 0, 0, 2, 1); // Fill with new color 2 at (0,0) where old color is 1\n\n        // Assert that the flood-filled image matches the expected result\n        assertArrayEquals(expected[0], image[0]);\n        assertArrayEquals(expected[1], image[1]);\n        assertArrayEquals(expected[2], image[2]);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n    @Test\n    public void floodFillTest() {\n        // Create a sample image represented by a 2D array\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        \n        // Define the old and new colors\n        int newColor = 2;\n        int oldColor = 1;\n\n        // Expected result after flood fill\n        int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n        \n        // Calling the floodFill method on the (1, 1) position\n        FloodFill.floodFill(image, 1, 1, newColor, oldColor);\n\n        // Assertions to make sure the floodFill method works as expected\n        for (int i = 0; i < image.length; i++) {\n            assertArrayEquals(expectedImage[i], image[i], \"The floodFill method did not fill the expected pixels.\");\n        }\n    }\n\n    // Helper methods that imitate the actual image manipulation logic\n    // These would need to be defined in the actual implementation\n    private static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n    \n    private static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    private static void putPixel(int[][] image, int x, int y, int color) {\n        image[x][y] = color;\n    }\n\n    private static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    @Test\n    public void floodFillTest() {\n        // Use a static nested class to access the method, assuming that the floodFill method \n        // is within a class named `FloodFillAlgorithm`\n        final class FloodFillAlgorithm {\n            public static void floodFill(int[][] image, int x, int y, int newColor, int oldColor) {\n                // Implementation is hidden as it is assumed to be provided above\n            }\n        }\n        \n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        int x = 1;\n        int y = 1;\n        int newColor = 2;\n        int oldColor = image[x][y];\n\n        FloodFillAlgorithm.floodFill(image, x, y, newColor, oldColor);\n\n        int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n\n        assertArrayEquals(expectedImage[0], image[0], \"First row did not match expected result.\");\n        assertArrayEquals(expectedImage[1], image[1], \"Second row did not match expected result.\");\n        assertArrayEquals(expectedImage[2], image[2], \"Third row did not match expected result.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    // Helper methods to use in the test case.\n    private static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    private static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n    \n    // Actual test method\n    @Test\n    public void floodFillTest() {\n        // Example input image, we will use it to test our flood fill method\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        \n        // Expected result after flood filling (6 is the new color)\n        int[][] expectedImage = {\n            {6, 6, 6},\n            {6, 6, 0},\n            {6, 0, 1}\n        };\n        \n        // The old color we want to replace (all '1's should be replaced)\n        int oldColor = 1; \n        \n        // The new color with which we should replace the old color\n        int newColor = 6; \n        \n        // Start flood fill from the coordinate (1, 1)\n        FloodFillTest.floodFill(image, 1, 1, newColor, oldColor);\n        \n        // Check every pixel to see if the fill was successful\n        assertArrayEquals(expectedImage, image);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n        // Source Code implementation...\n    }\n    \n    // Helper method to get the pixel color at a specific location.\n    private static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    // Helper method to set the pixel color at a specific location to the new color.\n    private static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n\n    @Test\n    public void floodFillTest() {\n        int newColor = 3;\n        int[][] image = {\n            {1, 1, 1, 2, 2},\n            {1, 1, 1, 2, 2},\n            {1, 1, 1, 2, 2},\n            {1, 1, 1, 1, 1},\n        };\n        int oldColor = image[0][0];\n        FloodFillTest.floodFill(image, 1, 1, newColor, oldColor);\n        \n        int[][] expectedImage = {\n            {3, 3, 3, 2, 2},\n            {3, 3, 3, 2, 2},\n            {3, 3, 3, 2, 2},\n            {3, 3, 3, 3, 3},\n        };\n        \n        assertArrayEquals(expectedImage, image, \"The image should be correctly flood filled with the new color.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    // Helper methods to simulate getPixel and putPixel to directly access the array.\n    private static int getPixel(int[][] image, int x, int y) {\n        return image[x][y];\n    }\n\n    private static void putPixel(int[][] image, int x, int y, int newColor) {\n        image[x][y] = newColor;\n    }\n    \n    // The test method itself\n    @Test\n    public void floodFillTest() {\n        int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        int x = 1; // Starting X coordinate\n        int y = 1; // Starting Y coordinate\n        int newColor = 2; // New color to apply\n        int oldColor = image[x][y]; // Color to replace, taken from the starting coordinates\n        \n        // Expected image after flood fill\n        int[][] expected = {\n            {1, 1, 1},\n            {1, 2, 0},\n            {1, 0, 1}\n        };\n        \n        // Perform flood fill\n        FloodFill.floodFill(image, x, y, newColor, oldColor);\n        \n        // Check each pixel to see if the flood fill worked as expected\n        for(int i = 0; i < image.length; i++) {\n            assertArrayEquals(expected[i], image[i], \"Row \" + i + \" of the image should match the expected result.\");\n        }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FloodFillTest {\n\n    // Static helper methods to simulate the methods that are called within floodFill\n    private static int getPixel(final int[][] image, final int x, final int y) {\n        return image[x][y];\n    }\n\n    private static void putPixel(final int[][] image, final int x, final int y, final int newColor) {\n        image[x][y] = newColor;\n    }\n    \n    // The floodFill method from the JAVA Source Code provided\n    public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n        if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n            return;\n        }\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n    \n    @Test\n    public void floodFillTest() {\n        final int[][] image = {\n            {1, 1, 1},\n            {1, 1, 0},\n            {1, 0, 1}\n        };\n        \n        final int[][] expectedImage = {\n            {2, 2, 2},\n            {2, 2, 0},\n            {2, 0, 1}\n        };\n        \n        final int newColor = 2;\n        final int x = 1;\n        final int y = 1;\n        final int oldColor = image[x][y];\n\n        // Perform the floodFill\n        floodFill(image, x, y, newColor, oldColor);\n\n        // Assertion to check the entire array for the expected result\n        for (int i = 0; i < image.length; i++) {\n            assertArrayEquals(expectedImage[i], image[i], \"Row \" + i + \" does not match expected result.\");\n        }\n    }\n}"
    ]
}