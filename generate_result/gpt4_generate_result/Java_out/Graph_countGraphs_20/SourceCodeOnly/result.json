{
    "project_name": "Java",
    "file_name": "ConnectedComponent.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/ConnectedComponent.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.graphs",
    "docstring": "/**\n     * Main method used for counting the connected components. Iterates through\n     * the array of nodes to do a depth first search to get all nodes of the\n     * graph from the actual node. These nodes are added to the array\n     * markedNodes and will be ignored if they are chosen in the nodeList.\n     *\n     * @return returns the amount of unconnected graphs\n     */",
    "source_code": "\npublic int countGraphs() {\n    int count = 0;\n    Set<Node> markedNodes = new HashSet<Node>();\n\n    for (Node n : nodeList) {\n        if (!markedNodes.contains(n)) {\n            markedNodes.add(n);\n            markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n            count++;\n        }\n    }\n\n    return count;\n}\n",
    "class_name": "Graph",
    "method_name": "countGraphs",
    "arguments": [],
    "generate_test": [
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GraphTest {\n\n    private Graph graph;\n\n    @BeforeEach\n    public void setUp() {\n        // Initialize Graph object here with nodes and edges according to your Graph implementation\n        // This setup is necessary to test the countGraphs method appropriately\n        graph = new Graph();\n        // Add nodes and edges to create disconnected graphs for testing\n        // For example, if your nodeList is a list field in Graph:\n        // graph.nodeList.add(new Node(\"Node1\"));\n        // graph.nodeList.add(new Node(\"Node2\"));\n        // ... Add all the nodes for the test graphs\n        // ... and connect them if necessary to form the disconnected subgraphs\n    }\n\n    @Test\n    public void countGraphsTest() {\n        // Assuming the setup creates two disconnected subgraphs:\n        int expectedCount = 2;\n        // Call the method countGraphs and assert that it returns the expected number of subgraphs\n        assertEquals(expectedCount, graph.countGraphs(), \"countGraphs should return the correct number of disconnected subgraphs\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GraphTest {\n\n    @Test\n    public void countGraphsTest() {\n        // Arrange\n        Graph graph = new Graph();\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n        Node node4 = new Node();\n\n        // Assuming Graph class has methods to add nodes and edges\n        graph.addNode(node1);\n        graph.addNode(node2);\n        graph.addEdge(node1, node2); // First connected component\n        \n        graph.addNode(node3);\n        graph.addNode(node4);\n        // No edges added between node3 and node4, hence they'll be separate components\n\n        int expectedCount = 3; // We expect 3 as there are 3 separate graphs (2 single nodes and 1 connected graph)\n\n        // Act\n        int actualCount = graph.countGraphs();\n\n        // Assert\n        assertEquals(expectedCount, actualCount, \"The count of separate graphs should be 3.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GraphTest {\n\n    @Test\n    public void countGraphsTest() {\n        // Create nodes and graphs\n        Node node1 = new Node(...); // Assuming Node class has been defined\n        Node node2 = new Node(...);\n        Node node3 = new Node(...);\n        Node node4 = new Node(...); // Assume more nodes as needed\n\n        // Connect nodes to form graphs\n        // For example:\n        // Graph 1: (node1)--(node2)\n        // Graph 2: (node3), (node4) are unconnected, hence two different graphs\n\n        // Add nodes to the nodeList used within the countGraphs method\n        List<Node> nodeList = new ArrayList<>();\n        nodeList.add(node1);\n        nodeList.add(node2);\n        nodeList.add(node3);\n        nodeList.add(node4);\n\n        // Inserting an anonymous Graph class that contains the nodeList\n        // and the countGraphs method\n        Graph graph = new Graph() {\n            List<Node> nodeList = this.nodeList;\n            \n            public int countGraphs() {\n                // Implement the original source code provided here\n                int count = 0;\n                Set<Node> markedNodes = new HashSet<Node>();\n\n                for (Node n : this.nodeList) {\n                    if (!markedNodes.contains(n)) {\n                        markedNodes.add(n);\n                        markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n                        count++;\n                    }\n                }\n\n                return count;\n            }\n            \n            private Set<Node> depthFirstSearch(Node node, List<Node> visited) {\n                // Implement DFS logic based on how the actual Node and Graph classes are set up\n                // This is just an indicative, since the actual implementation is not given\n                Set<Node> connectedNodes = new HashSet<>();\n                // ... Perform DFS to collect connected nodes...\n                return connectedNodes;\n            }\n        };\n\n        // Count the number of graphs and assert the expected value (which is 3 in this example)\n        int result = graph.countGraphs();\n        assertEquals(3, result);\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GraphTest {\n\n    private Graph graph;\n\n    @BeforeEach\n    void setUp() {\n        graph = new Graph();\n        // Assume Graph class has a method to add nodes or this could be the direct nodeList manipulation\n        // Add nodes and edges to simulate a graph\n        Node node1 = new Node(1);\n        Node node2 = new Node(2);\n        Node node3 = new Node(3);\n        Node node4 = new Node(4);\n        \n        graph.addNode(node1);\n        graph.addNode(node2);\n        graph.addNode(node3);\n        // Assuming node4 is disconnected to represent a separate graph\n        graph.addNode(node4);\n        \n        // Add edges to connect the nodes (skipped, as we don't have graph structure details)\n        // graph.addEdge(node1, node2);\n        // graph.addEdge(node2, node3);\n    }\n\n    @Test\n    public void countGraphsTest() {\n        int expectedCount = 2; // Assuming one connected component with node1, node2, node3 and one separate node node4\n        int actualCount = graph.countGraphs();\n        assertEquals(expectedCount, actualCount, \"The countGraphs method should return the number of disconnected graphs.\");\n    }\n\n    // If necessary, here add more test cases for various graph configurations\n\n    // Tear down resources if needed after tests\n    @AfterEach\n    void tearDown() {\n        graph = null;\n    }\n\n    // Assuming a Node class for the sake of completeness\n    private static class Node {\n        // Node class details\n        private int id;\n        public Node(int id) {\n            this.id = id;\n        }\n        // Implement hash and equals if used in a Hash-based collection\n        // ...\n    }\n    \n    // Assuming a Graph class that encapsulates nodeList, addNode, etc.\n    private static class Graph {\n        HashSet<Node> nodeList = new HashSet<>();\n        \n        public void addNode(Node node) {\n            nodeList.add(node);\n        }\n        \n        public int countGraphs() {\n            int count = 0;\n            Set<Node> markedNodes = new HashSet<Node>();\n\n            for (Node n : nodeList) {\n                if (!markedNodes.contains(n)) {\n                    markedNodes.add(n);\n                    // markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>())); // this line would be in real code\n                    count++;\n                }\n            }\n\n            return count;\n        }\n        // ...\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node {\n    // A simple Node class may be needed for the test unless it's provided elsewhere.\n}\n\npublic class GraphTest {\n    private Graph graph;\n\n    @BeforeEach\n    public void setUp() {\n        // Initialize a new Graph object before each test\n        graph = new Graph();\n    }\n\n    @Test\n    public void countGraphsTest() {\n        // Assuming nodeList is a public field or has an addNode method.\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n        Node node4 = new Node();\n        Node isolatedNode = new Node();\n\n        // Suppose we add edges like this, or in another way if Graph has specific edge methods\n        // 1-2-3 is one graph, and 4 is another graph, isolatedNode is an isolated graph\n        graph.addNode(node1);\n        graph.addNode(node2);\n        graph.addNode(node3);\n        graph.addNode(node4);\n        graph.addNode(isolatedNode);\n        \n        // Connect nodes here if needed, for example:\n        // graph.connectNodes(node1, node2);\n        // graph.connectNodes(node2, node3);\n\n        int graphCount = graph.countGraphs(); \n\n        assertEquals(3, graphCount, \"Graph should contain exactly three separate graphs.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\n// Assume that a class Graph and a class Node exist in the same package\n// with the appropriate implementation.\n\npublic class GraphTest {\n\n    private Graph graph;\n\n    @BeforeEach\n    public void setUp() {\n        // Set up is done before each test\n        graph = new Graph();\n    }\n\n    @Test\n    public void countGraphsTest() {\n        // Assuming Graph has an addNode method to add nodes to nodeList\n        Node node1 = new Node(1);\n        graph.addNode(node1); // First graph\n        Node node2 = new Node(2);\n        graph.addNode(node2); // Second graph\n        Node node3 = new Node(3);\n        Node node4 = new Node(4);\n        Node node5 = new Node(5);\n        // Node 3, 4, and 5 form the third graph (assuming there's some connection added between them)\n        graph.addNode(node3);\n        graph.addNode(node4);\n        graph.addNode(node5);\n        // Assuming Graph has an addEdge method\n        graph.addEdge(node3, node4);\n        graph.addEdge(node4, node5);\n\n        // Should count 3 separate graphs\n        assertEquals(3, graph.countGraphs(), \"The count of graphs should be 3\");\n\n        // Testing an edge case with no nodes\n        graph = new Graph(); // Reset graph\n        assertEquals(0, graph.countGraphs(), \"The count of graphs should be 0 with no nodes\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GraphTest {\n    private Graph graph; // Assuming there is a Graph class which has countGraphs method\n\n    @BeforeEach\n    public void setup() {\n        graph = new Graph();\n        // Initialize the graph with nodes and edges if necessary\n        // e.g., graph.addNode(new Node(...));\n        // graph.addEdge(new Node(...), new Node(...));\n    }\n\n    @Test\n    public void countGraphsTest() {\n        // Test with no nodes\n        assertEquals(0, graph.countGraphs(), \"Graph should have 0 graphs without any nodes.\");\n\n        // Add nodes and potentially some edges to the graph for testing\n        Node node1 = new Node();\n        graph.addNode(node1);\n        // Test with one node with no edges (i.e., the node itself forms a graph)\n        assertEquals(1, graph.countGraphs(), \"Graph should have 1 graph with one node.\");\n\n        Node node2 = new Node();\n        Node node3 = new Node();\n        graph.addNode(node2);\n        graph.addNode(node3);\n\n        // Connect nodes if you are testing connected components\n        graph.addEdge(node1, node2);\n\n        // Test with multiple nodes with a single graph\n        assertEquals(1, graph.countGraphs(), \"Graph should have 1 graph with two connected nodes.\");\n\n        // Test with multiple nodes, more than one graph\n        // Since node3 is not connected to node1 or node2, there should be two graphs\n        assertEquals(2, graph.countGraphs(), \"Graph should have 2 separate graphs.\");\n\n        // Add more tests as necessary to cover different scenarios,\n        // such as fully connected graph, graph with loops, etc.\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node {\n    // Assuming there is a class Node defined here for the purpose of this testing.\n}\n\nclass Graph {\n    private List<Node> nodeList;\n    \n    // Assuming there is an implementation detail here for nodeList and a depthFirstSearch method.\n    \n    public Graph(List<Node> nodeList) {\n        this.nodeList = nodeList;\n    }\n\n    public int countGraphs() {\n        int count = 0;\n        Set<Node> markedNodes = new HashSet<Node>();\n\n        for (Node n : nodeList) {\n            if (!markedNodes.contains(n)) {\n                markedNodes.add(n);\n                markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n                count++;\n            }\n        }\n\n        return count;\n    }\n    \n    // Other methods such as depthFirstSearch would be here\n}\n\npublic class GraphTest {\n    \n    Graph graph;\n\n    @BeforeEach\n    public void setUp() {\n        // Setup the graph with nodes for the test, this may change based on the Node implementation and Graph's constructor\n        List<Node> nodeList = new ArrayList<>();\n        // Add nodes to nodeList that form one or more separate graphs\n        graph = new Graph(nodeList);\n        // Assume the graph initialization here\n    }\n\n    @Test\n    public void countGraphsTest() {\n        // Assert that countGraphs returns the correct number of separate graphs\n        // The expected number should match the number of separate graphs added to the nodeList during setup\n        int expected = <EXPECTED_NUMBER_OF_GRAPHS>;\n        int actual = graph.countGraphs();\n        assertEquals(expected, actual, \"The count of graphs should be equal to the expected number.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GraphTest {\n    private Graph graph;\n\n    @BeforeEach\n    public void setUp() {\n        // Assuming Graph class has a default constructor\n        graph = new Graph();\n        // Assuming we have a method addNode to add nodes to the graph\n        // Assuming Node is a class that is used to create new nodes\n    }\n\n    @Test\n    public void countGraphsTest() {\n        // Assume graph is empty initially and should have 0 connected components\n        assertEquals(0, graph.countGraphs());\n\n        // Add first node, should result in one graph\n        Node node1 = new Node();\n        graph.addNode(node1);\n        assertEquals(1, graph.countGraphs());\n\n        // Add a second disconnected node, should increase graph count\n        Node node2 = new Node();\n        graph.addNode(node2);\n        assertEquals(2, graph.countGraphs());\n\n        // Connect node1 and node2, should decrease graph count as they are part of the same graph\n        // Assuming connectNodes is a method that takes two nodes and connects them\n        graph.connectNodes(node1, node2);\n        assertEquals(1, graph.countGraphs());\n\n        // Add another disconnected node, should result in two separate graphs\n        Node node3 = new Node();\n        graph.addNode(node3);\n        assertEquals(2, graph.countGraphs());\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Clean up resources, if necessary\n        graph = null;\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GraphTest {\n\n    @Test\n    public void countGraphsTest() {\n        // Set up an instance of Graph and populate it\n        Graph graph = new Graph();\n        // Assuming Graph has methods like addNode/Edge to construct the graph.\n\n        // We will set up two disconnected sets of nodes (assuming these methods exist)\n        // This could vary greatly depending on the actual implementation of the Graph class\n        Node node1 = new Node(1);\n        Node node2 = new Node(2);\n        Node node3 = new Node(3);\n        Node node4 = new Node(4);\n        \n        graph.addNode(node1);\n        graph.addNode(node2);\n        graph.addNode(node3);\n        graph.addNode(node4);\n        \n        graph.addEdge(node1, node2); // First graph\n        \n        // Node 3 and 4 are not connected to nodes 1 and 2, they form separate graphs.\n        \n        // Act\n        int graphCount = graph.countGraphs();\n        \n        // Assert\n        assertEquals(3, graphCount, \"Graph should have 3 separate graphs\");\n    }\n}"
    ]
}