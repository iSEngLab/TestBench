{
    "project_name": "Java",
    "file_name": "KahnsAlgorithm.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/KahnsAlgorithm.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.graphs",
    "docstring": "/**\n     * Returns an ArrayList with vertices arranged in topological order\n     */",
    "source_code": "\nArrayList<E> topSortOrder() {\n    calculateInDegree();\n    Queue<E> q = new LinkedList<E>();\n\n    for (E vertex : inDegree.keySet()) {\n        if (inDegree.get(vertex) == 0) {\n            q.add(vertex);\n        }\n    }\n\n    ArrayList<E> answer = new ArrayList<>();\n\n    while (!q.isEmpty()) {\n        E current = q.poll();\n        answer.add(current);\n        for (E adjacent : graph.getAdjacents(current)) {\n            inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n            if (inDegree.get(adjacent) == 0) {\n                q.add(adjacent);\n            }\n        }\n    }\n\n    return answer;\n}\n",
    "class_name": "KahnsAlgorithm",
    "method_name": "topSortOrder",
    "arguments": [],
    "generate_test": [
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\n\npublic class KahnsAlgorithmTest {\n    private AdjacencyList<String> createTestGraph() {\n        AdjacencyList<String> graph = new AdjacencyList<>();\n        graph.addEdge(\"A\", \"C\");\n        graph.addEdge(\"B\", \"C\");\n        graph.addEdge(\"C\", \"E\");\n        graph.addEdge(\"D\", \"F\");\n        graph.addEdge(\"E\", \"H\");\n        graph.addEdge(\"E\", \"F\");\n        graph.addEdge(\"F\", \"G\");\n\n        return graph;\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        AdjacencyList<String> graph = createTestGraph();\n        TopologicalSort<String> topologicalSort = new TopologicalSort<>(graph);\n        ArrayList<String> expectedResult = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"D\", \"C\", \"E\", \"F\", \"G\", \"H\"));\n        ArrayList<String> actualResult = topologicalSort.topSortOrder();\n\n        // The order in topological sorting is not unique, so assert that the array contains all elements\n        assertEquals(expectedResult.size(), actualResult.size(), \"The topological sort does not return the expected number of vertices\");\n\n        for (String vertex : expectedResult) {\n            assertTrue(actualResult.contains(vertex), \"The topological sort result does not contain vertex: \" + vertex);\n        }\n\n        // To further check that the order satisfies the topological ordering, we can ensure that for each directed edge u -> v, u comes before v in the list\n        assertTrue(actualResult.indexOf(\"A\") < actualResult.indexOf(\"C\"), \"In topological ordering, A should come before C\");\n        assertTrue(actualResult.indexOf(\"B\") < actualResult.indexOf(\"C\"), \"In topological ordering, B should come before C\");\n        assertTrue(actualResult.indexOf(\"C\") < actualResult.indexOf(\"E\"), \"In topological ordering, C should come before E\");\n        assertTrue(actualResult.indexOf(\"D\") < actualResult.indexOf(\"F\"), \"In topological ordering, D should come before F\");\n        assertTrue(actualResult.indexOf(\"E\") < actualResult.indexOf(\"H\"), \"In topological ordering, E should come before H\");\n        assertTrue(actualResult.indexOf(\"E\") < actualResult.indexOf(\"F\"), \"In topological ordering, E should come before F\");\n        assertTrue(actualResult.indexOf(\"F\") < actualResult.indexOf(\"G\"), \"In topological ordering, F should come before G\");\n    }\n}\n",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n\n    private TopologicalSort<Character> topologicalSort;\n    private AdjacencyList<Character> adjacencyList;\n\n    @BeforeEach\n    public void setUp() {\n        // Set up a simple graph with a known topological sort\n        adjacencyList = new AdjacencyList<>();\n        adjacencyList.addEdge('A', 'C');\n        adjacencyList.addEdge('B', 'C');\n        adjacencyList.addEdge('B', 'D');\n        adjacencyList.addEdge('C', 'E');\n        adjacencyList.addEdge('D', 'F');\n        adjacencyList.addEdge('E', 'F');\n        adjacencyList.addEdge('F', 'G');\n        \n        topologicalSort = new TopologicalSort<>(adjacencyList);\n    }\n    \n    @Test\n    public void topSortOrderTest() {\n        // Call the topSortOrder to get the result\n        ArrayList<Character> sortedOrder = topologicalSort.topSortOrder();\n        \n        // Expected topological sort result\n        ArrayList<Character> expectedOrder = new ArrayList<>();\n        expectedOrder.add('A');\n        expectedOrder.add('B');\n        expectedOrder.add('C');\n        expectedOrder.add('D');\n        expectedOrder.add('E');\n        expectedOrder.add('F');\n        expectedOrder.add('G');\n        \n        // Assert that the returned topological sort order is correct\n        assertEquals(expectedOrder, sortedOrder, \"The topological sort order is not as expected\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n\n    @Test\n    public void topSortOrderTest() {\n        // Create an instance of an adjacency list graph with integers\n        AdjacencyList<Integer> graph = new AdjacencyList<>();\n\n        // Add edges to represent a directed acyclic graph (DAG)\n        graph.addEdge(5, 2);\n        graph.addEdge(5, 0);\n        graph.addEdge(4, 0);\n        graph.addEdge(4, 1);\n        graph.addEdge(2, 3);\n        graph.addEdge(3, 1);\n\n        // Create a TopologicalSort instance with the DAG\n        TopologicalSort<Integer> topologicalSort = new TopologicalSort<>(graph);\n\n        // Run the topSortOrder method\n        ArrayList<Integer> result = topologicalSort.topSortOrder();\n\n        // Expected topological order result, one possible result could be {5, 4, 2, 3, 1, 0}\n        // Due to the nature of graphs, there could be multiple valid topological sorts.\n        // To test successfully, you can consider checking the validity of the topological sort\n        // instead of a specific expected order, or adapt the test if you are certain of the expected output.\n\n        // Test length first\n        assertEquals(6, result.size(), \"Topological sort result should have 6 vertices.\");\n\n        // Then test the validity of the topological sort\n        // The topological sort must satisfy that for every directed edge u -> v, u comes before v in the ordering\n        assertTrue(result.indexOf(5) < result.indexOf(2), \"Vertex 5 should come before Vertex 2.\");\n        assertTrue(result.indexOf(5) < result.indexOf(0), \"Vertex 5 should come before Vertex 0.\");\n        assertTrue(result.indexOf(4) < result.indexOf(0), \"Vertex 4 should come before Vertex 0.\");\n        assertTrue(result.indexOf(4) < result.indexOf(1), \"Vertex 4 should come before Vertex 1.\");\n        assertTrue(result.indexOf(2) < result.indexOf(3), \"Vertex 2 should come before Vertex 3.\");\n        assertTrue(result.indexOf(3) < result.indexOf(1), \"Vertex 3 should come before Vertex 1.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n\n    @Test\n    public void topSortOrderTest() {\n        // GIVEN: A directed acyclic graph (DAG)\n        AdjacencyList<String> graph = new AdjacencyList<>();\n        graph.addEdge(\"5\", \"2\");\n        graph.addEdge(\"5\", \"0\");\n        graph.addEdge(\"4\", \"0\");\n        graph.addEdge(\"4\", \"1\");\n        graph.addEdge(\"2\", \"3\");\n        graph.addEdge(\"3\", \"1\");\n\n        // WHEN: Applying topological sort using Kahn's Algorithm\n        TopologicalSort<String> topSort = new TopologicalSort<>(graph);\n        ArrayList<String> result = topSort.topSortOrder();\n\n        // THEN: The result should be a valid topological ordering\n        ArrayList<String> expectedResult = new ArrayList<>();\n        expectedResult.add(\"5\");\n        expectedResult.add(\"4\");\n        expectedResult.add(\"2\");\n        expectedResult.add(\"3\");\n        expectedResult.add(\"1\");\n        expectedResult.add(\"0\");\n\n        // Since there may be multiple valid topological orderings,\n        // the specific expected result depends on the implementation details.\n        // For this test, we are assuming one such valid ordering, as defined above.\n        \n        assertEquals(expectedResult, result);\n        \n        // Additionally, we can check if the result meets the criteria for valid topological ordering\n        // A valid topological order should have all vertices and for every directed edge uv,\n        // u should come before v in the ordering.\n        assertNotNull(result);\n        assertEquals(6, result.size());\n        assertTrue(result.indexOf(\"5\") < result.indexOf(\"2\"));\n        assertTrue(result.indexOf(\"5\") < result.indexOf(\"0\"));\n        assertTrue(result.indexOf(\"4\") < result.indexOf(\"0\"));\n        assertTrue(result.indexOf(\"4\") < result.indexOf(\"1\"));\n        assertTrue(result.indexOf(\"2\") < result.indexOf(\"3\"));\n        assertTrue(result.indexOf(\"3\") < result.indexOf(\"1\"));\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\n\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n  \n    private AdjacencyList<Character> graph;\n    private TopologicalSort<Character> topologicalSort;\n\n    @BeforeEach\n    public void setUp() {\n        graph = new AdjacencyList<>();\n        graph.addEdge('A', 'C');\n        graph.addEdge('B', 'C');\n        graph.addEdge('B', 'D');\n        graph.addEdge('C', 'E');\n        graph.addEdge('E', 'F');\n        graph.addEdge('D', 'F');\n        topologicalSort = new TopologicalSort<>(graph);\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<Character> expectedResult = new ArrayList<>(\n                Arrays.asList('A', 'B', 'C', 'D', 'E', 'F')\n        );\n\n        topologicalSort.calculateInDegree();\n        ArrayList<Character> actualResult = topologicalSort.topSortOrder();\n\n        assertNotNull(actualResult, \"Top Sort result should not be null\");\n        assertEquals(expectedResult.size(), actualResult.size(), \"Top Sort result should have the same size as expected\");\n        assertArrayEquals(expectedResult.toArray(), actualResult.toArray(), \"Top Sort should return the correct order\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n    \n    @Test\n    public void topSortOrderTest() {\n        // Initialize AdjacencyList with Character edges for simplicity\n        AdjacencyList<Character> graph = new AdjacencyList<>();\n        graph.addEdge('A', 'C');\n        graph.addEdge('B', 'C');\n        graph.addEdge('C', 'D');\n        \n        // Create an instance of the TopologicalSort class\n        TopologicalSort<Character> topologicalSort = new TopologicalSort<>(graph);\n        \n        // List to hold expected sort result, should be consistent with the edge relations\n        ArrayList<Character> expectedSortOrder = new ArrayList<>();\n        expectedSortOrder.add('A');\n        expectedSortOrder.add('B');\n        expectedSortOrder.add('C');\n        expectedSortOrder.add('D');\n        \n        // Perform topological sort using KahnsAlgorithm and get the sort result\n        ArrayList<Character> actualTopSortOrder = topologicalSort.topSortOrder();\n        \n        // Check if the two lists are equal\n        assertEquals(expectedSortOrder, actualTopSortOrder, \"The topologically sorted order does not match the expected order.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n    \n    private TopologicalSort<String> topSort;\n    private AdjacencyList<String> graph;\n\n    @BeforeEach\n    public void setUp() {\n        graph = new AdjacencyList<>();\n        graph.addEdge(\"a\", \"d\");\n        graph.addEdge(\"f\", \"b\");\n        graph.addEdge(\"b\", \"d\");\n        graph.addEdge(\"f\", \"a\");\n        graph.addEdge(\"d\", \"c\");\n        topSort = new TopologicalSort<>(graph);\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        topSort.calculateInDegree();\n        ArrayList<String> result = topSort.topSortOrder();\n        \n        ArrayList<String> expectedOrder = new ArrayList<>();\n        expectedOrder.add(\"f\");\n        expectedOrder.add(\"b\");\n        expectedOrder.add(\"a\");\n        expectedOrder.add(\"d\");\n        expectedOrder.add(\"c\");\n\n        assertEquals(expectedOrder, result, \"The topological sort did not return the expected order.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n    @Test\n    public void topSortOrderTest() {\n        // Assuming `E` stands for Integer for simplicity, it should be a generic type\n        AdjacencyList<Integer> graph = new AdjacencyList<>();\n        TopologicalSort<Integer> sorter = new TopologicalSort<>(graph);\n\n        // Construct a simple DAG\n        // A-->B-->C\n        graph.addEdge(1, 2); // A to B\n        graph.addEdge(2, 3); // B to C\n\n        sorter.calculateInDegree();\n\n        ArrayList<Integer> sorted = sorter.topSortOrder();\n        ArrayList<Integer> expected = new ArrayList<>();\n        expected.add(1); // A\n        expected.add(2); // B\n        expected.add(3); // C\n\n        // Check the topological order\n        assertEquals(expected, sorted, \"The topological sort order is not as expected\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\n// Import statements for junit and other relevant classes\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n\n    @Test\n    public void topSortOrderTest() {\n        // Create a mock graph from the AdjacencyList\n        AdjacencyList<String> graph = new AdjacencyList<>();\n        graph.addEdge(\"A\", \"C\");\n        graph.addEdge(\"B\", \"C\");\n        graph.addEdge(\"C\", \"D\");\n        graph.addEdge(\"C\", \"E\");\n\n        // Create the TopologicalSort object with the mock graph\n        TopologicalSort<String> topologicalSort = new TopologicalSort<>(graph);\n\n        // Call the method to test\n        ArrayList<String> sortedOrder = topologicalSort.topSortOrder();\n\n        // Validate the topSortOrder. Assuming we know the correct order.\n        // The correct order should be either A, B, C, D, E or B, A, C, D, E\n        // Since A and B don't depend on each other.\n        ArrayList<String> expectedOrder1 = new ArrayList<>();\n        expectedOrder1.add(\"A\");\n        expectedOrder1.add(\"B\");\n        expectedOrder1.add(\"C\");\n        expectedOrder1.add(\"D\");\n        expectedOrder1.add(\"E\");\n\n        ArrayList<String> expectedOrder2 = new ArrayList<>();\n        expectedOrder2.add(\"B\");\n        expectedOrder2.add(\"A\");\n        expectedOrder2.add(\"C\");\n        expectedOrder2.add(\"D\");\n        expectedOrder2.add(\"E\");\n\n        assertTrue(sortedOrder.equals(expectedOrder1) || sortedOrder.equals(expectedOrder2),\n                \"The topological sort order is incorrect.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n    @Test\n    public void topSortOrderTest() {\n        // Create a graph for the test\n        AdjacencyList<Integer> adjacencyList = new AdjacencyList<>();\n        // Build the graph by adding edges\n        adjacencyList.addEdge(5, 0);\n        adjacencyList.addEdge(5, 2);\n        adjacencyList.addEdge(4, 0);\n        adjacencyList.addEdge(4, 1);\n        adjacencyList.addEdge(2, 3);\n        adjacencyList.addEdge(3, 1);\n        \n        // Create an instance of TopologicalSort class with the graph created\n        TopologicalSort<Integer> topologicalSort = new TopologicalSort<>(adjacencyList);\n        \n        // Get the topological order of the graph\n        ArrayList<Integer> topSortOrder = topologicalSort.topSortOrder();\n        \n        // Expected topological order\n        // Note: There can be multiple valid topological orders for a graph\n        // The test assumes the above graph has the only valid topological sort order\n        ArrayList<Integer> expectedOrder = new ArrayList<>();\n        expectedOrder.add(5);\n        expectedOrder.add(4);\n        expectedOrder.add(2);\n        expectedOrder.add(3);\n        expectedOrder.add(1);\n        expectedOrder.add(0);\n        \n        // Assert that the actual topological order is the same as the expected one\n        assertEquals(expectedOrder, topSortOrder, \"The topological order is not as expected.\");\n    }\n}"
    ]
}