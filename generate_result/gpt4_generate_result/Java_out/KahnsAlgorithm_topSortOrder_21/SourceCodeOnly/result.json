{
    "project_name": "Java",
    "file_name": "KahnsAlgorithm.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/KahnsAlgorithm.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.graphs",
    "docstring": "/**\n     * Returns an ArrayList with vertices arranged in topological order\n     */",
    "source_code": "\nArrayList<E> topSortOrder() {\n    calculateInDegree();\n    Queue<E> q = new LinkedList<E>();\n\n    for (E vertex : inDegree.keySet()) {\n        if (inDegree.get(vertex) == 0) {\n            q.add(vertex);\n        }\n    }\n\n    ArrayList<E> answer = new ArrayList<>();\n\n    while (!q.isEmpty()) {\n        E current = q.poll();\n        answer.add(current);\n        for (E adjacent : graph.getAdjacents(current)) {\n            inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n            if (inDegree.get(adjacent) == 0) {\n                q.add(adjacent);\n            }\n        }\n    }\n\n    return answer;\n}\n",
    "class_name": "KahnsAlgorithm",
    "method_name": "topSortOrder",
    "arguments": [],
    "generate_test": [
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass MockGraph<E> {\n    HashMap<E, Integer> inDegree = new HashMap<>();\n    HashMap<E, ArrayList<E>> graph = new HashMap<>();\n\n    public void addEdge(E from, E to) {\n        graph.computeIfAbsent(from, k -> new ArrayList<>()).add(to);\n        inDegree.putIfAbsent(from, 0);\n        inDegree.put(to, inDegree.getOrDefault(to, 0) + 1);\n    }\n\n    public ArrayList<E> getAdjacents(E vertex) {\n        return graph.getOrDefault(vertex, new ArrayList<>());\n    }\n}\n\npublic class KahnsAlgorithmTest {\n    MockGraph<String> mockGraph;\n    ArrayList<String> result;\n\n    @BeforeEach\n    public void setUp() {\n        mockGraph = new MockGraph<>();\n        mockGraph.addEdge(\"A\", \"C\");\n        mockGraph.addEdge(\"B\", \"C\");\n        mockGraph.addEdge(\"C\", \"D\");\n        mockGraph.addEdge(\"C\", \"E\");\n        mockGraph.addEdge(\"D\", \"F\");\n        mockGraph.addEdge(\"E\", \"F\");\n        result = new ArrayList<>();\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        result = mockGraph.topSortOrder();\n        ArrayList<String> expectedResult = new ArrayList<>();\n        expectedResult.add(\"A\");\n        expectedResult.add(\"B\");\n        expectedResult.add(\"C\");\n        expectedResult.add(\"D\");\n        expectedResult.add(\"E\");\n        expectedResult.add(\"F\");\n\n        assertNotNull(result); // check that the result is not null\n        assertEquals(expectedResult.size(), result.size()); // check they are the same size\n\n        // The exact order can vary, but it should satisfy the partial order defined by the edges\n        assertTrue(result.indexOf(\"A\") < result.indexOf(\"C\")); // A must come before C\n        assertTrue(result.indexOf(\"B\") < result.indexOf(\"C\")); // B must come before C\n        assertTrue(result.indexOf(\"C\") < result.indexOf(\"D\")); // C must come before D\n        assertTrue(result.indexOf(\"C\") < result.indexOf(\"E\")); // C must come before E\n        assertTrue(result.indexOf(\"D\") < result.indexOf(\"F\")); // D must come before F\n        assertTrue(result.indexOf(\"E\") < result.indexOf(\"F\")); // E must come before F\n    }\n\n    @AfterEach\n    public void tearDown() {\n        mockGraph = null;\n        result = null;\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class KahnsAlgorithmTest {\n\n    static class Graph<E> {\n        private HashMap<E, Integer> inDegree = new HashMap<>();\n        private HashMap<E, ArrayList<E>> graph = new HashMap<>();\n\n        public void addVertex(E vertex) {\n            graph.putIfAbsent(vertex, new ArrayList<>());\n            inDegree.putIfAbsent(vertex, 0);\n        }\n\n        public void addEdge(E from, E to) {\n            graph.get(from).add(to);\n            inDegree.put(to, inDegree.getOrDefault(to, 0) + 1);\n        }\n\n        public ArrayList<E> getAdjacents(E vertex) {\n            return graph.get(vertex);\n        }\n\n        private void calculateInDegree() {\n            // Presumed to be implemented previously. Mock here if necessary.\n        }\n\n        public ArrayList<E> topSortOrder() {\n            calculateInDegree();\n            Queue<E> q = new LinkedList<E>();\n\n            for (E vertex : inDegree.keySet()) {\n                if (inDegree.get(vertex) == 0) {\n                    q.add(vertex);\n                }\n            }\n\n            ArrayList<E> answer = new ArrayList<>();\n\n            while (!q.isEmpty()) {\n                E current = q.poll();\n                answer.add(current);\n                for (E adjacent : graph.getAdjacents(current)) {\n                    inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n                    if (inDegree.get(adjacent) == 0) {\n                        q.add(adjacent);\n                    }\n                }\n            }\n\n            return answer;\n        }\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        Graph<Character> graph = new Graph<>();\n        graph.addVertex('A');\n        graph.addVertex('B');\n        graph.addVertex('C');\n        graph.addVertex('D');\n        graph.addVertex('E');\n        \n        graph.addEdge('A', 'B');\n        graph.addEdge('B', 'C');\n        graph.addEdge('C', 'D');\n        graph.addEdge('A', 'D');\n        graph.addEdge('E', 'D');\n        \n        ArrayList<Character> sortOrder = graph.topSortOrder();\n        \n        assertEquals(5, sortOrder.size(), \"The sort order should include all vertices.\");\n        \n        // Check if the resultant array is a valid topological ordering.\n        // Since multiple valid topological sorts can exist, we might need a more intricate test to check validity.\n        // Here we just check if every vertex appears before its dependants.\n        assertTrue(sortOrder.indexOf('A') < sortOrder.indexOf('B'), \"'A' should come before 'B'\");\n        assertTrue(sortOrder.indexOf('B') < sortOrder.indexOf('C'), \"'B' should come before 'C'\");\n        assertTrue(sortOrder.indexOf('C') < sortOrder.indexOf('D'), \"'C' should come before 'D'\");\n        assertTrue(sortOrder.indexOf('A') < sortOrder.indexOf('D'), \"'A' should come before 'D'\");\n        assertTrue(sortOrder.indexOf('E') < sortOrder.indexOf('D'), \"'E' should come before 'D'\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n    private Graph<Character> graph;\n\n    @BeforeEach\n    public void setup() {\n        graph = new Graph<>();\n\n        // Set up a simple graph\n        // For example, a graph with vertices 'A' to 'E' with some edges\n        graph.addEdge('A', 'C');\n        graph.addEdge('B', 'C');\n        graph.addEdge('B', 'D');\n        graph.addEdge('C', 'E');\n        graph.addEdge('D', 'E');\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<Character> result = graph.topSortOrder();\n        \n        // Create an expected order list (this might vary based on the graph)\n        // Since topological sort is not unique, there can be multiple valid orders.\n        // For this example, let's assume one correct order is [\"B\", \"D\", \"A\", \"C\", \"E\"]\n        ArrayList<Character> expectedOrder = new ArrayList<>(Arrays.asList('B', 'D', 'A', 'C', 'E'));\n\n        // Validate the result\n        assertEquals(expectedOrder, result, \"The topological order is incorrect.\");\n    }\n\n    // Additional tests here if needed ...\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class KahnsAlgorithmTest {\n\n    private <YOUR_CLASS> graph;\n\n    @BeforeEach\n    public void setup() {\n        graph = new <YOUR_CLASS>();\n        // Assuming setupGraph and createInDegreeMap are methods to setup the graph and its inDegree map\n        graph.setupGraph(); \n        graph.createInDegreeMap();\n        // Add vertices and edges to the graph here, for example:\n        // graph.addEdge(\"A\", \"B\");\n        // graph.addEdge(\"A\", \"C\");\n        // graph.addEdge(\"B\", \"D\");\n        // graph.addEdge(\"C\", \"D\");\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<String> expectedOrder = new ArrayList<>(Arrays.asList(\"A\", \"B\", \"C\", \"D\"));\n        ArrayList<String> sortOrder = graph.topSortOrder();\n\n        assertNotNull(sortOrder, \"The sortOrder should not be null\");\n        assertEquals(expectedOrder.size(), sortOrder.size(), \"sortOrder should have the same size as expectedOrder\");\n        for (int i = 0; i < expectedOrder.size(); i++) {\n            assertEquals(expectedOrder.get(i), sortOrder.get(i), \"Elements should be sorted in the defined topological order\");\n        }\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class KahnsAlgorithmTest {\n\n    private HashMap<Character, Integer> inDegree = new HashMap<>();\n    private HashMap<Character, ArrayList<Character>> graph = new HashMap<>();\n\n    private void calculateInDegree() {\n        // Assuming this method correctly calculates in-degrees for each vertex\n    }\n\n    private ArrayList<Character> graphGetAdjacents(Character vertex) {\n        // Assuming this method retrieves the list of adjacent vertices correctly\n        return graph.getOrDefault(vertex, new ArrayList<>());\n    }\n\n    ArrayList<Character> topSortOrder() {\n        calculateInDegree();\n        Queue<Character> q = new LinkedList<Character>();\n\n        for (Character vertex : inDegree.keySet()) {\n            if (inDegree.get(vertex) == 0) {\n                q.add(vertex);\n            }\n        }\n\n        ArrayList<Character> answer = new ArrayList<>();\n\n        while (!q.isEmpty()) {\n            Character current = q.poll();\n            answer.add(current);\n            for (Character adjacent : graphGetAdjacents(current)) {\n                inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n                if (inDegree.get(adjacent) == 0) {\n                    q.add(adjacent);\n                }\n            }\n        }\n\n        return answer;\n    }\n\n    // Initialize graph with a test case\n    private void createGraph() {\n        // Reset the graph and inDegree map\n        graph.clear();\n        inDegree.clear();\n\n        // Assuming that this is a directed acyclic graph (DAG)\n        // Example vertices (A, B, C, D, ...)\n        graph.put('A', new ArrayList<Character>(List.of('B', 'C')));\n        graph.put('B', new ArrayList<Character>(List.of('D')));\n        graph.put('C', new ArrayList<Character>(List.of('D')));\n        graph.put('D', new ArrayList<Character>());\n\n        // Manually setting in-degrees\n        inDegree.put('A', 0);\n        inDegree.put('B', 1);\n        inDegree.put('C', 1);\n        inDegree.put('D', 2);\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        createGraph(); // Prepare the test graph\n        ArrayList<Character> sortOrder = topSortOrder();\n        ArrayList<Character> expectedOrder = new ArrayList<>(List.of('A', 'B', 'C', 'D'));\n        assertEquals(expectedOrder, sortOrder, \"The topological sort order should match the expected order.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class KahnsAlgorithmTest {\n\n    private AdjacencyList<Character> adjacencyList;\n\n    @BeforeEach\n    public void setUp() {\n        adjacencyList = new AdjacencyList<>();\n        // Assuming we have methods to add vertices and edges\n        adjacencyList.addVertex('A');\n        adjacencyList.addVertex('B');\n        adjacencyList.addVertex('C');\n        adjacencyList.addVertex('D');\n        // Assume 'D' has no incoming edges for simplicity\n        adjacencyList.addEdge('A', 'B');\n        adjacencyList.addEdge('B', 'C');\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<Character> expectedOrder = new ArrayList<>(Arrays.asList('D', 'A', 'B', 'C'));\n        ArrayList<Character> actualOrder = adjacencyList.topSortOrder();\n        assertEquals(expectedOrder, actualOrder, \"The topological sort order does not match the expected output.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class AdjacencyList<E> {\n\n    private HashMap<E, Integer> inDegree = new HashMap<>();\n    private HashMap<E, ArrayList<E>> graph = new HashMap<>();\n    \n    public ArrayList<E> topSortOrder() {\n        //... given code here ...\n    }\n    \n    // Assume we have methods to fill the graph and calculate in-degrees (not provided).\n\n    // Rest of the class definition...\n}\n\npublic class KahnsAlgorithmTest {\n\n    private AdjacencyList<Character> adjacencyList;\n\n    @BeforeEach\n    public void setUp() {\n        adjacencyList = new AdjacencyList<>();\n        // Assuming methods to setup the graph are called `addEdge` and `calculateInDegree()`\n        adjacencyList.addEdge('A', 'C'); // Sample edges to create a directed graph\n        adjacencyList.addEdge('B', 'C');\n        adjacencyList.addEdge('C', 'D');\n        adjacencyList.calculateInDegree();\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<Character> sortedOrder = adjacencyList.topSortOrder();\n        ArrayList<Character> expectedOrder = new ArrayList<>(Arrays.asList('A', 'B', 'C', 'D'));\n        assertTrue(expectedOrder.equals(sortedOrder), \"The topological order should match the expected order\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class KahnsAlgorithmTest {\n    \n    private Graph<Character> graph;\n\n    @BeforeEach\n    public void setUp() {\n        graph = new Graph<>();\n        // Assumption: Graph class has addEdge method and calculateInDegree is used as part of topSortOrder.\n        graph.addEdge('A', 'C');\n        graph.addEdge('B', 'C');\n        graph.addEdge('B', 'D');\n        graph.addEdge('C', 'E');\n        graph.addEdge('E', 'F');\n        graph.addEdge('D', 'F');\n        // ... add other edges as needed to form a directed acyclic graph.\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<Character> expectedOrder = new ArrayList<>(Arrays.asList('B', 'A', 'D', 'C', 'E', 'F'));\n        // This expectedOrder is based on the assumption of the graph edges provided in the setUp.\n        ArrayList<Character> actualOrder = graph.topSortOrder();\n        assertEquals(expectedOrder, actualOrder, \"Topological sort order should match the expected order.\");\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n\n    private AdjacencyList<Character> graph;\n\n    @BeforeEach\n    public void setUp() {\n        // Initialize the graph\n        graph = new AdjacencyList<Character>();\n        // Populate the graph with vertices and edges to form a DAG (Directed Acyclic Graph)\n        graph.addEdge('A', 'C');\n        graph.addEdge('B', 'C');\n        graph.addEdge('B', 'D');\n        graph.addEdge('C', 'E');\n        graph.addEdge('E', 'F');\n        graph.addEdge('D', 'F');\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<Character> expectedOrder = new ArrayList<>(Arrays.asList('A', 'B', 'C', 'D', 'E', 'F'));\n        ArrayList<Character> actualOrder = graph.topSortOrder();\n        assertEquals(expectedOrder, actualOrder);\n    }\n}",
        "package com.thealgorithms.datastructures.graphs;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class KahnsAlgorithmTest {\n\n    private AdjacencyList<Integer> graph;\n    private HashMap<Integer, Integer> inDegree;\n\n    @BeforeEach\n    public void setUp() {\n        graph = new AdjacencyList<>();\n        inDegree = new HashMap<>();\n\n        // Assuming the methods exist to set up the graph and in-degree map\n        // Here is a simplistic graph setup for demonstration purposes\n        graph.addVertex(1);\n        graph.addVertex(2);\n        graph.addVertex(3);\n        graph.addVertex(4);\n        graph.addVertex(5);\n        graph.addEdge(1, 2);\n        graph.addEdge(1, 3);\n        graph.addEdge(3, 4);\n        graph.addEdge(5, 2);\n        graph.addEdge(5, 3);\n\n        // Setting up in-degree for the vertices\n        inDegree.put(1, 0);\n        inDegree.put(2, 2);\n        inDegree.put(3, 2);\n        inDegree.put(4, 1);\n        inDegree.put(5, 0);\n        graph.setInDegree(inDegree); // Assuming we can set the in-degree map\n    }\n\n    @Test\n    public void topSortOrderTest() {\n        ArrayList<Integer> expectedResult = new ArrayList<>(Arrays.asList(1, 5, 2, 3, 4));\n        ArrayList<Integer> topSortResult = graph.topSortOrder();\n        assertEquals(expectedResult, topSortResult, \"The topSortOrder method does not return the expected topological sort order.\");\n    }\n}\n\n// Placeholder class names and methods for the purpose of the unit test\n// These would need to be replaced by the actual implementation in `AdjacencyList`\nclass AdjacencyList<E> {\n    public void addVertex(E vertex) { /* ... */ }\n    public void addEdge(E from, E to) { /* ... */ }\n    public void setInDegree(HashMap<E, Integer> inDegree) { /* ... */ }\n    public ArrayList<E> topSortOrder() { /* ... */ return null; }\n}"
    ]
}