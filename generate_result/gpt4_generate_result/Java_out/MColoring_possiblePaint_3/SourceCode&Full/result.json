{
    "project_name": "Java",
    "file_name": "MColoring.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": null,
    "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
    "class_name": "MColoring",
    "method_name": "possiblePaint",
    "arguments": [
        "ArrayList<Node> nodes",
        "int n",
        "int m"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Let's create a graph with 3 nodes and 2 colors available for painting\n        int n = 3; // Represents total nodes\n        int m = 2; // Represents total colors\n        ArrayList<Node> nodes = new ArrayList<>(n + 1);\n\n        // Initialize all nodes\n        for (int i = 0; i <= n; i++) {\n            nodes.add(new Node());\n        }\n\n        // Define the edges of the graph\n        // Assume we create a simple graph where node 1 is connected with node 2\n        // and node 2 is connected with node 3\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1); // Since it's an undirected graph\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n\n        // Check if painting is possible with given number of colors\n        int result = MColoring.possiblePaint(nodes, n, m);\n\n        // Assert that painting is possible with the given constraints (returns 1)\n        assertEquals(1, result, \"Painting is not possible with the given number of colors.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Prepare a simple graph with 3 nodes in a line (1-2-3)\n        ArrayList<Node> nodes = new ArrayList<Node>();\n        nodes.add(null); // Add dummy node to start the index at 1\n        for(int i = 1; i <= 3; i++) {\n            nodes.add(new Node());\n        }\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n\n        // Test a scenario where painting is possible with m colors\n        assertEquals(1, MColoring.possiblePaint(nodes, 3, 2), \"Painting is possible with 2 colors.\");\n\n        // Test a scenario where painting is not possible with m colors\n        assertEquals(0, MColoring.possiblePaint(nodes, 3, 1), \"Painting is not possible with 1 color.\");\n\n        // Prepare a graph with 4 nodes in a cycle (1-2-3-4-1)\n        nodes.add(new Node());\n        nodes.get(1).edges.add(4);\n        nodes.get(4).edges.add(1);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(3);\n\n        // Test a scenario where painting is possible with m colors on a cycle\n        assertEquals(1, MColoring.possiblePaint(nodes, 4, 3), \"Painting is possible with 3 colors on a cycle.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Prepare a small graph for testing (example only)\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n\n        // Create adjacency list (graph with 3 nodes)\n        nodes.add(new Node()); // Adding an extra node at index 0 to match the 1-based indexing\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n\n        // Connect nodes (1 -- 2 -- 3)\n        node1.edges.add(2); // Node 1 connected to Node 2\n        node2.edges.add(1); // Node 2 connected to Node 1\n        node2.edges.add(3); // Node 2 connected to Node 3\n        node3.edges.add(2); // Node 3 connected to Node 2\n\n        // Test cases\n        // Should return 1 since we can paint in such way that no two adjacent nodes have the same color\n        assertEquals(1, MColoring.possiblePaint(nodes, 3, 2), \"Should return 1 for m >= 2 with this graph\");\n        // Should return 0 since there are not enough colors to paint nodes in a way that no two adjacent nodes have the same color\n        assertEquals(0, MColoring.possiblePaint(nodes, 3, 1), \"Should return 0 for m < 2 with this graph\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n\n    @Test\n    public void possiblePaintTest() {\n        // Define the nodes and set up the graph\n        ArrayList<Node> nodes = new ArrayList<>();\n        int n = 3; // Number of nodes\n        int m = 2; // Maximum colors allowed\n\n        // Initialize the nodes\n        for (int i = 0; i < n + 1; i++) {\n            nodes.add(new Node());\n        }\n\n        // Create edges to simulate a graph\n        // Let's say we create a simple graph where:\n        // Node 1 is connected to Node 2,\n        // Node 2 is connected to Node 3,\n        // and Node 3 is connected to Node 1.\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n        nodes.get(3).edges.add(1);\n        nodes.get(1).edges.add(3);\n\n        // Perform the test for m colors. This should be possible.\n        assertEquals(1, MColoring.possiblePaint(nodes, n, m));\n\n        // Now testing the impossible scenario with fewer colors than required.\n        // If we decrease m to 1, it should return 0, since painting is not possible with only one color.\n        assertEquals(0, MColoring.possiblePaint(nodes, n, 1));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create an ArrayList of Nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n\n        // Adding nodes for our graph, n = 4\n        int n = 4;\n        for (int i = 0; i <= n; i++) {\n            nodes.add(new Node());\n        }\n\n        // Add edges to the nodes to create a graph\n        // Assume a simple graph, where Node 1 is connected\n        // to Node 2 and 3, and Node 2 is connected to Node 4.\n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(3);\n        nodes.get(2).edges.add(4);\n        nodes.get(3).edges.add(4);\n\n        // There are 4 nodes, and we create 2 scenarios to test\n        // 1. Test with sufficient number of colors, should return 1 (possible)\n        // 2. Test with insufficient number of colors, should return 0 (not possible)\n        \n        // Test with sufficient number of colors (m = 3)\n        assertEquals(1, MColoring.possiblePaint(nodes, n, 3));\n\n        // Test with insufficient number of colors (m = 1)\n        assertEquals(0, MColoring.possiblePaint(nodes, n, 1));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Preparing a simple graph with 3 nodes where a 2-coloring is possible\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(new Node()); // Adding a dummy Node at index 0, as the algorithm starts from index 1\n        for (int i = 1; i <= 3; i++) {\n            nodes.add(new Node());\n        }\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(3);\n\n        // Test case where painting is possible with 2 colors\n        int possible = MColoring.possiblePaint(nodes, 3, 2);\n        assertEquals(1, possible, \"Graph can be painted with 2 colors\");\n        \n        // Test case where painting is not possible with only 1 color due to the edges between the nodes\n        possible = MColoring.possiblePaint(nodes, 3, 1);\n        assertEquals(0, possible, \"Graph cannot be painted with 1 color\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n\n    @Test\n    public void possiblePaintTest() {\n        // Construct graph nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(null); // Add a null at index 0, so the index starts from 1\n        for (int i = 1; i <= 4; i++) {\n            nodes.add(new Node());\n        }\n\n        // Add edges for an undirected graph\n        // Connections: 1-2, 2-3, 3-4, 4-1\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(3);\n        nodes.get(4).edges.add(1);\n        nodes.get(1).edges.add(4);\n\n        // Test with m = 3 colors\n        int resultFor3Colors = MColoring.possiblePaint(nodes, 4, 3);\n        assertEquals(1, resultFor3Colors, \"Graph should be colored with 3 colors\");\n\n        // Test with m = 2 colors which should fail\n        int resultFor2Colors = MColoring.possiblePaint(nodes, 4, 2);\n        assertEquals(0, resultFor2Colors, \"Graph should not be colored with only 2 colors\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\n\npublic class MColoringTest {\n \n    @Test\n    public void possiblePaintTest() {\n        // Create an ArrayList of Nodes for the graph\n        ArrayList<Node> nodes = new ArrayList<Node>();\n\n        // Create several nodes for the graph\n        for (int i = 0; i <= 3; i++) {\n            nodes.add(new Node());\n        }\n\n        // Manually add edges to nodes to form a connected graph\n        // Assuming a graph like this:\n        // 1 -- 2\n        // |    |\n        // 4 -- 3 \n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(4);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(1);\n        nodes.get(4).edges.add(3);\n\n        // Execute the possiblePaint method with n nodes and m colors\n        int n = 4; // number of nodes\n        int m = 3; // max number of colors\n        \n        int result = MColoring.possiblePaint(nodes, n, m);\n\n        // This should pass if the graph can be painted with m colors where adjacent nodes are different.\n        assertEquals(1, result, \"The provided graph should be possible to paint with \" + m + \" colors.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Initialize nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i <= 3; i++) {\n            nodes.add(new Node());\n        }\n        \n        // Simulate the graph:\n        // Node 1 connects with Node 2 and 3\n        // Node 2 connects with Node 1 and 3\n        // Node 3 connects with Node 1 and 2\n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(3);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(1);\n        nodes.get(3).edges.add(2);\n\n        // Test cases\n        // When m (number of colors) is sufficient, should return 1\n        assertEquals(1, MColoring.possiblePaint(nodes, 3, 3));\n\n        // When m (number of colors) is not sufficient, should return 0\n        assertEquals(0, MColoring.possiblePaint(nodes, 3, 2));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n\n    // Helper method to create a graph with n nodes and no edges\n    private ArrayList<Node> createGraph(int n) {\n        ArrayList<Node> nodes = new ArrayList<>();\n        // Creating an empty list first as index 0 will not be used\n        nodes.add(new Node());\n        for (int i = 1; i <= n; i++) {\n            nodes.add(new Node());\n        }\n        return nodes;\n    }\n\n    // Helper method to add an undirected edge between two nodes\n    private void addEdge(ArrayList<Node> nodes, int from, int to) {\n        nodes.get(from).edges.add(to);\n        nodes.get(to).edges.add(from);\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        // Test scenario when painting is possible\n        int n = 3; // Number of nodes\n        int m = 2; // Number of colors available\n\n        // Creating the graph\n        ArrayList<Node> nodes = createGraph(n);\n        // Adding edges - forming a simple chain from 1-2-3\n        addEdge(nodes, 1, 2);\n        addEdge(nodes, 2, 3);\n\n        // Call the method under test\n        int result = MColoring.possiblePaint(nodes, n, m);\n\n        // Since we have 2 colors and 3 nodes in a non-cyclic graph, it's possible to paint.\n        assertEquals(1, result);\n\n        // Test scenario when painting is not possible\n        // Reset graph with same nodes and change edges to create a triangle\n        nodes = createGraph(n);\n        addEdge(nodes, 1, 2);\n        addEdge(nodes, 2, 3);\n        addEdge(nodes, 3, 1); // Adding edge to form a cycle (triangle)\n\n        // Call the method under test\n        result = MColoring.possiblePaint(nodes, n, m);\n\n        // With 2 colors, it's not possible to paint a triangle where each node has a different color\n        assertEquals(0, result);\n    }\n}"
    ]
}