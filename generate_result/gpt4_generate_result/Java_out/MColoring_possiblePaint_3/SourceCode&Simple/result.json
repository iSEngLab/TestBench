{
    "project_name": "Java",
    "file_name": "MColoring.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": null,
    "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
    "class_name": "MColoring",
    "method_name": "possiblePaint",
    "arguments": [
        "ArrayList<Node> nodes",
        "int n",
        "int m"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Node {\n    int color;\n    Set<Integer> edges;\n\n    Node() {\n        this.color = 1; // Assuming initial color is always 1\n        this.edges = new HashSet<>();\n    }\n}\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Setup the graph with sample nodes and edges\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(new Node()); // Node 0 (dummy, not used but needed to align the index)\n        \n        // Create node 1 and it's edges\n        Node node1 = new Node();\n        node1.edges.add(2); // Node 1 is connected to Node 2\n        \n        // Create node 2 and it's edges\n        Node node2 = new Node();\n        node2.edges.add(1); // Node 2 is connected back to Node 1\n        \n        nodes.add(node1);\n        nodes.add(node2);\n        \n        // Test the graph with 2 nodes and max 2 colors\n        int possible = MColoring.possiblePaint(nodes, 2, 2);\n        assertEquals(1, possible, \"Painting the graph with 2 colors should be possible\");\n        \n        // Add more nodes and edges for a more complex graph as needed\n        \n        // Test failure case with too few colors\n        // Assume we have a case where we know 2 colors are not enough\n        possible = MColoring.possiblePaint(nodes, 2, 1);\n        assertEquals(0, possible, \"Painting the graph with only 1 color should not be possible\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Setup nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i <= 4; i++) {  // Create 4 nodes (+1 for 1-based indexing)\n            Node node = new Node();\n            node.color = 1;\n            node.edges = new HashSet<>();\n            nodes.add(node);\n        }\n        \n        // Add edges to create a square with a diagonal line\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(3);\n        nodes.get(4).edges.add(1);\n        nodes.get(1).edges.add(4);\n        nodes.get(1).edges.add(3);  // Diagonal line\n        nodes.get(3).edges.add(1);\n\n        // Case 1: Test if possible to paint with 2 colours (expecting to fail)\n        int resultWithTwoColors = MColoring.possiblePaint(nodes, 4, 2);\n        assertEquals(0, resultWithTwoColors, \"Should return 0, as it's not possible to paint with 2 colors without adjacent colors clashing\");\n        \n        // Case 2: Test if possible to paint with 3 colours (expecting to succeed)\n        int resultWithThreeColors = MColoring.possiblePaint(nodes, 4, 3);\n        assertEquals(1, resultWithThreeColors, \"Should return 1, as it's possible to paint with 3 colors without adjacent colors clashing\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n\n    @Test\n    public void possiblePaintTest() {\n        // Initialize nodes and the graph structure\n        int n = 3; // number of nodes\n        int m = 3; // number of colors\n        ArrayList<Node> nodes = new ArrayList<>(n + 1);\n        \n        // Adding 0th node as dummy to use 1-based indexing\n        nodes.add(new Node());\n        \n        for (int i = 1; i <= n; i++) {\n            Node node = new Node();\n            node.color = 1; // Set initial color to 1 for all nodes\n            node.edges = new HashSet<>();\n            nodes.add(node);\n        }\n        \n        // Let's say our graph is a line: 1 - 2 - 3\n        // Adding edges to each node\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n        \n        // Call the method under test\n        int result = MColoring.possiblePaint(nodes, n, m);\n\n        // Assert that painting with m colors is possible\n        assertEquals(1, result, \"The graph should be paintable with m colors.\");\n\n        // Test with not enough colors\n        int mInsufficient = 2;\n\n        int resultInsufficient = MColoring.possiblePaint(nodes, n, mInsufficient);\n\n        // Assert that painting with insufficient number of colors is not possible\n        assertEquals(0, resultInsufficient, \"The graph should not be paintable with mInsufficient colors.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Initialize nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i <= 4; i++) {\n            nodes.add(new Node());\n            nodes.get(i).color = 1; // Let's assume initial color of all nodes is 1\n            nodes.get(i).edges = new HashSet<>();\n        }\n        \n        // Build a simple graph (assuming 1-indexed nodes)\n        // Node 1 with edges to 2 and 3\n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(3);\n        // Node 2 with edges to 1 and 4\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(4);\n        // Node 3 with edges to 1 and 4\n        nodes.get(3).edges.add(1);\n        nodes.get(3).edges.add(4);\n        // Node 4 with edges to 2 and 3\n        nodes.get(4).edges.add(2);\n        nodes.get(4).edges.add(3);\n\n        // Test case where painting is possible using 2 colors (m=2)\n        int result = MColoring.possiblePaint(nodes, 4, 2); // 4 nodes with max 2 colors\n        assertEquals(1, result, \"Painting with 2 colors should be possible\");\n\n        // Test case where painting is not possible\n        result = MColoring.possiblePaint(nodes, 4, 1); // 4 nodes with max 1 color\n        assertEquals(0, result, \"Painting with 1 color should not be possible\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Node initialization\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i <= 3; i++) { // 3 nodes, indexed from 1 to 3\n            nodes.add(new Node());\n            nodes.get(i).color = 1;\n            nodes.get(i).edges = new HashSet<>();\n        }\n        \n        // Simple graph connections (no cycles, all nodes separate)\n        // Node 1 with 2\n        nodes.get(1).edges.add(2);\n        // Node 2 with 3\n        nodes.get(2).edges.add(3);\n        // Node 3 with 1\n        nodes.get(3).edges.add(1);\n        \n        int n = 3; // Number of nodes\n        int m = 2; // Number of colors\n        \n        // Invoke possiblePaint to check if we can color the graph with given m colors\n        int result = MColoring.possiblePaint(nodes, n, m);\n        \n        // Assert that the paint is possible with 2 colors\n        assertEquals(1, result, \"The graph should be paintable with 2 colors\");\n        \n        // Testing with non-colorable scenario\n        m = 1; // Only 1 color\n        result = MColoring.possiblePaint(nodes, n, m);\n        \n        // Assert that with only 1 color, it's impossible to paint the graph\n        assertEquals(0, result, \"The graph should not be paintable with only 1 color\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        int n = 3; // number of nodes\n        int m = 3; // max number of colors allowed\n        ArrayList<Node> nodes = new ArrayList<>();\n\n        // Initialize nodes with their respective edges\n        // Assuming nodes start from index 1 for simplicity\n        nodes.add(null); // 0th index is unused\n        for (int i = 1; i <= n; i++) {\n            nodes.add(new Node());\n            nodes.get(i).color = 1; // Initial color set to 1\n            nodes.get(i).edges = new HashSet<>();\n        }\n\n        // Add edges for testing\n        // Example: A triangle where all nodes are connected with each other\n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(3);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(1);\n        nodes.get(3).edges.add(2);\n        \n        // Call the method with the test nodes\n        MColoring coloring = new MColoring();\n        int result = coloring.possiblePaint(nodes, n, m);\n\n        // Assert that the result is as expected\n        // In this case, the triangle graph can be colored with 3 different colors\n        assertEquals(1, result);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass Node {\n    int color;\n    Set<Integer> edges;\n    \n    public Node(int color) {\n        this.color = color;\n        this.edges = new HashSet<>();\n    }\n    \n    // Function to add edge from this node to another node\n    public void addEdge(int dest) {\n        this.edges.add(dest);\n    }\n}\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create a small graph with 3 nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(null); // Adding null for 0-index based array to make it 1-index based\n        \n        // Initialize three nodes with color 1\n        for (int i = 0; i < 3; i++) {\n            nodes.add(new Node(1));\n        }\n        \n        // Create a simple graph\n        // Node 1 is connected to Node 2 and Node 3\n        nodes.get(1).addEdge(2);\n        nodes.get(1).addEdge(3);\n        // Node 2 is connected to Node 1 only\n        nodes.get(2).addEdge(1);\n        // Node 3 is connected to Node 1 only\n        nodes.get(3).addEdge(1);\n        \n        // We test if it's possible to paint such a graph using no more than 3 colors\n        int result = MColoring.possiblePaint(nodes, 3, 3);\n        assertEquals(1, result); // Graph can be successfully colored with 3 colors\n\n        // Test with just 2 colors, which should fail due to the initial color being 1 for all nodes\n        int resultInsufficientColors = MColoring.possiblePaint(nodes, 3, 2);\n        assertEquals(0, resultInsufficientColors); // Graph cannot be successfully colored with 2 colors\n        \n        // Test scenario where no edges exist, which means any given number of colors should suffice as each node can be painted independently\n        ArrayList<Node> isolatedNodes = new ArrayList<>();\n        isolatedNodes.add(null); // Adding null for 0-index based array to make it 1-index based\n        for (int i = 0; i < 3; i++) {\n            isolatedNodes.add(new Node(1));\n        }\n        int resultNoEdges = MColoring.possiblePaint(isolatedNodes, 3, 1);\n        assertEquals(1, resultNoEdges); // Graph without edges can be colored with 1 color\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class MColoringTest {\n\n    @Test\n    public void possiblePaintTest() {\n        // Create an array list to hold the nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n\n        // Initialize nodes with some arbitrary colors and edges\n        // Assuming n=3 and m=2 for this test case\n        for (int i = 0; i <= 3; i++) {\n            nodes.add(new Node());\n        }\n\n        // Define colors and edges for 3 nodes\n        nodes.get(1).color = 1;\n        nodes.get(2).color = 1;\n        nodes.get(3).color = 1;\n\n        nodes.get(1).edges = new HashSet<>(Set.of(2, 3)); // Node 1 is connected to Node 2 and 3\n        nodes.get(2).edges = new HashSet<>(Set.of(1));    // Node 2 is connected to Node 1\n        nodes.get(3).edges = new HashSet<>(Set.of(1));    // Node 3 is connected to Node 1\n\n        // Run the method under test\n        int result = MColoring.possiblePaint(nodes, 3, 2);\n\n        // Assert the expected result\n        // Assuming the coloring is possible with the provided m=2 (max color),\n        // the test should expect a result of 1.\n        assertEquals(1, result, \"The paint function should return 1, indicating that coloring is possible with the given number of colors.\");\n    }\n}\n\nclass MColoring {\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        // Original method code...\n        return 0; // Placeholder, actual code is provided earlier\n    }\n}\n\nclass Node {\n    int color;\n    Set<Integer> edges;\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Node {\n    int color;\n    Set<Integer> edges;\n\n    public Node() {\n        this.color = 1; // Assuming default color is 1\n        this.edges = new HashSet<>();\n    }\n}\n\npublic class MColoringTest {\n\n    @Test\n    public void possiblePaintTest() {\n        // Initialize nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        // Add a dummy node for 1-based indexing according to source code\n        nodes.add(new Node()); \n        nodes.add(new Node());\n        nodes.add(new Node());\n        nodes.add(new Node());\n\n        // Add edges to the nodes to form a graph\n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(3);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(1);\n        nodes.get(3).edges.add(2);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(3);\n\n        int n = 4; // Number of nodes\n        int m = 3; // Number of colors\n\n        // Call the actual function we are testing\n        int result = MColoring.possiblePaint(nodes, n, m);\n\n        // Assert that with 3 colors, it's possible to paint the given graph\n        assertEquals(1, result);\n\n        // Change m to 2, which should not be enough for the given graph\n        m = 2;\n        result = MColoring.possiblePaint(nodes, n, m);\n        \n        // Assert that with only 2 colors, it's not possible to paint this graph\n        assertEquals(0, result);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\nclass Node {\n    int color;\n    HashSet<Integer> edges;\n\n    public Node() {\n        color = 1; // assuming the default color is 1 for all nodes\n        edges = new HashSet<>();\n    }\n}\n\npublic class MColoring {\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        // Original source code provided\n    }\n}\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Create nodes for the graph\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i <= 4; i++) { // Using 4 as an example graph size (nodes 0 to 4)\n            nodes.add(new Node());\n        }\n        \n        // Add edges (assuming undirected graph)\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(3);\n        \n        // Test with an appropriate number of colors (e.g., 3)\n        // Assuming n = 4, the number of actual nodes (not counting node 0),\n        // and m = 3, the number of colors\n        int result = MColoring.possiblePaint(nodes, 4, 3);\n        assertEquals(1, result, \"Should return 1 for a possible paint configuration\");\n        \n        // Now, test an impossible scenario with fewer colors\n        // Assuming m = 2, which is less than required\n        result = MColoring.possiblePaint(nodes, 4, 2);\n        assertEquals(0, result, \"Should return 0 for an impossible paint configuration\");\n    }\n}"
    ]
}