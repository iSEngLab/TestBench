{
    "project_name": "Java",
    "file_name": "MColoring.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": null,
    "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
    "class_name": "MColoring",
    "method_name": "possiblePaint",
    "arguments": [
        "ArrayList<Node> nodes",
        "int n",
        "int m"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\nclass Node {\n    int color;\n    ArrayList<Integer> edges;\n\n    Node(int color) {\n        this.color = color;\n        this.edges = new ArrayList<>();\n    }\n\n    void addEdge(int nodeIndex) {\n        edges.add(nodeIndex);\n    }\n}\n\npublic class MColoringTest {\n    @Test\n    public void possiblePaintTest() {\n        // Prepare test data with a mock graph structure\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(null); // Add dummy node at 0 to align indices at 1\n\n        // Create 4 nodes for the graph; add a dummy index at 0 for ease of understanding\n        for (int i = 1; i <= 4; i++) {\n            nodes.add(new Node(1));\n        }\n\n        // Set the color connections (graph edges)\n        nodes.get(1).addEdge(2);\n        nodes.get(1).addEdge(3);\n        nodes.get(2).addEdge(1);\n        nodes.get(2).addEdge(4);\n        nodes.get(3).addEdge(1);\n        nodes.get(3).addEdge(4);\n        nodes.get(4).addEdge(2);\n        nodes.get(4).addEdge(3);\n\n        int n = 4; // The number of nodes\n        int m = 3; // The maximum colors available\n\n        // Assert the expected behavior\n        // Assuming our graph is a bipartite graph where m colors are sufficient.\n        int result = possiblePaint(nodes, n, m);\n        assertEquals(1, result, \"The paint operation should be possible with given m colors.\");\n\n        // Test with insufficient number of colors; expect failure (0 return)\n        m = 1; // Insufficient colors\n        result = possiblePaint(nodes, n, m);\n        assertEquals(0, result, \"The paint operation should not be possible with insufficient m colors.\");\n    }\n\n    // Include the source code method here, due to its static nature.\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        // ... (implementation from the JAVA source code provided)\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class MColoringTest {\n\n    static class Node {\n        public int color;\n        public ArrayList<Integer> edges;\n\n        public Node(int color) {\n            this.color = color;\n            this.edges = new ArrayList<>();\n        }\n\n        public void addEdge(int node) {\n            edges.add(node);\n        }\n    }\n\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        // ... [JAVA Source Code above] ...\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        int n = 3; // Number of nodes\n        int m = 2; // Max number of colors\n\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(new Node(1)); // adding an initial empty node to align index with 1-based\n\n        // Initialize nodes with their color number 1\n        for (int i = 1; i <= n; i++) {\n            nodes.add(new Node(1));\n        }\n\n        // Add some edges to the nodes\n        nodes.get(1).addEdge(2);\n        nodes.get(2).addEdge(1);\n        nodes.get(2).addEdge(3);\n        nodes.get(3).addEdge(2);\n\n        // Test to see if it's possible to paint with the given M colors\n        int result = possiblePaint(nodes, n, m);\n        assertEquals(1, result, \"Should return 1 if painting is possible\");\n\n        // Adding an edge that makes painting impossible within M colors\n        nodes.get(1).addEdge(3);\n        nodes.get(3).addEdge(1);\n\n        // Test painting again, expecting it to fail now\n        result = possiblePaint(nodes, n, m);\n        assertEquals(0, result, \"Should return 0 if painting is not possible with M colors\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList; // Import required for ArrayList\nimport java.util.LinkedList; // Import required for LinkedList implementation of Queue\nimport java.util.Queue; // Import required for Queue\n\npublic class MColoringTest {\n\n    // Assuming that we have a Node class with an 'edges' list and a 'color' property.\n    static class Node {\n        ArrayList<Integer> edges;\n        int color;\n\n        public Node() {\n            edges = new ArrayList<>();\n            color = 1; // Assuming default color is 1 for all nodes.\n        }\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        // Let's create a simple test with 3 nodes, where node 1 connects to node 2\n        // and node 2 connects to node 3. Max allowed colors (m) will be 3.\n        int n = 3; // Number of nodes\n        int m = 3; // Max allowed colors\n        ArrayList<Node> nodes = new ArrayList<>();\n\n        // Note: nodes.get(0) will not be used because index starts from 1 based on the source code\n        nodes.add(new Node()); // Dummy node to fill index 0\n        for (int i = 1; i <= n; i++) {\n            nodes.add(new Node()); // Create node for each index\n        }\n\n        // Assume color for nodes are already 1 as specified in Node constructor\n\n        // Set up edges\n        nodes.get(1).edges.add(2); // Node 1 connects to Node 2\n        nodes.get(2).edges.add(3); // Node 2 connects to Node 3\n\n        // Now we are ready to test the possiblePaint method\n        int result = MColoringTest.possiblePaint(nodes, n, m);\n\n        // Since the colors will only increment as needed and not exceed the maximum of 3,\n        // the result should be 1 indicating the painting is possible.\n        assertEquals(1, result, \"The paint function should return 1 if painting is possible within the given color range.\");\n    }\n\n    // We define the static possiblePaint method under the MColoringTest class for simplicity\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        // ... (rest of the source code remains the same as in the original JAVA Source Code) ...\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.Queue;\nimport java.util.LinkedList;\n\npublic class MColoringTest {\n\n    static class Node {\n        int color;\n        ArrayList<Integer> edges;\n\n        public Node() {\n            color = 1;\n            edges = new ArrayList<Integer>();\n        }\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        // Setup - create a graph with nodes and edges here\n        // This part would change according to how the Node class is expected to be used in your context.\n        ArrayList<Node> nodes = new ArrayList<Node>();\n        for (int i = 0; i <= 4; i++) {\n            nodes.add(new Node());\n        }\n\n        // connect the nodes - represent the graph\n        nodes.get(1).edges.add(2);\n        nodes.get(2).edges.add(1);\n        nodes.get(2).edges.add(3);\n        nodes.get(3).edges.add(2);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(3);\n\n        // Test with a case where it's possible to paint all nodes\n        // Here, we simulate a case for n nodes with m colors that should return 1 which means possible to paint\n        int result = MColoringTest.possiblePaint(nodes, 4, 3);\n        assertEquals(1, result);\n\n        // Test with a case where it is not possible to paint all nodes due to color limit\n        // Here, we simulate a case for n nodes with m too few colors that should return 0 which means not possible to paint\n        result = MColoringTest.possiblePaint(nodes, 4, 2);\n        assertEquals(0, result);\n    }\n\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        // The provided JAVA Source Code\n        // Create a visited array of n nodes\n        ArrayList<Integer> visited = new ArrayList<Integer>();\n        for (int i = 0; i < n + 1; i++) {\n            visited.add(0);\n        }\n\n        // maxColors used till now are 1 as\n        // all nodes are painted color 1\n        int maxColors = 1;\n\n        for (int sv = 1; sv <= n; sv++) {\n            if (visited.get(sv) > 0) {\n                continue;\n            }\n\n            // If the starting point is unvisited,\n            // mark it visited and push it in queue\n            visited.set(sv, 1);\n            Queue<Integer> q = new LinkedList<>();\n            q.add(sv);\n\n            // BFS\n            while (q.size() != 0) {\n                int top = q.peek();\n                q.remove();\n\n                // Checking all adjacent nodes\n                // to \"top\" edge in our queue\n                for (int it : nodes.get(top).edges) {\n\n                    // If the color of the\n                    // adjacent node is same, increase it by\n                    // 1\n                    if (nodes.get(top).color == nodes.get(it).color) {\n                        nodes.get(it).color += 1;\n                    }\n\n                    // If number of colors used exceeds m,\n                    // return 0\n                    maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                    if (maxColors > m) return 0;\n\n                    // If the adjacent node is not visited,\n                    // mark it visited and push it in queue\n                    if (visited.get(it) == 0) {\n                        visited.set(it, 1);\n                        q.add(it);\n                    }\n                }\n            }\n        }\n        return 1;\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node {\n    int color;\n    List<Integer> edges;\n\n    public Node() {\n        color = 1; // Assuming default color is 1\n        edges = new ArrayList<>();\n    }\n\n    public void addEdge(int nodeIndex) {\n        edges.add(nodeIndex);\n    }\n}\n\npublic class MColoringTest {\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        // The source code provided here is the same as the one from the instruction.\n        // ...\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        // Create nodes\n        ArrayList<Node> nodes = new ArrayList<>();\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n        Node node4 = new Node();\n\n        // Adding nodes to the list\n        nodes.add(new Node()); // Placeholder for 0-index which is not used.\n        nodes.add(node1);\n        nodes.add(node2);\n        nodes.add(node3);\n        nodes.add(node4);\n\n        // Adding edges to the nodes\n        node1.addEdge(2);\n        node2.addEdge(1);\n        node2.addEdge(3);\n        node3.addEdge(2);\n        node3.addEdge(4);\n        node4.addEdge(3);\n\n        int n = 4; // Number of nodes\n        int m = 3; // Maximum colors\n\n        // Call the method under test\n        int result = possiblePaint(nodes, n, m);\n\n        // Assert expected results\n        assertEquals(1, result, \"Algorithm should return that painting is possible.\");\n\n        // Add additional test cases as needed with varying n, m, and graph structures\n        // For example, an impossible case with m=2 could be here\n        // and you assert the result is 0.\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class MColoringTest {\n\n    // Helper method to construct nodes with edges\n    private ArrayList<Node> prepareGraph(int[][] edges, int color, int n) {\n        ArrayList<Node> nodes = new ArrayList<>();\n        for (int i = 0; i <= n; i++) { // assuming node numbering starts at 1\n            nodes.add(new Node(color)); // All nodes initially with the same color\n        }\n        for (int[] edge: edges) {\n            nodes.get(edge[0]).edges.add(edge[1]);\n            nodes.get(edge[1]).edges.add(edge[0]); // Assuming undirected graph\n        }\n        return nodes;\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        // Assuming that the method and the Node class is static and exists in the Main class\n        // Graph: 1 -- 2 -- 3 -- 4\n        int[][] edges = {\n            {1, 2}, {2, 3}, {3, 4}\n        };\n\n        ArrayList<Node> nodes = prepareGraph(edges, 1, 4);\n        int result = Main.possiblePaint(nodes, 4, 3);\n        // Should return 1 as it is possible to paint with 3 colors\n        assertEquals(1, result, \"Test failed for possible painting scenario.\");\n\n        // Change color of a node to make impossible to paint with 3 colors.\n        // Setting an edge case where during BFS, increasing color would lead to requiring more than m colors\n        nodes.get(3).edges.add(4); // self loop on node 3, making it impossible with 3 color limit\n        result = Main.possiblePaint(nodes, 4, 3);\n        // Should return 0 as it is not possible to paint with 3 colors because of the self loop\n        assertEquals(0, result, \"Test failed for impossible painting scenario.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class MColoringTest {\n\n    static class Node {\n        int color;\n        ArrayList<Integer> edges;\n\n        public Node() {\n            this.color = 1; // assuming default color is 1\n            this.edges = new ArrayList<>();\n        }\n\n        public void connect(Node other) {\n            this.edges.add(other.color); // or other identifier if not color\n        }\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        // Create nodes\n        Node node1 = new Node();\n        Node node2 = new Node();\n        Node node3 = new Node();\n        Node node4 = new Node();\n        \n        // Set edges (assuming a 0-indexed ArrayList)\n        node1.edges.addAll(Arrays.asList(2, 3)); // node1 connected to node2 and node3\n        node2.edges.addAll(Arrays.asList(1, 4)); // node2 connected to node1 and node4\n        node3.edges.addAll(Arrays.asList(1));    // node3 connected to node1\n        node4.edges.addAll(Arrays.asList(2));    // node4 connected to node2\n\n        // Set list of nodes\n        ArrayList<Node> nodes = new ArrayList<>(Arrays.asList(new Node(), node1, node2, node3, node4)); //adding a dummy node at index 0\n        \n        // Test 1: Verify that with 3 colors, the painting is possible\n        assertEquals(1, MColoringTest.possiblePaint(nodes, 4, 3), \"Painting with 3 colors should be possible\");\n\n        // Test 2: Verify that with only 2 colors, the painting is not possible\n        assertEquals(0, MColoringTest.possiblePaint(nodes, 4, 2), \"Painting with 2 colors should not be possible\");\n\n        // Assuming additional tests here for different graph configurations and color limitations...\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Node {\n    int color;\n    List<Integer> edges;\n    \n    Node() {\n        color = 1;\n        edges = new ArrayList<Integer>();\n    }\n}\n\npublic class MColoringTest {\n\n    @Test\n    public void possiblePaintTest() {\n        // Setup\n        int n = 4; // number of nodes\n        int m = 3; // number of colors available\n        ArrayList<Node> nodes = new ArrayList<>();\n        for(int i = 0; i <= n; i++) {\n            nodes.add(new Node()); // Initialize nodes with a color of 1\n        }\n\n        // Building the graph\n        // Define edges\n        // Let's assume a simple graph where node 1 is connected to node 2 and node 3,\n        // and node 3 is connected to node 4\n        nodes.get(1).edges.add(2);\n        nodes.get(1).edges.add(3);\n        nodes.get(2).edges.add(1);\n        nodes.get(3).edges.add(1);\n        nodes.get(3).edges.add(4);\n        nodes.get(4).edges.add(3);\n\n        // Act\n        int result = BacktrackingAlgorithms.possiblePaint(nodes, n, m);\n\n        // Assert\n        // Assuming the particular graph and the number of colors available are sufficient,\n        // The result should be 1 (possible to paint)\n        assertEquals(1, result, \"The graph should be possible to paint with m colors.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MColoringTest {\n  \n    static class Node {\n        int color;\n        ArrayList<Integer> edges;\n        \n        public Node(int color) {\n            this.color = color;\n            this.edges = new ArrayList<>();\n        }\n        \n        public void addEdge(int nodeIndex) {\n            edges.add(nodeIndex);\n        }\n    }\n\n    @Test\n    public void possiblePaintTest() {\n        ArrayList<Node> nodes = new ArrayList<>();\n        nodes.add(null);  // Adding null to align node indices with 1-based index\n        nodes.add(new Node(1)); // Node 1\n        nodes.add(new Node(1)); // Node 2\n        \n        nodes.get(1).addEdge(2); // Assuming a bidirectional edge between nodes 1 and 2\n        nodes.get(2).addEdge(1);\n                \n        assertEquals(1, MColoringTest.possiblePaint(nodes, 2, 2), \"Expected to be able to paint with 2 colors\");\n        nodes.get(2).color = 2; // Change color to simulate different setup\n        assertEquals(0, MColoringTest.possiblePaint(nodes, 2, 1), \"Expected to fail to paint with only 1 color\");\n    }\n    \n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n        //... original method implementation\n    }\n}",
        "public class Node {\n    ArrayList<Integer> edges;\n    int color;\n\n    public Node() {\n        edges = new ArrayList<>();\n        color = 1; // Assuming default color is 1 for all nodes.\n    }\n\n    public void addEdge(int vertex) {\n        edges.add(vertex);\n    }\n}"
    ]
}