{
    "project_name": "Java",
    "file_name": "MazeRecursion.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
    "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
    "class_name": "MazeRecursion",
    "method_name": "setWay",
    "arguments": [
        "int[][] map",
        "int i",
        "int j"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        // prepare the map\n        int[][] map = new int[8][7];\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // call the method\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        \n        // expected layout of map after calling setWay if a path is found\n        int[][] expectedMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 0, 0, 0, 0, 1},\n            {1, 2, 0, 0, 0, 0, 1},\n            {1, 1, 1, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 2, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // verify the result\n        assertTrue(result); // the method should return true if a path is found\n\n        // the map should be updated to reflect the path found by setWay method\n        assertArrayEquals(expectedMap, map);\n\n        // call the method with map filled with walls to test for no path case\n        int[][] noPathMap = new int[8][7];\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                noPathMap[i][j] = 1; // All walls, no path possible\n            }\n        }\n        boolean noPathResult = MazeRecursion.setWay(noPathMap, 1, 1);\n\n        // verify that the result is false as no path should be found\n        assertFalse(noPathResult);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        // Initialize our test map based on the context information\n        int[][] testMap = new int[8][7];\n        // Set the borders\n        for (int i = 0; i < 7; i++) {\n            testMap[0][i] = 1;\n            testMap[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            testMap[i][0] = 1;\n            testMap[i][6] = 1;\n        }\n        // Set obstacles\n        testMap[3][1] = 1;\n        testMap[3][2] = 1;\n\n        // Using setWay to find the path\n        boolean result = MazeRecursion.setWay(testMap, 1, 1);\n\n        // Assert that the path is found correctly\n        assertTrue(result);\n\n        // Validate that the path was marked correctly with 2's\n        // We only check the exit condition (6, 5) which is enough here\n        assertEquals(2, testMap[6][5]);\n\n        // Also, make sure the no-go areas are still marked as 1 (walls) and 3 (tried and failed)\n        // Check the walls\n        for (int i = 0; i < 7; i++) {\n            assertEquals(1, testMap[0][i]);\n            assertEquals(1, testMap[7][i]);\n        }\n        for (int i = 0; i < 8; i++) {\n            assertEquals(1, testMap[i][0]);\n            assertEquals(1, testMap[i][6]);\n        }\n        // Check the obstacle\n        assertEquals(1, testMap[3][1]);\n        assertEquals(1, testMap[3][2]);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Prepare a test maze map with known layout\n        int[][] map = new int[8][7];\n        // Initialize walls\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        // Initialize obstacles\n        map[3][1] = 1;\n        map[3][2] = 1;\n        \n        // Test a scenario where the path is achievable\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        assertTrue(result, \"The path should be found.\");\n        assertEquals(2, map[6][5], \"The endpoint should be marked as part of the path.\");\n\n        // Now test a scenario where the path is blocked, and there is no way to the endpoint\n        int[][] blockedMap = new int[8][7];\n        // Initialize walls\n        for (int i = 0; i < 7; i++) {\n            blockedMap[0][i] = 1;\n            blockedMap[7][i] = 1;\n            blockedMap[i][0] = 1;\n            blockedMap[i][6] = 1;\n        }\n        // Initialize obstacles\n        blockedMap[1][1] = 1; // Blocking the start position\n\n        result = MazeRecursion.setWay(blockedMap, 1, 1);\n        assertFalse(result, \"The path should not be found.\");\n        \n        // In this case, assert the state of the map after the algorithm has run,\n        // it should be unchanged since the start position was blocked.\n        for (int i = 0; i < blockedMap.length; i++) {\n            for (int j = 0; j < blockedMap[i].length; j++) {\n                if (i == 0 || i == 7 || j == 0 || j == 6) {\n                    assertEquals(1, blockedMap[i][j], \"Walls should remain as 1.\");\n                } else if (i == 1 && j == 1) {\n                    assertEquals(1, blockedMap[i][j], \"Blocked start position should remain as 1.\");\n                } else {\n                    assertEquals(0, blockedMap[i][j], \"Other paths should remain unvisited (0).\");\n                }\n            }\n        }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Create a maze map as per the context provided\n        int[][] map = new int[8][7];\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Test whether the ball can find its way to the endpoint (map[6][5])\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n\n        // The expected result should be true since the ball should find a way\n        assertTrue(result);\n\n        // Further checks can be made to see if the correct path is being marked with '2'\n        // For instance, the ball would initially move down from (1,1), so we expect (2,1) to be '2'\n        assertEquals(2, map[2][1]);\n\n        // Checking for the end point being reached\n        assertEquals(2, map[6][5]);\n        \n        // We can also check that the walls are still intact (not overwritten by the setWay method)\n        for (int i = 0; i < 7; i++) {\n            assertEquals(1, map[0][i]);\n            assertEquals(1, map[7][i]);\n        }\n        for (int i = 0; i < 8; i++) {\n            assertEquals(1, map[i][0]);\n            assertEquals(1, map[i][6]);\n        }\n        \n        // If additional assertions are needed for the entire path, these would depend on the specific implementation of setWay\n        // For a more thorough test, one could loop through all cells in the maze and verify that no '2's are next to walls or outside the valid path\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        // Initialize a maze with the same structure as described in the problem context\n        int[][] map = new int[8][7];\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        map[3][1] = 1;\n        map[3][2] = 1;\n        \n        // Test path finding starting from the entry point (1,1)\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        \n        // Assert that a path has been found\n        assertTrue(result);\n        \n        // Assert that the endpoint has been marked as part of the path\n        assertEquals(2, map[6][5]);\n        \n        // Additional assertions could check the correctness of the path marked by '2's\n        // and that there are no incorrect paths marked by '3's after the full path has been found.\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Create a map with the initial setup according to the context provided\n        int[][] map = new int[8][7];\n\n        // Set walls on borders\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Set some obstacles inside the maze\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n\n        // Expected map after running the setWay method\n        int[][] expectedMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 0, 0, 0, 0, 1},\n            {1, 2, 0, 0, 0, 0, 1},\n            {1, 1, 1, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 0, 0, 0, 2, 1},\n            {1, 0, 0, 0, 0, 2, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // Verify that the setWay method finds the correct path (result is true)\n        assertTrue(result, \"The setWay method should find a path to the destination.\");\n\n        // Verify that the maze has been updated correctly to reflect the path found\n        assertArrayEquals(expectedMap, map, \"The map should match the expected map layout with the path marked.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[8][7];\n        // Set walls\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Set some obstacles\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Use setWay method on the map starting from position (1,1)\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n\n        // Since we start from (1,1) and the exit is assumed at (6,5)\n        // and we have not set any obstacles that block the path completely,\n        // the result should be true, meaning a path is found\n        assertTrue(result, \"setWay should return true as a path exists\");\n\n        // Validate the path marked by '2's actually leads to the exit\n        assertEquals(2, map[6][5], \"The path should reach the exit\");\n\n        // Check if the path does not contains '0's which means all points are either visited or are walls\n        for (int i = 1; i < map.length - 1; i++) {\n            for (int j = 1; j < map[i].length - 1; j++) {\n                if (map[i][j] == 0) {\n                    fail(\"There should be no unvisited open space ('0') on the path found\");\n                }\n            }\n        }\n\n        // Optionally check that the path found is continuous and there are no isolated '2's\n        // For brevity, this part is not included here but could be added to make the test more robust\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\npublic class MazeRecursionTest {\n    \n    @Test\n    public void setWayTest() {\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 1, 1, 0, 0, 0, 1},\n            {1, 1, 1, 0, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 2, 1}, // The expected path ending\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // Check if the method finds the path\n        assertTrue(MazeRecursion.setWay(map, 1, 1)); // Start from the coordinate (1,1)\n\n        // Check if the method does not find the path when starting from a wall\n        assertFalse(MazeRecursion.setWay(map, 0, 0)); // Start from a wall (0,0)\n\n        // Modify the maze to have no exit\n        for (int i = 0; i < 7; i++) {\n            map[6][i] = 1;\n        }\n\n        // Check if the method returns false when there is no path\n        assertFalse(MazeRecursion.setWay(map, 1, 1)); // No exit from the maze\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[8][7];\n\n        // Initialize the map with walls\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Set obstacles\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Test that the setWay method returns true when a path is found\n        assertTrue(MazeRecursion.setWay(map, 1, 1), \"The path is not found when it should be.\");\n        \n        // Check the final state of the map to ensure the path (indicated by 2's) is created\n        int[][] expectedMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 2, 2, 2, 2, 1},\n            {1, 2, 3, 3, 3, 2, 1},\n            {1, 1, 1, 3, 2, 2, 1},\n            {1, 3, 3, 3, 3, 1, 1},\n            {1, 3, 2, 2, 2, 2, 1},\n            {1, 3, 3, 3, 3, 2, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n        };\n        assertArrayEquals(expectedMap, map, \"The map state after executing setWay is not as expected.\");\n\n        // Test that the setWay method returns false when no path is found\n        // Here, we add an obstacle to the exit to ensure the path is blocked\n        map[6][5] = 1;\n        assertFalse(MazeRecursion.setWay(map, 1, 1), \"A path is found when it should not be possible.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        // Initialize maze with the same configurations as provided in the source code\n        int[][] map = new int[8][7];\n        // Set walls\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n        // Set some obstacles\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Perform the test\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n\n        // Since the endpoint at [6][5] cannot be reached with the given obstacle setup,\n        // the expected result is false\n        assertFalse(result, \"The ball did not find a path\");\n\n        // Now, set a successful path for the ball to find its way to the endpoint at [6][5]\n        // Remove the obstacles\n        map[3][1] = 0;\n        map[3][2] = 0;\n        // Set additional paths\n        map[2][2] = 0;\n        map[2][3] = 0;\n        map[2][4] = 0;\n        map[3][4] = 0;\n        map[4][4] = 0;\n        map[5][4] = 0;\n        map[6][4] = 0;\n\n        // Perform the test again with a successful path\n        result = MazeRecursion.setWay(map, 1, 1);\n\n        // Now the expected result is true since the endpoint at [6][5] can be reached\n        assertTrue(result, \"The ball found a path to the endpoint\");\n        \n        // We can also check that the endpoint [6][5] has value 2 (i.e. part of the path)\n        assertEquals(2, map[6][5], \"The ball reached the endpoint at map[6][5]\");\n    }\n}"
    ]
}