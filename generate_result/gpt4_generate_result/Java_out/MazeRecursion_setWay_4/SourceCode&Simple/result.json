{
    "project_name": "Java",
    "file_name": "MazeRecursion.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
    "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
    "class_name": "MazeRecursion",
    "method_name": "setWay",
    "arguments": [
        "int[][] map",
        "int i",
        "int j"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    \n    @Test\n    public void setWayTest() {\n        // Given a maze represented by a 2D array\n        int[][] mazeMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n        \n        // When trying to find a way through maze starting from point (1,1)\n        boolean result = MazeRecursion.setWay(mazeMap, 1, 1);\n        \n        // Expected successful path finding (this example path is hardcoded based on the fact \n        // that setWay would return true when the location (6,5) is reached)\n        int[][] expectedMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 2, 2, 1, 2, 1},\n            {1, 2, 1, 2, 2, 2, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n        \n        // Then the path should be found\n        assertTrue(result);\n        \n        // And the map should have been marked with the path taken (denoted by 2s)\n        assertArrayEquals(expectedMap, mazeMap);\n        \n        // Case when no path is available\n        int[][] noPathMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n        \n        // When trying to find a way through a maze with no path available\n        boolean noPathResult = MazeRecursion.setWay(noPathMap, 1, 1);\n        \n        // Then no path should be found\n        assertFalse(noPathResult);\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = {\n                {1, 1, 1, 1, 1, 1, 1},\n                {1, 0, 0, 0, 1, 0, 1},\n                {1, 0, 1, 0, 0, 0, 1},\n                {1, 1, 1, 1, 1, 1, 1},\n                {1, 1, 1, 0, 0, 0, 1},\n                {1, 1, 1, 0, 1, 0, 1},\n                {1, 1, 1, 0, 2, 0, 1}\n        };\n        \n        // Test reaching the endpoint\n        assertTrue(MazeRecursion.setWay(map, 1, 1), \"The path to the endpoint should be found.\");\n\n        // Test on unwalkable path (wall)\n        assertFalse(MazeRecursion.setWay(map, 0, 0), \"The ball should not be able to pass through walls.\");\n\n        // Test when already on an endpoint\n        assertTrue(MazeRecursion.setWay(map, 6, 4), \"Being on the endpoint should return true.\");\n        \n        // Test going through a path with a dead end\n        map[3][3] = 0; // Creating a path and dead end\n        assertFalse(MazeRecursion.setWay(map, 1, 1), \"The ball should be unable to find a path when a dead end is present.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 2, 1},\n        };\n\n        // The ball should find its way to the endpoint (6, 5) here\n        assertTrue(MazeRecursion.setWay(map, 1, 1));\n\n        // Changing the endpoint to a wall (a value of 1) to make it inaccessible\n        map[6][5] = 1;\n\n        // The ball should not be able to find a path now\n        assertFalse(MazeRecursion.setWay(map, 1, 1));\n\n        // Try starting from a wall, expecting false as walls are not a valid starting point\n        assertFalse(MazeRecursion.setWay(map, 0, 0));\n\n        // Test a corner of the map which is a dead end\n        assertFalse(MazeRecursion.setWay(map, 1, 6));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 0, 1, 0, 0, 1},\n            {1, 1, 0, 0, 0, 1, 1},\n            {1, 1, 1, 1, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // Assuming the path starts at (1, 1) and the exit is at (5, 5) which is map[6][5]\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n\n        // Checking if entrance and exit are correctly set.\n        assertTrue(result, \"Path from entrance to exit should be found.\");\n\n        // Check that the exit is marked as part of the path in the maze (with value 2).\n        assertEquals(2, map[6][5], \"The exit should be marked as part of the path.\");\n\n        // Optional: Check if a certain position is part of the path, other than the exit\n        // This may vary depending on the maze structure and should be used to verify specific behaviors\n        // For example, check if [5][4] is part of the path, expecting a 2 or a 3.\n        assertTrue(map[5][4] == 2 || map[5][4] == 3, \"Position (5, 4) should be part of the path or a dead-end.\");\n\n        // Add more specific assertions if needed, for example, checking points along the path\n        // or verifying dead ends (points that should have been marked as 3 during backtrack)\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = { \n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 1, 0, 1},\n            {1, 0, 1, 0, 1, 0, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 2, 1}\n        };\n\n        // Starting at position (1,1)\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        assertTrue(result, \"The ball should find its path to the end.\");\n\n        // Additional assertions can be included to ensure that the path is correctly marked (value 2)\n        // and that no dead-ends are incorrectly marked (value 3)\n        // Consider using assertions like assertArrayEquals to check the entire map state if needed\n\n        // For example, to check if the specific path was found, assert like this (manual path marking):\n        int[][] expectedMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 2, 2, 2, 2, 1},\n            {1, 2, 1, 1, 1, 2, 1},\n            {1, 2, 1, 0, 1, 2, 1},\n            {1, 2, 1, 0, 1, 2, 1},\n            {1, 2, 2, 2, 2, 2, 1},\n            {1, 1, 1, 1, 1, 2, 1}\n        };\n\n        assertArrayEquals(expectedMap, map, \"The final map state should match the expected path.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = new int[7][6];\n        // Initialize map with walls (1) and paths (0)\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[0].length; j++) {\n                map[i][j] = 1; // initialize walls\n                if (i == 1 || i == 5 || (j == 1 && i != 2) || (j == 2 && i == 3) || (j == 4 && i > 2 && i < 6)) {\n                    map[i][j] = 0; // initialize paths\n                }\n            }\n        }\n        // Set the start position to be 2 as per source code logic\n        map[6][5] = 0;\n\n        // Test a successful path\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        assertTrue(result, \"The method should return true when a path is found.\");\n\n        // Check if the correct path is marked with 2's\n        int[][] expectedMap = new int[][]{\n                {1, 1, 1, 1, 1, 1},\n                {1, 2, 0, 0, 0, 1},\n                {1, 2, 1, 1, 2, 1},\n                {1, 2, 1, 1, 2, 1},\n                {1, 2, 2, 2, 2, 1},\n                {1, 1, 1, 1, 2, 1},\n                {1, 1, 1, 1, 2, 2}\n        };\n        assertArrayEquals(expectedMap, map, \"The map should have the path from the starting point to the destination marked with 2's.\");\n\n        // Test a failure path (initializing map with different configuration)\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[0].length; j++) {\n                map[i][j] = 1;\n                if ((i == 1 && j < 4) || (i == 2 && j == 1) || (i == 3 && j > 1 && j < 4) || (i == 4 && j == 3)) {\n                    map[i][j] = 0;\n                }\n            }\n        }\n\n        boolean resultNoPath = MazeRecursion.setWay(map, 1, 1);\n        assertFalse(resultNoPath, \"The method should return false when no path is found.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    \n    @Test\n    public void setWayTest() {\n        // Initialize a map for the test\n        int[][] map = new int[7][6];\n        \n        // Fill the map with '0's representing empty space where the ball can go through\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 6; j++) {\n                map[i][j] = 0;\n            }\n        }\n        \n        // Create obstacles by setting some cells to '1' to represent walls\n        // (Adjust these values according to the specific test case you want to create)\n        map[0][2] = 1;\n        map[1][2] = 1;\n        map[2][2] = 1;\n        map[3][2] = 1;\n        map[4][2] = 1;\n        // etc...\n\n        // Define the starting position (i, j) for the ball\n        int startI = 0;\n        int startJ = 0;\n\n        // Define the ending position\n        // Here, (6, 5) is mentioned in the provided source code as the endpoint\n        int endI = 6;\n        int endJ = 5;\n        \n        // Place the endpoint value as per the source code requirement\n        map[endI][endJ] = 2;\n\n        // Perform the test by calling the setWay function with the starting position\n        boolean result = MazeRecursion.setWay(map, startI, startJ);\n        \n        // Assert whether the path is found or not by checking the outcome\n        assertTrue(result, \"Path to the given endpoint should be found\");\n\n        // Additional checks can be added to validate map state after algorithm execution\n        // For example: Check if the path set by the solution contains '2's\n        assertTrue(map[endI][endJ] == 2, \"Path should be marked with '2's up to the endpoint\");\n\n        // if needed, print the map to visually assess the test\n        // for (int i = 0; i < map.length; i++) {\n        //     for (int j = 0; j < map[0].length; j++) {\n        //         System.out.print(map[i][j] + \" \");\n        //     }\n        //     System.out.println();\n        // }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // the ball will start from (1,1) and find its path to (6,5) which is already set to 2\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        assertTrue(result, \"The ball should find its path to the destination\");\n\n        // To make sure the path is correctly set, all '2's should be a continuous path\n        // from the start point to the destination without breaking any walls (1's).\n        // The actual path can be tested visually or via some more complex path validation logic.\n        // Also assuming that the rest of the map (externals) are walls (1's).\n        // However, for simplicity, this test case only asserts if the ball reached the destination.\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    \n    @Test\n    public void setWayTest() {\n        // Initialize the map array\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 1, 0, 1, 1, 0, 1},\n            {1, 1, 0, 0, 0, 2, 1},\n        };\n\n        // Execute the test case\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        \n        // Assert that the result is true as the path should find the destination at map[6][5].\n        assertTrue(result, \"The path should find its way to the destination\");\n\n        // Optional: You can include additional checks to make sure the path '2' leads to the correct goal.\n        assertEquals(2, map[6][5], \"The destination should be marked by '2'\");\n        \n        // Alternatively, to verify that the correct path is taken (filled with 2's), \n        // you could check the values in the 'map' array against the expected values\n        // if you have a known solution to the maze.\n\n        // Additional checks could be performed such as asserting that no other elements\n        // on the path from the start (1,1) to the end (6,5) have the value 3 - indicating no backtracking was necessary.\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Define the maze map, where 0 is an open path, and 1 is a wall\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 0, 1, 0, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // Starting point is (1,1), and the ending condition is that map[6][5] must be 2 (i.e., the path is found)\n        boolean pathFound = MazeRecursion.setWay(map, 1, 1);\n\n        // Assert that a path has been found\n        assertTrue(pathFound, \"A path should exist from the starting point to the end.\");\n\n        // Additionally, we could check if the correct path has been marked with 2\n        int[][] expectedMap = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 2, 2, 2, 2, 1},\n            {1, 2, 1, 1, 1, 2, 1},\n            {1, 2, 1, 0, 0, 2, 1},\n            {1, 2, 1, 0, 1, 1, 1},\n            {1, 2, 2, 2, 2, 2, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n        \n        // Using Assertions.assertArrayEquals to compare two-dimensional arrays\n        assertArrayEquals(expectedMap, map, \"The paths marked on the maze map do not match the expected result.\");\n    }\n}"
    ]
}