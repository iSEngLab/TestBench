{
    "project_name": "Java",
    "file_name": "MazeRecursion.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.backtracking",
    "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
    "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
    "class_name": "MazeRecursion",
    "method_name": "setWay",
    "arguments": [
        "int[][] map",
        "int i",
        "int j"
    ],
    "generate_test": [
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Assuming the size of the maze map is 7x6 as specified in the base condition (map[6][5])\n        // Initializes the map with zeros (0), where the ball has not gone through\n        int[][] map = new int[7][6];\n        \n        // Set initial and ending points (assuming the ball can only start at map[0][0])\n        map[0][0] = 2; // starting point\n        map[6][5] = 0; // ending point\n        \n        // Set some obstacles, represented by 1\n        map[1][0] = 1;\n        map[1][2] = 1;\n        map[1][3] = 1;\n        map[1][4] = 1;\n        map[3][2] = 1;\n        map[4][4] = 1;\n        map[5][1] = 1;\n        \n        // Expected outcome is for the ball to find a way to map[6][5]\n        // We modify the map accordingly for the path that should result in success\n        \n        // An example solution path might look like this (represented by 2):\n        // 2 0 0 0 0 0\n        // 1 2 1 1 1 0\n        // 0 2 2 2 0 0\n        // 0 0 1 2 2 0\n        // 0 0 0 0 1 0\n        // 0 1 0 0 2 2\n        // 0 0 0 0 0 2\n        // This example is one of the many possible solutions depending on the setup\n        \n        // Tests the success scenario\n        assertTrue(MazeRecursion.setWay(map, 0, 1), \"The ball should be able to find a way to the end point.\");\n        \n        // Check the final state of map for the expected path (2's marked) - Can be omitted if we're only testing for success/failure\n        int[][] expectedMap = {\n            {2, 0, 0, 0, 0, 0},\n            {1, 2, 1, 1, 1, 0},\n            {0, 2, 2, 2, 0, 0},\n            {0, 0, 1, 2, 2, 0},\n            {0, 0, 0, 0, 1, 0},\n            {0, 1, 0, 0, 2, 2},\n            {0, 0, 0, 0, 0, 2}\n        };\n        assertArrayEquals(expectedMap, map, \"The map should have a path of 2's from the start to the end point.\");\n        \n        // Tests scenario where no path is available\n        map[2][3] = 1; // Create a dead end by adding an obstacle\n        assertFalse(MazeRecursion.setWay(map, 0, 1), \"The ball should not be able to find a way to the end point.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Initialize the maze with walls (1) and open paths(0)\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 2, 1}\n        };\n\n        // Perform the test\n        boolean result = MazeRecursionTest.setWay(map, 1, 1);\n\n        // We expect the result to be true since there's a path to the destination (2)\n        assertTrue(result, \"The path to the destination should be found.\");\n\n        // Additionally, we can check if setWay correctly marks the path\n        assertEquals(2, map[1][1], \"The starting point should be part of the path.\");\n        assertEquals(2, map[6][5], \"The destination should be part of the path.\");\n\n        // Test with no possible path\n        int[][] mapNoPath = {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 0, 0, 1, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 2, 1}\n        };\n\n        // Perform the test for no path scenario\n        result = MazeRecursionTest.setWay(mapNoPath, 1, 1);\n\n        // We expect the result to be false since there's no path to the destination (2)\n        assertFalse(result, \"There should be no path to the destination.\");\n    }\n\n    // Utility method to execute setWay in the test class\n    public static boolean setWay(int[][] map, int i, int j) {\n        // Here we would paste the JAVA Source Code for setWay method\n        // [JAVA Source Code here]\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Here we create a sample map for testing. Number 1 represents a wall that cannot be crossed, \n        // while number 0 represents an open space where the ball can travel.\n        int[][] map = {\n                {1, 1, 1, 1, 1, 1, 1},\n                {1, 0, 0, 0, 0, 0, 1},\n                {1, 0, 1, 1, 1, 0, 1},\n                {1, 0, 1, 0, 1, 0, 1},\n                {1, 0, 1, 0, 0, 0, 1},\n                {1, 0, 1, 0, 1, 1, 1},\n                {1, 0, 0, 0, 0, 0, 1},\n                {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // Case: Starting at a point that results in successful path finding.\n        assertTrue(MazeRecursion.setWay(map, 1, 1), \"The path should be found successfully from point (1,1)\");\n\n        // Reset the map for a new test or alternatively create a new map array.\n        for (int i = 0; i < map.length; i++) {\n            for (int j = 0; j < map[0].length; j++) {\n                if (map[i][j] == 2 || map[i][j] == 3) {\n                    map[i][j] = 0;\n                }\n            }\n        }\n\n        // Case: Starting from a blocked point, expecting failure.\n        assertFalse(MazeRecursion.setWay(map, 2, 2), \"The path should not be found starting from a wall (2,2)\");\n\n        // Additional test cases could be written here to assert different scenarios, such as boundaries, already visited paths, etc.\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    private static final int MAZE_SIZE = 7;\n\n    @Test\n    public void setWayTest() {\n        // Initialize the map with all zeros\n        int[][] map = new int[MAZE_SIZE][MAZE_SIZE];\n        for (int[] row : map) {\n            java.util.Arrays.fill(row, 0);\n        }\n        \n        // Create barriers by setting some cells to 1\n        // As an example assuming barriers are around the perimeter except at the exit\n        for (int i = 0; i < MAZE_SIZE; i++) {\n            map[0][i] = map[MAZE_SIZE - 1][i] = 1; // Top and bottom rows\n            map[i][0] = map[i][MAZE_SIZE - 1] = 1; // Leftmost and rightmost columns\n        }\n\n        // Assume we know that position (6,5) is our path's endpoint and leave it as 0\n        map[6][5] = 0; // Ensure the endpoint is not a barrier\n\n        // Assume the start position is (1,1)\n        boolean result = MazeRecursionTest.setWay(map, 1, 1);\n\n        // Check if the correct path to the exit was found\n        assertTrue(result, \"The method should return true when a path to the exit is found.\");\n\n        // Additionally, could check if the correct path is marked with '2's and dead ends with '3's\n        // Here's an example of how you might check a known path:\n        // Path goes from (1,1) down to (5,1), then to right to (5,5)\n        for (int i = 1; i <= 5; i++) {\n            assertEquals(2, map[i][1], \"The path should be marked by '2's\");\n        }\n        for (int i = 2; i <= 5; i++) {\n            assertEquals(2, map[5][i], \"The path should be marked by '2's\");\n        }\n\n        // Check that (6,5) is reached by the path\n        assertEquals(2, map[6][5], \"The endpoint should be part of the path and marked by '2'\");\n\n        // Uncomment and adjust this part if you need to check for specific dead ends\n        /*\n        assertEquals(3, map[deadEndI][deadEndJ], \"Dead ends should be marked by '3's\");\n        */\n    }\n\n    // The setWay method should be declared here to be static, or alternatively it should be put in a separate class\n\n    public static boolean setWay(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball hasn't gone through this point\n            // then the ball follows the move strategy: down -> right -> up -> left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n\n            if (setWay(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // the current point is the dead end, the ball cannot proceed, set the current point to 3\n                map[i][j] = 3;\n                return false;\n            }\n        } else {\n            // if the map[i][j] != 0, it's a wall or a visited/dead-end cell\n            return false;\n        }\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Assuming map layout is such that 1 is obstacles, 0 is path, 2 is visited,\n        // and 6x5 is the goal.\n        int map[][] = {\n                { 1, 1, 1, 1, 1, 1, 1 },\n                { 1, 0, 0, 1, 0, 0, 1 },\n                { 1, 0, 0, 1, 1, 0, 1 },\n                { 1, 1, 1, 0, 1, 1, 1 },\n                { 1, 1, 1, 0, 0, 0, 1 },\n                { 1, 1, 1, 1, 1, 0, 1 },\n                { 1, 1, 1, 1, 1, 1, 1 }};\n\n        // Test the expected success path to the end\n        assertTrue(MazeRecursion.setWay(map, 1, 1));\n\n        // After a successful path, the goal should be marked as visited (2)\n        assertEquals(2, map[6][5]);\n        \n        // Test cases where it starts from an obstacle or already visited path\n        assertFalse(MazeRecursion.setWay(map, 1, 0));\n        assertFalse(MazeRecursion.setWay(map, 6, 5));\n        \n        // Test case where it starts right before the goal\n        int mapBeforeEnd[][] = {\n                { 1, 1, 1, 1, 1, 1, 1 },\n                { 1, 1, 1, 1, 1, 1, 1 },\n                { 1, 1, 1, 1, 1, 1, 1 },\n                { 1, 1, 1, 1, 1, 1, 1 },\n                { 1, 1, 1, 1, 1, 1, 1 },\n                { 1, 1, 1, 1, 1, 2, 1 },\n                { 1, 1, 1, 1, 1, 0, 1 }};\n                \n        assertTrue(MazeRecursion.setWay(mapBeforeEnd, 6, 5));\n        \n        // Test starting at dead end\n        int deadEndMap[][] = {\n                { 1, 1, 1, 1, 1, 1, 1 },\n                { 1, 0, 0, 1, 0, 0, 1 },\n                { 1, 0, 1, 1, 1, 0, 1 },\n                { 1, 0, 1, 0, 1, 1, 1 },\n                { 1, 0, 1, 0, 0, 1, 1 },\n                { 1, 0, 1, 1, 1, 1, 1 },\n                { 1, 0, 1, 1, 1, 1, 1 }};\n        \n        assertFalse(MazeRecursion.setWay(deadEndMap, 1, 1));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Example maze\n        int[][] map = {\n                {1, 1, 1, 1, 1, 1, 1},\n                {1, 0, 0, 0, 0, 0, 1},\n                {1, 0, 1, 1, 1, 0, 1},\n                {1, 0, 1, 0, 1, 0, 1},\n                {1, 0, 1, 0, 0, 0, 1},\n                {1, 0, 1, 1, 1, 0, 1},\n                {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        assertTrue(MazeRecursion.setWay(map, 1, 1)); // Assuming that the ball starts at position (1,1)\n\n        // The ball should be able to reach the destination, which implies that map[6][5] should be set to 2 if there's a path.\n        assertEquals(2, map[6][5]);\n\n        // Test the scenario where no path exists by blocking the path.\n        map[5][1] = 1;\n        assertFalse(MazeRecursion.setWay(map, 1, 1)); // Now the ball should not be able to reach the destination.\n\n        // Test the scenario where an invalid starting point is provided.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {\n            MazeRecursion.setWay(map, -1, -1); // Invalid starting point.\n        });\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    \n    @Test\n    public void setWayTest() {\n        // Given\n        // Initializing a map of all zeros (1 represents an obstacle)\n        int[][] map = {\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 1, 1, 1, 1, 1, 0},\n            {0, 0, 0, 0, 1, 0, 0},\n            {0, 1, 1, 0, 0, 0, 0},\n            {0, 1, 0, 1, 1, 1, 0},\n            {0, 0, 0, 0, 0, 0, 0},\n            {0, 1, 1, 1, 1, 2, 0} // destination point with a value of 2\n        };\n        \n        // When\n        // Test whether the ball can find its path and set it to `true`\n        boolean result = MazeRecursion.setWay(map, 1, 1);\n        \n        // Then\n        // Assert that the result is true - path is found\n        assertTrue(result, \"The ball did not find the correct path.\");\n        \n        // Now test the case where no path exists by setting an obstacle before the\n        // destination point, map[6][5], changing its value from 2 to 1.\n        map[6][5] = 1;\n        \n        // When\n        // Path cannot be found now, expecting `false`\n        result = MazeRecursion.setWay(map, 1, 1);\n        \n        // Then\n        // Assert that now the result is false - path is not found\n        assertFalse(result, \"The ball should not find a path because the destination is blocked.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        int[][] map = {\n            {1, 1, 1, 1, 1, 1, 1}, \n            {1, 0, 0, 0, 0, 0, 1}, \n            {1, 0, 1, 1, 1, 0, 1}, \n            {1, 0, 1, 0, 0, 0, 1}, \n            {1, 0, 1, 1, 1, 1, 1}, \n            {1, 0, 0, 0, 0, 0, 1}, \n            {1, 1, 1, 1, 1, 2, 1}\n        };\n        \n        // Correct path to true\n        assertTrue(MazeRecursion.setWay(map, 1, 1));\n\n        // Setting destination as wall turning into 1\n        map[6][5] = 1;\n        assertFalse(MazeRecursion.setWay(map, 1, 1));\n\n        // Setting destination unreachable\n        map = new int[][] {\n            {1, 1, 1, 1, 1, 1, 1}, \n            {1, 0, 0, 0, 1, 0, 1}, \n            {1, 0, 1, 1, 1, 0, 1}, \n            {1, 0, 1, 0, 1, 0, 1}, \n            {1, 0, 1, 1, 1, 1, 1}, \n            {1, 0, 0, 0, 0, 0, 1}, \n            {1, 1, 1, 1, 1, 2, 1}\n        };\n        assertFalse(MazeRecursion.setWay(map, 1, 1));\n\n        // Setting the starting position as wall (1)\n        map[1][1] = 1;\n        assertFalse(MazeRecursion.setWay(map, 1, 1));\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n\n    @Test\n    public void setWayTest() {\n        // Example map setup\n        int[][] map = new int[][] {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 0, 1, 0, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        // Test a successful case where the ball finds a path to map[6][5]\n        boolean result1 = MazeRecursion.setWay(map, 1, 1);\n        assertTrue(result1, \"The setWay method should return true, path found.\");\n\n        // Test map after finding the path\n        int[][] expectedMapAfterPathFound = new int[][] {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 2, 2, 2, 2, 2, 1},\n            {1, 0, 1, 1, 1, 2, 1},\n            {1, 0, 1, 0, 0, 2, 1},\n            {1, 0, 1, 0, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n        assertArrayEquals(expectedMapAfterPathFound, map, \"The map should reflect the path taken by setting positions to 2.\");\n\n        // Test a case with no possible path\n        int[][] mapWithNoPath = new int[][] {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 1, 0, 0, 0, 1},\n            {1, 0, 1, 1, 1, 0, 1},\n            {1, 0, 0, 0, 1, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n\n        boolean result2 = MazeRecursion.setWay(mapWithNoPath, 1, 1);\n        assertFalse(result2, \"The setWay method should return false, no path found.\");\n\n        // Test map after attempting to find a path in a map with no path\n        int[][] expectedMapAfterNoPathFound = new int[][] {\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 3, 1, 0, 0, 0, 1},\n            {1, 3, 1, 1, 1, 0, 1},\n            {1, 3, 3, 3, 1, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1}\n        };\n        assertArrayEquals(expectedMapAfterNoPathFound, mapWithNoPath, \"The map should reflect the dead ends with 3 where no path was found.\");\n    }\n}",
        "package com.thealgorithms.backtracking;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class MazeRecursionTest {\n    @Test\n    public void setWayTest() {\n        // Assuming the maze is defined with 7x6 (row x column) size\n        int[][] map = new int[7][6];\n\n        // Setting walls, represented by '1'\n        for (int i = 0; i < 7; i++) {\n            map[i][0] = 1;\n            map[i][5] = 1;\n        }\n        for (int j = 0; j < 6; j++) {\n            map[0][j] = 1;\n            map[6][j] = 1;\n        }\n\n        // Starting and ending points, assuming we start at (1,1) and end at (6,5)\n        map[1][1] = 0; // start\n        map[6][5] = 0; // end\n\n        // Simulating a simple path from start to the end\n        // Path: (1,1) -> (2,1) -> (2,2) -> (2,3) -> (2,4) -> (3,4) -> (4,4) -> (5,4) -> (6,4) -> (6,5)\n        map[2][1] = map[2][2] = map[2][3] = map[2][4] = \n        map[3][4] = map[4][4] = map[5][4] = map[6][4] = 0;\n        \n        // Check if the method correctly finds the path\n        assertTrue(setWay(map, 1, 1), \"Method should return true as path is available\");\n\n        // Altering the path making it impossible to reach the destination\n        map[6][4] = 1; // block the path before the end point\n\n        // Check if the method correctly identifies there is no path\n        assertFalse(setWay(map, 1, 1), \"Method should return false as path is blocked\");\n    }\n}"
    ]
}