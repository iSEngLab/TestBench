{
    "project_name": "Java",
    "file_name": "Merge_K_SortedLinkedlist.java",
    "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/lists/Merge_K_SortedLinkedlist.java",
    "execute_path": "Java",
    "package": "com.thealgorithms.datastructures.lists",
    "docstring": "/**\n     * This function merge K sorted LinkedList\n     *\n     * @param a array of LinkedList\n     * @param N size of array\n     * @return node\n     */",
    "source_code": "\nNode mergeKList(Node[] a, int N) {\n    // Min Heap\n    PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n\n    // adding head of all linkedList in min heap\n    min.addAll(Arrays.asList(a).subList(0, N));\n\n    // Make new head among smallest heads in K linkedList\n    Node head = min.poll();\n    min.add(head.next);\n    Node curr = head;\n\n    // merging LinkedList\n    while (!min.isEmpty()) {\n        Node temp = min.poll();\n        curr.next = temp;\n        curr = temp;\n\n        // Add Node in min Heap only if temp.next is not null\n        if (temp.next != null) {\n            min.add(temp.next);\n        }\n    }\n\n    return head;\n}\n",
    "class_name": "Merge_K_SortedLinkedlist",
    "method_name": "mergeKList",
    "arguments": [
        "Node a",
        "int N"
    ],
    "generate_test": [
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node implements Comparable<Node> {\n    int data;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        return this.data - o.data;\n    }\n}\n\npublic class Merge_K_SortedLinkedlistTest {\n\n    private Node[] createTestLists() {\n        // Create test linked lists:\n        // List 1: 1 -> 4 -> 5\n        Node n11 = new Node(1);\n        Node n12 = new Node(4);\n        Node n13 = new Node(5);\n        n11.next = n12;\n        n12.next = n13;\n\n        // List 2: 1 -> 3 -> 4\n        Node n21 = new Node(1);\n        Node n22 = new Node(3);\n        Node n23 = new Node(4);\n        n21.next = n22;\n        n22.next = n23;\n\n        // List 3: 2 -> 6\n        Node n31 = new Node(2);\n        Node n32 = new Node(6);\n        n31.next = n32;\n\n        return new Node[] { n11, n21, n31 };\n    }\n\n    @Test\n    public void mergeKListTest() {\n        // Implement test by completing <FILL> tag\n        Node[] lists = createTestLists();\n        Merge_K_SortedLinkedlist algo = new Merge_K_SortedLinkedlist();\n        \n        Node mergedHead = algo.mergeKList(lists, lists.length);\n        \n        // Expected merged list = 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\n        int[] expectedData = {1, 1, 2, 3, 4, 4, 5, 6};\n        int index = 0;\n        \n        while (mergedHead != null && index < expectedData.length) {\n            assertEquals(expectedData[index], mergedHead.data);\n            mergedHead = mergedHead.next;\n            index++;\n        }\n        \n        // Check that we have reached the end of the merged list\n        assertNull(mergedHead);\n        // Check that we have seen all expected elements\n        assertEquals(expectedData.length, index);\n    }\n}\n\nclass Merge_K_SortedLinkedlist {\n    // Assuming this is the method supplied in the JAVA Source Code you need to test.\n    Node mergeKList(Node[] a, int N) {\n        PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n        min.addAll(Arrays.asList(a).subList(0, N));\n\n        Node head = min.poll();\n        if (head.next != null) {\n            min.add(head.next);\n        }\n        Node curr = head;\n\n        while (!min.isEmpty()) {\n            Node temp = min.poll();\n            curr.next = temp;\n            curr = temp;\n\n            if (temp.next != null) {\n                min.add(temp.next);\n            }\n        }\n\n        return head;\n    }\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node implements Comparable<Node> {\n    int data;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        return Integer.compare(this.data, o.data);\n    }\n}\n\npublic class Merge_K_SortedLinkedlistTest {\n\n    @Test\n    public void mergeKListTest() {\n        // Create linked lists\n        Node list1 = new Node(1);\n        list1.next = new Node(4);\n        list1.next.next = new Node(5);\n\n        Node list2 = new Node(1);\n        list2.next = new Node(3);\n        list2.next.next = new Node(4);\n\n        Node list3 = new Node(2);\n        list3.next = new Node(6);\n\n        // Array of linked list heads\n        Node[] arr = {list1, list2, list3};\n\n        // Merge K sorted linked lists\n        Merge_K_SortedLinkedlist mergeKSortedLinkedList = new Merge_K_SortedLinkedlist();\n        Node result = mergeKSortedLinkedList.mergeKList(arr, arr.length);\n\n        // Verify the merged linked list\n        assertNotNull(result);\n\n        // Expected sorted order in a flat array for easy verification\n        int[] expected = {1, 1, 2, 3, 4, 4, 5, 6};\n        int i = 0;\n        while (result != null) {\n            assertEquals(expected[i++], result.data);\n            result = result.next;\n        }\n\n        // Make sure every expected element was checked\n        assertEquals(expected.length, i);\n    }\n}\n\nclass Merge_K_SortedLinkedlist {\n    Node mergeKList(Node[] a, int N) {\n        // Min Heap\n        PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n\n        // adding head of all linkedList in min heap\n        min.addAll(Arrays.asList(a).subList(0, N));\n\n        // Make new head among smallest heads in K linkedList\n        Node head = min.poll();\n        if (head != null && head.next != null) {\n            min.add(head.next);\n        }\n        Node curr = head;\n\n        // merging LinkedList\n        while (!min.isEmpty()) {\n            Node temp = min.poll();\n            curr.next = temp;\n            curr = temp;\n\n            // Add Node in min Heap only if temp.next is not null\n            if (temp.next != null) {\n                min.add(temp.next);\n            }\n        }\n\n        return head;\n    }\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node implements Comparable<Node> {\n    int data;\n    Node next;\n\n    public Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    @Override\n    public int compareTo(Node other) {\n        return Integer.compare(this.data, other.data);\n    }\n}\n\npublic class Merge_K_SortedLinkedlistTest {\n    \n    private Node[] createLists() {\n        // Creating 3 linked lists for the test\n        // List 1: 1->3->5\n        Node l1 = new Node(1);\n        l1.next = new Node(3);\n        l1.next.next = new Node(5);\n\n        // List 2: 2->4->6\n        Node l2 = new Node(2);\n        l2.next = new Node(4);\n        l2.next.next = new Node(6);\n\n        // List 3: 0->7->8\n        Node l3 = new Node(0);\n        l3.next = new Node(7);\n        l3.next.next = new Node(8);\n        \n        return new Node[] { l1, l2, l3 };\n    }\n    \n    private String listToString(Node head) {\n        StringBuilder sb = new StringBuilder();\n        while (head != null) {\n            sb.append(head.data);\n            if (head.next != null) {\n                sb.append(\"->\");\n            }\n            head = head.next;\n        }\n        return sb.toString();\n    }\n\n    @Test\n    public void mergeKListTest() {\n        // SETUP\n        Node[] lists = createLists();\n        Merge_K_SortedLinkedlist merger = new Merge_K_SortedLinkedlist();\n\n        // EXECUTION\n        Node mergedHead = merger.mergeKList(lists, lists.length);\n        String resultAsString = listToString(mergedHead);\n\n        // VERIFICATION\n        assertEquals(\"0->1->2->3->4->5->6->7->8\", resultAsString, \"The merged list should be sorted from 0 to 8\");\n    }\n    \n    // INNER CLASS TO TEST\n    private class Merge_K_SortedLinkedlist {\n        Node mergeKList(Node[] a, int N) {\n            PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n            min.addAll(Arrays.asList(a).subList(0, N));\n            Node head = min.poll();\n            if(head != null && head.next != null) {\n                min.add(head.next);\n            }\n            Node curr = head;\n            while (!min.isEmpty()) {\n                Node temp = min.poll();\n                curr.next = temp;\n                curr = temp;\n                if (temp.next != null) {\n                    min.add(temp.next);\n                }\n            }\n            return head;\n        }\n    }\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Merge_K_SortedLinkedlistTest {\n\n    class Node implements Comparable<Node> {\n        int data;\n        Node next;\n\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n\n        @Override\n        public int compareTo(Node node) {\n            return Integer.compare(this.data, node.data);\n        }\n    }\n\n    @Test\n    public void mergeKListTest() {\n        // Prepare test data: create sorted linked lists\n        Node list1 = new Node(1);\n        list1.next = new Node(4);\n        list1.next.next = new Node(5);\n\n        Node list2 = new Node(1);\n        list2.next = new Node(3);\n        list2.next.next = new Node(4);\n\n        Node list3 = new Node(2);\n        list3.next = new Node(6);\n\n        // Array of linked list heads\n        Node[] lists = new Node[]{list1, list2, list3};\n\n        // Merge k sorted linked lists\n        Merge_K_SortedLinkedlistTest test = new Merge_K_SortedLinkedlistTest();\n        Node mergedHead = test.mergeKList(lists, lists.length);\n\n        // Verify the merged linked list is sorted\n        int[] expectedData = {1, 1, 2, 3, 4, 4, 5, 6};\n        Node current = mergedHead;\n\n        for (int expectedValue : expectedData) {\n            assertNotNull(current, \"Node should not be null\");\n            assertEquals(expectedValue, current.data, \"Node data should be in ascending order\");\n            current = current.next;\n        }\n\n        assertNull(current, \"The merged list should be finished\");\n    }\n    \n    Node mergeKList(Node[] a, int N) {\n        // Min Heap\n        PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n    \n        // adding head of all linkedList in min heap\n        min.addAll(Arrays.asList(a).subList(0, N));\n    \n        // Make new head among smallest heads in K linkedList\n        Node head = min.poll();\n        if (head != null && head.next != null) {\n            min.add(head.next);\n        }\n    \n        Node curr = head;\n    \n        // merging LinkedList\n        while (!min.isEmpty()) {\n            Node temp = min.poll();\n            curr.next = temp;\n            curr = temp;\n    \n            // Add Node in min Heap only if temp.next is not null\n            if (temp.next != null) {\n                min.add(temp.next);\n            }\n        }\n    \n        return head;\n    }\n}",
        "class Node implements Comparable<Node> {\n    int data;\n    Node next;\n\n    public Node(int data) {\n        this.data = data;\n    }\n\n    @Override\n    public int compareTo(Node other) {\n        return Integer.compare(this.data, other.data);\n    }\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Merge_K_SortedLinkedlistTest {\n\n    private Node[] createTestLists() {\n        // Assume Node class has two fields: int data and Node next;\n        // and Node constructor takes data as parameter.\n\n        // List 1: 1 -> 4 -> 7\n        Node l1 = new Node(1);\n        l1.next = new Node(4);\n        l1.next.next = new Node(7);\n        \n        // List 2: 2 -> 5 -> 8\n        Node l2 = new Node(2);\n        l2.next = new Node(5);\n        l2.next.next = new Node(8);\n        \n        // List 3: 3 -> 6 -> 9\n        Node l3 = new Node(3);\n        l3.next = new Node(6);\n        l3.next.next = new Node(9);\n        \n        return new Node[]{ l1, l2, l3 };\n    }\n\n    @Test\n    public void mergeKListTest() {\n        Merge_K_SortedLinkedlist solution = new Merge_K_SortedLinkedlist();\n        Node[] testLists = createTestLists();\n        Node mergedList = solution.mergeKList(testLists, testLists.length);\n\n        // Verify the merged list is: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9\n        int[] expectedData = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        Node current = mergedList;\n        for (int data : expectedData) {\n            assertNotNull(current, \"Node should not be null\");\n            assertEquals(data, current.data, \"Node data should match expected value\");\n            current = current.next;\n        }\n        assertNull(current, \"The merged list should end with null\");\n    }\n}\n\nclass Node implements Comparable<Node> {\n    int data;\n    Node next;\n\n    Node(int data){\n        this.data = data;\n    }\n\n    @Override\n    public int compareTo(Node other) {\n        return Integer.compare(this.data, other.data);\n    }\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node implements Comparable<Node> {\n    int data;\n    Node next;\n\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        return this.data - o.data;\n    }\n}\n\npublic class Merge_K_SortedLinkedlistTest {\n    Merge_K_SortedLinkedlist mergeKLists;\n\n    @BeforeEach\n    public void setUp() {\n        mergeKLists = new Merge_K_SortedLinkedlist();\n    }\n\n    @Test\n    public void mergeKListTest() {\n        // Assuming the Merge_K_SortedLinkedlist class has a method called mergeKList\n        Node n1 = new Node(1);\n        n1.next = new Node(4);\n        n1.next.next = new Node(5);\n        \n        Node n2 = new Node(1);\n        n2.next = new Node(3);\n        n2.next.next = new Node(4);\n\n        Node n3 = new Node(2);\n        n3.next = new Node(6);\n\n        Node[] lists = new Node[]{n1, n2, n3};\n\n        Node result = mergeKLists.mergeKList(lists, lists.length);\n        \n        assertNotNull(result, \"The result should not be null\");\n        \n        int[] expectedData = {1, 1, 2, 3, 4, 4, 5, 6};\n        for (int data: expectedData) {\n            assertEquals(data, result.data, \"The node data should match the expected value\");\n            result = result.next;\n        }\n        \n        assertNull(result, \"The result should be null after iterating through all the nodes\");\n    }\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Node implements Comparable<Node> {\n    int data;\n    Node next;\n    \n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n    \n    @Override\n    public int compareTo(Node other) {\n        return Integer.compare(this.data, other.data);\n    }\n}\n\npublic class Merge_K_SortedLinkedlistTest {\n\n    @Test\n    public void mergeKListTest() {\n        // Initialize nodes for list 1 (1 -> 4 -> 7)\n        Node head1 = new Node(1);\n        head1.next = new Node(4);\n        head1.next.next = new Node(7);\n        \n        // Initialize nodes for list 2 (2 -> 5 -> 8)\n        Node head2 = new Node(2);\n        head2.next = new Node(5);\n        head2.next.next = new Node(8);\n\n        // Initialize nodes for list 3 (3 -> 6 -> 9)\n        Node head3 = new Node(3);\n        head3.next = new Node(6);\n        head3.next.next = new Node(9);\n\n        // Create an array of the starting nodes of each list\n        Node[] startNodes = { head1, head2, head3 };\n\n        // Instance of the class containing mergeKList method\n        Merge_K_SortedLinkedlist solution = new Merge_K_SortedLinkedlist();\n        \n        // Merge all lists\n        Node mergedHead = solution.mergeKList(startNodes, startNodes.length);\n\n        // Check the merged list for correctness\n        Node current = mergedHead;\n        int[] expectedData = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        for (int expected : expectedData) {\n            assertNotNull(current, \"Node should not be null\");\n            assertEquals(expected, current.data, \"Data should match the expected value\");\n            current = current.next;\n        }\n        assertNull(current, \"The merged list should end with null\");\n    }\n    \n    // Assuming Node and Merge_K_SortedLinkedlist are defined elsewhere within the same package\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Merge_K_SortedLinkedlistTest {\n\n    public static class Node implements Comparable<Node> {\n        int data;\n        Node next;\n\n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n\n        @Override\n        public int compareTo(Node node) {\n            return Integer.compare(this.data, node.data);\n        }\n    }\n\n    private Node[] createTestLists() {\n        // Create 3 sorted linked lists\n        Node list1 = new Node(1);\n        list1.next = new Node(4);\n        list1.next.next = new Node(5);\n\n        Node list2 = new Node(1);\n        list2.next = new Node(3);\n        list2.next.next = new Node(4);\n\n        Node list3 = new Node(2);\n        list3.next = new Node(6);\n\n        return new Node[] { list1, list2, list3 };\n    }\n\n    private String linkedListToString(Node head) {\n        StringBuilder sb = new StringBuilder();\n        Node current = head;\n        while (current != null) {\n            sb.append(current.data);\n            if (current.next != null) {\n                sb.append(\"->\");\n            }\n            current = current.next;\n        }\n        return sb.toString();\n    }\n\n    @Test\n    public void mergeKListTest() {\n        Merge_K_SortedLinkedlistTest testClass = new Merge_K_SortedLinkedlistTest();\n        Node[] lists = testClass.createTestLists();\n        Merge_K_SortedLinkedlist problemInstance = new Merge_K_SortedLinkedlist();\n\n        Node mergedList = problemInstance.mergeKList(lists, lists.length);\n        String result = testClass.linkedListToString(mergedList);\n        String expected = \"1->1->2->3->4->4->5->6\";\n        \n        assertEquals(expected, result);\n    }\n}",
        "package com.thealgorithms.datastructures.lists;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class Merge_K_SortedLinkedlistTest {\n\n    // Assuming the existence of a helper Node class and a constructor\n    // Node(int data), where 'data' is an integer value stored in the node\n    // and a 'next' pointer to the next node in the list.\n    static class Node {\n        int data;\n        Node next;\n\n        Node(int d) {\n            data = d;\n            next = null;\n        }\n    }\n\n    private Node[] createLists() {\n        // Creating 3 sorted linked lists\n        Node list1 = new Node(1);\n        list1.next = new Node(4);\n        list1.next.next = new Node(5);\n\n        Node list2 = new Node(1);\n        list2.next = new Node(3);\n        list2.next.next = new Node(4);\n\n        Node list3 = new Node(2);\n        list3.next = new Node(6);\n\n        Node[] lists = new Node[3];\n        lists[0] = list1;\n        lists[1] = list2;\n        lists[2] = list3;\n\n        return lists;\n    }\n\n    private String printList(Node head) {\n        StringBuilder builder = new StringBuilder();\n        while (head != null) {\n            builder.append(head.data);\n            if (head.next != null) {\n                builder.append(\"->\");\n            }\n            head = head.next;\n        }\n        return builder.toString();\n    }\n\n    // The actual MergeKSortedLinkedList class would need to be implemented\n    // and imported for this test to run\n    private MergeKSortedLinkedList mergeKSortedLinkedList = new MergeKSortedLinkedList();\n\n    @Test\n    public void mergeKListTest() {\n        // Prepare the input\n        Node[] lists = createLists();\n\n        // Perform the merge operation\n        Node mergedListHead = mergeKSortedLinkedList.mergeKList(lists, lists.length);\n\n        // Use the `printList` method to convert the linked list to a string.\n        String mergedListStr = printList(mergedListHead);\n\n        // Assert the result with expected output\n        assertEquals(\"1->1->2->3->4->4->5->6\", mergedListStr);\n    }\n}"
    ]
}