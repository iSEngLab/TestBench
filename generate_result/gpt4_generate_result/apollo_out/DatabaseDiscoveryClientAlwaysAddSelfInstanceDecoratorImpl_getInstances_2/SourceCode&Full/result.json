{
    "project_name": "apollo",
    "file_name": "DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.java",
    "relative_path": "apollo/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/registry/DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.java",
    "execute_path": "apollo",
    "package": "com.ctrip.framework.apollo.biz.registry",
    "docstring": "/**\n   * if the serviceName is same with self, always return self's instance\n   * @return never be empty list when serviceName is same with self\n   */",
    "source_code": "\n@Override\npublic List<ServiceInstance> getInstances(String serviceName) {\n  if (Objects.equals(serviceName, this.selfInstance.getServiceName())) {\n    List<ServiceInstance> serviceInstances = this.delegate.getInstances(serviceName);\n    if (containSelf(serviceInstances, this.selfInstance)) {\n      // contains self instance already\n      return serviceInstances;\n    }\n\n    // add self instance to result\n    List<ServiceInstance> result = new ArrayList<>(serviceInstances.size() + 1);\n    result.add(this.selfInstance);\n    result.addAll(serviceInstances);\n    return result;\n  } else {\n    return this.delegate.getInstances(serviceName);\n  }\n}\n",
    "class_name": "DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl",
    "method_name": "getInstances",
    "arguments": [
        "String serviceName"
    ],
    "generate_test": [
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\nimport static org.mockito.Mockito.*;\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    public void setUp() {\n        // Initialize the mock delegate and a self instance for testing\n        delegate = Mockito.mock(DatabaseDiscoveryClient.class);\n        selfInstance = new ServiceInstance(\"selfService\", URI.create(\"http://localhost:8080\"), \"default\");\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstancesTest_SelfInstanceNotInList_ShouldAddSelfInstance() {\n        // Given a service name same as self instance's name, and a delegate returning a list not containing the self instance\n        String serviceName = \"selfService\";\n        List<ServiceInstance> mockInstances = Arrays.asList(\n                new ServiceInstance(\"otherService\", URI.create(\"http://otherhost:8080\"), \"default\")\n        );\n        when(delegate.getInstances(serviceName)).thenReturn(mockInstances);\n\n        // When calling getInstances on decorator\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Then the result should contain the self instance\n        assertTrue(instances.contains(selfInstance));\n        assertEquals(2, instances.size());\n        verify(delegate, times(1)).getInstances(serviceName);\n    }\n\n    @Test\n    public void getInstancesTest_SelfInstanceInList_ShouldReturnOriginalList() {\n        // Given a service name same as self instance's name, and a delegate returning a list containing the self instance\n        String serviceName = \"selfService\";\n        List<ServiceInstance> mockInstances = Arrays.asList(\n                selfInstance,\n                new ServiceInstance(\"otherService\", URI.create(\"http://otherhost:8080\"), \"default\")\n        );\n        when(delegate.getInstances(serviceName)).thenReturn(mockInstances);\n\n        // When calling getInstances on decorator\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Then the result should be same as the delegate's returned list\n        assertEquals(mockInstances, instances);\n        assertTrue(instances.contains(selfInstance));\n        assertEquals(2, instances.size());\n        verify(delegate, times(1)).getInstances(serviceName);\n    }\n\n    @Test\n    public void getInstancesTest_DifferentServiceName_ShouldDelegate() {\n        // Given a different service name and a delegate returning a list of instances\n        String serviceName = \"otherService\";\n        List<ServiceInstance> mockInstances = Arrays.asList(\n                new ServiceInstance(serviceName, URI.create(\"http://otherhost:8080\"), \"default\")\n        );\n        when(delegate.getInstances(serviceName)).thenReturn(mockInstances);\n\n        // When calling getInstances on decorator\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Then the result should be only the delegate's returned list without self instance\n        assertEquals(mockInstances, instances);\n        assertFalse(instances.contains(selfInstance));\n        verify(delegate, times(1)).getInstances(serviceName);\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    \n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n    \n    @BeforeEach\n    public void setUp() {\n        delegate = Mockito.mock(DatabaseDiscoveryClient.class);\n        selfInstance = Mockito.mock(ServiceInstance.class);\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstancesTest() {\n        String serviceName = \"test-service\";\n        String selfServiceName = \"test-service\";\n        URI uri = URI.create(\"http://localhost:8080\");\n        String cluster = \"default\";\n        \n        ServiceInstance otherInstance1 = Mockito.mock(ServiceInstance.class);\n        ServiceInstance otherInstance2 = Mockito.mock(ServiceInstance.class);\n        \n        when(selfInstance.getServiceName()).thenReturn(selfServiceName);\n        when(selfInstance.getUri()).thenReturn(uri);\n        when(selfInstance.getCluster()).thenReturn(cluster);\n        \n        // Scenario 1: Delegate contains self instance\n        List<ServiceInstance> initialInstances = Arrays.asList(selfInstance, otherInstance1, otherInstance2);\n        when(delegate.getInstances(serviceName)).thenReturn(initialInstances);\n        \n        List<ServiceInstance> result = decorator.getInstances(serviceName);\n        assertEquals(3, result.size(), \"Size should be the same as the delegate returned because self instance is already present\");\n        assertTrue(result.contains(selfInstance), \"List should contain the self instance\");\n        \n        // Scenario 2: Delegate does not contain self instance, and serviceName equals selfInstance service name\n        List<ServiceInstance> initialInstancesWithoutSelf = Arrays.asList(otherInstance1, otherInstance2);\n        when(delegate.getInstances(selfServiceName)).thenReturn(initialInstancesWithoutSelf);\n        \n        List<ServiceInstance> resultWhenSelfNotContained = decorator.getInstances(selfServiceName);\n        assertEquals(3, resultWhenSelfNotContained.size(), \"Should add self instance to the list when it is not contained\");\n        assertTrue(resultWhenSelfNotContained.contains(selfInstance), \"List should now contain the self instance\");\n\n        // Scenario 3: Delegate does not contain self instance, and serviceName does not equal selfInstance service name\n        String differentServiceName = \"different-service\";\n        when(delegate.getInstances(differentServiceName)).thenReturn(initialInstancesWithoutSelf);\n        \n        List<ServiceInstance> resultWithDifferentServiceName = decorator.getInstances(differentServiceName);\n        assertEquals(2, resultWithDifferentServiceName.size(), \"Should not add self instance if the serviceName is different\");\n        assertFalse(resultWithDifferentServiceName.contains(selfInstance), \"List should not contain the self instance\");\n    }\n    \n    // Additional tests can be implemented here, such as handling null responses from delegated getInstances,\n    // checking if the correct instance is added first (i.e., the self instance), and so on.\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private static final String SERVICE_NAME = \"testService\";\n    private static final URI SELF_URI = URI.create(\"http://localhost:8080\");\n    private static final String CLUSTER = \"testCluster\";\n\n    private DatabaseDiscoveryClient delegateMock;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    public void setUp() {\n        delegateMock = Mockito.mock(DatabaseDiscoveryClient.class);\n        selfInstance = new ServiceInstance(SERVICE_NAME, SELF_URI, CLUSTER);\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegateMock, selfInstance);\n    }\n\n    @Test\n    public void getInstances_WhenServiceNameMatches_ShouldAlwaysReturnSelfInstance() {\n        // Arrange\n        ServiceInstance anotherInstance = new ServiceInstance(SERVICE_NAME, SELF_URI, \"anotherCluster\");\n        List<ServiceInstance> mockInstances = Collections.singletonList(anotherInstance);\n        \n        when(delegateMock.getInstances(SERVICE_NAME)).thenReturn(mockInstances);\n        \n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(SERVICE_NAME);\n        \n        // Assert\n        assertNotNull(instances);\n        assertFalse(instances.isEmpty(), \"The instance list should not be empty.\");\n        assertTrue(instances.contains(selfInstance), \"The list should contain the self instance.\");\n        assertEquals(2, instances.size(), \"There should be two instances.\");\n        verify(delegateMock, times(1)).getInstances(SERVICE_NAME);\n    }\n\n    @Test\n    public void getInstances_WhenServiceNameDoesNotMatch_ShouldDelegate() {\n        // Arrange\n        String anotherServiceName = \"anotherService\";\n        List<ServiceInstance> mockInstances = Arrays.asList(new ServiceInstance(anotherServiceName, SELF_URI, CLUSTER), \n                                                           new ServiceInstance(anotherServiceName, SELF_URI, CLUSTER));\n        \n        when(delegateMock.getInstances(anotherServiceName)).thenReturn(mockInstances);\n        \n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(anotherServiceName);\n        \n        // Assert\n        assertNotNull(instances);\n        assertEquals(mockInstances, instances, \"Instances must be the same as those returned from delegate.\");\n        verify(delegateMock, times(1)).getInstances(anotherServiceName);\n    }\n\n    @Test\n    public void getInstances_WhenContainingSelf_ShouldReturnOriginalList() {\n        // Arrange\n        List<ServiceInstance> mockInstances = Collections.singletonList(selfInstance);\n        when(delegateMock.getInstances(SERVICE_NAME)).thenReturn(mockInstances);\n        \n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(SERVICE_NAME);\n        \n        // Assert\n        assertNotNull(instances);\n        assertTrue(instances.contains(selfInstance), \"The list should contain the self instance.\");\n        assertEquals(1, instances.size(), \"Only the self instance should be present.\");\n        verify(delegateMock, times(1)).getInstances(SERVICE_NAME);\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n\n    @BeforeEach\n    public void setUp() {\n        delegate = mock(DatabaseDiscoveryClient.class);\n        selfInstance = new ServiceInstance(\"serviceName-self\", URI.create(\"http://localhost:8080\"), \"default\");\n    }\n    \n    @Test\n    public void getInstances_whenSelfInstanceIsNotInList_addsSelfInstance() {\n        // Arrange\n        String serviceName = selfInstance.getServiceName();\n        List<ServiceInstance> instancesFromDelegate = Collections.singletonList(\n                new ServiceInstance(\"serviceName1\", URI.create(\"http://otherservice:8080\"), \"default\"));\n        DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator =\n                new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n        when(delegate.getInstances(serviceName)).thenReturn(instancesFromDelegate);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Assert\n        assertEquals(2, instances.size());\n        assertTrue(instances.contains(selfInstance));\n    }\n\n    @Test\n    public void getInstances_whenSelfInstanceIsInList_doesNotAddSelfInstance() {\n        // Arrange\n        String serviceName = selfInstance.getServiceName();\n        List<ServiceInstance> instancesFromDelegate = Arrays.asList(\n                selfInstance,\n                new ServiceInstance(\"serviceName1\", URI.create(\"http://otherservice:8080\"), \"default\"));\n        DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator =\n                new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n        when(delegate.getInstances(serviceName)).thenReturn(instancesFromDelegate);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Assert\n        assertEquals(2, instances.size());\n        // Verify that the returned list matches exactly with the list from the delegate\n        assertIterableEquals(instancesFromDelegate, instances);\n    }\n\n    @Test\n    public void getInstances_whenServiceNameIsDifferent_usesDelegate() {\n        // Arrange\n        String differentServiceName = \"different-service\";\n        List<ServiceInstance> instancesFromDelegate = Collections.singletonList(\n                new ServiceInstance(\"serviceName1\", URI.create(\"http://otherservice:8080\"), \"default\"));\n        DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator =\n                new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n        when(delegate.getInstances(differentServiceName)).thenReturn(instancesFromDelegate);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(differentServiceName);\n\n        // Assert\n        assertIterableEquals(instancesFromDelegate, instances);\n        // Verify that the instances returned are genuinely those returned by the delegate\n        assertEquals(instancesFromDelegate, instances);\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    \n    private static final String SERVICE_NAME = \"TestService\";\n\n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl discoveryClient;\n\n    @BeforeEach\n    public void setUp() {\n        delegate = Mockito.mock(DatabaseDiscoveryClient.class);\n        selfInstance = new ServiceInstance(SERVICE_NAME, URI.create(\"http://localhost:8080\"), \"default\");\n        \n        discoveryClient = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstances_withSelfServiceName_containSelfInstance() {\n        String serviceName = SERVICE_NAME;\n        ServiceInstance otherInstance = new ServiceInstance(SERVICE_NAME, URI.create(\"http://localhost:9090\"), \"default\");\n        List<ServiceInstance> delegatedInstances = Collections.singletonList(otherInstance);\n\n        Mockito.when(delegate.getInstances(serviceName)).thenReturn(delegatedInstances);\n\n        List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);\n\n        Mockito.verify(delegate).getInstances(serviceName);\n        assertFalse(instances.isEmpty(), \"Instances list should never be empty\");\n        assertTrue(instances.contains(selfInstance), \"Instances list should contain self instance\");\n        assertTrue(instances.containsAll(delegatedInstances), \"Instances list should contain all instances from delegate\");\n        assertEquals(2, instances.size(), \"Instances list should contain exactly two instances\");\n    }\n\n    @Test\n    public void getInstances_withSelfServiceName_alreadyContainSelfInstance() {\n        String serviceName = SERVICE_NAME;\n        List<ServiceInstance> delegatedInstances = Collections.singletonList(selfInstance);\n\n        Mockito.when(delegate.getInstances(serviceName)).thenReturn(delegatedInstances);\n\n        List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);\n\n        Mockito.verify(delegate).getInstances(serviceName);\n        assertFalse(instances.isEmpty(), \"Instances list should never be empty\");\n        assertTrue(instances.contains(selfInstance), \"Instances list should contain self instance\");\n        assertEquals(1, instances.size(), \"Instances list should contain only the self instance\");\n    }\n\n    @Test\n    public void getInstances_withOtherServiceName_delegateToOriginal() {\n        String otherServiceName = \"OtherService\";\n        ServiceInstance otherInstance = new ServiceInstance(otherServiceName, URI.create(\"http://localhost:9091\"), \"default\");\n        List<ServiceInstance> delegatedInstances = Collections.singletonList(otherInstance);\n\n        Mockito.when(delegate.getInstances(otherServiceName)).thenReturn(delegatedInstances);\n\n        List<ServiceInstance> instances = discoveryClient.getInstances(otherServiceName);\n\n        Mockito.verify(delegate).getInstances(otherServiceName);\n        assertEquals(delegatedInstances, instances, \"Instances list should be equal to what delegate returns\");\n    }\n\n\n    @AfterEach\n    public void tearDown() {\n        Mockito.validateMockitoUsage();\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    @Test\n    public void getInstancesTest() {\n        // Create the delegate mock\n        DatabaseDiscoveryClient delegate = mock(DatabaseDiscoveryClient.class);\n        \n        // Define a self instance for the decorator\n        ServiceInstance selfInstance = new ServiceInstance() {\n            @Override\n            public String getServiceName() {\n                return \"TestService\";\n            }\n\n            @Override\n            public URI getUri() {\n                return URI.create(\"http://local.test:8080\");\n            }\n\n            @Override\n            public String getCluster() {\n                return \"TestCluster\";\n            }\n        };\n        \n        // Initialize the decorator with the delegate and self instance\n        DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator =\n                new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n\n        // Create a scenario where the delegate returns a list without the self instance\n        when(delegate.getInstances(\"TestService\")).thenReturn(Collections.emptyList());\n\n        // Invoke the getInstances method which should always return the self instance included\n        List<ServiceInstance> instancesNoSelfInDelegate = decorator.getInstances(\"TestService\");\n        \n        // Verify self instance is added when not present\n        assertNotNull(instancesNoSelfInDelegate);\n        assertFalse(instancesNoSelfInDelegate.isEmpty());\n        assertEquals(selfInstance, instancesNoSelfInDelegate.get(0));\n        \n        // Create a scenario where the delegate returns a list with the self instance\n        when(delegate.getInstances(\"TestService\")).thenReturn(Arrays.asList(selfInstance));\n\n        // Invoke the getInstances method\n        List<ServiceInstance> instancesWithSelfInDelegate = decorator.getInstances(\"TestService\");\n        \n        // Verify no extra self instance is added if already present\n        assertNotNull(instancesWithSelfInDelegate);\n        assertEquals(1, instancesWithSelfInDelegate.size());\n        assertEquals(selfInstance, instancesWithSelfInDelegate.get(0));\n        \n        // Now test a different service name, should delegate only\n        when(delegate.getInstances(\"AnotherService\")).thenReturn(Collections.singletonList(mock(ServiceInstance.class)));\n\n        // Invoke getInstances with a different service name\n        List<ServiceInstance> instancesDifferentService = decorator.getInstances(\"AnotherService\");\n\n        // Verify self instance is not added for a different service name\n        assertNotNull(instancesDifferentService);\n        assertNotEquals(selfInstance.getServiceName(), instancesDifferentService.stream()\n            .map(ServiceInstance::getServiceName)\n            .findFirst()\n            .orElse(null)\n        );\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private DatabaseDiscoveryClient delegateMock;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    public void setUp() {\n        delegateMock = Mockito.mock(DatabaseDiscoveryClient.class);\n        selfInstance = new ServiceInstance(\"self-service\", URI.create(\"http://localhost:8080\"), \"self-cluster\");\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegateMock, selfInstance);\n    }\n\n    @Test\n    public void getInstancesTest_whenServiceNameIsSelfAndContainsSelfInstance() {\n        List<ServiceInstance> mockInstances = Arrays.asList(selfInstance, new ServiceInstance(\"other-service\", URI.create(\"http://otherhost:9090\"), \"other-cluster\"));\n        Mockito.when(delegateMock.getInstances(selfInstance.getServiceName())).thenReturn(mockInstances);\n\n        List<ServiceInstance> instances = decorator.getInstances(selfInstance.getServiceName());\n\n        assertAll(\n                () -> assertEquals(2, instances.size(), \"Expected size to be 2\"),\n                () -> assertTrue(instances.contains(selfInstance), \"Expected list to contain selfInstance\")\n        );\n    }\n\n    @Test\n    public void getInstancesTest_whenServiceNameIsSelfAndDoesNotContainSelfInstance() {\n        ServiceInstance otherInstance = new ServiceInstance(\"other-service\", URI.create(\"http://otherhost:9090\"), \"other-cluster\");\n        List<ServiceInstance> mockInstances = Collections.singletonList(otherInstance);\n        Mockito.when(delegateMock.getInstances(selfInstance.getServiceName())).thenReturn(mockInstances);\n\n        List<ServiceInstance> instances = decorator.getInstances(selfInstance.getServiceName());\n\n        assertAll(\n                () -> assertEquals(2, instances.size(), \"Expected size to be 2\"),\n                () -> assertTrue(instances.contains(selfInstance), \"Expected list to contain selfInstance\"),\n                () -> assertTrue(instances.contains(otherInstance), \"Expected list to contain otherInstance\")\n        );\n    }\n\n    @Test\n    public void getInstancesTest_whenServiceNameIsNotSelf() {\n        ServiceInstance anotherInstance = new ServiceInstance(\"another-service\", URI.create(\"http://anotherhost:8080\"), \"another-cluster\");\n        List<ServiceInstance> mockInstances = Collections.singletonList(anotherInstance);\n        Mockito.when(delegateMock.getInstances(anyString())).thenReturn(mockInstances);\n\n        List<ServiceInstance> instances = decorator.getInstances(\"different-service\");\n\n        assertAll(\n                () -> assertEquals(1, instances.size(), \"Expected size to be 1\"),\n                () -> assertEquals(anotherInstance, instances.get(0), \"Expected list to contain anotherInstance\")\n        );\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport static org.mockito.Mockito.*;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    void setUp() {\n        delegate = mock(DatabaseDiscoveryClient.class);\n        selfInstance = new ServiceInstance(\"myService\", URI.create(\"http://localhost:8080\"), \"DEFAULT\");\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstancesWhenServiceNameEqualsSelfShouldReturnSelfPlusDelegateInstances() {\n        // Arrange\n        String serviceName = selfInstance.getServiceName();\n        List<ServiceInstance> mockInstances = Arrays.asList(\n                new ServiceInstance(serviceName, URI.create(\"http://localhost:8081\"), \"DEFAULT\"),\n                new ServiceInstance(serviceName, URI.create(\"http://localhost:8082\"), \"DEFAULT\"));\n        when(delegate.getInstances(serviceName)).thenReturn(mockInstances);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Assert\n        assertNotNull(instances);\n        assertFalse(instances.isEmpty());\n        assertTrue(instances.contains(selfInstance));\n        assertEquals(mockInstances.size() + 1, instances.size());\n        verify(delegate).getInstances(serviceName);\n    }\n\n    @Test\n    public void getInstancesWhenServiceNameNotEqualsSelfShouldReturnDelegateInstancesOnly() {\n        // Arrange\n        String otherServiceName = \"otherService\";\n        List<ServiceInstance> mockInstances = Arrays.asList(\n                new ServiceInstance(otherServiceName, URI.create(\"http://localhost:9080\"), \"DEFAULT\"));\n        when(delegate.getInstances(otherServiceName)).thenReturn(mockInstances);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(otherServiceName);\n\n        // Assert\n        assertEquals(mockInstances, instances);\n        verify(delegate).getInstances(otherServiceName);\n    }\n\n    @Test\n    public void getInstancesShouldReturnListContainingSelfInstanceWhenNotAlreadyIncluded() {\n        // Arrange\n        String serviceName = selfInstance.getServiceName();\n        when(delegate.getInstances(serviceName)).thenReturn(Collections.emptyList());\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Assert\n        assertNotNull(instances);\n        assertFalse(instances.isEmpty());\n        assertTrue(instances.contains(selfInstance));\n        assertEquals(1, instances.size());\n    }\n\n    @Test\n    public void getInstancesShouldReturnSameListWhenSelfInstanceAlreadyIncluded() {\n        // Arrange\n        String serviceName = selfInstance.getServiceName();\n        List<ServiceInstance> mockInstances = Collections.singletonList(selfInstance);\n        when(delegate.getInstances(serviceName)).thenReturn(mockInstances);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Assert\n        assertNotNull(instances);\n        assertFalse(instances.isEmpty());\n        assertEquals(mockInstances, instances);\n        assertSame(mockInstances, instances, \"Expected list returned is the same list as the delegate provided\");\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    @Test\n    public void getInstancesTest() {\n        // Arrange\n        DatabaseDiscoveryClient mockDelegate = mock(DatabaseDiscoveryClient.class);\n        ServiceInstance selfInstance = new ServiceInstance(\"selfService\", URI.create(\"http://localhost:8080\"), \"default\");\n        DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl discoveryClient =\n                new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(mockDelegate, selfInstance);\n\n        // When self instance should be added (not contained in the delegate response)\n        String serviceName = \"selfService\";\n        List<ServiceInstance> delegatedList = Collections.emptyList();\n        when(mockDelegate.getInstances(serviceName)).thenReturn(delegatedList);\n\n        // Act\n        List<ServiceInstance> actualInstancesWhenNotContained = discoveryClient.getInstances(serviceName);\n\n        // Assert\n        assertEquals(1, actualInstancesWhenNotContained.size(), \"The list should contain exactly one instance when the delegate returns empty.\");\n        assertTrue(actualInstancesWhenNotContained.contains(selfInstance), \"The list should contain the self instance.\");\n\n        // When self instance is already contained\n        List<ServiceInstance> delegatedListWithSelf = Collections.singletonList(selfInstance);\n        when(mockDelegate.getInstances(serviceName)).thenReturn(delegatedListWithSelf);\n\n        // Act\n        List<ServiceInstance> actualInstancesWhenContained = discoveryClient.getInstances(serviceName);\n\n        // Assert\n        assertEquals(1, actualInstancesWhenContained.size(), \"The list should not contain duplicates of the self instance.\");\n        assertTrue(actualInstancesWhenContained.contains(selfInstance), \"The list should contain the self instance.\");\n\n        // When the serviceName is different\n        String differentServiceName = \"otherService\";\n        List<ServiceInstance> delegatedListForDifferentService = Arrays.asList(\n                new ServiceInstance(differentServiceName, URI.create(\"http://otherhost:1234\"), \"default\")\n        );\n        when(mockDelegate.getInstances(differentServiceName)).thenReturn(delegatedListForDifferentService);\n\n        // Act\n        List<ServiceInstance> actualInstancesForDifferentService = discoveryClient.getInstances(differentServiceName);\n\n        // Assert\n        assertEquals(delegatedListForDifferentService, actualInstancesForDifferentService, \"The list should be exactly what the delegate returns for different service names.\");\n    }\n}\n",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private DatabaseDiscoveryClient delegateMock;\n    private ServiceInstance selfInstanceMock;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl clientDecorator;\n\n    @BeforeEach\n    public void setUp() {\n        delegateMock = mock(DatabaseDiscoveryClient.class);\n        selfInstanceMock = mock(ServiceInstance.class);\n        clientDecorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegateMock, selfInstanceMock);\n    }\n\n    @Test\n    public void getInstancesTest_WhenSelfInstanceIsAlreadyPresent() {\n        String serviceName = \"testService\";\n        when(selfInstanceMock.getServiceName()).thenReturn(serviceName);\n        \n        // Mock a response that already includes the self instance\n        List<ServiceInstance> mockResponse = Collections.singletonList(selfInstanceMock);\n        when(delegateMock.getInstances(serviceName)).thenReturn(mockResponse);\n\n        List<ServiceInstance> result = clientDecorator.getInstances(serviceName);\n\n        verify(delegateMock).getInstances(serviceName);\n        assertEquals(mockResponse, result, \"List should contain the self instance already\");\n    }\n\n    @Test\n    public void getInstancesTest_WhenSelfInstanceIsNotPresent() {\n        String serviceName = \"testService\";\n        when(selfInstanceMock.getServiceName()).thenReturn(serviceName);\n\n        ServiceInstance anotherInstanceMock = mock(ServiceInstance.class);\n        List<ServiceInstance> mockResponse = Collections.singletonList(anotherInstanceMock);\n        when(delegateMock.getInstances(serviceName)).thenReturn(mockResponse);\n\n        List<ServiceInstance> result = clientDecorator.getInstances(serviceName);\n\n        verify(delegateMock).getInstances(serviceName);\n        assertTrue(result.contains(selfInstanceMock), \"List should contain the self instance\");\n        assertTrue(result.containsAll(mockResponse), \"Original instances should be included in the result\");\n        assertEquals(mockResponse.size() + 1, result.size(), \"The result list size should be increased by 1\");\n    }\n\n    @Test\n    public void getInstancesTest_WhenServiceNameDoesNotMatch() {\n        String searchedServiceName = \"otherService\";\n        when(selfInstanceMock.getServiceName()).thenReturn(\"testService\");\n\n        ServiceInstance otherInstanceMock = mock(ServiceInstance.class);\n        when(otherInstanceMock.getServiceName()).thenReturn(\"otherService\");\n        List<ServiceInstance> mockResponse = Arrays.asList(selfInstanceMock, otherInstanceMock);\n\n        when(delegateMock.getInstances(searchedServiceName)).thenReturn(mockResponse);\n\n        List<ServiceInstance> result = clientDecorator.getInstances(searchedServiceName);\n\n        verify(delegateMock).getInstances(searchedServiceName);\n        assertEquals(mockResponse, result, \"Should return delegated instances without adding self instance\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        reset(delegateMock, selfInstanceMock);\n    }\n}"
    ]
}