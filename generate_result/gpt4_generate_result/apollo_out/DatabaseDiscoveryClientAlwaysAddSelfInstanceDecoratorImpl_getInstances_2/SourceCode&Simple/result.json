{
    "project_name": "apollo",
    "file_name": "DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.java",
    "relative_path": "apollo/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/registry/DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.java",
    "execute_path": "apollo",
    "package": "com.ctrip.framework.apollo.biz.registry",
    "docstring": "/**\n   * if the serviceName is same with self, always return self's instance\n   * @return never be empty list when serviceName is same with self\n   */",
    "source_code": "\n@Override\npublic List<ServiceInstance> getInstances(String serviceName) {\n  if (Objects.equals(serviceName, this.selfInstance.getServiceName())) {\n    List<ServiceInstance> serviceInstances = this.delegate.getInstances(serviceName);\n    if (containSelf(serviceInstances, this.selfInstance)) {\n      // contains self instance already\n      return serviceInstances;\n    }\n\n    // add self instance to result\n    List<ServiceInstance> result = new ArrayList<>(serviceInstances.size() + 1);\n    result.add(this.selfInstance);\n    result.addAll(serviceInstances);\n    return result;\n  } else {\n    return this.delegate.getInstances(serviceName);\n  }\n}\n",
    "class_name": "DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl",
    "method_name": "getInstances",
    "arguments": [
        "String serviceName"
    ],
    "generate_test": [
        "public interface DatabaseDiscoveryClient {\n    List<ServiceInstance> getInstances(String serviceName);\n}\n\npublic class ServiceInstance {\n    private String serviceName;\n    private URI uri;\n\n    public ServiceInstance(String serviceName, URI uri) {\n        this.serviceName = serviceName;\n        this.uri = uri;\n    }\n\n    public String getServiceName() {\n        return serviceName;\n    }\n\n    public URI getUri() {\n        return uri;\n    }\n    // Equals and hashCode methods based on serviceName and uri for comparison.\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.mockito.Mockito;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl discoveryClientDecorator;\n\n    @BeforeEach\n    public void setUp() {\n        delegate = Mockito.mock(DatabaseDiscoveryClient.class);\n        selfInstance = Mockito.mock(ServiceInstance.class);\n        discoveryClientDecorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstances_WhenServiceNameIsSelfAndContainsSelf_ShouldReturnServiceInstancesIncludingSelf() {\n        String serviceName = \"testService\";\n        \n        // Mock the scenario where the service name equals self's service name and the list already contains self\n        Mockito.when(selfInstance.getServiceName()).thenReturn(serviceName);\n        Mockito.when(delegate.getInstances(serviceName)).thenReturn(Arrays.asList(selfInstance));\n        Mockito.when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(Mockito.anyList(), Mockito.eq(selfInstance))).thenReturn(true);\n\n        List<ServiceInstance> instances = discoveryClientDecorator.getInstances(serviceName);\n\n        // Assertions\n        assertEquals(1, instances.size(), \"Returned list should contain exactly one service instance.\");\n        assertTrue(instances.contains(selfInstance), \"Returned list should include the self instance.\");\n    }\n\n    @Test\n    public void getInstances_WhenServiceNameIsSelfAndDoesNotContainSelf_ShouldReturnServiceInstancesAddedSelf() {\n        String serviceName = \"testService\";\n\n        // Mock the scenario where the service name equals self's service name but the list does not contain self\n        ServiceInstance otherInstance = Mockito.mock(ServiceInstance.class);\n        Mockito.when(selfInstance.getServiceName()).thenReturn(serviceName);\n        Mockito.when(delegate.getInstances(serviceName)).thenReturn(Arrays.asList(otherInstance));\n        Mockito.when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(Mockito.anyList(), Mockito.eq(selfInstance))).thenReturn(false);\n\n        List<ServiceInstance> instances = discoveryClientDecorator.getInstances(serviceName);\n\n        // Assertions\n        assertEquals(2, instances.size(), \"Returned list should contain two service instances.\");\n        assertTrue(instances.contains(selfInstance), \"Returned list should include the self instance.\");\n        assertTrue(instances.contains(otherInstance), \"Returned list should include the other service instance retrieved from delegate.\");\n    }\n\n    @Test\n    public void getInstances_WhenServiceNameIsNotSelf_ShouldDelegateGetInstances() {\n        String serviceName = \"testService\";\n        String otherServiceName = \"otherService\";\n\n        // Mock the scenario where the service name does not equal self's service name\n        ServiceInstance otherInstance = Mockito.mock(ServiceInstance.class);\n        Mockito.when(selfInstance.getServiceName()).thenReturn(serviceName);\n        Mockito.when(delegate.getInstances(otherServiceName)).thenReturn(Arrays.asList(otherInstance));\n\n        List<ServiceInstance> instances = discoveryClientDecorator.getInstances(otherServiceName);\n\n        // Assertions\n        assertEquals(1, instances.size(), \"Returned list should contain exactly one service instance from delegate.\");\n        assertTrue(instances.contains(otherInstance), \"Returned list should include the other service instance retrieved from delegate.\");\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    @Test\n    public void getInstancesTest() {\n        // Setup mocks and test data\n        DatabaseDiscoveryClient delegate = mock(DatabaseDiscoveryClient.class);\n        ServiceInstance selfInstance = mock(ServiceInstance.class);\n        ServiceInstance otherInstance = mock(ServiceInstance.class);\n\n        // Mock the delegation client's behavior\n        when(delegate.getInstances(\"selfService\")).thenReturn(Arrays.asList(otherInstance));\n        when(delegate.getInstances(\"otherService\")).thenReturn(Arrays.asList(otherInstance));\n        when(selfInstance.getServiceName()).thenReturn(\"selfService\");\n        \n        // Test the condition where the service name matches and doesn't contain self instance\n        DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl service = \n            new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n\n        // When containSelf returns false, we add the self instance\n        DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl spyService = spy(service);\n        doReturn(false).when(spyService).containSelf(anyList(), eq(selfInstance));\n\n        List<ServiceInstance> result = spyService.getInstances(\"selfService\");\n\n        // Verification\n        assertNotNull(result);\n        assertEquals(2, result.size());\n        assertTrue(result.contains(selfInstance));\n        verify(spyService, times(1)).containSelf(anyList(), eq(selfInstance));\n\n        // Test the condition where the service name doesn't match and simply delegates without modification\n        List<ServiceInstance> otherServiceResult = spyService.getInstances(\"otherService\");\n        assertNotNull(otherServiceResult);\n        assertEquals(1, otherServiceResult.size());\n        assertFalse(otherServiceResult.contains(selfInstance));\n\n        // Test the condition where containSelf returns true (already contains self instance)\n        doReturn(true).when(spyService).containSelf(anyList(), eq(selfInstance));\n        List<ServiceInstance> selfContainedResult = spyService.getInstances(\"selfService\");\n        \n        assertNotNull(selfContainedResult);\n        assertEquals(1, selfContainedResult.size());\n        verify(spyService, times(2)).containSelf(anyList(), eq(selfInstance));\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private DatabaseDiscoveryClient delegateMock;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    public void setUp() {\n        delegateMock = mock(DatabaseDiscoveryClient.class);\n        selfInstance = mock(ServiceInstance.class);\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegateMock, selfInstance);\n    }\n\n    @Test\n    public void getInstancesTest() {\n        String serviceName = \"testService\";\n        \n        // Assuming when selfInstance's serviceName equals the input parameter.\n        when(selfInstance.getServiceName()).thenReturn(serviceName);\n        \n        // Assuming delegate returns a list containing some mock service instances.\n        ServiceInstance otherInstance = mock(ServiceInstance.class);\n        List<ServiceInstance> mockList = Arrays.asList(otherInstance);\n        when(delegateMock.getInstances(serviceName)).thenReturn(mockList);\n        \n        // Assuming containSelf method for decorator is false to make the test add selfInstance.\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(mockList, selfInstance)).thenReturn(false);\n        \n        List<ServiceInstance> result = decorator.getInstances(serviceName);\n\n        assertNotNull(result, \"The result should not be null.\");\n        assertFalse(result.isEmpty(), \"The result list should not be empty.\");\n        assertTrue(result.contains(selfInstance), \"The result list should contain selfInstance.\");\n\n        // Validation for cases where the selfInstance should be added at the beginning of the list.\n        assertEquals(selfInstance, result.get(0), \"The first element in the list should be selfInstance.\");\n        assertEquals(2, result.size(), \"The result list should contain exactly two instances.\");\n        \n        // Assuming when given a different service name, delegate is called and selfInstance is not added.\n        String anotherServiceName = \"anotherService\";\n        when(selfInstance.getServiceName()).thenReturn(serviceName);\n        when(delegateMock.getInstances(anotherServiceName)).thenReturn(Collections.singletonList(otherInstance));\n        \n        List<ServiceInstance> anotherResult = decorator.getInstances(anotherServiceName);\n        \n        assertEquals(Collections.singletonList(otherInstance), anotherResult, \"The result should be equal to the one returned by delegate.\");\n        assertFalse(anotherResult.contains(selfInstance), \"The result list should not contain selfInstance for different service names.\");\n    }\n\n    // Helpers to mock static methods if needed\n    private static <T> T mock(Class<T> classToMock) {\n        // This is a placeholder for mocking framework like Mockito.\n        return org.mockito.Mockito.mock(classToMock);\n    }\n\n    private static <T> void when(T methodCall) {\n        // This is a placeholder for mocking framework setup like Mockito.when\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport static org.mockito.Mockito.*;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    \n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n    \n    @BeforeEach\n    public void setUp() {\n        delegate = mock(DatabaseDiscoveryClient.class);\n        selfInstance = mock(ServiceInstance.class);\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n    \n    @Test\n    public void getInstancesTest_ContainsSelf() {\n        String serviceName = \"testService\";\n        List<ServiceInstance> mockedInstances = Arrays.asList(mock(ServiceInstance.class), selfInstance);\n        when(delegate.getInstances(serviceName)).thenReturn(mockedInstances);\n        when(selfInstance.getServiceName()).thenReturn(serviceName);\n        \n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n        \n        assertNotNull(instances);\n        assertTrue(instances.contains(selfInstance));\n        assertEquals(mockedInstances.size(), instances.size());\n        verify(delegate, times(1)).getInstances(serviceName);\n    }\n    \n    @Test\n    public void getInstancesTest_DoesNotContainSelf() {\n        String serviceName = \"testService\";\n        List<ServiceInstance> mockedInstances = Collections.singletonList(mock(ServiceInstance.class));\n        when(delegate.getInstances(serviceName)).thenReturn(mockedInstances);\n        when(selfInstance.getServiceName()).thenReturn(serviceName);\n        \n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n        \n        assertNotNull(instances);\n        assertTrue(instances.contains(selfInstance));\n        assertEquals(mockedInstances.size() + 1, instances.size());\n        verify(delegate, times(1)).getInstances(serviceName);\n    }\n    \n    @Test\n    public void getInstancesTest_DifferentServiceName() {\n        String requestedServiceName = \"requestedService\";\n        String selfServiceName = \"selfService\";\n        List<ServiceInstance> mockedInstances = Collections.singletonList(mock(ServiceInstance.class));\n        when(delegate.getInstances(requestedServiceName)).thenReturn(mockedInstances);\n        when(selfInstance.getServiceName()).thenReturn(selfServiceName);\n        \n        List<ServiceInstance> instances = decorator.getInstances(requestedServiceName);\n        \n        assertNotNull(instances);\n        assertFalse(instances.contains(selfInstance));\n        assertEquals(mockedInstances.size(), instances.size());\n        verify(delegate, times(1)).getInstances(requestedServiceName);\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.when;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    private DatabaseDiscoveryClient delegateMock;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    public void setup() {\n        delegateMock = Mockito.mock(DatabaseDiscoveryClient.class);\n        selfInstance = Mockito.mock(ServiceInstance.class);\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegateMock, selfInstance);\n    }\n\n    @Test\n    public void getInstancesTest_whenServiceNameMatchesAndSelfInstanceNotContained() {\n        // Arrange\n        String serviceName = \"testService\";\n        ServiceInstance otherInstance = Mockito.mock(ServiceInstance.class);\n        List<ServiceInstance> returnedInstances = Collections.singletonList(otherInstance);\n\n        when(selfInstance.getServiceName()).thenReturn(serviceName);\n        when(delegateMock.getInstances(anyString())).thenReturn(returnedInstances);\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(returnedInstances, selfInstance)).thenReturn(false);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n\n        // Assert\n        assertNotNull(instances);\n        assertEquals(2, instances.size()); // because it should add selfInstance\n        assertTrue(instances.contains(selfInstance)); // assert selfInstance is added\n        assertTrue(instances.contains(otherInstance)); // assert otherInstance is still there\n    }\n\n    @Test\n    public void getInstancesTest_whenServiceNameMatchesAndSelfInstanceIsContained() {\n        // Arrange\n        String serviceName = \"testService\";\n        when(selfInstance.getServiceName()).thenReturn(serviceName);\n        when(delegateMock.getInstances(serviceName)).thenReturn(Arrays.asList(selfInstance));\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(Arrays.asList(selfInstance), selfInstance)).thenReturn(true);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n        \n        // Assert\n        assertNotNull(instances);\n        assertEquals(1, instances.size()); // selfInstance is already contained, so no new addition\n        assertTrue(instances.contains(selfInstance)); // assert that selfInstance is present\n    }\n\n    @Test\n    public void getInstancesTest_whenServiceNameDoesNotMatch() {\n        // Arrange\n        String serviceName = \"testService\";\n        String differentServiceName = \"differentService\";\n        ServiceInstance otherInstance = Mockito.mock(ServiceInstance.class);\n        List<ServiceInstance> delegateInstances = Collections.singletonList(otherInstance);\n\n        when(selfInstance.getServiceName()).thenReturn(differentServiceName); // different service name\n        when(delegateMock.getInstances(serviceName)).thenReturn(delegateInstances);\n\n        // Act\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n        \n        // Assert\n        assertEquals(delegateInstances, instances); // returned list should be exactly what delegate returns\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    \n    @Mock\n    private DatabaseDiscoveryClient delegate;\n    \n    @Mock\n    private ServiceInstance selfInstance;\n    \n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl discoveryClient;\n    \n    @BeforeEach\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        discoveryClient = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n    \n    @Test\n    public void getInstancesTest() {\n        // Assume selfInstance's serviceName is \"self-service-name\"\n        when(selfInstance.getServiceName()).thenReturn(\"self-service-name\");\n        \n        // When requesting a service instance that matches the self service name.\n        String serviceName = \"self-service-name\";\n        List<ServiceInstance> mockServiceInstances = Arrays.asList(mock(ServiceInstance.class), mock(ServiceInstance.class)); // mock instances\n        when(delegate.getInstances(serviceName)).thenReturn(mockServiceInstances);\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(mockServiceInstances, selfInstance)).thenReturn(false);\n        \n        List<ServiceInstance> resultInstances = discoveryClient.getInstances(serviceName);\n        assertNotNull(resultInstances);\n        assertTrue(resultInstances.contains(selfInstance));\n        assertEquals(mockServiceInstances.size() + 1, resultInstances.size());\n        \n        // When requesting a service instance that does not match the self service name\n        serviceName = \"other-service-name\";\n        mockServiceInstances = Arrays.asList(mock(ServiceInstance.class), mock(ServiceInstance.class));\n        when(delegate.getInstances(serviceName)).thenReturn(mockServiceInstances);\n        \n        resultInstances = discoveryClient.getInstances(serviceName);\n        assertNotNull(resultInstances);\n        assertFalse(resultInstances.contains(selfInstance));\n        assertEquals(mockServiceInstances.size(), resultInstances.size());\n        \n        // When the serviceInstances list already contains the selfInstance\n        serviceName = \"self-service-name\";\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(mockServiceInstances, selfInstance)).thenReturn(true);\n        \n        resultInstances = discoveryClient.getInstances(serviceName);\n        assertNotNull(resultInstances);\n        assertEquals(mockServiceInstances.size(), resultInstances.size());\n    }\n    \n    // An example of how to setup the mock to return true when checking if the list contains selfInstance\n    // This static method is assumed to be properly defined in your actual implementation\n    static {\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(anyList(), any(ServiceInstance.class)))\n            .thenAnswer(invocation -> {\n                List<ServiceInstance> list = invocation.getArgument(0);\n                ServiceInstance self = invocation.getArgument(1);\n                return list.contains(self);\n            });\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport static org.mockito.Mockito.*;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    public void setUp() {\n        // Creating mocks for delegate and selfInstance\n        delegate = mock(DatabaseDiscoveryClient.class);\n        selfInstance = mock(ServiceInstance.class);\n\n        // Initializing the object to test\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstancesTest() {\n        String serviceName = \"testService\";\n        String selfServiceName = \"selfService\";\n        \n        // Return the same service name for selfInstance\n        when(selfInstance.getServiceName()).thenReturn(selfServiceName);\n        \n        // Mock services returned by the delegate when queried with the corresponding service name\n        List<ServiceInstance> delegateInstances = Arrays.asList(mock(ServiceInstance.class), mock(ServiceInstance.class));\n        when(delegate.getInstances(serviceName)).thenReturn(delegateInstances);\n\n        // Return true when checking if the collection contains selfInstance. It simulates that selfInstance is in the list.\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(any(), eq(selfInstance))).thenReturn(true);\n        \n        // Test when the service name does not match selfInstance's service name\n        List<ServiceInstance> instances = decorator.getInstances(serviceName);\n        assertEquals(delegateInstances, instances, \"The returned list should match the delegate's when service names do not match\");\n\n        // Test when the service name matches selfInstance's service name but already contains self\n        instances = decorator.getInstances(selfServiceName);\n        assertEquals(delegateInstances, instances, \"The returned list should match the delegate's when the service name matches and contains self\");\n\n        // Simulate situation when the serviceInstances list does not contain selfInstance\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(any(), eq(selfInstance))).thenReturn(false);\n\n        // The expected list should have the selfInstance included at the beginning\n        List<ServiceInstance> expectedInstancesWithSelf = Arrays.asList(selfInstance);\n        expectedInstancesWithSelf.addAll(delegateInstances);\n        \n        // Test when the service name matches and does not contain self\n        instances = decorator.getInstances(selfServiceName);\n        assertIterableEquals(expectedInstancesWithSelf, instances, \"The returned list should include the selfInstance when the service name matches and does not contain self\");\n    }\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n    \n    private DatabaseDiscoveryClient delegate;\n    private ServiceInstance selfInstance;\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl decorator;\n\n    @BeforeEach\n    void setUp() {\n        delegate = mock(DatabaseDiscoveryClient.class);\n        selfInstance = mock(ServiceInstance.class);\n        decorator = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstances_WhenServiceNameMatches_IncludesSelfInstance() {\n        // Arrange\n        String serviceName = \"serviceA\";\n        ServiceInstance otherInstance = mock(ServiceInstance.class);\n        List<ServiceInstance> mockList = Arrays.asList(otherInstance);\n        when(selfInstance.getServiceName()).thenReturn(serviceName);\n        when(delegate.getInstances(serviceName)).thenReturn(mockList);\n        when(DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.containSelf(mockList, selfInstance)).thenReturn(false);\n\n        // Act\n        List<ServiceInstance> result = decorator.getInstances(serviceName);\n\n        // Assert\n        assertNotNull(result);\n        assertEquals(2, result.size());\n        assertTrue(result.contains(selfInstance));\n        verify(delegate).getInstances(serviceName);\n    }\n\n    @Test\n    public void getInstances_WhenServiceNameDoesNotMatch_Delegates() {\n        // Arrange\n        String serviceName = \"serviceB\";\n        String selfServiceName = \"serviceA\";\n        ServiceInstance otherInstance = mock(ServiceInstance.class);\n        List<ServiceInstance> expectedList = Arrays.asList(otherInstance);\n        when(selfInstance.getServiceName()).thenReturn(selfServiceName);\n        when(delegate.getInstances(serviceName)).thenReturn(expectedList);\n\n        // Act\n        List<ServiceInstance> result = decorator.getInstances(serviceName);\n\n        // Assert\n        verify(delegate).getInstances(serviceName);\n        assertEquals(expectedList, result);\n    }\n    \n    // Other potential tests could be written for the following cases:\n    // - verify the self instance is not added again if it's already in the list\n    // - test behaviour when getServiceName returns null\n    // - test behaviour when getInstances returns null or an empty list\n    // - test exception handling (if any)\n}",
        "package com.ctrip.framework.apollo.biz.registry;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImplTest {\n\n    private final String TEST_SERVICE_NAME = \"testService\";\n    private final String DIFFERENT_SERVICE_NAME = \"differentService\";\n    private final DatabaseDiscoveryClient delegate = mock(DatabaseDiscoveryClient.class);\n    private final ServiceInstance selfInstance = mock(ServiceInstance.class);\n    private DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl databaseDiscoveryClient;\n\n    @BeforeEach\n    public void setUp() {\n        when(selfInstance.getServiceName()).thenReturn(TEST_SERVICE_NAME);\n        databaseDiscoveryClient = new DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(delegate, selfInstance);\n    }\n\n    @Test\n    public void getInstancesTest() {\n        List<ServiceInstance> mockInstances = Arrays.asList(mock(ServiceInstance.class), mock(ServiceInstance.class));\n        when(delegate.getInstances(TEST_SERVICE_NAME)).thenReturn(mockInstances);\n        when(delegate.getInstances(DIFFERENT_SERVICE_NAME)).thenReturn(mockInstances);\n\n        // When requesting instances for the same service name which self instance has\n        List<ServiceInstance> instances = databaseDiscoveryClient.getInstances(TEST_SERVICE_NAME);\n\n        assertTrue(instances.contains(selfInstance), \"Instances should contain self instance\");\n        assertEquals(mockInstances.size() + 1, instances.size(), \"Instances size should be the delegate size plus one\");\n\n        // When requesting instances for a different service name\n        List<ServiceInstance> differentInstances = databaseDiscoveryClient.getInstances(DIFFERENT_SERVICE_NAME);\n\n        assertFalse(differentInstances.contains(selfInstance), \"Instances should not contain self instance for different service name\");\n        assertEquals(mockInstances.size(), differentInstances.size(), \"Instances size should be equal to the delegate size for different service name\");\n\n        // Verify underlying delegate method was called\n        verify(delegate, times(1)).getInstances(TEST_SERVICE_NAME);\n        verify(delegate, times(1)).getInstances(DIFFERENT_SERVICE_NAME);\n    }\n}"
    ]
}