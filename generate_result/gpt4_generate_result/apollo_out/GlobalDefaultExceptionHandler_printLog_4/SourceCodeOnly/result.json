{
    "project_name": "apollo",
    "file_name": "GlobalDefaultExceptionHandler.java",
    "relative_path": "apollo/apollo-common/src/main/java/com/ctrip/framework/apollo/common/controller/GlobalDefaultExceptionHandler.java",
    "execute_path": "apollo",
    "package": "com.ctrip.framework.apollo.common.controller",
    "docstring": null,
    "source_code": "//\u6253\u5370\u65e5\u5fd7, \u5176\u4e2dlogLevel\u4e3a\u65e5\u5fd7\u7ea7\u522b: ERROR/WARN/DEBUG/INFO/TRACE\nprivate void printLog(String message, Throwable ex, Level logLevel) {\n  switch (logLevel) {\n    case ERROR:\n      logger.error(message, ex);\n      break;\n    case WARN:\n      logger.warn(message, ex);\n      break;\n    case DEBUG:\n      logger.debug(message, ex);\n      break;\n    case INFO:\n      logger.info(message, ex);\n      break;\n    case TRACE:\n      logger.trace(message, ex);\n      break;\n  }\n\n  Tracer.logError(ex);\n}\n",
    "class_name": "GlobalDefaultExceptionHandler",
    "method_name": "printLog",
    "arguments": [
        "String message",
        "Throwable ex",
        "Level logLevel"
    ],
    "generate_test": [
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.lang.reflect.Method;\n\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class GlobalDefaultExceptionHandlerTest {\n\n    private GlobalDefaultExceptionHandler exceptionHandler;\n\n    @Mock\n    private Logger logger;\n\n    @BeforeEach\n    void setUp() {\n        exceptionHandler = new GlobalDefaultExceptionHandler();\n        // Suppose Logger instance is obtained somewhere within this class\n        // and can be set or accessed for mocking\n        exceptionHandler.setLogger(logger);\n    }\n    \n    // Assuming Level is an enum with ERROR, WARN, DEBUG, INFO, TRACE\n    private enum Level {\n        ERROR, WARN, DEBUG, INFO, TRACE\n    }\n\n    @Test\n    public void printLogTest() throws Exception {\n        String message = \"Test Message\";\n        Throwable ex = new RuntimeException(\"Test Exception\");\n\n        for (Level logLevel : Level.values()) {\n            Method printLogMethod = GlobalDefaultExceptionHandler.class\n                    .getDeclaredMethod(\"printLog\", String.class, Throwable.class, Level.class);\n            printLogMethod.setAccessible(true);\n\n            printLogMethod.invoke(exceptionHandler, message, ex, logLevel);\n\n            switch (logLevel) {\n                case ERROR:\n                    verify(logger).error(message, ex);\n                    break;\n                case WARN:\n                    verify(logger).warn(message, ex);\n                    break;\n                case DEBUG:\n                    verify(logger).debug(message, ex);\n                    break;\n                case INFO:\n                    verify(logger).info(message, ex);\n                    break;\n                case TRACE:\n                    verify(logger).trace(message, ex);\n                    break;\n            }\n\n            // Assuming Tracer is a utility class that should be called whenever an exception is logged\n            // You would also need to mock this static method call appropriately\n            verifyStatic(Tracer.class);\n            Tracer.logError(ex);\n        }\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class GlobalDefaultExceptionHandlerTest {\n\n    @Mock\n    private Logger logger;\n    \n    @Mock\n    private Tracer tracer;\n    \n    @InjectMocks\n    private YourClassUnderTest yourClassUnderTest; // Replace with the actual class name where printLog method is.\n    \n    @Test\n    public void printLogTest() {\n        Throwable mockException = new RuntimeException(\"This is a test exception\");\n        Level testLevel = Level.ERROR; // Assuming Level is an enum with values like ERROR, WARN, etc.\n\n        doNothing().when(logger).error(anyString(), any(Throwable.class));\n        doNothing().when(tracer).logError(any(Throwable.class));\n\n        yourClassUnderTest.printLog(\"Test Message\", mockException, testLevel); // Calling the method under test.\n\n        verify(logger).error(\"Test Message\", mockException); // Verifies that logger.error was called with the expected parameters.\n        verify(tracer).logError(mockException); // Verifies that tracer.logError was called with the expected parameters.\n    }\n}\n",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport static org.mockito.Mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.logging.Level;\n\n@ExtendWith(MockitoExtension.class)\npublic class GlobalDefaultExceptionHandlerTest {\n\n    @Mock\n    private YourLoggerClass logger; // Assuming YourLoggerClass is the class containing the printLog method\n\n    @Mock\n    private Tracer tracer;\n\n    private final String testMessage = \"Test message\";\n    private final Throwable testException = new Exception(\"Test exception\");\n\n    // Let's assume we have a method to inject mocks in our class under test\n    // You would typically use @InjectMocks annotation or manually inject it.\n    private YourClassUnderTest classUnderTest = new YourClassUnderTest(logger, tracer);\n\n    @Test\n    public void printLogTest() {\n        // Mock the Tracer.logError call because it's a side-effect we don't want to execute.\n        doNothing().when(tracer).logError(any(Throwable.class));\n\n        // Test ERROR level logging\n        classUnderTest.printLog(testMessage, testException, Level.ERROR);\n        verify(logger).error(testMessage, testException);\n        verify(tracer).logError(testException);\n\n        // Test WARN level logging\n        classUnderTest.printLog(testMessage, testException, Level.WARN);\n        verify(logger).warn(testMessage, testException);\n\n        // Test DEBUG level logging\n        classUnderTest.printLog(testMessage, testException, Level.DEBUG);\n        verify(logger).debug(testMessage, testException);\n\n        // Test INFO level logging\n        classUnderTest.printLog(testMessage, testException, Level.INFO);\n        verify(logger).info(testMessage, testException);\n\n        // Test TRACE level logging\n        classUnderTest.printLog(testMessage, testException, Level.TRACE);\n        verify(logger).trace(testMessage, testException);\n\n        // Verify that the Tracer.logError method was called for each log level.\n        verify(tracer, times(5)).logError(testException);\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.*;\nimport static org.mockito.Mockito.*;\nimport java.util.logging.Level;\n\npublic class LoggerUtilityTest {\n\n    @Mock\n    private Logger logger; // Assuming logger is mockable\n\n    @Mock\n    private Tracer tracer; // Assuming Tracer is also mockable\n\n    @InjectMocks\n    private LoggerUtility loggerUtility;\n\n    @BeforeEach\n    public void setUp() {\n        MockitoAnnotations.openMocks(this);\n    }\n\n    private void testPrintLog(Level logLevel) {\n        Throwable ex = new RuntimeException(\"Test Exception\");\n        String message = \"Test message\";\n        loggerUtility.printLog(message, ex, logLevel);\n\n        switch (logLevel) {\n            case ERROR:\n                verify(logger).error(message, ex);\n                break;\n            case WARN:\n                verify(logger).warn(message, ex);\n                break;\n            case DEBUG:\n                verify(logger).debug(message, ex);\n                break;\n            case INFO:\n                verify(logger).info(message, ex);\n                break;\n            case TRACE:\n                verify(logger).trace(message, ex);\n                break;\n        }\n\n        verify(tracer).logError(ex);\n    }\n\n    @Test\n    public void printLogTest_ERROR() {\n        testPrintLog(Level.ERROR);\n    }\n\n    @Test\n    public void printLogTest_WARN() {\n        testPrintLog(Level.WARN);\n    }\n\n    @Test\n    public void printLogTest_DEBUG() {\n        testPrintLog(Level.DEBUG);\n    }\n\n    @Test\n    public void printLogTest_INFO() {\n        testPrintLog(Level.INFO);\n    }\n\n    @Test\n    public void printLogTest_TRACE() {\n        testPrintLog(Level.TRACE);\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.logging.Level;\n\n@ExtendWith(MockitoExtension.class)\npublic class GlobalDefaultExceptionHandlerTest {\n\n    @Mock\n    private Logger logger;\n    \n    @Mock\n    private Tracer tracer;\n    \n    private GlobalDefaultExceptionHandler exceptionHandler;\n    \n    @BeforeEach\n    public void setUp() {\n        this.exceptionHandler = new GlobalDefaultExceptionHandler(logger, tracer);\n    }\n    \n    @Test\n    public void printLogTest() {\n        // We need to provide mock behavior for Tracer.logError\n        doNothing().when(tracer).logError(any(Throwable.class));\n        \n        // Create throwable to pass as a parameter\n        Throwable exception = new Exception(\"Test exception\");\n        String message = \"Test log message\";\n        \n        // Check call for each log level and verify the correct method was called\n        for (Level level : Level.values()) {\n            exceptionHandler.printLog(message, exception, level);\n            switch (level) {\n                case ERROR:\n                    verify(logger).error(message, exception);\n                    break;\n                case WARN:\n                    verify(logger).warn(message, exception);\n                    break;\n                case DEBUG:\n                    verify(logger).debug(message, exception);\n                    break;\n                case INFO:\n                    verify(logger).info(message, exception);\n                    break;\n                case TRACE:\n                    verify(logger).trace(message, exception);\n                    break;\n            }\n            \n            // Verify that Tracer.logError was called after each logging\n            verify(tracer).logError(exception);\n            \n            // Clear interactions so that we do not have cumulative verifications\n            clearInvocations(logger, tracer);\n        }\n    }\n\n    // We would need a mock implementation of the Logger interface\n    interface Logger {\n        void error(String message, Throwable ex);\n        void warn(String message, Throwable ex);\n        void debug(String message, Throwable ex);\n        void info(String message, Throwable ex);\n        void trace(String message, Throwable ex);\n    }\n\n    // We would need a mock implementation of Tracer and the logError method\n    static class Tracer {\n        static void logError(Throwable ex) {\n            // Log error\n        }\n    }\n\n    // Assuming we have a GlobalDefaultExceptionHandler class that uses logger and tracer\n    class GlobalDefaultExceptionHandler {\n        private final Logger logger;\n        private final Tracer tracer;\n        \n        // Constructor injection for dependencies\n        public GlobalDefaultExceptionHandler(Logger logger, Tracer tracer) {\n            this.logger = logger;\n            this.tracer = tracer;\n        }\n        \n        // Original method under test\n        private void printLog(String message, Throwable ex, Level logLevel) {\n            // ... original method code ...\n        }\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Captor;\nimport org.mockito.MockitoAnnotations;\nimport static org.mockito.Mockito.*;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class GlobalDefaultExceptionHandlerTest {\n    \n    private Logger logger;\n    private GlobalDefaultExceptionHandler exceptionHandler;\n    \n    @Captor\n    private ArgumentCaptor<String> stringCaptor;\n    \n    @Captor\n    private ArgumentCaptor<Throwable> throwableCaptor;\n    \n    @BeforeEach\n    public void setUp() {\n        logger = mock(Logger.class);\n        exceptionHandler = new GlobalDefaultExceptionHandler(logger);\n        MockitoAnnotations.openMocks(this);\n    }\n    \n    @Test\n    public void printLogTest() {\n        Throwable ex = new RuntimeException(\"Test exception\");\n        \n        // Test each log level\n        for (Level level : Level.values()) {\n            exceptionHandler.printLog(\"Test message\", ex, level);\n            switch (level) {\n                case ERROR:\n                    verify(logger).error(anyString(), same(ex));\n                    break;\n                case WARN:\n                    verify(logger).warn(anyString(), same(ex));\n                    break;\n                case DEBUG:\n                    verify(logger).debug(anyString(), same(ex));\n                    break;\n                case INFO:\n                    verify(logger).info(anyString(), same(ex));\n                    break;\n                case TRACE:\n                    verify(logger).trace(anyString(), same(ex));\n                    break;\n            }\n            \n            // Verify Tracer.logError is called with the exception\n            verify(logger).logError(same(ex));\n            \n            // Reset the mocks for the next iteration\n            reset(logger);\n        }\n    }\n    \n    // It's assumed that the custom Tracer class has a static method to log errors\n    // You would also need to mock this static method if it's not managed by logger\n    private static class Tracer {\n        public static void logError(Throwable ex) {\n            // Placeholder for the actual implementation of logging an error\n        }\n    }\n    \n    private static class GlobalDefaultExceptionHandler {\n        \n        private Logger logger;\n        \n        public GlobalDefaultExceptionHandler(Logger logger) {\n            this.logger = logger;\n        }\n        \n        // Assume this is the method you're testing\n        private void printLog(String message, Throwable ex, Level logLevel) {\n            // ... Existing implementation\n        }\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.*;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.slf4j.Logger;\n\nimport java.util.logging.Level;\n\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class GlobalDefaultExceptionHandlerTest {\n    @Mock\n    private Logger logger;\n    \n    @Mock\n    private Tracer tracer;\n    \n    @InjectMocks\n    private GlobalDefaultExceptionHandler exceptionHandler;\n\n    @Test\n    public void printLogTest() {\n        String testMessage = \"Test message\";\n        Throwable testException = new RuntimeException(\"Test exception\");\n        \n        doNothing().when(tracer).logError(any(Throwable.class));\n\n        // Test case for ERROR level logging\n        exceptionHandler.printLog(testMessage, testException, Level.ERROR);\n        verify(logger).error(testMessage, testException);\n        verify(tracer).logError(testException);\n\n        // Test case for WARN level logging\n        exceptionHandler.printLog(testMessage, testException, Level.WARN);\n        verify(logger).warn(testMessage, testException);\n        verify(tracer).logError(testException);\n\n        // Test case for DEBUG level logging\n        exceptionHandler.printLog(testMessage, testException, Level.DEBUG);\n        verify(logger).debug(testMessage, testException);\n        verify(tracer).logError(testException);\n\n        // Test case for INFO level logging\n        exceptionHandler.printLog(testMessage, testException, Level.INFO);\n        verify(logger).info(testMessage, testException);\n        verify(tracer).logError(testException);\n\n        // Test case for TRACE level logging\n        exceptionHandler.printLog(testMessage, testException, Level.TRACE);\n        verify(logger).trace(testMessage, testException);\n        verify(tracer).logError(testException);\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.*;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.slf4j.Logger;\n\nimport java.util.logging.Level;\n\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class GlobalDefaultExceptionHandlerTest {\n\n    @Mock\n    private Logger logger;\n\n    @Mock\n    private Tracer tracer;\n\n    @InjectMocks\n    private GlobalDefaultExceptionHandler handler = new GlobalDefaultExceptionHandler();\n\n    @Test\n    public void printLogTestError() {\n        Throwable ex = new RuntimeException(\"An error occurred\");\n        handler.printLog(\"Test error message\", ex, Level.ERROR);\n        verify(logger).error(\"Test error message\", ex);\n        verify(tracer).logError(ex);\n    }\n    \n    @Test\n    public void printLogTestWarn() {\n        Throwable ex = new RuntimeException(\"A warning occurred\");\n        handler.printLog(\"Test warn message\", ex, Level.WARN);\n        verify(logger).warn(\"Test warn message\", ex);\n        verify(tracer).logError(ex);\n    }\n    \n    @Test\n    public void printLogTestDebug() {\n        Throwable ex = new RuntimeException(\"A debug message\");\n        handler.printLog(\"Test debug message\", ex, Level.DEBUG);\n        verify(logger).debug(\"Test debug message\", ex);\n        verify(tracer).logError(ex);\n    }\n    \n    @Test\n    public void printLogTestInfo() {\n        Throwable ex = new RuntimeException(\"An info message\");\n        handler.printLog(\"Test info message\", ex, Level.INFO);\n        verify(logger).info(\"Test info message\", ex);\n        verify(tracer).logError(ex);\n    }\n    \n    @Test\n    public void printLogTestTrace() {\n        Throwable ex = new RuntimeException(\"A trace message\");\n        handler.printLog(\"Test trace message\", ex, Level.TRACE);\n        verify(logger).trace(\"Test trace message\", ex);\n        verify(tracer).logError(ex);\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.*;\nimport static org.mockito.Mockito.*;\n\npublic class GlobalDefaultExceptionHandlerTest {\n\n    private GlobalDefaultExceptionHandler handler;\n\n    @Captor\n    private ArgumentCaptor<String> stringCaptor;\n\n    @Captor\n    private ArgumentCaptor<Throwable> throwableCaptor;\n\n    @Mock\n    private Logger logger;\n\n    @Mock\n    private Tracer tracer;\n\n    @BeforeEach\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        handler = new GlobalDefaultExceptionHandler(logger, tracer);\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Optionally, clear resources or reset mocks after each test if needed.\n    }\n\n    @Test\n    public void printLogTest() {\n        // Arrange\n        String testMessage = \"Test message\";\n        Throwable testException = new RuntimeException(\"Test exception\");\n        Level[] logLevels = {Level.ERROR, Level.WARN, Level.DEBUG, Level.INFO, Level.TRACE};\n\n        // Act and Assert\n        for (Level logLevel : logLevels) {\n            handler.printLog(testMessage, testException, logLevel);\n\n            switch (logLevel) {\n                case ERROR:\n                    verify(logger).error(stringCaptor.capture(), throwableCaptor.capture());\n                    break;\n                case WARN:\n                    verify(logger).warn(stringCaptor.capture(), throwableCaptor.capture());\n                    break;\n                case DEBUG:\n                    verify(logger).debug(stringCaptor.capture(), throwableCaptor.capture());\n                    break;\n                case INFO:\n                    verify(logger).info(stringCaptor.capture(), throwableCaptor.capture());\n                    break;\n                case TRACE:\n                    verify(logger).trace(stringCaptor.capture(), throwableCaptor.capture());\n                    break;\n            }\n\n            assertEquals(testMessage, stringCaptor.getValue());\n            assertEquals(testException, throwableCaptor.getValue());\n\n            verify(tracer).logError(throwableCaptor.capture());\n            assertEquals(testException, throwableCaptor.getValue());\n            reset(logger);\n        }\n    }\n}",
        "package com.ctrip.framework.apollo.common.controller;\n\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.never;\n\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.Level;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class GlobalDefaultExceptionHandlerTest {\n    private Logger logger;\n    private Tracer tracer;\n    private GlobalDefaultExceptionHandler handler;\n    \n    @BeforeEach\n    public void setUp() {\n        logger = mock(Logger.class);\n        tracer = mock(Tracer.class);\n        handler = new GlobalDefaultExceptionHandler(logger, tracer); // Assuming you can inject mocks via constructor\n    }\n    \n    @Test\n    public void printLogTest() {\n        Throwable ex = new Exception(\"Test Exception\");\n        Level level = Level.ERROR;\n        String message = \"Test message\";\n\n        handler.printLog(message, ex, level);\n\n        verify(logger).error(eq(message), eq(ex));\n        verify(tracer).logError(eq(ex));\n        \n        // Optionally asserting that no other logging levels are being called\n        verify(logger, never()).warn(any(String.class), any(Throwable.class));\n        verify(logger, never()).debug(any(String.class), any(Throwable.class));\n        verify(logger, never()).info(any(String.class), any(Throwable.class));\n        verify(logger, never()).trace(any(String.class), any(Throwable.class));\n    }\n    \n    // Assuming GlobalDefaultExceptionHandler class has other methods to test\n    // Additional test methods would go here\n    \n}"
    ]
}