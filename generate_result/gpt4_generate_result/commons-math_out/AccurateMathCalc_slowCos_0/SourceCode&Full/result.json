{
    "project_name": "commons-math",
    "file_name": "AccurateMathCalc.java",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "execute_path": "commons-math/commons-math-core",
    "package": "org.apache.commons.math4.core.jdkmath",
    "docstring": "/**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */",
    "source_code": "\nstatic double slowCos(final double x, final double[] result) {\n\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        if ((i & 1) != 0) { // skip odd entries\n            continue;\n        }\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        if ((i & 2) != 0) { // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0]; ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
    "class_name": "AccurateMathCalc",
    "method_name": "slowCos",
    "arguments": [
        "double x",
        "double[] result"
    ],
    "generate_test": [
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void slowCosTest() {\n        // Test values within the range -2\u03c0 to 2\u03c0\n        double[] testValues = {-2 * Math.PI, -3 * Math.PI / 2, -Math.PI, -Math.PI / 2, -Math.PI / 4, 0, Math.PI / 4, Math.PI / 2, Math.PI, 3 * Math.PI / 2, 2 * Math.PI};\n        double[] result = new double[2];\n\n        for (double value : testValues) {\n            double expected = Math.cos(value);\n            double actual = AccurateMathCalc.slowCos(value, result);\n\n            // The result should be close to the value from Math.cos\n            assertEquals(expected, actual, DELTA, \"slowCos should approximate Math.cos for \" + value);\n\n            // Check if the extended precision result array (result) also matches the expectations (optional)\n            // This part of the test assumes the implementation of slowCos intends to return a high-precision result as its second return value\n            // We're not doing this part due to the lack of information regarding the split method's handling of extended precision results\n        }\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    @Test\n    public void slowCosTest() {\n        // Test for zero input\n        double[] result = new double[2];\n        double ans = AccurateMathCalc.slowCos(0.0, result);\n        assertEquals(1.0, ans, \"The cosine of 0 should be 1\");\n\n        // Compare against java.lang.Math.cos for a set of inputs\n        double[] inputs = {Math.PI / 6, Math.PI / 4, Math.PI / 3, Math.PI / 2, Math.PI};\n        for (double input : inputs) {\n            double expected = Math.cos(input);\n            ans = AccurateMathCalc.slowCos(input, null);\n            assertEquals(expected, ans, 1e-15, \"The cosine of \" + input + \" should be close to \" + expected);\n        }\n        \n        // Test if the result array is filled correctly when not null\n        ans = AccurateMathCalc.slowCos(Math.PI / 4, result);\n        assertNotNull(result, \"Result array should be filled\");\n        assertEquals(ans, result[0] + result[1], \"The result array should contain the split components of cos value for \" + (Math.PI / 4));\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double EPSILON = 1e-14;\n\n    @Test\n    public void slowCosTest() {\n        // Test using a known cosine value.\n        final double angle = Math.PI / 3; // 60 degrees\n        final double expectedResult = 0.5; // cos(60 degrees) = cos(pi/3) = 0.5\n        double[] result = new double[2];\n        \n        // Call the method under test\n        double actualResult = AccurateMathCalc.slowCos(angle, result);\n        \n        // Use an epsilon value for comparison of floating points\n        assertEquals(expectedResult, actualResult, EPSILON, \"The cosine value did not match the expected result\");\n        \n        // Testing edge case close to zero\n        double actualCosZero = AccurateMathCalc.slowCos(0.0, null);\n        assertEquals(1.0, actualCosZero, EPSILON, \"The cosine of 0 should be 1\");\n\n        // Testing edge case close to pi/2\n        double actualCosPiOverTwo = AccurateMathCalc.slowCos(Math.PI / 2, null);\n        assertEquals(0.0, actualCosPiOverTwo, EPSILON, \"The cosine of pi/2 should be 0\");\n\n        // Ensure that the extended result is also correct if provided\n        assertNotNull(result, \"The result array should not be null when passed to the method\");\n        assertEquals(expectedResult, result[0] + result[1], EPSILON, \"The extended precision result did not match expected result\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    \n    private static final double TOLERANCE = 1e-10;\n    \n    @Test\n    public void slowCosTest() {\n        // Test around zero\n        double[] result = new double[2];\n        assertEquals(Math.cos(0.0), AccurateMathCalc.slowCos(0.0, result), TOLERANCE, \"slowCos should be close to Math.cos for 0.0\");\n        assertEquals(Math.cos(0.0), result[0] + result[1], TOLERANCE, \"Result array should sum up to slowCos for 0.0\");\n\n        // Test around Pi/2\n        result = new double[2];\n        assertEquals(Math.cos(Math.PI / 2), AccurateMathCalc.slowCos(Math.PI / 2, result), TOLERANCE, \"slowCos should be close to Math.cos for Pi/2\");\n        assertEquals(Math.cos(Math.PI / 2), result[0] + result[1], TOLERANCE, \"Result array should sum up to slowCos for Pi/2\");\n\n        // Test around Pi\n        result = new double[2];\n        assertEquals(Math.cos(Math.PI), AccurateMathCalc.slowCos(Math.PI, result), TOLERANCE, \"slowCos should be close to Math.cos for Pi\");\n        assertEquals(Math.cos(Math.PI), result[0] + result[1], TOLERANCE, \"Result array should sum up to slowCos for Pi\");\n\n        // Test around 3*Pi/2\n        result = new double[2];\n        assertEquals(Math.cos(3 * Math.PI / 2), AccurateMathCalc.slowCos(3 * Math.PI / 2, result), TOLERANCE, \"slowCos should be close to Math.cos for 3*Pi/2\");\n        assertEquals(Math.cos(3 * Math.PI / 2), result[0] + result[1], TOLERANCE, \"Result array should sum up to slowCos for 3*Pi/2\");\n\n        // Test null result array does not cause an exception\n        assertDoesNotThrow(() -> AccurateMathCalc.slowCos(Math.PI, null), \"Passing null result array should not throw an exception\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void slowCosTest() {\n        // Angle close to 0\n        double result = AccurateMathCalc.slowCos(0.0, null);\n        assertEquals(Math.cos(0.0), result, 1e-9, \"Cosine of 0 should be 1\");\n\n        // Angle is PI / 2\n        result = AccurateMathCalc.slowCos(Math.PI / 2, null);\n        assertEquals(Math.cos(Math.PI / 2), result, 1e-9, \"Cosine of PI / 2 should be close to 0\");\n\n        // Angle is PI\n        result = AccurateMathCalc.slowCos(Math.PI, null);\n        assertEquals(Math.cos(Math.PI), result, 1e-9, \"Cosine of PI should be -1\");\n\n        // Test with supplied result array to check extended precision\n        double[] extendedResult = new double[2];\n        result = AccurateMathCalc.slowCos(Math.PI / 4, extendedResult);\n        double expected = Math.cos(Math.PI / 4);\n        double actualExtended = extendedResult[0] + extendedResult[1];\n        assertEquals(expected, result, 1e-9, \"Cosine of PI / 4 should be sqrt(2)/2\");\n        assertEquals(expected, actualExtended, 1e-9, \"Extended precision result of PI / 4 should be close to sqrt(2)/2\");\n\n        // Test for negative angle\n        result = AccurateMathCalc.slowCos(-Math.PI / 3, null);\n        assertEquals(Math.cos(-Math.PI / 3), result, 1e-9, \"Cosine of -PI / 3 should be 0.5\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void slowCosTest() {\n        double x = 0.5; // Test value in radians, within range for which the Taylor series is accurate\n        double delta = 1e-9; // Acceptable delta error for the approximation vs. Math.cos\n        double[] result = new double[2];\n        double slowCosResult = AccurateMathCalc.slowCos(x, result);\n\n        // Check the slowCos against Math.cos for accuracy\n        assertEquals(Math.cos(x), slowCosResult, delta);\n\n        // We can also verify the result array for extended precision\n        double expectedHighPrecisionResult = result[0] + result[1];\n        assertEquals(Math.cos(x), expectedHighPrecisionResult, delta,\n                     \"Extended precision result not close enough to Math.cos\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double TOLERANCE = 1e-9;\n\n    @Test\n    public void slowCosTest() {\n        // Test values around zero, pi/2, pi, and 3*pi/2\n        double testValues[] = {0, Math.PI / 2, Math.PI, 3 * Math.PI / 2};\n\n        for (double angle : testValues) {\n            double expectedCos = Math.cos(angle);\n            double[] result = new double[2];\n            double slowCos = AccurateMathCalc.slowCos(angle, result);\n\n            assertEquals(expectedCos, slowCos, TOLERANCE, \"Incorrect cosine value for angle: \" + angle);\n        }\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double TOLERANCE = 1e-12;\n\n    @Test\n    public void slowCosTest() {\n        double[] testValues = {0.0, Math.PI / 6, Math.PI / 4, Math.PI / 3, Math.PI / 2};\n        double[] expectedResult = {1.0, Math.sqrt(3) / 2, Math.sqrt(2) / 2, 0.5, 0.0};\n        double[] resultContainer = new double[2];\n\n        for (int i = 0; i < testValues.length; i++) {\n            double result = AccurateMathCalc.slowCos(testValues[i], resultContainer);\n            double expected = expectedResult[i];\n            assertEquals(expected, result, TOLERANCE, \"SlowCos does not match standard Math.cos for angle \" + testValues[i]);\n        }\n\n        // Test that resultContainer returns the same result\n        for (int i = 0; i < testValues.length; i++) {\n            AccurateMathCalc.slowCos(testValues[i], resultContainer);\n            double combinedResult = resultContainer[0] + resultContainer[1];\n            assertEquals(expectedResult[i], combinedResult, TOLERANCE, \"Result container does not match expected result for angle \" + testValues[i]);\n        }\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void slowCosTest() {\n        final double delta = 1e-9;\n        double x = Math.PI / 4; // Test input for cosine\n        double expectedCos = Math.cos(x); // Expected value using Math.cos\n        double[] result = new double[2];\n        double actualCos = AccurateMathCalc.slowCos(x, result);\n\n        // Check the main result is close to the expected value\n        assertEquals(expectedCos, actualCos, delta, \"slowCos result differs from Math.cos\");\n\n        // Check the split parts when added give the correct result\n        double splitCos = result[0] + result[1];\n        assertEquals(expectedCos, splitCos, delta, \"The sum of split parts of slowCos does not match expected value.\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double TOLERANCE = 1e-15;\n\n    @Test\n    public void slowCosTest() {\n        // Test for angle 0\n        assertEquals(Math.cos(0.0), AccurateMathCalc.slowCos(0.0, null), TOLERANCE);\n\n        // Test for angle PI/4\n        assertEquals(Math.cos(Math.PI / 4), AccurateMathCalc.slowCos(Math.PI / 4, null), TOLERANCE);\n        \n        // Test for angle PI/2\n        assertEquals(Math.cos(Math.PI / 2), AccurateMathCalc.slowCos(Math.PI / 2, null), TOLERANCE);\n\n        // Test for negative angle -PI/4\n        assertEquals(Math.cos(-Math.PI / 4), AccurateMathCalc.slowCos(-Math.PI / 4, null), TOLERANCE);\n\n        // Test with result array\n        double[] result = new double[2];\n        double expected = Math.cos(Math.PI / 3);\n        double actual = AccurateMathCalc.slowCos(Math.PI / 3, result);\n        double highPrecisionResult = result[0] + result[1];\n\n        assertEquals(expected, actual, TOLERANCE, \"Regular precision result mismatch\");\n        assertEquals(expected, highPrecisionResult, TOLERANCE, \"High precision result mismatch\");\n    }\n}"
    ]
}