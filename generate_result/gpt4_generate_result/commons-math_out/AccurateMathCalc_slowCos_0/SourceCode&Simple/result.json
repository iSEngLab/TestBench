{
    "project_name": "commons-math",
    "file_name": "AccurateMathCalc.java",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "execute_path": "commons-math/commons-math-core",
    "package": "org.apache.commons.math4.core.jdkmath",
    "docstring": "/**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */",
    "source_code": "\nstatic double slowCos(final double x, final double[] result) {\n\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        if ((i & 1) != 0) { // skip odd entries\n            continue;\n        }\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        if ((i & 2) != 0) { // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0]; ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
    "class_name": "AccurateMathCalc",
    "method_name": "slowCos",
    "arguments": [
        "double x",
        "double[] result"
    ],
    "generate_test": [
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void slowCosTest() {\n        // Test values\n        double epsilon = 1e-10;\n        double testAngleDegrees = 45.0;\n        double testAngleRadians = Math.toRadians(testAngleDegrees);\n        \n        // Expected result from Math.cos for comparison\n        double expectedCosValue = Math.cos(testAngleRadians);\n        \n        // Array to place the high-precision result\n        double[] result = new double[2];\n        \n        // Call the method under test\n        double actualCosValue = AccurateMathCalc.slowCos(testAngleRadians, result);\n        \n        // Verify the high-precision result is close to the expected value\n        assertEquals(expectedCosValue, result[0] + result[1], epsilon, \"The slowCos result should be close to the Math.cos result.\");\n        \n        // If the result is not supposed to be split across two numbers, also check the main result\n        assertEquals(expectedCosValue, actualCosValue, epsilon, \"The returned slowCos value should be close to the Math.cos result.\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void slowCosTest() {\n        // Since no details of the `split`, `splitMult`, `splitReciprocal`, and `splitAdd` methods are provided,\n        // we will simply test for known cosine values.\n        double[] result = new double[2];\n        \n        // Test for zero\n        assertEquals(Math.cos(0.0), AccurateMathCalc.slowCos(0.0, result), DELTA, \"slowCos should match Math.cos for 0.0\");\n        \n        // Test for Pi/2\n        assertEquals(Math.cos(Math.PI / 2), AccurateMathCalc.slowCos(Math.PI / 2, result), DELTA, \"slowCos should match Math.cos for PI/2\");\n        \n        // Test for Pi\n        assertEquals(Math.cos(Math.PI), AccurateMathCalc.slowCos(Math.PI, result), DELTA, \"slowCos should match Math.cos for PI\");\n        \n        // Test for 3Pi/2\n        assertEquals(Math.cos(3 * Math.PI / 2), AccurateMathCalc.slowCos(3 * Math.PI / 2, result), DELTA, \"slowCos should match Math.cos for 3PI/2\");\n        \n        // Test for 2Pi\n        assertEquals(Math.cos(2 * Math.PI), AccurateMathCalc.slowCos(2 * Math.PI, result), DELTA, \"slowCos should match Math.cos for 2PI\");\n        \n        // Test if the method fulfills the contract of filling the provided `result` array\n        double expectedValue = Math.cos(2.0);\n        AccurateMathCalc.slowCos(2.0, result);\n        double actualValue = result[0] + result[1];\n        assertEquals(expectedValue, actualValue, DELTA, \"Result array should contain the sum of split parts equaling the computed value for cos(2.0)\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n  \n    private static final double DELTA = 1e-15; // Define a delta for comparing double values\n\n    @Test\n    public void slowCosTest() {\n        double[] result = new double[2];\n        double[] expected = new double[2];\n        \n        // Case 1: cos(0) should return 1\n        assertEquals(Math.cos(0), AccurateMathCalc.slowCos(0, result), DELTA);\n        expected[0] = Math.cos(0); // Expected high precision part\n        expected[1] = 0; // Expected low precision part (assuming split)\n        assertArrayEquals(expected, result, DELTA, \"Result for cos(0)\");\n        \n        // Case 2: cos(PI / 2) should return close to 0\n        assertEquals(Math.cos(Math.PI / 2), AccurateMathCalc.slowCos(Math.PI / 2, result), DELTA);\n        expected[0] = Math.cos(Math.PI / 2); // Expected high precision part\n        expected[1] = 0; // Expected low precision part (assuming split)\n        assertArrayEquals(expected, result, DELTA, \"Result for cos(PI / 2)\");\n        \n        // Case 3: cos(PI) should return -1\n        assertEquals(Math.cos(Math.PI), AccurateMathCalc.slowCos(Math.PI, result), DELTA);\n        expected[0] = Math.cos(Math.PI); // Expected high precision part\n        expected[1] = 0; // Expected low precision part (assuming split)\n        assertArrayEquals(expected, result, DELTA, \"Result for cos(PI)\");\n        \n        // You can add more test cases for different angles if necessary\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    // Tolerance for comparison of floating-point numbers\n    private static final double EPSILON = 1e-15;\n\n    @Test\n    public void slowCosTest() {\n        double angle;\n        double[] result = new double[2];\n        double expected;\n        double actual;\n        \n        // Test for angle 0\n        angle = 0;\n        expected = Math.cos(angle); // Expected value from java.lang.Math\n        actual = AccurateMathCalc.slowCos(angle, result);\n        assertEquals(expected, actual, EPSILON, \"The slowCos method did not return the expected value for angle 0\");\n\n        // Test for angle PI/2\n        angle = Math.PI / 2;\n        expected = Math.cos(angle); // Expected value from java.lang.Math\n        actual = AccurateMathCalc.slowCos(angle, result);\n        assertEquals(expected, actual, EPSILON, \"The slowCos method did not return the expected value for angle PI/2\");\n\n        // Test for angle PI\n        angle = Math.PI;\n        expected = Math.cos(angle); // Expected value from java.lang.Math\n        actual = AccurateMathCalc.slowCos(angle, result);\n        assertEquals(expected, actual, EPSILON, \"The slowCos method did not return the expected value for angle PI\");\n\n        // Test for angle 3PI/2\n        angle = 3 * Math.PI / 2;\n        expected = Math.cos(angle); // Expected value from java.lang.Math\n        actual = AccurateMathCalc.slowCos(angle, result);\n        assertEquals(expected, actual, EPSILON, \"The slowCos method did not return the expected value for angle 3PI/2\");\n\n        // Test for a negative angle -PI/4\n        angle = -Math.PI / 4;\n        expected = Math.cos(angle); // Expected value from java.lang.Math\n        actual = AccurateMathCalc.slowCos(angle, result);\n        assertEquals(expected, actual, EPSILON, \"The slowCos method did not return the expected value for angle -PI/4\");\n\n        // Test result parameter being filled properly\n        angle = Math.PI / 3; // 60 degrees\n        expected = Math.cos(angle); // Expected value from java.lang.Math\n        actual = AccurateMathCalc.slowCos(angle, result);\n        assertEquals(expected, result[0] + result[1], EPSILON, \"The slowCos method did not fill the result array with the expected value\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void slowCosTest() {\n        final double delta = 1e-9; // Define a tolerance level for floating-point comparison\n        double input;\n        double expected;\n        double[] result = new double[2];\n        \n        // Test 1: cos(0) = 1\n        input = 0;\n        expected = Math.cos(input);\n        assertEquals(expected, AccurateMathCalc.slowCos(input, result), delta);\n        assertEquals(expected, result[0], delta);\n        \n        // Test 2: cos(pi/2) = 0\n        input = Math.PI / 2;\n        expected = Math.cos(input);\n        assertEquals(expected, AccurateMathCalc.slowCos(input, result), delta);\n        assertEquals(expected, result[0], delta);\n        \n        // Test 3: cos(pi) = -1\n        input = Math.PI;\n        expected = Math.cos(input);\n        assertEquals(expected, AccurateMathCalc.slowCos(input, result), delta);\n        assertEquals(expected, result[0], delta);\n        \n        // Test 4: cos(3pi/2) = 0\n        input = 3 * Math.PI / 2;\n        expected = Math.cos(input);\n        assertEquals(expected, AccurateMathCalc.slowCos(input, result), delta);\n        assertEquals(expected, result[0], delta);\n        \n        // Test 5: cos(2pi) = 1\n        input = 2 * Math.PI;\n        expected = Math.cos(input);\n        assertEquals(expected, AccurateMathCalc.slowCos(input, result), delta);\n        assertEquals(expected, result[0], delta);\n        \n        // Test with null result\n        assertEquals(Math.cos(0), AccurateMathCalc.slowCos(0, null), delta);\n        \n        // Note: More tests can be added for a more thorough test coverage, especially for edge cases.\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void slowCosTest() {\n        double tolerance = 1e-15;\n\n        // Test case for cos(0)\n        double[] result0 = new double[2];\n        assertEquals(Math.cos(0), AccurateMathCalc.slowCos(0, result0), tolerance, \n            \"The cosine of 0 should be 1\");\n        assertEquals(1.0, result0[0] + result0[1], tolerance, \n            \"Result array should also contain the cosine of 0\");\n\n        // Test case for cos(PI/2)\n        double[] resultPiOver2 = new double[2];\n        assertEquals(Math.cos(Math.PI / 2), AccurateMathCalc.slowCos(Math.PI / 2, resultPiOver2), tolerance, \n            \"The cosine of PI/2 should be 0\");\n        assertEquals(0.0, resultPiOver2[0] + resultPiOver2[1], tolerance, \n            \"Result array should also contain the cosine of PI/2\");\n\n        // Test case for cos(PI)\n        double[] resultPi = new double[2];\n        assertEquals(Math.cos(Math.PI), AccurateMathCalc.slowCos(Math.PI, resultPi), tolerance, \n            \"The cosine of PI should be -1\");\n\n        // Test case for cos(3PI/2)\n        double[] result3PiOver2 = new double[2];\n        assertEquals(Math.cos(3 * Math.PI / 2), AccurateMathCalc.slowCos(3 * Math.PI / 2, result3PiOver2), tolerance, \n            \"The cosine of 3PI/2 should be 0\");\n\n        // Test case for cos(2PI)\n        double[] result2Pi = new double[2];\n        assertEquals(Math.cos(2 * Math.PI), AccurateMathCalc.slowCos(2 * Math.PI, result2Pi), tolerance, \n            \"The cosine of 2PI should be 1\");\n\n        // Additional test with a non-special angle, cos(1)\n        double[] result1 = new double[2];\n        assertEquals(Math.cos(1), AccurateMathCalc.slowCos(1, result1), tolerance, \n            \"The cosine of 1 should match the Math.cos result\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AccurateMathCalcTest {\n\n    private static final double EPSILON = 1e-6; // A small delta for comparing double values\n\n    @Test\n    public void slowCosTest() {\n        // Test the method with different `x` values\n        double[] result = new double[2];\n        double value;\n\n        // Test for x = 0\n        value = AccurateMathCalc.slowCos(0.0, result);\n        assertEquals(Math.cos(0.0), value, EPSILON, \"The cosine of 0 should be 1\");\n\n        // Test for x = \u03c0/2\n        value = AccurateMathCalc.slowCos(Math.PI / 2, result);\n        assertEquals(Math.cos(Math.PI / 2), value, EPSILON, \"The cosine of \u03c0/2 should be close to 0\");\n\n        // Test for x = \u03c0\n        value = AccurateMathCalc.slowCos(Math.PI, result);\n        assertEquals(Math.cos(Math.PI), value, EPSILON, \"The cosine of \u03c0 should be -1\");\n\n        // Test for x = 3\u03c0/2\n        value = AccurateMathCalc.slowCos(3 * Math.PI / 2, result);\n        assertEquals(Math.cos(3 * Math.PI / 2), value, EPSILON, \"The cosine of 3\u03c0/2 should be close to 0\");\n\n        // Test for large x value which should be within the periodic range [-\u03c0, \u03c0]\n        value = AccurateMathCalc.slowCos(10 * Math.PI, result);\n        assertEquals(Math.cos(10 * Math.PI), value, EPSILON, \"The cosine of 10\u03c0 should be 1\");\n\n        // Check if result array is properly filled if not null\n        value = AccurateMathCalc.slowCos(Math.PI / 4, result);\n        assertEquals(Math.cos(Math.PI / 4), result[0] + result[1], EPSILON, \"The sum of result's components should match cosine value\");\n\n        // boundary conditions such as NaN and infinities can also be tested\n        value = AccurateMathCalc.slowCos(Double.NaN, result);\n        assertEquals(Double.NaN, value, \"The cosine of NaN should be NaN\");\n\n        value = AccurateMathCalc.slowCos(Double.POSITIVE_INFINITY, result);\n        assertEquals(Double.NaN, value, \"The cosine of positive infinity should be NaN\");\n\n        value = AccurateMathCalc.slowCos(Double.NEGATIVE_INFINITY, result);\n        assertEquals(Double.NaN, value, \"The cosine of negative infinity should be NaN\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double TOLERANCE = 1e-9;\n\n    @Test\n    public void slowCosTest() {\n        double[] result = new double[2];\n        \n        // Test with specific values including\n        // 0, PI/2, PI, 3*PI/2, etc.\n        double[] testValues = {0, Math.PI / 2, Math.PI, 3 * Math.PI / 2};\n\n        for (double value : testValues) {\n            double expected = Math.cos(value);\n            double actual = AccurateMathCalc.slowCos(value, result);\n\n            // Allow a small difference due to precision differences\n            assertEquals(expected, actual, TOLERANCE,\n                         \"The slowCos method does not produce the expected result for: \" + value);\n            // You could also use this alternative check for array values:\n            double[] expectedArray = new double[]{expected, 0.0};\n            assertArrayEquals(expectedArray, result, TOLERANCE,\n                         \"The slowCos output array does not match the expected result for: \" + value);\n        }\n        \n        // Edge cases\n        // Test the function at the boundaries of the input domain or special cases\n        // For example, we decide to test some large number to check consistency\n        double largeValue = 12345.6789;\n        double expectedLarge = Math.cos(largeValue);\n        double actualLarge = AccurateMathCalc.slowCos(largeValue, result);\n\n        assertEquals(expectedLarge, actualLarge, TOLERANCE,\n                     \"The slowCos method does not produce the expected result for a large input value.\");\n\n        // Null result array\n        // Verify the function does not throw an exception when result array is null.\n        // If the real implementation should throw a NullPointerException,\n        // this test should expect it.\n        assertDoesNotThrow(() -> AccurateMathCalc.slowCos(Math.PI / 4, null),\n                           \"The slowCos method should not throw an exception when the result array is null.\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    \n    private static final double DELTA = 1e-15;\n   \n    @Test\n    public void slowCosTest() {\n        double[] result = new double[2];\n        double x = Math.PI / 4; // 45 degrees\n        double expected = Math.cos(x);\n        double actual = AccurateMathCalc.slowCos(x, result);\n        \n        // First, assert the computational result is close to Math.cos\n        assertEquals(expected, actual, DELTA, \"The slowCos computation should approximate the cosine properly.\");\n\n        // Second, assert that the result has been stored correctly\n        assertNotNull(result, \"Result array should not be null.\");\n        assertEquals(2, result.length, \"Result array should have a length of 2.\");\n        \n        // Verify its correctness in the result array\n        assertEquals(expected, result[0] + result[1], DELTA, \"The split cosine value should be close to the correct value.\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    \n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void slowCosTest() {\n        // Arrange\n        double angle = 0.0; // angle for which cos(angle) is known to be 1\n        double[] result = new double[2];\n        \n        // Act\n        double cosValue = AccurateMathCalc.slowCos(angle, result);\n\n        // Assert\n        assertEquals(Math.cos(angle), cosValue, DELTA, \"The cosine of 0 should be 1\");\n        assertEquals(1.0, result[0] + result[1], DELTA, \"The split cosine of 0 should sum to 1\");\n        \n        // Additional test cases can include different angles (e.g., Math.PI / 2, Math.PI, 3 * Math.PI / 2, etc.)\n        // You can also test edge cases like very large inputs or negative inputs\n    }\n}"
    ]
}