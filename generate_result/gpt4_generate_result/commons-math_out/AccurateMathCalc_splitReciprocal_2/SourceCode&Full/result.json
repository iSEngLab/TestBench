{
    "project_name": "commons-math",
    "file_name": "AccurateMathCalc.java",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "execute_path": "commons-math/commons-math-core",
    "package": "org.apache.commons.math4.core.jdkmath",
    "docstring": "/** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */",
    "source_code": "\nstatic void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n\n    /* Resplit */\n    resplit(result);\n\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}\n",
    "class_name": "AccurateMathCalc",
    "method_name": "splitReciprocal",
    "arguments": [
        "double[] in",
        "double[] result"
    ],
    "generate_test": [
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double EPSILON = 1e-12;\n\n    @Test\n    public void splitReciprocalTest() {\n        // Define the input array for testing the splitReciprocal method\n        double[] input = {2.0, 0.5};\n        double[] expectedResult = new double[2];\n        double[] actualResult = new double[2];\n\n        // Calculate the expected result manually\n        expectedResult[0] = 1.0 / input[0];\n        expectedResult[1] = (1.0 * input[0] - (1.0 - 1.0 / 4194304.0) * input[1]) / (input[0] * input[0] + input[0] * input[1]);\n\n        // Call the method under test\n        AccurateMathCalc.splitReciprocal(input, actualResult);\n\n        // Check that the results are as expected\n        assertAll(() -> assertEquals(expectedResult[0], actualResult[0], EPSILON, \"The most significant part of the reciprocal should match.\"),\n                  () -> assertEquals(expectedResult[1], actualResult[1], EPSILON, \"The least significant part of the reciprocal should match.\"));\n\n        // Additional Tests for edge cases (such as input[0] == 0)\n        double[] inputForEdgeCase = {0.0, 5.0};\n        double[] edgeCaseResult = new double[2];\n\n        // Expectation when first element is zero\n        expectedResult[0] = 1.0 / inputForEdgeCase[1];\n        expectedResult[1] = 0.0; // based on the condition in the method\n\n        // Call the method with the edge case input\n        AccurateMathCalc.splitReciprocal(inputForEdgeCase, edgeCaseResult);\n\n        // Check that the results are accurate for the edge case as well\n        assertAll(() -> assertEquals(expectedResult[0], edgeCaseResult[0], EPSILON, \"When the first element is zero, the reciprocal's most significant part should match the second element's reciprocal.\"),\n                  () -> assertEquals(expectedResult[1], edgeCaseResult[1], EPSILON, \"When the first element is zero, the reciprocal's least significant part should be zero.\"));\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AccurateMathCalcTest {\n\n    private static final double EPSILON = 1e-15;\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] inputNonZero = new double[] {3.0, 4.0};\n        double[] inputZero = new double[] {0.0, 4.0};\n        double[] expectedOutputNonZero = new double[2];\n        double[] expectedOutputZero = new double[2];\n        double[] outputNonZero = new double[2];\n        double[] outputZero = new double[2];\n\n        // Expected results calculated manually or by an external means\n        expectedOutputNonZero[0] = 0.3333333333333333;\n        expectedOutputNonZero[1] = -1.666667470136045E-17;\n\n        // Non-zero input splitReciprocal calculation\n        AccurateMathCalc.splitReciprocal(inputNonZero, outputNonZero);\n        assertArrayEquals(expectedOutputNonZero, outputNonZero, EPSILON);\n\n        // Zero input handling in splitReciprocal calculation\n        AccurateMathCalc.splitReciprocal(inputZero, outputZero);\n        // The result should be [0.25, 0.0], since the second component becomes zero after the reciprocal calculation.\n        assertEquals(0.25, outputZero[0], EPSILON);\n        assertEquals(0.0, outputZero[1], EPSILON);\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] input = {2.0, 0.5}; // Input values must be strictly positive.\n        double[] result = new double[2];\n\n        // Calculate reciprocal using splitReciprocal method\n        AccurateMathCalc.splitReciprocal(input, result);\n\n        // Expecting 1/2.0 for the most significant bits\n        double reciprocalMSB = 1.0 / input[0];\n\n        // Verify that the result's most significant bits are as expected\n        assertEquals(reciprocalMSB, result[0], \"Most significant bits do not match the expected reciprocal of the input.\");\n\n        // Verify the invariant: (result[0] + result[1]) * (input[0] + input[1]) \u2248 1\n        double product = (result[0] + result[1]) * (input[0] + input[1]);\n        assertEquals(1.0, product, 1e-10, \"The product of the input and reciprocal does not approximate 1 closely enough.\");\n\n        // Check special case where input[0] is zero\n        input[0] = 0.0;\n        AccurateMathCalc.splitReciprocal(input, result);\n        product = (result[0] + result[1]) * (input[1]);\n        assertEquals(1.0, product, 1e-10, \"The product of the input and reciprocal does not approximate 1 closely enough when the first element of input is zero.\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    \n    @Test\n    public void splitReciprocalTest() {\n        // Setup input values and a target array for the result\n        double[] input = {2.0, 0.0}; // split form of 2.0\n        double[] result = new double[2];\n        \n        // Call the method under test\n        AccurateMathCalc.splitReciprocal(input, result);\n        \n        // Prepare the expected values (reciprocal of 2.0)\n        double expectedValue = 0.5;\n        \n        // Check that the result in split form represents the expected reciprocal value\n        assertTrue(result[0] <= expectedValue && (result[0] + result[1]) >= expectedValue,\n                   \"Reciprocal calculation does not provide the expected results\");\n        \n        // Since the second part of a split is often an adjustment for precision,\n        // we check that the result is close to the expected value within a small epsilon.\n        double epsilon = 1e-15;\n        assertEquals(expectedValue, result[0] + result[1], epsilon,\n                     \"Reciprocal calculation does not match within an acceptable error margin.\");\n    }\n    \n    // Additional test cases can be added to verify other edge cases and behaviors\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class AccurateMathCalcTest {\n    private static final double EPSILON = 1e-15;\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] input = {2.0, 0.5};\n        double[] expectedResult = {0.25, 0.0};\n        double[] result = new double[2];\n\n        AccurateMathCalc.splitReciprocal(input, result);\n\n        assertTrue(Math.abs(expectedResult[0] - result[0]) < EPSILON,\n                \"The splitReciprocal method did not produce the expected most significant part of the result.\");\n        assertTrue(Math.abs(expectedResult[1] - result[1]) < EPSILON,\n                \"The splitReciprocal method did not produce the expected least significant part of the result.\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        double[] input = new double[] {2.0, 0.5};\n        double[] result = new double[2];\n\n        // Call the method to test\n        AccurateMathCalc.splitReciprocal(input, result);\n\n        // Verify the results\n        double a = 1.0 - (1.0 / 4194304.0);\n        double expectedResult0 = a / input[0];\n        double expectedResult1 = ((1.0 / 4194304.0) * input[0] - a * input[1]) / (input[0] * input[0] + input[0] * input[1]);\n\n        // Fix NaN to the expected value if required\n        if (Double.isNaN(expectedResult1)) {\n            expectedResult1 = 0.0;\n        }\n\n        // Check the first part of the result\n        assertEquals(expectedResult0, result[0], \"The first part of the split reciprocal is incorrect\");\n\n        // Check the second part of the result within a tolerance since it involves more operations\n        assertEquals(expectedResult1, result[1], 1e-15, \"The second part of the split reciprocal is incorrect\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double EPSILON = 1e-15;\n\n    @Test\n    public void splitReciprocalTest() {\n        final double inValue = 2.0;\n        final double[] in = {inValue, 0.0};\n        final double[] result = new double[2];\n        final double expectedReciprocal = 1.0 / inValue;\n\n        AccurateMathCalc.splitReciprocal(in, result);\n\n        double actualReciprocal = result[0] + result[1];\n        assertEquals(expectedReciprocal, actualReciprocal, EPSILON,\n            \"The reciprocal does not match the expected value\");\n\n        // Additional test: handling zero as input\n        final double[] zeroIn = {0.0, 2.0};\n        AccurateMathCalc.splitReciprocal(zeroIn, result);\n        \n        // When zero is encountered, it is expected to use the second element of the array\n        double zeroActualReciprocal = result[0] + result[1];\n        assertEquals(1.0 / zeroIn[1], zeroActualReciprocal, EPSILON,\n            \"The reciprocal for zero input does not match the expected value\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] input = {2.0, 0.5};\n        double[] result = new double[2];\n        AccurateMathCalc.splitReciprocal(input, result);\n\n        // Expected result calculated manually\n        double expectedReciprocalFirstPart = 0.5;\n        double expectedReciprocalSecondPart = -0.125;\n\n        // Assert that the reciprocal was split correctly (with a small delta for floating point errors)\n        assertEquals(expectedReciprocalFirstPart, result[0], DELTA, \"The first part of the split reciprocal should equal 0.5\");\n        assertEquals(expectedReciprocalSecondPart, result[1], DELTA, \"The second part of the split reciprocal should equal -0.125\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.junit.jupiter.api.Test;\n\npublic class AccurateMathCalcTest {\n\n    @Test\n    public void splitReciprocalTest() {\n        double[][] inputPairs = {\n            {1.0, 0.0},\n            {2.0, 0.5},\n            {4.0, 1.0},\n            {8.0, 2.0},\n            {16.0, 4.0}\n        };\n\n        double[][] expectedResults = {\n            {1.0, 0.0},\n            {0.5, 0.0},\n            {0.25, 0.0},\n            {0.125, 0.0},\n            {0.0625, 0.0}\n        };\n\n        for (int i = 0; i < inputPairs.length; i++) {\n            double[] result = new double[2];\n            AccurateMathCalc.splitReciprocal(inputPairs[i], result);\n\n            // Using a delta due to floating-point arithmetic inaccuracies\n            final double delta = 1e-15;\n            assertArrayEquals(expectedResults[i], result, delta,\n                \"The splitReciprocal result for input \" + inputPairs[i][0] + \" was expected to equal the expected result\");\n        }\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double EPSILON = 1e-15;\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = new double[] {2.0, 1.0};\n        double[] expected = new double[] {0.5, -0.25};\n        double[] result = new double[2];\n\n        AccurateMathCalc.splitReciprocal(in, result);\n\n        // Compare both parts of the reciprocal independently\n        assertArrayEquals(expected, result, EPSILON, \"The split reciprocal did not match the expected values.\");\n    }\n}"
    ]
}