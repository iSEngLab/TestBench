{
    "project_name": "commons-math",
    "file_name": "AccurateMathCalc.java",
    "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
    "execute_path": "commons-math/commons-math-core",
    "package": "org.apache.commons.math4.core.jdkmath",
    "docstring": "/** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */",
    "source_code": "\nstatic void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n\n    /* Resplit */\n    resplit(result);\n\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}\n",
    "class_name": "AccurateMathCalc",
    "method_name": "splitReciprocal",
    "arguments": [
        "double[] in",
        "double[] result"
    ],
    "generate_test": [
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    static void splitReciprocal(final double[] in, final double[] result) {\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n                result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err *= result[0] + result[1];\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n\n    private static void resplit(double[] a) {\n        // This would be the implementation of the resplit method.\n        // For this example, we will assume it modifies the array in some way.\n        // Replace with actual implementation.\n    }\n\n    @Test\n    public void splitReciprocalTest() {\n        double in[] = {123456.0, 654321.0};\n        double[] result = {0.0, 0.0};\n        splitReciprocal(in, result);\n\n        double expectedValue0 = 1.0 - (1.0 / 4194304.0) / in[0];\n        double b = 1.0 / 4194304.0;\n        double a = 1.0 - b;\n        double expectedValue1 = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n        \n        // Add a small tolerance for floating-point comparisons\n        double tolerance = 1e-14;\n        \n        // Assert that the results are as expected\n        assertEquals(expectedValue0, result[0], tolerance, \"The first result element is incorrect\");\n        assertEquals(expectedValue1, result[1], tolerance, \"The second result element is incorrect\");\n\n        // Additional checks for special conditions (such as NaN or infinite results) can be added as needed\n        assertFalse(Double.isNaN(result[1]), \"The second result element should not be NaN\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    // Method assumed to be part of the same class as the splitReciprocal method\n    public static void resplit(double[] a) {\n        // Just a placeholder since the actual implemenation of resplit is not provided\n        // Assuming resplit logic as simple splitting process\n        for (int i = 0; i < a.length; i++) {\n            a[i] /= 2.0;\n        }\n    }\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = new double[]{2.0, 3.0};\n        double[] expected = new double[] { 0.5 / 2.0, (-3.0 / 2.0) / 4.0 };\n        double[] result = new double[2];\n\n        AccurateMathCalcTest.splitReciprocal(in, result);\n\n        assertArrayEquals(expected, result, \"The splitReciprocal method did not produce the expected result\");\n\n        // Testing edge case - input with first element as zero.\n        in = new double[]{0.0, 3.0};\n        double[] expectedForZeroCase = new double[]{0.5 / 3.0, -0.5 / 9.0}; // Assuming the `resplit` logic similar as above simple splitting.\n        AccurateMathCalcTest.splitReciprocal(in, result);\n\n        assertArrayEquals(expectedForZeroCase, result, \"The splitReciprocal method did not handle zero input as expected\");\n\n        // Test for NaN handling\n        in = new double[]{2.0, Double.NaN};\n        double[] resultWithNaN = new double[2];\n        AccurateMathCalcTest.splitReciprocal(in, resultWithNaN);\n\n        assertFalse(Double.isNaN(resultWithNaN[1]), \"The splitReciprocal method did not handle NaN values as expected\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double EPSILON = 1e-10;\n\n    private static void resplit(double[] a) {\n        // Mock implementation of resplit\n        double c = a[0] + a[1];\n        double d = -(c - a[0] - a[1]);\n        a[0] = c;\n        a[1] = d;\n    }\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = new double[] {2.0, 1.0};\n        double[] result = new double[2];\n        \n        // Call the method to test\n        AccurateMathCalc.splitReciprocal(in, result);\n        \n        double expectedA = 0.5 * (1.0 - 1.0 / 4194304.0);\n        double expectedB = (1.0 / 4194304.0 * 2.0 - (1.0 - 1.0 / 4194304.0) * 1.0) / (2.0 * 2.0 + 2.0 * 1.0);\n\n        // Adjust for resplit; this assumes a mock or actual resplit method is implemented\n        resplit(new double[]{expectedA, expectedB});\n\n        assertAll(\n            () -> assertEquals(expectedA, result[0], EPSILON, \"The first element of the result should be the expected value after resplit\"),\n            () -> assertEquals(expectedB, result[1], EPSILON, \"The second element of the result should be the expected value after resplit\")\n        );\n    }\n    \n    // This assumes that the splitReciprocal method is part of the AccurateMathCalc class\n    static void splitReciprocal(final double[] in, final double[] result) {\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n    \n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n    \n        result[0] = a / in[0];\n        result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n    \n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n    \n        /* Resplit */\n        resplit(result);\n    \n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n                result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err *= result[0] + result[1];\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] in = {5.0, 2.0};\n        double[] result = new double[2];\n        AccurateMathCalc.splitReciprocal(in, result);\n        double a = 1.0 - (1.0 / 4194304.0);\n        double expectedResult0 = a / in[0];\n        double expectedResult1 = ((1.0 / 4194304.0) * in[0] - a * in[1]) / \n                                 (in[0] * in[0] + in[0] * in[1]);\n        assertEquals(expectedResult0, result[0], DELTA, \"The calculated result[0] does not match the expected value.\");\n        assertEquals(expectedResult1, result[1], DELTA, \"The calculated result[1] does not match the expected value.\");\n\n        // Test with in[0] being zero\n        in[0] = 0.0;\n        in[1] = 3.5;\n        AccurateMathCalc.splitReciprocal(in, result);\n        expectedResult0 = a / in[0];\n        expectedResult1 = ((1.0 / 4194304.0) * in[0] - a * in[1]) / \n                                 (in[0] * in[0] + in[0] * in[1]);\n        if (Double.isNaN(expectedResult1)) expectedResult1 = 0.0;\n        \n        assertEquals(in[1], result[0], DELTA, \"When in[0] is zero, result[0] should be set to in[1].\");\n        assertEquals(expectedResult1, result[1], DELTA, \"The calculated result[1] when in[0] is zero does not match the expected value.\");\n    }\n\n    // Additional tests might include edge cases such as\n    // in = {Double.MAX_VALUE, Double.MIN_VALUE}, in = {Double.MIN_VALUE, Double.MAX_VALUE}\n    // and cases to check floating-point precision errors.\n\n    // Note: resplit function needs to be mocked or assumed to be correct for this test to pass.\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    /* Since the resplit method is called inside splitReciprocal, \n     * we need to either implement it or mock its behavior for testing purposes. \n     * For this example, a simple implementation is provided.\n     */\n    private static void resplit(double[] result) {\n        // Mock implementation just for the test.\n        // The actual implementation might have more complex logic.\n        result[0] += Math.ulp(result[0]);\n        result[1] += Math.ulp(result[1]);\n    }\n    \n    @Test\n    public void splitReciprocalTest() {\n        double[] input = new double[]{2.0, 1.0};\n        double[] result = new double[2];\n        \n        AccurateMathCalcTest.splitReciprocal(input, result);\n\n        double a = 1.0 - 1.0 / 4194304.0;\n        double expected0 = a / input[0];\n        double expected1 = ((1.0 / 4194304.0) * input[0] - a * input[1]) \n                            / (input[0] * input[0] + input[0] * input[1]);\n        \n        /* Adjust expected1 due to possible NAN as per source code */\n        if (Double.isNaN(expected1)) {\n          expected1 = 0.0;\n        }\n\n       /* Since resplit is called, if necessary adjust the expectations */\n        expected0 += Math.ulp(expected0);\n        expected1 += Math.ulp(expected1);\n        \n        /* Adjust for rounding errors from the loop at the end of splitReciprocal */\n        for (int i = 0; i < 2; i++) {\n            double err = 1.0 - expected0 * input[0] - expected0 * input[1] \n                        - expected1 * input[0] - expected1 * input[1];\n            err *= expected0 + expected1;\n            expected1 += err;\n        }\n        \n        // Assert that the actual result is close to the expected result \n        // within the precision errors. Specify a small delta for floating-point comparisons.\n        assertEquals(expected0, result[0], 1e-15, \"The first element of the result is not correct\");\n        assertEquals(expected1, result[1], 1e-15, \"The second element of the result is not correct\");\n    }\n    \n    /* The main method that performs the split reciprocal */\n    private static void splitReciprocal(final double[] in, final double[] result) {\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n        \n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n        \n        result[0] = a / in[0];\n        result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n        \n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n        \n        /* Resplit */\n        resplit(result);\n    \n        for (int i = 0; i < 2; i++) {\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] \n                         - result[1] * in[0] - result[1] * in[1];\n            err *= result[0] + result[1];\n            result[1] += err;\n        }\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static void resplit(double[] split) {\n        // TODO: This is a placeholder for the actual 'resplit' implementation,\n        // this should be replaced with the real method once provided.\n        double c = split[0] + split[1];\n        double d = -(c - split[0] - split[1]);\n        \n        split[0] = c;\n        split[1] = d;\n    }\n\n    @Test\n    public void splitReciprocalTest() {\n        // Define the example inputs and expected results.\n        final double[] input = {2.0, 3.0};\n        final double[] expected = new double[2];\n        final double[] result = new double[2];\n        \n        // Call splitReciprocal to obtain the results.\n        AccurateMathCalcTest.splitReciprocal(input, result);\n        \n        // Perform the reciprocal operation to verify the result.\n        expected[0] = 1 / input[0];\n        expected[1] = 1 / (input[0] + input[1]);\n        \n        // Assertions to verify the reciprocal split\n        // Check if the result is not NaN\n        assertFalse(Double.isNaN(result[0]));\n        assertFalse(Double.isNaN(result[1]));\n        \n        // Use an epsilon value for comparison of floating-point numbers due to precision errors\n        double epsilon = 1e-15;\n        \n        // Check if the first part of the result is correctly calculated\n        assertEquals(expected[0], result[0], epsilon, \"The first part of the reciprocal did not match.\");\n        \n        // Check if the second part of the result is correctly calculated and rationalized\n        assertEquals(expected[1], result[1], epsilon, \"The second part of the reciprocal did not match.\");\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double DELTA = 1e-15;\n\n    @Test\n    public void splitReciprocalTest() {\n        // Test with a positive non-zero value\n        double[] input = new double[]{2.0, 1.0};\n        double[] result = new double[2];\n        AccurateMathCalc.splitReciprocal(input, result);\n        assertEquals(0.5, result[0], DELTA, \"The reciprocal of the first element should be 0.5\");\n        assertEquals(-0.25, result[1], DELTA, \"The second element should be calculated correctly\");\n\n        // Test for input where the first element is zero\n        double[] inputZero = new double[]{0.0, 3.0};\n        double[] resultZero = new double[2];\n        AccurateMathCalc.splitReciprocal(inputZero, resultZero);\n        assertNotEquals(0.0, resultZero[0], \"The first element should not be zero\");\n        assertEquals(1.0 / 3.0, resultZero[0], DELTA, \"The reciprocal of the second element should be 1/3\");\n        \n        // Test to verify NAN handling\n        double[] inputNan = new double[]{1.0, Double.NaN};\n        double[] resultNan = new double[2];\n        AccurateMathCalc.splitReciprocal(inputNan, resultNan);\n        assertNotNull(resultNan[1], \"The NAN should have been handled\");\n        assertEquals(0.0, resultNan[1], DELTA, \"The NAN should be converted to 0\");\n\n        // Additional tests for other cases such as negative numbers, very large/small input values,\n        // and checks to ensure the 'resplit' functionality is working correctly could also be added here.\n    }\n    \n    // This is a mock-up of the resplit method. Replace with the actual resplit implementation.\n    private static void resplit(double[] result) {\n        // Placeholder for resplit method as it's not included in the code snippet provided.\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    // Helper method mimicking the 'resplit' method called in the source code (if applicable)\n    // Since the 'resplit' method is not provided, here's a mock for compiling purposes.\n    // Replace with actual 'resplit' implementation.\n    static void resplit(double[] result) {\n        // This is just a stub. The actual implementation should do the 'resplit'\n    }\n    \n    // A static access helper for the private method `splitReciprocal`\n    static void callSplitReciprocal(final double[] in, final double[] result) {\n        // Call the static method from the source code\n        AccurateMathCalc.splitReciprocal(in, result);\n    }\n\n    @Test\n    public void splitReciprocalTest() {\n        double[] input = new double[]{2.0, 0.5}; // Example input values\n        double[] result = new double[2];\n        \n        callSplitReciprocal(input, result);\n        \n        // Expected results computed manually or by a different, reliable method\n        double expectedFirst = 0.5; // Assuming a expected value for the first element\n        double expectedSecond = -0.25; // Assuming a expected value for the second element\n        \n        // Validate the results with an acceptable delta for floating point comparisons\n        assertEquals(expectedFirst, result[0], 1e-9, \"The first element of the result array is not as expected\");\n        assertEquals(expectedSecond, result[1], 1e-9, \"The second element of the result array is not as expected\");\n        \n        // Additional test cases could include input values of 0.0 for checking the early path,\n        // and other boundary conditions or typical usage scenarios.\n    }\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n    @Test\n    public void splitReciprocalTest() {\n        // Arrange\n        double[] input = new double[] {2.0, 3.0}; // Example input\n        double[] expectedResult = new double[2]; // Container for the result\n        double[] actualResult = new double[2]; // Container for the actual result\n\n        // Act\n        AccurateMathCalc.splitReciprocal(input, actualResult);\n\n        // The exact expected result would depend on the splitReciprocal method logic\n        // Assuming the expected logic works properly, calculate the expectedResult accordingly\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n\n        expectedResult[0] = a / input[0];\n        expectedResult[1] = (b * input[0] - a * input[1]) / (input[0] * input[0] + input[0] * input[1]);\n        \n        // Call resplit for expectedResult to match the postconditions of splitReciprocal\n        // Note: The method 'resplit' needs to be accessible or emulated here.\n        // AccurateMathCalc.resplit(expectedResult); // Assuming this method exists\n\n        // Additionally handle NaN case as per original method logic, if needed for expectedResult\n        if (Double.isNaN(expectedResult[1])) {\n            expectedResult[1] = 0.0;\n        }\n        \n        // Add err correction loop equivalent to original source if needed for expectedResult\n\n        // Assert\n        assertArrayEquals(expectedResult, actualResult, \"The splitReciprocal method did not produce the expected result.\");\n    }\n    \n    // Assuming AccurateMathCalc class exists and splitReciprocal is a static method within it\n}",
        "package org.apache.commons.math4.core.jdkmath;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AccurateMathCalcTest {\n\n    private static final double DELTA = 1e-15; // A constant for comparison precision\n\n    static void splitReciprocal(final double[] in, final double[] result) {\n        // ... (Original Source Code content)\n    }\n\n    // ... (Rest of the Original Source Code content)\n\n    @Test\n    public void splitReciprocalTest() {\n        // Test with a non-zero positive number\n        double[] input = {2.0, 3.0};\n        double[] result = new double[2];\n        splitReciprocal(input, result);\n        double expected0 = 1.0 / input[0];\n        double expected1 = (1.0 / 4194304.0 * input[0] - (1.0 - 1.0 / 4194304.0) * input[1]) / (input[0] * input[0] + input[0] * input[1]);\n        assertEquals(expected0, result[0], DELTA, \"The first element of the result should match the expected value.\");\n        assertEquals(expected1, result[1], DELTA, \"The second element of the result should match the expected value.\");\n\n        // Test with zero as the first element of the input array\n        input = new double[]{0.0, 5.0};\n        result = new double[2];\n        splitReciprocal(input, result);\n        expected0 = 1.0 / input[1];\n        assertEquals(expected0, result[0], DELTA, \"The first element of the result should be the reciprocal of the second input value when the first input is zero.\");\n        assertEquals(0.0, result[1], DELTA, \"The second element of the result should be zero when the first input is zero.\");\n\n        // Test to ensure NaN handling in result[1]\n        input = new double[]{1.0, Double.POSITIVE_INFINITY};\n        result = new double[2];\n        splitReciprocal(input, result);\n        assertFalse(Double.isNaN(result[1]), \"result[1] should not be NaN even when the calculation produces NaN.\");\n\n        // Additional tests can be added to cover different scenarios like negative inputs or extreme values.\n    }\n}"
    ]
}