{
    "project_name": "javacv",
    "file_name": "AndroidFrameConverter.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/AndroidFrameConverter.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Convert YUV 4:2:0 SP (NV21) data to BGR, as received, for example,\n     * via {@link Camera.PreviewCallback#onPreviewFrame(byte[],Camera)}.\n     */",
    "source_code": "\npublic Frame convert(byte[] data, int width, int height) {\n    if (frame == null || frame.imageWidth != width\n            || frame.imageHeight != height || frame.imageChannels != 3) {\n        if (frame != null) {\n            frame.close();\n        }\n        frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    }\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n\n    // ported from https://android.googlesource.com/platform/development/+/master/tools/yuv420sp2rgb/yuv420sp2rgb.c\n    int offset = height * width;\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[offset + (i/2) * width + 2 * (j/2)    ] & 0xFF;\n            int U = data[offset + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n\n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n\n            if (Y < 0)\n                Y = 0;\n\n            // R = (int)(1.164 * Y + 2.018 * U);\n            // G = (int)(1.164 * Y - 0.813 * V - 0.391 * U);\n            // B = (int)(1.164 * Y + 1.596 * V);\n\n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n\n            R = Math.min(262143, Math.max(0, R));\n            G = Math.min(262143, Math.max(0, G));\n            B = Math.min(262143, Math.max(0, B));\n\n            R >>= 10; R &= 0xff;\n            G >>= 10; G &= 0xff;\n            B >>= 10; B &= 0xff;\n\n            out.put(i * stride + 3 * j,     (byte)B);\n            out.put(i * stride + 3 * j + 1, (byte)G);\n            out.put(i * stride + 3 * j + 2, (byte)R);\n        }\n    }\n    return frame;\n}\n",
    "class_name": "AndroidFrameConverter",
    "method_name": "convert",
    "arguments": [
        "byte[] data",
        "int width",
        "int height"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.ByteBuffer;\n\npublic class AndroidFrameConverterTest {\n\n    private AndroidFrameConverter converter;\n    private ByteBuffer out;\n    private Frame frame;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n    }\n\n    @Test\n    public void convertTest() {\n        int width = 2;\n        int height = 2;\n        byte[] nv21 = new byte[] {\n            // Y plane\n            (byte)0xFF, (byte)0xFF,\n            (byte)0xFF, (byte)0xFF,\n            // U and V planes\n            (byte)0x80, (byte)0xFF,\n            (byte)0x80, (byte)0xFF\n        };\n\n        frame = converter.convert(nv21, width, height);\n        assertNotNull(frame, \"Frame should not be null after conversion.\");\n        assertEquals(width, frame.imageWidth, \"Width should match the input width.\");\n        assertEquals(height, frame.imageHeight, \"Height should match the input height.\");\n        assertEquals(3, frame.imageChannels, \"The number of channels should be 3 for a BGR image.\");\n\n        out = (ByteBuffer) frame.image[0];\n        out.position(0);\n\n        // Check pixel values. NV21 is a luminance-chrominance format, and here we assume a simple\n        // grayscale image where Y should be at maximum and U and V are mid-range.\n        // So we expect white color (BGR all at maximum).\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                assertEquals((byte)0xFF, out.get(), \"Blue channel should be at maximum\");\n                assertEquals((byte)0xFF, out.get(), \"Green channel should be at maximum\");\n                assertEquals((byte)0xFF, out.get(), \"Red channel should be at maximum\");\n            }\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (frame != null) {\n            frame.close(); // Cleanup after conversion\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n\n    private AndroidFrameConverter converter;\n    private byte[] testData;\n    private final int width = 4;\n    private final int height = 4;\n\n    // Setup test data and the converter before each test\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        \n        // Simple test data (2x2 pixels, YUV format)\n        testData = new byte[] {\n            // Y values\n            (byte)150, (byte)150, (byte)150, (byte)150, \n            (byte)150, (byte)150, (byte)150, (byte)150, \n            (byte)150, (byte)150, (byte)150, (byte)150, \n            (byte)150, (byte)150, (byte)150, (byte)150, \n            // U and V values (UV pairs for each 2x2 block)\n            (byte)64, (byte)192, \n            (byte)64, (byte)192,\n            (byte)64, (byte)192,\n            (byte)64, (byte)192,\n        };\n    }\n\n    @Test\n    public void convertTest() {\n        // Convert the YUV data to a Frame\n        Frame resultFrame = converter.convert(testData, width, height);\n        \n        // Validate the result\n        assertNotNull(resultFrame, \"The converted Frame should not be null\");\n        assertEquals(width, resultFrame.imageWidth, \"Frame width should match\");\n        assertEquals(height, resultFrame.imageHeight, \"Frame height should match\");\n        assertEquals(3, resultFrame.imageChannels, \"Should have 3 channels for BGR format\");\n\n        ByteBuffer buffer = (ByteBuffer)resultFrame.image[0];\n        if (buffer != null) {\n            for (int i = 0; i < height; i++) {\n                for (int j = 0; j < width; j++) {\n                    int index = (i * resultFrame.imageStride) + (3 * j);\n                    byte b = buffer.get(index);\n                    byte g = buffer.get(index + 1);\n                    byte r = buffer.get(index + 2);\n\n                    // The exact values will depend on the YUV to RGB conversion logic.\n                    // Here, we are just checking if values are within the expected range [0, 255].\n                    assertTrue((b & 0xFF) >= 0 && (b & 0xFF) <= 255, \"Blue channel should be between 0 and 255\");\n                    assertTrue((g & 0xFF) >= 0 && (g & 0xFF) <= 255, \"Green channel should be between 0 and 255\");\n                    assertTrue((r & 0xFF) >= 0 && (r & 0xFF) <= 255, \"Red channel should be between 0 and 255\");\n                }\n            }\n        } else {\n            fail(\"Frame buffer should not be null\");\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    AndroidFrameConverter converter;\n    Frame frame;\n    byte[] yuvData;\n    int width;\n    int height;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        width = 2;  // small test size to keep it simple\n        height = 2;\n\n        // Example NV21 (YUV 4:2:0 SP) data for a 2x2 image\n        // Y Y V U (luminance and chrominance values)\n        yuvData = new byte[]{\n                0x10, 0x10, 0x80, 0x90,  \n                0x10, 0x10, 0x70, 0x60   \n        };\n        // Here, we just set some values to test.\n        // In reality, you would want a set of values that map to a known BGR output.\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (frame != null) {\n            frame.close();\n        }\n    }\n\n    @Test\n    public void convertTest() {\n        // Convert the YUV data\n        frame = converter.convert(yuvData, width, height);\n\n        // Check frame properties\n        assertNotNull(frame, \"The frame should not be null after conversion.\");\n        assertEquals(height, frame.imageHeight, \"The frame height does not match.\");\n        assertEquals(width, frame.imageWidth, \"The frame width does not match.\");\n        assertEquals(3, frame.imageChannels, \"The frame should have 3 channels (BGR).\");\n\n        // Get the output buffer and check a couple of pixels\n        ByteBuffer outBuffer = (ByteBuffer)frame.image[0];\n\n        // Since YUV values were set above and we're only testing functionality,\n        // we will check to see if the buffer was filled starting at the first position.\n        outBuffer.rewind();\n        // Check if the buffer has been filled with non-zero values\n        boolean bufferFilled = false;\n        while (outBuffer.hasRemaining()) {\n            if (outBuffer.get() != 0) {\n                bufferFilled = true;\n                break;\n            }\n        }\n        assertTrue(bufferFilled, \"The output buffer should be filled with non-zero values.\");\n        \n        // Note: For more rigorous testing, you would check specific BGR values.\n        // This would require a known and correct YUV -> BGR conversion to compare against.\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n\n    static final int WIDTH = 10;\n    static final int HEIGHT = 20;\n\n    // Mock frame for testing\n    static class MockFrame extends Frame {\n        public MockFrame(int width, int height, int depth, int channels) {\n            super(width, height, depth, channels);\n            image = new ByteBuffer[] { ByteBuffer.allocateDirect(width * height * channels) };\n            imageWidth = width;\n            imageHeight = height;\n            imageChannels = channels;\n            imageStride = width * channels;\n        }\n    }\n\n    AndroidFrameConverter converter;\n    byte[] yuvData;\n    int width = WIDTH;\n    int height = HEIGHT;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        // initializing NV21 YUV data with dummy values\n        yuvData = new byte[width * height * 3 / 2];\n        for (int i = 0; i < yuvData.length; i++) {\n            yuvData[i] = (byte)(i % 256);\n        }\n    }\n\n    @Test\n    public void convertTest() {\n        Frame frame = converter.convert(yuvData, width, height);\n        assertNotNull(frame, \"The converted frame should not be null\");\n        assertEquals(width, frame.imageWidth, \"Frame width does not match\");\n        assertEquals(height, frame.imageHeight, \"Frame height does not match\");\n        assertEquals(3, frame.imageChannels, \"Frame should have 3 channels (BGR)\");\n\n        ByteBuffer buffer = (ByteBuffer)frame.image[0];\n        buffer.rewind();\n        // Checking if ByteBuffer has been filled\n        assertFalse(buffer.capacity() == 0, \"Buffer should have been filled with data\");\n\n        // Verify that the conversion respects the NV21 format\n        // As the given YUV data doesn't represent any actual image, real pixel\n        // values are not checked, just verifying that the test code runs correctly\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n\n    private AndroidFrameConverter converter;\n    private Frame frame;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (frame != null) {\n            frame.close();\n        }\n    }\n\n    @Test\n    public void convertTest() {\n        int width = 2;\n        int height = 2;\n        // Generate a simple NV21 image with known values\n        byte[] nv21Data = new byte[] {\n            16, 16, 16, 16, // Mock Y values for YUV, kept simple for the test\n            (byte)81, 90,  // Mock V (Cr) and U (Cb) values for YUV NV21\n        };\n\n        frame = converter.convert(nv21Data, width, height);\n\n        assertNotNull(frame, \"Frame should not be null after conversion.\");\n        assertEquals(width, frame.imageWidth, \"Frame width mismatch.\");\n        assertEquals(height, frame.imageHeight, \"Frame height mismatch.\");\n        assertEquals(3, frame.imageChannels, \"Frame should have 3 channels for BGR.\");\n\n        ByteBuffer out = (ByteBuffer)frame.image[0];\n        out.rewind();\n\n        byte[] expectedData = new byte[width * height * 3]; // Expected data size should match BGR format\n        out.get(expectedData);\n\n        byte[] expectedValues = new byte[] {\n            // Expected conversion results for BGR from the given NV21 data\n            // This needs to be calculated based on the convert function logic\n            // Placeholder values given for the sake of example; should be replaced with accurate expectations\n            (byte)0, (byte)0, (byte)0,\n            (byte)0, (byte)0, (byte)0,\n            (byte)0, (byte)0, (byte)0,\n            (byte)0, (byte)0, (byte)0\n        };\n\n        assertArrayEquals(expectedValues, expectedData, \"Converted BGR values did not match the expected output.\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n\n    @Test\n    public void convertTest() {\n        // Initialize the parameters for the conversion\n        int width = 2;\n        int height = 2;\n        byte[] data = new byte[width * height * 3 / 2]; // YUV420SP size\n\n        // Create a sample YUV pattern (simple and predictable)\n        for (int i = 0; i < data.length; ++i) {\n            data[i] = (byte) i;\n        }\n\n        // Instantiate the converter\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n\n        // Perform the conversion\n        Frame convertedFrame = converter.convert(data, width, height);\n\n        // Assert that the frame is not null\n        assertNotNull(convertedFrame, \"Converted frame should not be null\");\n\n        // Assert the properties of the converted frame\n        assertEquals(width, convertedFrame.imageWidth, \"Frame width mismatch\");\n        assertEquals(height, convertedFrame.imageHeight, \"Frame height mismatch\");\n        assertEquals(3, convertedFrame.imageChannels, \"Frame should have 3 channels for BGR\");\n\n        ByteBuffer out = (ByteBuffer) convertedFrame.image[0];\n        \n        // Check a few pixels to ensure conversion is correct\n        // For the sake of simplicity, we're just checking the first pixel\n        int stride = convertedFrame.imageStride;\n        assertEquals((byte) 0, out.get(0), \"Blue channel of first pixel mismatch\");\n        assertEquals((byte) 0, out.get(1), \"Green channel of first pixel mismatch\");\n        assertEquals((byte) 0, out.get(2), \"Red channel of first pixel mismatch\");\n        \n        // Additional pixel checks can be performed here if a known YUV input to RGB output mapping is available\n        // ensuring that the conversion is following the YUV to RGB conversion formulas correctly.\n        \n        // Clean-up if necessary\n        if (convertedFrame != null) {\n            convertedFrame.close();\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    private AndroidFrameConverter frameConverter;\n    private Frame frame;\n\n    @BeforeEach\n    public void setUp() {\n        frameConverter = new AndroidFrameConverter();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (frame != null) {\n            frame.close();\n        }\n    }\n\n    @Test\n    public void testConvertValidData() {\n        int width = 2;\n        int height = 2;\n        byte[] data = new byte[]{\n                (byte)160, (byte)160,\n                (byte)160, (byte)160,\n                // U and V for 2x2 block\n                (byte)255, (byte)0,\n        };\n        \n        frame = frameConverter.convert(data, width, height);\n        ByteBuffer out = (ByteBuffer)frame.image[0];\n\n        assertNotNull(frame, \"The frame should not be null after conversion\");\n        assertEquals(frame.imageWidth, width, \"The width of the frame should match the provided width\");\n        assertEquals(frame.imageHeight, height, \"The height of the frame should match the provided height\");\n        assertEquals(frame.imageChannels, 3, \"The number of channels in the frame should be 3\");\n\n        byte[] expectedOutput = new byte[width * height * 3];\n\n        // Manually calculate expected BGR values from the provided data\n        expectedOutput[0] = (byte)255; // B\n        expectedOutput[1] = (byte)0;   // G\n        expectedOutput[2] = (byte)0;   // R\n        expectedOutput[3] = (byte)255; // B\n        expectedOutput[4] = (byte)0;   // G\n        expectedOutput[5] = (byte)0;   // R\n        expectedOutput[6] = (byte)255; // B\n        expectedOutput[7] = (byte)0;   // G\n        expectedOutput[8] = (byte)0;   // R\n        expectedOutput[9] = (byte)255; // B\n        expectedOutput[10] = (byte)0;  // G\n        expectedOutput[11] = (byte)0;  // R\n\n        // Verify each byte of the output\n        for (int i = 0; i < expectedOutput.length; i++) {\n            assertEquals(expectedOutput[i], out.get(i), \"The converted frame data does not match the expected BGR values\");\n        }\n    }\n\n    @Test\n    public void testConvertInvalidData() {\n        int width = 2;\n        int height = 2;\n        byte[] data = null; // invalid data\n\n        assertThrows(NullPointerException.class, () -> {\n            frameConverter.convert(data, width, height);\n        }, \"Conversion should throw NullPointerException for null data\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    private AndroidFrameConverter converter;\n    private byte[] testYuvData;\n    private int testWidth;\n    private int testHeight;\n    private Frame testFrame;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        testWidth = 4; // choose a reasonable width\n        testHeight = 4; // choose a reasonable height\n        // Initialize test data to some values; 12 is the size for 4x4 YUV420 image\n        testYuvData = new byte[testWidth * testHeight * 3 / 2];\n        // Fill it with data that has a defined transformation for your test\n        for (int i = 0; i < testYuvData.length; i++) {\n            testYuvData[i] = (byte) (i % 255);\n        }\n    }\n\n    @Test\n    public void convertTest() {\n        // Given\n        testFrame = converter.convert(testYuvData, testWidth, testHeight);\n        ByteBuffer buffer = (ByteBuffer) testFrame.image[0];\n\n        // When\n        int stride = testFrame.imageStride;\n\n        // Then\n        for (int i = 0; i < testHeight; i++) {\n            for (int j = 0; j < testWidth; j++) {\n                byte B = buffer.get(i * stride + 3 * j);\n                byte G = buffer.get(i * stride + 3 * j + 1);\n                byte R = buffer.get(i * stride + 3 * j + 2);\n\n                // Check RGB values as per the conversion logic in source code\n                // These will need to be calculated based on expected results from the original YUV values\n                byte expectedB = <expected blue value given testYuvData>;\n                byte expectedG = <expected green value given testYuvData>;\n                byte expectedR = <expected red value given testYuvData>;\n\n                assertEquals(expectedB, B, \"Blue component did not match for pixel at (\" + j + \", \" + i + \")\");\n                assertEquals(expectedG, G, \"Green component did not match for pixel at (\" + j + \", \" + i + \")\");\n                assertEquals(expectedR, R, \"Red component did not match for pixel at (\" + j + \", \" + i + \")\");\n            }\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (testFrame != null) {\n            testFrame.close();\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    @Test\n    public void convertTest() {\n        // Create an instance of the class under test\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n\n        // Assume a 2x2 image with known YUV data\n        // YUV 4:2:0 SP (NV21) has the Y values for four pixels followed by U and V values for each pair of pixels\n        byte[] nv21data = new byte[]{\n            0x10, 0x10, 0x10, 0x10, // Y values (pretend grayscale for simplicity)\n            (byte)0x80, (byte)0x80,   // U values for two pixels, 0x80 represents a center value of 128\n            (byte)0x80, (byte)0x80    // V values for two pixels, 0x80 represents a center value of 128\n        };\n        \n        // Act\n        Frame frame = converter.convert(nv21data, 2, 2);\n        \n        // Assert that frame is not null\n        assertNotNull(frame);\n        \n        // Assert that frame has correct properties\n        assertEquals(2, frame.imageWidth);\n        assertEquals(2, frame.imageHeight);\n        assertEquals(Frame.DEPTH_UBYTE, frame.depth);\n        assertEquals(3, frame.imageChannels);\n\n        ByteBuffer buffer = (ByteBuffer) frame.image[0];\n        \n        // Check pixel data\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                int index = i * frame.imageStride + j * 3;\n                byte b = buffer.get(index);\n                byte g = buffer.get(index + 1);\n                byte r = buffer.get(index + 2);\n                \n                // Here we assert the expected values of B, G, and R, which need to be calculated based on YUV to BGR conversion.\n                // For this example, we assume the conversion formula results in B=G=R=value for grayscale with 16<=Y<=235 range\n                // These values would need to be calculated by hand for the U and V values provided above.\n                byte expectedValue = <calculated_expectation_based_on_formula_and_assumed_U_V_values>;\n\n                assertEquals(expectedValue, b); // Fail if the B component is not as expected\n                assertEquals(expectedValue, g); // Fail if the G component is not as expected\n                assertEquals(expectedValue, r); // Fail if the R component is not as expected\n            }\n        }\n    }\n}\n",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    \n    // Dummy data for testing\n    private byte[] createTestYUV420Data(int width, int height) {\n        byte[] data = new byte[width * height * 3 / 2]; // YUV420 size is width*height*1.5\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte)(i % 255); // Populate with some pattern\n        }\n        return data;\n    }\n\n    @Test\n    public void convertTest() {\n        int testWidth = 10;\n        int testHeight = 10;\n        byte[] testData = createTestYUV420Data(testWidth, testHeight);\n        \n        AndroidFrameConverter converter = new AndroidFrameConverter();\n        Frame frame = converter.convert(testData, testWidth, testHeight);\n        \n        assertNotNull(frame, \"Frame should not be null after conversion.\");\n        assertEquals(testWidth, frame.imageWidth, \"Width should match input width.\");\n        assertEquals(testHeight, frame.imageHeight, \"Height should match input height.\");\n        assertEquals(3, frame.imageChannels, \"Image channels must be 3 for RGB output.\");\n\n        ByteBuffer outBuffer = (ByteBuffer)frame.image[0];\n        assertNotNull(outBuffer, \"The ByteBuffer should not be null.\");\n        \n        // Test a couple of pixels to ensure correct YUV to RGB conversion\n        // Here we will check corner pixels for some basic validation\n        int stride = frame.imageStride;\n        \n        // Check the first pixel\n        int index = 0;\n        assertEquals((byte)0xff, outBuffer.get(index), \"First pixel Blue channel does not match.\");\n        assertEquals((byte)0xff, outBuffer.get(index + 1), \"First pixel Green channel does not match.\");\n        assertEquals((byte)0xff, outBuffer.get(index + 2), \"First pixel Red channel does not match.\");\n\n        // Check last pixel\n        index = (testHeight - 1) * stride + (testWidth - 1) * 3;\n        assertEquals((byte)0xff, outBuffer.get(index), \"Last pixel Blue channel does not match.\");\n        assertEquals((byte)0xff, outBuffer.get(index + 1), \"Last pixel Green channel does not match.\");\n        assertEquals((byte)0xff, outBuffer.get(index + 2), \"Last pixel Red channel does not match.\");\n\n        // Clean up the frame\n        frame.close();\n    }\n}"
    ]
}