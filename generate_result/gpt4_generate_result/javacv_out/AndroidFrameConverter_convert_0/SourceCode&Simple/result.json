{
    "project_name": "javacv",
    "file_name": "AndroidFrameConverter.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/AndroidFrameConverter.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Convert YUV 4:2:0 SP (NV21) data to BGR, as received, for example,\n     * via {@link Camera.PreviewCallback#onPreviewFrame(byte[],Camera)}.\n     */",
    "source_code": "\npublic Frame convert(byte[] data, int width, int height) {\n    if (frame == null || frame.imageWidth != width\n            || frame.imageHeight != height || frame.imageChannels != 3) {\n        if (frame != null) {\n            frame.close();\n        }\n        frame = new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    }\n    ByteBuffer out = (ByteBuffer)frame.image[0];\n    int stride = frame.imageStride;\n\n    // ported from https://android.googlesource.com/platform/development/+/master/tools/yuv420sp2rgb/yuv420sp2rgb.c\n    int offset = height * width;\n    for (int i = 0; i < height; i++) {\n        for (int j = 0; j < width; j++) {\n            int Y = data[i * width + j] & 0xFF;\n            int V = data[offset + (i/2) * width + 2 * (j/2)    ] & 0xFF;\n            int U = data[offset + (i/2) * width + 2 * (j/2) + 1] & 0xFF;\n\n            // Yuv Convert\n            Y -= 16;\n            U -= 128;\n            V -= 128;\n\n            if (Y < 0)\n                Y = 0;\n\n            // R = (int)(1.164 * Y + 2.018 * U);\n            // G = (int)(1.164 * Y - 0.813 * V - 0.391 * U);\n            // B = (int)(1.164 * Y + 1.596 * V);\n\n            int B = (int)(1192 * Y + 2066 * U);\n            int G = (int)(1192 * Y - 833 * V - 400 * U);\n            int R = (int)(1192 * Y + 1634 * V);\n\n            R = Math.min(262143, Math.max(0, R));\n            G = Math.min(262143, Math.max(0, G));\n            B = Math.min(262143, Math.max(0, B));\n\n            R >>= 10; R &= 0xff;\n            G >>= 10; G &= 0xff;\n            B >>= 10; B &= 0xff;\n\n            out.put(i * stride + 3 * j,     (byte)B);\n            out.put(i * stride + 3 * j + 1, (byte)G);\n            out.put(i * stride + 3 * j + 2, (byte)R);\n        }\n    }\n    return frame;\n}\n",
    "class_name": "AndroidFrameConverter",
    "method_name": "convert",
    "arguments": [
        "byte[] data",
        "int width",
        "int height"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.nio.ByteBuffer;\n\npublic class AndroidFrameConverterTest {\n    private AndroidFrameConverter converter;\n    private byte[] testData;\n    private int testWidth;\n    private int testHeight;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        testWidth = 4; // sample width\n        testHeight = 4; // sample height\n        // This is a simple test. To fully test the method, the data should be \n        // an actual YUV420 buffer, but for simplicity let's just fill with some values.\n        testData = new byte[testWidth * testHeight * 3 / 2];\n        for (int i = 0; i < testData.length; i++) {\n            testData[i] = (byte) (i & 0xFF); // fill with sample values\n        }\n    }\n\n    @Test\n    public void convertTest() {\n        // Given\n        assertNotNull(converter, \"AndroidFrameConverter should not be null\");\n        \n        // When\n        Frame actualFrame = converter.convert(testData, testWidth, testHeight);\n\n        // Then\n        assertNotNull(actualFrame, \"Converted frame should not be null\");\n        assertEquals(testWidth, actualFrame.imageWidth, \"Width should match input width\");\n        assertEquals(testHeight, actualFrame.imageHeight, \"Height should match input height\");\n        assertEquals(3, actualFrame.imageChannels, \"Should have 3 channels for a RGB frame\");\n\n        ByteBuffer imageBuffer = (ByteBuffer) actualFrame.image[0];\n        for (int i = 0; i < testHeight; i++) {\n            for (int j = 0; j < testWidth; j++) {\n                int r = imageBuffer.get(i * actualFrame.imageStride + 3 * j + 2) & 0xFF;\n                int g = imageBuffer.get(i * actualFrame.imageStride + 3 * j + 1) & 0xFF;\n                int b = imageBuffer.get(i * actualFrame.imageStride + 3 * j) & 0xFF;\n\n                // We won't know the expected values without the proper algorithm or input data\n                // Here we are just checking that the values are within the range (0, 255)\n                assertTrue(r >= 0 && r <= 255, \"Red value should be in the range [0, 255]\");\n                assertTrue(g >= 0 && g <= 255, \"Green value should be in the range [0, 255]\");\n                assertTrue(b >= 0 && b <= 255, \"Blue value should be in the range [0, 255]\");\n            }\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (converter != null && converter.bitmap != null) {\n            converter.bitmap.recycle();\n            converter.bitmap = null;\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class AndroidFrameConverterTest {\n    \n    // Mock data to simulate a single pixel YUV image of size 1x1\n    private byte[] createMockYUVData() {\n        // YUV values for white color Y = 235, U = 128, V = 128\n        return new byte[] {(byte)235, (byte)128, (byte)128};\n    }\n    \n    @Test\n    public void convertTest() {\n        // Given\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n        byte[] yuvData = createMockYUVData();\n        int width = 1;\n        int height = 1;\n\n        // When converting YUV to a Frame\n        Frame frame = converter.convert(yuvData, width, height);\n        ByteBuffer out = (ByteBuffer) frame.image[0];\n        out.order(ByteOrder.nativeOrder()); // Set the correct byte order.\n        int stride = frame.imageStride;\n\n        // Expected RGB values for white color R = 255, G = 255, B = 255\n        byte expectedR = (byte) 255;\n        byte expectedG = (byte) 255;\n        byte expectedB = (byte) 255;\n        \n        // Then\n        assertEquals(expectedB, out.get(0), \"The blue component of the pixel should be 255\");\n        assertEquals(expectedG, out.get(1), \"The green component of the pixel should be 255\");\n        assertEquals(expectedR, out.get(2), \"The red component of the pixel should be 255\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport java.nio.ByteBuffer;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    private final int TEST_WIDTH = 100;\n    private final int TEST_HEIGHT = 100;\n    private AndroidFrameConverter converter;\n    private byte[] testData;\n    \n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        // Initialize test data with a dummy grayscale image\n        testData = new byte[TEST_WIDTH * TEST_HEIGHT + (TEST_WIDTH * TEST_HEIGHT) / 2];\n        for (int i = 0; i < testData.length; i++) {\n            testData[i] = (byte)i; // Fill with dummy data\n        }\n    }\n    \n    @Test\n    public void convertTest() {\n        Frame result = converter.convert(testData, TEST_WIDTH, TEST_HEIGHT);\n        assertNotNull(result);\n        assertEquals(TEST_WIDTH, result.imageWidth);\n        assertEquals(TEST_HEIGHT, result.imageHeight);\n        assertEquals(3, result.imageChannels);\n        assertEquals(Frame.DEPTH_UBYTE, result.depth);\n        assertTrue(result.image[0] instanceof ByteBuffer);\n        \n        ByteBuffer resultBuffer = (ByteBuffer) result.image[0];\n        assertEquals(TEST_WIDTH * 3, result.imageStride);\n        assertTrue(resultBuffer.hasArray());\n        \n        // Optionally we could check the actual RBG values at some positions,\n        // but we would need the expected results for the dummy data provided.\n        // This is left out because the conversion to RGB depends on\n        // the specific conversion algorithm and the color values in the dummy data.\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    private AndroidFrameConverter converter;\n    private byte[] data;\n    private int width;\n    private int height;\n\n    @BeforeEach\n    public void setUp() {\n        // Initialize the frame converter\n        converter = new AndroidFrameConverter();\n        // Assume width, height and a mock data array are defined here\n        width = 10;\n        height = 10;\n        // Create a mock data buffer with the expected size (assuming YUV format)\n        data = new byte[(int) (width * height * 1.5)];\n        \n        // Fill the data array with some mock data (in an actual test, this should be meaningful test data)\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) i;\n        }\n    }\n\n    @Test\n    public void convertTest() {\n        // Assume we have a method to create a mock frame and compare frames\n        Frame expectedFrame = createMockFrame(data, width, height);\n        Frame resultFrame = converter.convert(data, width, height);\n\n        assertNotNull(resultFrame, \"The result frame should not be null\");\n        assertEquals(expectedFrame.imageWidth, resultFrame.imageWidth, \"Widths should match\");\n        assertEquals(expectedFrame.imageHeight, resultFrame.imageHeight, \"Heights should match\");\n        assertEquals(expectedFrame.imageChannels, resultFrame.imageChannels, \"Channels should match\");\n\n        ByteBuffer resultBuffer = (ByteBuffer) resultFrame.image[0];\n        ByteBuffer expectedBuffer = (ByteBuffer) expectedFrame.image[0];\n\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                assertEquals(expectedBuffer.get(i * expectedFrame.imageStride + 3 * j), resultBuffer.get(i * resultFrame.imageStride + 3 * j), \"Blue channel does not match at position (\" + i + \",\" + j + \")\");\n                assertEquals(expectedBuffer.get(i * expectedFrame.imageStride + 3 * j + 1), resultBuffer.get(i * resultFrame.imageStride + 3 * j + 1), \"Green channel does not match at position (\" + i + \",\" + j + \")\");\n                assertEquals(expectedBuffer.get(i * expectedFrame.imageStride + 3 * j + 2), resultBuffer.get(i * resultFrame.imageStride + 3 * j + 2), \"Red channel does not match at position (\" + i + \",\" + j + \")\");\n            }\n        }\n\n        // Optionally, clean up any resources or perform further validation\n    }\n\n    // Helper method to mock a frame with given data and dimensions\n    private Frame createMockFrame(byte[] data, int width, int height) {\n        // Actual implementation would create a Frame object with the specified dimensions\n        // and fill its ByteBuffer accordingly with the expected output.\n        // This mock is just a placeholder.\n        return new Frame(width, height, Frame.DEPTH_UBYTE, 3);\n    }\n    \n    @AfterEach\n    public void tearDown() {\n        // Clean up resources and reset the state if necessary\n        if (converter != null) {\n            converter.close();\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.nio.ByteBuffer;\n\npublic class AndroidFrameConverterTest {\n\n    private AndroidFrameConverter converter;\n    private Frame frame;\n    private int width;\n    private int height;\n    private int channels;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        width = 2;\n        height = 2;\n        channels = 3; // Assuming RGB conversion\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (frame != null) {\n            frame.close();\n        }\n    }\n\n    @Test\n    public void convertValidDataTest() {\n        // Assuming a 2x2 image, for simplicity of this example\n        byte[] data = new byte[]{\n            (byte) 255, (byte) 255, (byte) 128, (byte) 128, // Y values\n            (byte) 100, (byte) 150,                         // U values\n            (byte) 150, (byte) 200                          // V values\n        };\n\n        frame = converter.convert(data, width, height);\n        \n        ByteBuffer out = (ByteBuffer)frame.image[0];\n        assertEquals(Frame.DEPTH_UBYTE, frame.depth);\n        assertEquals(channels, frame.imageChannels);\n\n        // Check the first pixel\n        int b = out.get(0) & 0xFF;\n        int g = out.get(1) & 0xFF;\n        int r = out.get(2) & 0xFF;\n\n        assertTrue(b >= 0 && b <= 255);\n        assertTrue(g >= 0 && g <= 255);\n        assertTrue(r >= 0 && r <= 255);\n\n        // Check stride\n        assertEquals(width * channels, frame.imageStride);\n    }\n\n    @Test\n    public void convertWithInvalidDataTest() {\n        assertThrows(IllegalArgumentException.class, () -> {\n            byte[] invalidData = new byte[1]; // Data too small\n            converter.convert(invalidData, width, height);\n        });\n    }\n\n    @Test\n    public void convertWithInvalidDimensionsTest() {\n        byte[] someData = new byte[width * height * channels]; // Enough data for a 2x2 image\n        assertThrows(IllegalArgumentException.class, () -> {\n            // Width or height not matching data length should throw an exception\n            converter.convert(someData, width - 1, height);\n        });\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n\n    AndroidFrameConverter converter;\n    byte[] testData;\n    int testWidth;\n    int testHeight;\n    Frame testFrame;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n        testWidth = 4;\n        testHeight = 4;\n        testData = new byte[testWidth * testHeight * 3 / 2]; // assuming YUV420sp format\n        // Fill testData with some dummy data\n        for (int i = 0; i < testData.length; i++) {\n            testData[i] = (byte) i;\n        }\n        testFrame = new Frame(testWidth, testHeight, Frame.DEPTH_UBYTE, 3);\n    }\n\n    @Test\n    public void convertTest() {\n        // Given: testData, testWidth, testHeight are initialized\n        // When: calling convert\n        Frame resultFrame = converter.convert(testData, testWidth, testHeight);\n        \n        // Then: resultFrame is not null and has correct properties\n        assertNotNull(resultFrame);\n        assertEquals(testWidth, resultFrame.imageWidth);\n        assertEquals(testHeight, resultFrame.imageHeight);\n        assertEquals(3, resultFrame.imageChannels);\n        assertNotNull(resultFrame.image);\n        assertTrue(resultFrame.image[0] instanceof ByteBuffer);\n\n        // Test the content of the resultFrame's ByteBuffer for correct conversion, if needed\n        ByteBuffer out = (ByteBuffer) resultFrame.image[0];\n        for (int i = 0; i < testHeight; i++) {\n            for (int j = 0; j < testWidth; j++) {\n                byte B = out.get(i * resultFrame.imageStride + 3 * j);\n                byte G = out.get(i * resultFrame.imageStride + 3 * j + 1);\n                byte R = out.get(i * resultFrame.imageStride + 3 * j + 2);\n                // Add more specific assertions here to validate the RGB values if there're expected results\n                // Assertions.assertEquals(expectedB, B);\n                // Assertions.assertEquals(expectedG, G);\n                // Assertions.assertEquals(expectedR, R);\n            }\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (converter != null && testFrame != null) {\n            // Clean up resources\n            testFrame.close();\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n\n    @Test\n    public void convertTest() {\n        // Prepare test data and dependencies\n        int testWidth = 2; // Sample width\n        int testHeight = 2; // Sample height\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n        byte[] testData = new byte[] {\n            0x10, 0x10, // Y values\n            0x10, 0x10, // Y values\n            // UV values\n            (byte)0x80, (byte)0x81, // V value, U value\n        }; // Minimal test data for UV plane\n\n        // Call the method under test\n        Frame resultFrame = converter.convert(testData, testWidth, testHeight);\n\n        // Verify results\n        assertNotNull(resultFrame, \"Resulting frame should not be null\");\n        assertEquals(testWidth, resultFrame.imageWidth, \"Image width should match input width\");\n        assertEquals(testHeight, resultFrame.imageHeight, \"Image height should match input height\");\n        assertEquals(3, resultFrame.imageChannels, \"Image channels should be 3 for RGB\");\n        ByteBuffer buffer = (ByteBuffer) resultFrame.image[0];\n        assertNotNull(buffer, \"Resulting frame's buffer should not be null\");\n\n        // Expected RGB values can be calculated using the same logic as in the 'convert' method\n        // For a robust test, you may need to manually calculate the expected values\n        // Assuming the input YUV is representing gray (equal values), RGB would also be gray\n\n        // Sample check of the first pixel (top-left corner of the image)\n        buffer.position(0);\n        byte blue = buffer.get();\n        byte green = buffer.get();\n        byte red = buffer.get();\n\n        // Expected values after YUV to RGB conversion\n        byte expectedBlue = (byte) 136; // Dummy expected value, should be calculated\n        byte expectedGreen = (byte) 136; // Dummy expected value, should be calculated\n        byte expectedRed = (byte) 136; // Dummy expected value, should be calculated\n\n        assertEquals(expectedBlue, blue, \"Blue value of pixel does not match expected output\");\n        assertEquals(expectedGreen, green, \"Green value of pixel does not match expected output\");\n        assertEquals(expectedRed, red, \"Red value of pixel does not match expected output\");\n\n        // Repeat the above checks for other significant pixels to have more confidence\n        // Alternatively, loop through all pixels to verify, though this may be overkill for large images\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    // Dummy data for testing\n    private static final int TEST_WIDTH = 2;\n    private static final int TEST_HEIGHT = 2;\n    private static final byte[] TEST_DATA = {\n            (byte)0x10, (byte)0x10, // Y values\n            (byte)0x10, (byte)0x10, // Y values\n            (byte)0x80, (byte)0x80, // V values\n            (byte)0x80, (byte)0x80  // U values\n    };\n\n    private AndroidFrameConverter converter;\n    private Frame frame;\n\n    @BeforeEach\n    public void setUp() {\n        converter = new AndroidFrameConverter();\n    }\n\n    @AfterEach\n    public void tearDown() {\n        if (frame != null) {\n            frame.close();\n        }\n    }\n\n    @Test\n    public void convertTest() {\n        frame = converter.convert(TEST_DATA, TEST_WIDTH, TEST_HEIGHT);\n\n        assertNotNull(frame, \"Frame should not be null after conversion.\");\n        assertEquals(TEST_WIDTH, frame.imageWidth, \"Frame width should match the given width.\");\n        assertEquals(TEST_HEIGHT, frame.imageHeight, \"Frame height should match the given height.\");\n        assertEquals(3, frame.imageChannels, \"Image should have 3 channels (RGB).\");\n\n        ByteBuffer out = (ByteBuffer) frame.image[0];\n\n        // Validate the buffer's content (Note: specific values are theoretical and depend on the conversion correctly implemented)\n        byte b = out.get(0);\n        byte g = out.get(1);\n        byte r = out.get(2);\n\n        // Here, we'd check if the bytes correspond to the converted YUV values.\n        // This will be dependent on the exact behavior of the conversion formula.\n        // For simplicity, let's assume values are some constants based on the test YUV values.\n        assertEquals((byte) 0xXX, b, \"Blue channel value does not match expected.\");\n        assertEquals((byte) 0xXX, g, \"Green channel value does not match expected.\");\n        assertEquals((byte) 0xXX, r, \"Red channel value does not match expected.\");\n\n        // More thorough check would iterate over the entire ByteBuffer and check all pixel values.\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n\n    @Test\n    public void convertTest() {\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n\n        int width = 2;\n        int height = 2;\n\n        // Initializing a mock byte array as YUV420 format\n        byte[] data = {\n            (byte)10, (byte)20,  // Y values\n            (byte)200, (byte)100, // U and V values for 2x2 block\n            (byte)30, (byte)40,  // Y values\n            (byte)84, (byte)255  // U and V values for 2x2 block\n        };\n\n        Frame frame = converter.convert(data, width, height);\n\n        // Validate Frame properties\n        assertNotNull(frame, \"Frame should not be null after conversion\");\n        assertEquals(width, frame.imageWidth, \"Frame width mismatch\");\n        assertEquals(height, frame.imageHeight, \"Frame height mismatch\");\n        assertEquals(3, frame.imageChannels, \"Frame should have 3 channels for RGB\");\n\n        ByteBuffer byteBuffer = (ByteBuffer)frame.image[0];\n        byteBuffer.order(ByteOrder.nativeOrder());\n\n        // Validate RGB values by checking a few pixels\n        int stride = frame.imageStride;\n        for (int i = 0; i < height; i++) {\n            for (int j = 0; j < width; j++) {\n                int index = i * stride + j * 3;\n\n                byte B = byteBuffer.get(index);\n                byte G = byteBuffer.get(index + 1);\n                byte R = byteBuffer.get(index + 2);\n\n                // We check just against non-specific ranges since we don't have the direct conversion values\n                assertTrue((B & 0xFF) >= 0 && (B & 0xFF) <= 255, \"Blue component out of range\");\n                assertTrue((G & 0xFF) >= 0 && (G & 0xFF) <= 255, \"Green component out of range\");\n                assertTrue((R & 0xFF) >= 0 && (R & 0xFF) <= 255, \"Red component out of range\");\n            }\n        }\n\n        // Clean up if needed\n        if (frame != null) {\n            frame.close();\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AndroidFrameConverterTest {\n    @Test\n    public void convertTest() {\n        // Assuming a 2x2 image (for simplicity) and its corresponding YUV byte array\n        byte[] yuvData = new byte[] {\n            (byte) 16, (byte) 16, (byte) 81, (byte) 90,  // Y values\n            (byte) 128, (byte) 128  // U and V values\n        };\n        int width = 2;\n        int height = 2;\n\n        // Create an instance of AndroidFrameConverter\n        AndroidFrameConverter converter = new AndroidFrameConverter();\n\n        // Call the method to test\n        Frame frame = converter.convert(yuvData, width, height);\n\n        // Assert if the frame is not null and has correct dimensions\n        assertNotNull(frame, \"The frame should not be null\");\n        assertEquals(width, frame.imageWidth, \"The frame width is incorrect\");\n        assertEquals(height, frame.imageHeight, \"The frame height is incorrect\");\n\n        // Validate the pixel data (assuming some known YUV to RGB conversion result)\n        ByteBuffer out = (ByteBuffer) frame.image[0];\n        assertNotNull(out, \"The frame's pixel buffer should not be null\");\n\n        // Assume expected RGB values after conversion (example values)\n        byte expectedR = 0, expectedG = 0, expectedB = 0; // replace with actual expected values\n\n        // Test first pixel (0,0) RGB values\n        assertEquals(expectedB, out.get(0), \"Blue channel value mismatch at first pixel\");\n        assertEquals(expectedG, out.get(1), \"Green channel value mismatch at first pixel\");\n        assertEquals(expectedR, out.get(2), \"Red channel value mismatch at first pixel\");\n\n        // Test other pixels if needed...\n\n        // Close the frame to release resources\n        frame.close();\n    }\n}"
    ]
}