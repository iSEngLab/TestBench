{
    "project_name": "javacv",
    "file_name": "Frame.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/Frame.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * This private method takes a buffer array as input and returns a deep copy.\n     * It is assumed that all buffers in the input array are of the same subclass.\n     *\n     * @param srcBuffers - Buffer array to be cloned\n     * @param clonedBuffers - Buffer array to fill with clones\n     * @return Opaque object to store\n     *\n     *  @author Extension proposed by Dragos Dutu\n     */",
    "source_code": "\nprivate static Pointer cloneBufferArray(Buffer[] srcBuffers, Buffer[] clonedBuffers) {\n    Pointer opaque = null;\n\n    if (srcBuffers != null && srcBuffers.length > 0) {\n        int totalCapacity = 0;\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            totalCapacity += srcBuffers[i].capacity();\n        }\n\n        /*\n         * In order to optimize the transfer we need a type check.\n         *\n         * Most CPUs support hardware memory transfer for different data\n         * types, so it's faster to copy more bytes at once rather\n         * than one byte per iteration as in case of ByteBuffer.\n         *\n         * For example, Intel CPUs support MOVSB (byte transfer), MOVSW\n         * (word transfer), MOVSD (double word transfer), MOVSS (32 bit\n         * scalar single precision floating point), MOVSQ (quad word\n         * transfer) and so on...\n         *\n         * Type checking may be improved by changing the order in\n         * which a buffer is checked against. If it's likely that the\n         * expected buffer is of type \"ShortBuffer\", then it should be\n         * checked at first place.\n         *\n         */\n\n        if (srcBuffers[0] instanceof ByteBuffer) {\n            BytePointer pointer = new BytePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ByteBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof ShortBuffer) {\n            ShortPointer pointer = new ShortPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((ShortBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof IntBuffer) {\n            IntPointer pointer = new IntPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((IntBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof LongBuffer) {\n            LongPointer pointer = new LongPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((LongBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof FloatBuffer) {\n            FloatPointer pointer = new FloatPointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((FloatBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        } else if (srcBuffers[0] instanceof DoubleBuffer) {\n            DoublePointer pointer = new DoublePointer(totalCapacity);\n            for (int i = 0; i < srcBuffers.length; i++) {\n                clonedBuffers[i] = pointer.limit(pointer.position() + srcBuffers[i].limit())\n                        .asBuffer().put((DoubleBuffer)srcBuffers[i]);\n                pointer.position(pointer.limit());\n            }\n            opaque = pointer;\n        }\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n        }\n    }\n\n    if (opaque != null) {\n        opaque.retainReference();\n    }\n    return opaque;\n}\n",
    "class_name": "Frame",
    "method_name": "cloneBufferArray",
    "arguments": [
        "Buffer srcBuffers",
        "Buffer clonedBuffers"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.*;\n\npublic class FrameTest {\n\n    @Test\n    public void cloneBufferArrayTest() {\n        // Let's prepare a ByteBuffer array to test cloneBufferArray method with ByteBuffers\n        ByteBuffer[] srcBuffers = new ByteBuffer[]{ByteBuffer.allocate(10), ByteBuffer.allocate(20)};\n        for (ByteBuffer buffer : srcBuffers) {\n            buffer.put(new byte[buffer.capacity()]); // Fill with dummy data\n            buffer.flip();\n        }\n\n        ByteBuffer[] clonedBuffers = new ByteBuffer[srcBuffers.length];\n\n        // Here we invoke the method to be tested\n        Pointer pointer = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n\n        // Now, let's assert the clonedBuffers are properly cloned\n        assertNotNull(clonedBuffers);\n        assertEquals(srcBuffers.length, clonedBuffers.length);\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            ByteBuffer srcBuffer = srcBuffers[i];\n            ByteBuffer clonedBuffer = (ByteBuffer) clonedBuffers[i];\n\n            assertEquals(srcBuffer.capacity(), clonedBuffer.capacity());\n            assertEquals(srcBuffer.position(), clonedBuffer.position());\n            assertEquals(srcBuffer.limit(), clonedBuffer.limit());\n\n            while (srcBuffer.hasRemaining()) {\n                // Check if the content is the same\n                assertEquals(srcBuffer.get(), clonedBuffer.get());\n            }\n        }\n\n        // Assert the returned pointer is not null and assert reference is retained\n        assertNotNull(pointer);\n        assertTrue(pointer.retainReference() >= 1);\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.Test;\nimport java.nio.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FrameTest {\n\n    @Test\n    public void cloneBufferArrayTest() {\n        // Assuming that the cloneBufferArray method is changed to public for testing purpose\n        // Let's test cloning ByteBuffer which is one of the types supported by cloneBufferArray\n        \n        // Create a source ByteBuffer and fill it with some data\n        ByteBuffer[] sourceBuffers = new ByteBuffer[1];\n        sourceBuffers[0] = ByteBuffer.allocate(5);\n        sourceBuffers[0].put(new byte[]{1, 2, 3, 4, 5});\n        \n        // Create an array to hold the cloned buffers\n        Buffer[] clonedBuffers = new Buffer[1];\n        \n        // Invoke the cloneBufferArray method\n        Pointer opaque = Frame.cloneBufferArray(sourceBuffers, clonedBuffers);\n        \n        // Assertions\n        assertNotNull(opaque, \"The opaque pointer should not be null.\");\n        assertTrue(opaque instanceof BytePointer, \"The opaque pointer should be an instance of BytePointer.\");\n        \n        assertNotNull(clonedBuffers[0], \"The cloned buffer should not be null.\");\n        assertTrue(clonedBuffers[0] instanceof ByteBuffer, \"The cloned buffer should be an instance of ByteBuffer.\");\n        \n        // Cast the cloned buffer back to ByteBuffer\n        ByteBuffer clonedByteBuffer = (ByteBuffer) clonedBuffers[0];\n        \n        // Verify that the content is identical\n        for (int i = 0; i < sourceBuffers[0].capacity(); i++) {\n            assertEquals(sourceBuffers[0].get(i), clonedByteBuffer.get(i), \n                         \"The content of the cloned ByteBuffer should be identical to the source ByteBuffer.\");\n        }\n        \n        // Verify that the capacity is the same\n        assertEquals(sourceBuffers[0].capacity(), clonedByteBuffer.capacity(), \n                     \"The capacity of the cloned ByteBuffer should be equal to the source ByteBuffer.\");\n\n        // Verify that position and limit are properly set\n        assertEquals(0, clonedByteBuffer.position(), \"The position of the cloned ByteBuffer should be at the beginning.\");\n        assertEquals(sourceBuffers[0].capacity(), clonedByteBuffer.limit(),\n                     \"The limit of the cloned ByteBuffer should be set to the capacity.\");\n        \n        // Test if the references are kept properly\n        clonedByteBuffer.rewind(); // Set position back to 0 to mimic the behavior of cloneBufferArray\n        for (int i = 0; i < clonedByteBuffer.capacity(); i++) {\n            clonedByteBuffer.put(i, (byte) (clonedByteBuffer.get(i) + 1));\n        }\n        opaque.releaseReference();\n        \n        // Check changes are not reflected in the original buffer\n        assertNotEquals(sourceBuffers[0].get(0), clonedByteBuffer.get(0), \n                        \"The changes made to cloned buffer should not reflect in the original buffer.\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.*;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        int bufferCount = 3;\n        int bufferSize = 5; // arbitrary buffer size for testing\n\n        ByteBuffer[] srcByteBuffers = new ByteBuffer[bufferCount];\n        Buffer[] clonedByteBuffers = new Buffer[bufferCount];\n        for (int i = 0; i < bufferCount; i++) {\n            srcByteBuffers[i] = ByteBuffer.allocate(bufferSize);\n            // mock some data in the buffer\n            for (int j = 0; j < bufferSize; j++) {\n                srcByteBuffers[i].put((byte) (j + i * bufferSize));\n            }\n            srcByteBuffers[i].flip();\n        }\n        // Actual cloning\n        Pointer bytePointer = Frame.cloneBufferArray(srcByteBuffers, clonedByteBuffers);\n\n        // Assertions\n        assertNotNull(bytePointer, \"The returned Pointer must not be null.\");\n        for (int i = 0; i < bufferCount; i++) {\n            assertEquals(srcByteBuffers[i].remaining(), clonedByteBuffers[i].remaining(), \"Buffer sizes must be equal.\");\n            assertEquals(srcByteBuffers[i], clonedByteBuffers[i], \"Content of cloned buffers must match the source buffers.\");\n        }\n\n        // Test cloning with different buffer types, e.g., IntBuffer; similar setup needed\n        // ...\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.*;\n\npublic class FrameTest {\n\n    @Test\n    public void cloneBufferArrayTest() {\n        // As actual implementation may need different mock-up objects\n        // we are using arbitrary buffer sizes and types for the test.\n        int bufferSize = 5;\n        Buffer[] srcBuffers = new Buffer[2];\n        srcBuffers[0] = ByteBuffer.allocateDirect(bufferSize);\n        srcBuffers[1] = ByteBuffer.allocateDirect(bufferSize);\n        ((ByteBuffer)srcBuffers[0]).put(new byte[bufferSize]);\n        ((ByteBuffer)srcBuffers[1]).put(new byte[bufferSize]);\n\n        Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n\n        Pointer result = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n\n        assertNotNull(result, \"Resulting Pointer should not be null\");\n        assertTrue(result instanceof BytePointer, \"Resulting Pointer should be an instance of BytePointer since ByteBuffer was used\");\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            assertNotNull(clonedBuffers[i], \"Cloned Buffers should not contain nulls\");\n            assertTrue(clonedBuffers[i] instanceof ByteBuffer, \"Cloned Buffers should be of type ByteBuffer\");\n            assertEquals(srcBuffers[i].capacity(), clonedBuffers[i].capacity(), \"Source and cloned buffer capacities should match\");\n\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n            for (int j = 0; j < bufferSize; j++) {\n                assertEquals(((ByteBuffer) srcBuffers[i]).get(), ((ByteBuffer) clonedBuffers[i]).get(), \"Buffer content at index \" + j + \" should match\");\n            }\n        }\n        // In real code, consider releasing the native memory of the Pointer if necessary.\n        // Here, for the purposes of unit testing, we focus on functionality testing only.\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.*;\n\npublic class FrameTest {\n\n    @Test\n    public void cloneBufferArrayTest() {\n        // Create source buffers with sample data\n        ByteBuffer srcByteBuffer = ByteBuffer.allocate(4).put(new byte[]{1, 2, 3, 4});\n        ShortBuffer srcShortBuffer = ShortBuffer.allocate(4).put(new short[]{1, 2, 3, 4});\n        IntBuffer srcIntBuffer = IntBuffer.allocate(4).put(new int[]{1, 2, 3, 4});\n        LongBuffer srcLongBuffer = LongBuffer.allocate(4).put(new long[]{1L, 2L, 3L, 4L});\n        FloatBuffer srcFloatBuffer = FloatBuffer.allocate(4).put(new float[]{1f, 2f, 3f, 4f});\n        DoubleBuffer srcDoubleBuffer = DoubleBuffer.allocate(4).put(new double[]{1.0, 2.0, 3.0, 4.0});\n\n        // Create cloned buffers array\n        Buffer[] clonedBuffers = new Buffer[6];\n\n        // Perform the clone\n        Pointer opaque = Frame.cloneBufferArray(\n                new Buffer[]{\n                        srcByteBuffer, srcShortBuffer, srcIntBuffer,\n                        srcLongBuffer, srcFloatBuffer, srcDoubleBuffer\n                },\n                clonedBuffers\n        );\n\n        // Assertions\n        assertNotNull(opaque, \"The Pointer should not be null\");\n\n        // Verify the contents of the cloned buffers are the same as the source\n        srcByteBuffer.rewind();\n        ByteBuffer clonedByteBuffer = (ByteBuffer) clonedBuffers[0];\n        assertEquals(srcByteBuffer, clonedByteBuffer);\n\n        srcShortBuffer.rewind();\n        ShortBuffer clonedShortBuffer = (ShortBuffer) clonedBuffers[1];\n        assertEquals(srcShortBuffer, clonedShortBuffer);\n\n        srcIntBuffer.rewind();\n        IntBuffer clonedIntBuffer = (IntBuffer) clonedBuffers[2];\n        assertEquals(srcIntBuffer, clonedIntBuffer);\n\n        srcLongBuffer.rewind();\n        LongBuffer clonedLongBuffer = (LongBuffer) clonedBuffers[3];\n        assertEquals(srcLongBuffer, clonedLongBuffer);\n\n        srcFloatBuffer.rewind();\n        FloatBuffer clonedFloatBuffer = (FloatBuffer) clonedBuffers[4];\n        assertEquals(srcFloatBuffer, clonedFloatBuffer);\n\n        srcDoubleBuffer.rewind();\n        DoubleBuffer clonedDoubleBuffer = (DoubleBuffer) clonedBuffers[5];\n        assertEquals(srcDoubleBuffer, clonedDoubleBuffer);\n\n        // Check if the buffers have been reset after clone operation\n        assertFalse(srcByteBuffer.position() > 0, \"Source ByteBuffer should be rewound\");\n        assertFalse(clonedByteBuffer.position() > 0, \"Cloned ByteBuffer should be rewound\");\n\n        assertFalse(srcShortBuffer.position() > 0, \"Source ShortBuffer should be rewound\");\n        assertFalse(clonedShortBuffer.position() > 0, \"Cloned ShortBuffer should be rewound\");\n\n        assertFalse(srcIntBuffer.position() > 0, \"Source IntBuffer should be rewound\");\n        assertFalse(clonedIntBuffer.position() > 0, \"Cloned IntBuffer should be rewound\");\n\n        assertFalse(srcLongBuffer.position() > 0, \"Source LongBuffer should be rewound\");\n        assertFalse(clonedLongBuffer.position() > 0, \"Cloned LongBuffer should be rewound\");\n\n        assertFalse(srcFloatBuffer.position() > 0, \"Source FloatBuffer should be rewound\");\n        assertFalse(clonedFloatBuffer.position() > 0, \"Cloned FloatBuffer should be rewound\");\n\n        assertFalse(srcDoubleBuffer.position() > 0, \"Source DoubleBuffer should be rewound\");\n        assertFalse(clonedDoubleBuffer.position() > 0, \"Cloned DoubleBuffer should be rewound\");\n    }\n}",
        "\npackage org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        // Prepare source buffers with some test data\n        ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n        byteBuffer.put(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0});\n        ShortBuffer shortBuffer = ShortBuffer.allocate(10);\n        shortBuffer.put(new short[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0});\n        // You can also fill in with test data for IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer\n\n        // Initializing arrays of buffers for source and cloned\n        Buffer[] srcBuffers = new Buffer[]{byteBuffer, shortBuffer};\n        Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n        \n        // Call the method to test\n        Pointer result = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n\n        // Assertions and Assumptions\n        assertNotNull(result);\n        assertEquals(srcBuffers.length, clonedBuffers.length);\n\n        for (int i = 0; i < srcBuffers.length; i++) {\n            assertNotNull(clonedBuffers[i]);\n            assertEquals(srcBuffers[i].capacity(), clonedBuffers[i].capacity());\n            \n            // Rewind buffers to check content equality\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n\n            if (srcBuffers[i] instanceof ByteBuffer) {\n                ByteBuffer original = (ByteBuffer) srcBuffers[i];\n                ByteBuffer clone = (ByteBuffer) clonedBuffers[i];\n                while (original.hasRemaining()) {\n                    assertEquals(original.get(), clone.get());\n                }\n            } else if (srcBuffers[i] instanceof ShortBuffer) {\n                ShortBuffer original = (ShortBuffer) srcBuffers[i];\n                ShortBuffer clone = (ShortBuffer) clonedBuffers[i];\n                while (original.hasRemaining()) {\n                    assertEquals(original.get(), clone.get());\n                }\n            }\n\n            // You can add similar checks for IntBuffer, LongBuffer, FloatBuffer, DoubleBuffer\n\n            // Reset positions after checking\n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n        }\n\n        // Retain reference check\n        assertEquals(1, result.referenceCount());\n    }\n}\n",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.nio.*;\n\npublic class FrameTest {\n\n    @Test\n    public void cloneBufferArrayTest() {\n        // Sample test case for cloneBufferArray method with ByteBuffer\n        ByteBuffer srcBuffer1 = ByteBuffer.allocate(10);\n        ByteBuffer srcBuffer2 = ByteBuffer.allocate(10);\n        srcBuffer1.put(new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0});\n        srcBuffer2.put(new byte[]{-1, -2, -3, -4, -5, -6, -7, -8, -9, -10});\n\n        ByteBuffer[] srcBuffers = {srcBuffer1, srcBuffer2};\n        ByteBuffer[] clonedBuffers = new ByteBuffer[srcBuffers.length];\n\n        Pointer result = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n\n        assertNotNull(result, \"Resulting 'Pointer' should not be null\");\n        assertTrue(result instanceof BytePointer, \"Resulting 'Pointer' should be an instance of BytePointer\");\n        \n        for (int i = 0; i < srcBuffers.length; i++) {\n            byte[] srcArray = new byte[srcBuffers[i].capacity()];\n            byte[] clonedArray = new byte[clonedBuffers[i].capacity()];\n            \n            srcBuffers[i].rewind();\n            clonedBuffers[i].rewind();\n            srcBuffers[i].get(srcArray);\n            clonedBuffers[i].get(clonedArray);\n            \n            assertArrayEquals(srcArray, clonedArray, \"Buffer content mismatch at index \" + i);\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.nio.*;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        // Test cloning of ByteBuffer array\n        ByteBuffer srcBuf1 = ByteBuffer.allocateDirect(10).put(new byte[10]);\n        ByteBuffer srcBuf2 = ByteBuffer.allocateDirect(20).put(new byte[20]);\n        Buffer[] srcBuffers = new Buffer[] {srcBuf1, srcBuf2};\n        Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n        \n        Pointer opaque1 = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n        assertNotNull(opaque1);\n        assertTrue(opaque1 instanceof BytePointer);\n        \n        for (int i = 0; i < srcBuffers.length; i++) {\n            assertTrue(clonedBuffers[i] instanceof ByteBuffer);\n            ByteBuffer srcBuffer = (ByteBuffer)srcBuffers[i];\n            ByteBuffer clonedBuffer = (ByteBuffer)clonedBuffers[i];\n            \n            assertEquals(srcBuffer.capacity(), clonedBuffer.capacity());\n            assertEquals(srcBuffer.position(), clonedBuffer.position());\n            srcBuffer.rewind();\n            clonedBuffer.rewind();\n            for (int j = 0; j < srcBuffer.limit(); j++) {\n                assertEquals(srcBuffer.get(), clonedBuffer.get());\n            }\n        }\n\n        // Test cloning of another buffer type, e.g., IntBuffer\n        // Additional buffer types can be tested in a similar manner by creating a new test or by looping over different buffer types\n        IntBuffer srcIntBuf1 = IntBuffer.allocate(10).put(new int[10]);\n        IntBuffer srcIntBuf2 = IntBuffer.allocate(20).put(new int[20]);\n        Buffer[] srcIntBuffers = new Buffer[] {srcIntBuf1, srcIntBuf2};\n        Buffer[] clonedIntBuffers = new Buffer[srcIntBuffers.length];\n        \n        Pointer opaque2 = Frame.cloneBufferArray(srcIntBuffers, clonedIntBuffers);\n        assertNotNull(opaque2);\n        assertTrue(opaque2 instanceof IntPointer);\n        \n        for (int i = 0; i < srcIntBuffers.length; i++) {\n            assertTrue(clonedIntBuffers[i] instanceof IntBuffer);\n            IntBuffer srcIntBuffer = (IntBuffer)srcIntBuffers[i];\n            IntBuffer clonedIntBuffer = (IntBuffer)clonedIntBuffers[i];\n            \n            assertEquals(srcIntBuffer.capacity(), clonedIntBuffer.capacity());\n            assertEquals(srcIntBuffer.position(), clonedIntBuffer.position());\n            srcIntBuffer.rewind();\n            clonedIntBuffer.rewind();\n            for (int j = 0; j < srcIntBuffer.limit(); j++) {\n                assertEquals(srcIntBuffer.get(), clonedIntBuffer.get());\n            }\n        }\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport java.nio.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class FrameTest {\n    @Test\n    public void cloneBufferArrayTest() {\n        // Given\n        ByteBuffer srcBufferOne = ByteBuffer.allocateDirect(5).put(new byte[]{1, 2, 3, 4, 5});\n        ByteBuffer srcBufferTwo = ByteBuffer.allocateDirect(5).put(new byte[]{6, 7, 8, 9, 10});\n        srcBufferOne.rewind();\n        srcBufferTwo.rewind();\n        \n        Buffer[] srcBuffers = new Buffer[]{srcBufferOne, srcBufferTwo};\n        Buffer[] clonedBuffers = new Buffer[srcBuffers.length];\n\n        // When\n        Pointer resultPointer = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n\n        // Then\n        assertNotNull(resultPointer, \"The result pointer should not be null\");\n        assertTrue(resultPointer instanceof BytePointer, \"The result should be an instance of BytePointer\");\n        \n        ByteBuffer clonedBufferOne = (ByteBuffer) clonedBuffers[0];\n        ByteBuffer clonedBufferTwo = (ByteBuffer) clonedBuffers[1];\n        \n        // Check the contents of the first cloned buffer\n        byte[] clonedContentsOne = new byte[clonedBufferOne.capacity()];\n        clonedBufferOne.get(clonedContentsOne);\n        assertArrayEquals(new byte[]{1, 2, 3, 4, 5}, clonedContentsOne, \"The contents of the first cloned buffer must match the source buffer\");\n        \n        // Check the contents of the second cloned buffer\n        byte[] clonedContentsTwo = new byte[clonedBufferTwo.capacity()];\n        clonedBufferTwo.get(clonedContentsTwo);\n        assertArrayEquals(new byte[]{6, 7, 8, 9, 10}, clonedContentsTwo, \"The contents of the second cloned buffer must match the source buffer\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.nio.*;\n\npublic class FrameTest {\n\n    // Method to initialize a ByteBuffer with given capacity and fill it with sequential bytes\n    private ByteBuffer initByteBuffer(int capacity) {\n        ByteBuffer buffer = ByteBuffer.allocate(capacity);\n        for (int i = 0; i < capacity; i++) {\n            buffer.put((byte) i);\n        }\n        buffer.rewind();\n        return buffer;\n    }\n\n    @Test\n    public void cloneBufferArrayTest() {\n        // Initialize the source Buffer array with ByteBuffers\n        int numBuffers = 2;\n        int bufferCapacity = 10;\n        Buffer[] srcBuffers = new Buffer[numBuffers];\n        for (int i = 0; i < numBuffers; i++) {\n            srcBuffers[i] = initByteBuffer(bufferCapacity);\n        }\n        \n        // Initialize an empty Buffer array for cloned Buffers with the same length\n        Buffer[] clonedBuffers = new Buffer[numBuffers];\n        \n        // Call the method to be tested\n        Pointer resultPointer = Frame.cloneBufferArray(srcBuffers, clonedBuffers);\n\n        // Verify the result: clonedBuffers should contain ByteBuffers with the same content as srcBuffers\n        assertNotNull(resultPointer, \"Returned Pointer should not be null\");\n        for (int i = 0; i < numBuffers; i++) {\n            assertTrue(clonedBuffers[i] instanceof ByteBuffer, \"Cloned Buffer should be an instance of ByteBuffer\");\n            ByteBuffer srcByteBuffer = (ByteBuffer) srcBuffers[i];\n            ByteBuffer clonedByteBuffer = (ByteBuffer) clonedBuffers[i];\n            assertEquals(srcByteBuffer.capacity(), clonedByteBuffer.capacity(), \"Capacities of source and cloned ByteBuffer should be equal\");\n            while (srcByteBuffer.hasRemaining()) {\n                assertEquals(srcByteBuffer.get(), clonedByteBuffer.get(), \"Contents of corresponding positions should match\");\n            }\n            srcByteBuffer.rewind();\n            clonedByteBuffer.rewind();\n        }\n    }\n}"
    ]
}