{
    "project_name": "javacv",
    "file_name": "IPCameraFrameGrabber.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/IPCameraFrameGrabber.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Returns the value of the {@code long} argument;\n     * throwing an exception if the value overflows an {@code int}.\n     *\n     * @param value the long value\n     * @return the argument as an int\n     * @throws ArithmeticException if the {@code argument} overflows an int\n     * @see <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toIntExact-long-\">Java 8 Implementation</a>\n     */",
    "source_code": "\nprivate static int toIntExact(long value) {\n    if ((int) value != value) {\n        throw new ArithmeticException(\"integer overflow\");\n    }\n    return (int) value;\n}\n",
    "class_name": "IPCameraFrameGrabber",
    "method_name": "toIntExact",
    "arguments": [
        "long value"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n    \n    // Test for success on a value that can be precisely represented as an int\n    @Test\n    public void toIntExactSuccessTest() {\n        long withinIntRange = 1234567890L;\n        assertEquals((int) withinIntRange, IPCameraFrameGrabber.toIntExact(withinIntRange), \n            \"Conversion of long within int range did not succeed as expected.\");\n    }\n    \n    // Test for expected exception on a value that cannot be represented as an int\n    @Test\n    public void toIntExactOverflowTest() {\n        long outsideIntRange = ((long) Integer.MAX_VALUE) + 1;\n        assertThrows(ArithmeticException.class, () -> {\n            IPCameraFrameGrabber.toIntExact(outsideIntRange);\n        }, \"ArithmeticException was expected due to integer overflow, but was not thrown.\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n    @Test\n    public void toIntExactTest() {\n        // Test with a value that does not cause overflow\n        int expected = 123456;\n        long value = 123456L;\n        assertEquals(expected, IPCameraFrameGrabber.toIntExact(value),\n                \"The toIntExact method should return the int value when there's no overflow\");\n\n        // Test with a maximum int value that does not cause overflow\n        expected = Integer.MAX_VALUE;\n        value = (long) Integer.MAX_VALUE;\n        assertEquals(expected, IPCameraFrameGrabber.toIntExact(value),\n                \"The toIntExact method should return the int value when there's no overflow\");\n\n        // Test with a value that causes overflow\n        value = ((long) Integer.MAX_VALUE) + 1;\n        Exception exception = assertThrows(ArithmeticException.class,\n                () -> IPCameraFrameGrabber.toIntExact(value),\n                \"The toIntExact method should throw ArithmeticException when overflow occurs\");\n\n        String expectedMessage = \"integer overflow\";\n        String actualMessage = exception.getMessage();\n        assertTrue(actualMessage.contains(expectedMessage),\n                \"Exception message must contain the expected overflow message\");\n\n        // Test with a minimum int value that does not cause overflow\n        expected = Integer.MIN_VALUE;\n        value = (long) Integer.MIN_VALUE;\n        assertEquals(expected, IPCameraFrameGrabber.toIntExact(value),\n                \"The toIntExact method should return the int value when there's no overflow\");\n\n        // Test with a value that causes underflow\n        value = ((long) Integer.MIN_VALUE) - 1;\n        exception = assertThrows(ArithmeticException.class,\n                () -> IPCameraFrameGrabber.toIntExact(value),\n                \"The toIntExact method should throw ArithmeticException when underflow occurs\");\n\n        actualMessage = exception.getMessage();\n        assertTrue(actualMessage.contains(expectedMessage),\n                \"Exception message must contain the expected underflow message\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class IPCameraFrameGrabberTest {\n    \n    // Utility method to access the private method 'toIntExact'\n    private static int toIntExact(long value) {\n        try {\n            java.lang.reflect.Method method = IPCameraFrameGrabber.class.getDeclaredMethod(\"toIntExact\", long.class);\n            method.setAccessible(true);\n            return (Integer) method.invoke(null, value);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Test\n    public void toIntExactTestWithinIntRange() {\n        // Test with a value within the int range.\n        long inRangeValue = 100L;\n        assertEquals(100, toIntExact(inRangeValue), \"The value should be properly cast to int.\");\n    }\n\n    @Test\n    public void toIntExactTestAtIntBoundary() {\n        // Test with the maximum int value.\n        long intMaxValue = Integer.MAX_VALUE;\n        assertEquals(Integer.MAX_VALUE, toIntExact(intMaxValue), \"The maximum int value should not overflow.\");\n\n        // Test with the minimum int value.\n        long intMinValue = Integer.MIN_VALUE;\n        assertEquals(Integer.MIN_VALUE, toIntExact(intMinValue), \"The minimum int value should not overflow.\");\n    }\n\n    @Test\n    public void toIntExactTestOverflow() {\n        // Test with a value just above the int range to check for the overflow exception.\n        long overflowValue = ((long) Integer.MAX_VALUE) + 1;\n        assertThrows(ArithmeticException.class, () -> toIntExact(overflowValue), \"Overflow should throw an ArithmeticException.\");\n\n        // Test with a value just below the int range to check for the overflow exception.\n        long underflowValue = ((long) Integer.MIN_VALUE) - 1;\n        assertThrows(ArithmeticException.class, () -> toIntExact(underflowValue), \"Underflow should throw an ArithmeticException.\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n    // Since the method is private, it needs to be accessed via reflection or by adding a testing seam\n    // For the sake of this exercise, I'm assuming a public or package-private access has been given for testing.\n\n    @Test\n    public void toIntExactTestWithValidInput() {\n        assertEquals(0, IPCameraFrameGrabber.toIntExact(0L));\n        assertEquals(42, IPCameraFrameGrabber.toIntExact(42L));\n        assertEquals(-42, IPCameraFrameGrabber.toIntExact(-42L));\n        assertEquals(Integer.MAX_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE));\n        assertEquals(Integer.MIN_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE));\n    }\n\n    @Test\n    public void toIntExactTestWithOverflow() {\n        assertThrows(ArithmeticException.class, () -> {\n            IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE + 1);\n        });\n\n        assertThrows(ArithmeticException.class, () -> {\n            IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE - 1);\n        });\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n\n    // Assuming toIntExact is a method within IPCameraFrameGrabber \n    // and can be accessed in the test context\n    // (e.g., it has package-private access).\n    // If it's private, it should not be tested directly or should be made package-private.\n    \n    @Test\n    public void toIntExactTest() {\n        assertAll(\"toIntExact should correctly convert long values to int or throw\",\n            // Test case with a value that fits into an int\n            () -> assertEquals(42, IPCameraFrameGrabber.toIntExact(42L), \"toIntExact should return the same int value for a long that fits within int range\"),\n            // Test case with the maximum int value\n            () -> assertEquals(Integer.MAX_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE), \"toIntExact should return the same value for the maximum int as long\"),\n            // Test case with the minimum int value\n            () -> assertEquals(Integer.MIN_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE), \"toIntExact should return the same value for the minimum int as long\"),\n            // Test case that should throw an ArithmeticException due to overflow - value too large\n            () -> assertThrows(ArithmeticException.class, () -> IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE + 1), \"toIntExact should throw ArithmeticException when long value is too large to fit into an int range\"),\n            // Test case that should throw an ArithmeticException due to underflow - value too small\n            () -> assertThrows(ArithmeticException.class, () -> IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE - 1), \"toIntExact should throw ArithmeticException when long value is too small to fit into an int range\")\n        );\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n    @Test\n    public void toIntExactTest() {\n        // Test for values that fit within int range\n        assertEquals(0, IPCameraFrameGrabber.toIntExact(0L));\n        assertEquals(Integer.MAX_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE));\n        assertEquals(Integer.MIN_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE));\n\n        // Test for values that overflow int range\n        assertThrows(ArithmeticException.class, () -> {\n            IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE + 1);\n        });\n\n        assertThrows(ArithmeticException.class, () -> {\n            IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE - 1);\n        });\n\n        // Test for large long values outside the int range\n        assertThrows(ArithmeticException.class, () -> {\n            IPCameraFrameGrabber.toIntExact(Long.MAX_VALUE);\n        });\n\n        assertThrows(ArithmeticException.class, () -> {\n            IPCameraFrameGrabber.toIntExact(Long.MIN_VALUE);\n        });\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n\n    @Test\n    public void toIntExactTest() {\n\n        // Case where conversion is successful\n        assertEquals(0, IPCameraFrameGrabber.toIntExact(0L), \"Conversion of 0L should succeed\");\n        assertEquals(Integer.MAX_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE), \"Conversion of max int value should succeed\");\n        assertEquals(Integer.MIN_VALUE, IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE), \"Conversion of min int value should succeed\");\n\n        // Case where conversion should fail due to overflow\n        assertThrows(ArithmeticException.class, () -> IPCameraFrameGrabber.toIntExact((long) Integer.MAX_VALUE + 1), \"Conversion should overflow and fail\");\n        assertThrows(ArithmeticException.class, () -> IPCameraFrameGrabber.toIntExact((long) Integer.MIN_VALUE - 1), \"Conversion should underflow and fail\");\n        \n        // Additional tests could be written to cover more edge cases if necessary\n    }\n}\n",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n\n    // Inner class to access private methods of IPCameraFrameGrabber for testing\n    static class TestFrameGrabber extends IPCameraFrameGrabber {\n        public TestFrameGrabber() throws Exception {\n            // Dummy URL is passed since we are testing a static utility method.\n            super(\"http://127.0.0.1\", -1, -1, null);\n        }\n\n        public static int callToIntExact(long value) {\n            // This static method accesses the private static method in IPCameraFrameGrabber\n            return toIntExact(value);\n        }\n    }\n\n    @Test\n    public void toIntExactTest() {\n        // Test for a value that does not cause overflow\n        assertEquals(0, TestFrameGrabber.callToIntExact(0L));\n        assertEquals(Integer.MAX_VALUE, TestFrameGrabber.callToIntExact((long) Integer.MAX_VALUE));\n        assertEquals(Integer.MIN_VALUE, TestFrameGrabber.callToIntExact((long) Integer.MIN_VALUE));\n\n        // Test for value that overflows an int should throw ArithmeticException\n        Throwable overflowException = assertThrows(ArithmeticException.class, () -> {\n            TestFrameGrabber.callToIntExact((long) Integer.MAX_VALUE + 1);\n        });\n        assertEquals(\"integer overflow\", overflowException.getMessage());\n\n        // Test for negative value that overflows an int should also throw ArithmeticException\n        Throwable underflowException = assertThrows(ArithmeticException.class, () -> {\n            TestFrameGrabber.callToIntExact((long) Integer.MIN_VALUE - 1);\n        });\n        assertEquals(\"integer overflow\", underflowException.getMessage());\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n\n    // Assuming we have an inner class for the purpose of test so that we can access the private method.\n    // If the method toIntExact was not private, we would simply call it directly on IPCameraFrameGrabber class.\n    private static class IPCameraFrameGrabberForTest extends IPCameraFrameGrabber {\n        public static int toIntExactPublic(long value) {\n            return IPCameraFrameGrabber.toIntExact(value);\n        }\n    }\n\n    @Test\n    public void toIntExactTest() {\n        // Test for cases without overflow.\n        assertEquals(0, IPCameraFrameGrabberForTest.toIntExactPublic(0), \"toIntExact should return 0 for input 0.\");\n        assertEquals(42, IPCameraFrameGrabberForTest.toIntExactPublic(42), \"toIntExact should return 42 for input 42.\");\n        assertEquals(-42, IPCameraFrameGrabberForTest.toIntExactPublic(-42), \"toIntExact should return -42 for input -42.\");\n        assertEquals(Integer.MAX_VALUE, IPCameraFrameGrabberForTest.toIntExactPublic(Integer.MAX_VALUE), \n                     \"toIntExact should return Integer.MAX_VALUE for input Integer.MAX_VALUE.\");\n\n        // Test for cases with overflow.\n        ArithmeticException exception;\n\n        exception = assertThrows(ArithmeticException.class, () -> IPCameraFrameGrabberForTest.toIntExactPublic((long) Integer.MAX_VALUE + 1));\n        assertEquals(\"integer overflow\", exception.getMessage(), \n                     \"toIntExact should throw an exception for integer overflow when input is greater than Integer.MAX_VALUE.\");\n        \n        exception = assertThrows(ArithmeticException.class, () -> IPCameraFrameGrabberForTest.toIntExactPublic((long) Integer.MIN_VALUE - 1));\n        assertEquals(\"integer overflow\", exception.getMessage(), \n                     \"toIntExact should throw an exception for integer overflow when input is less than Integer.MIN_VALUE.\");\n    }\n}\n",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class IPCameraFrameGrabberTest {\n    \n    // Helper method to invoke the private toIntExact method using reflection.\n    private static int callToIntExact(long value) throws Exception {\n        java.lang.reflect.Method method = IPCameraFrameGrabber.class.getDeclaredMethod(\"toIntExact\", long.class);\n        method.setAccessible(true);\n        return (int) method.invoke(null, value);\n    }\n    \n    @Test\n    public void toIntExactWithinIntRange() {\n        assertAll(\"toIntExact for values within int range\",\n            () -> assertEquals(0, callToIntExact(0L)),\n            () -> assertEquals(Integer.MAX_VALUE, callToIntExact((long) Integer.MAX_VALUE)),\n            () -> assertEquals(Integer.MIN_VALUE, callToIntExact((long) Integer.MIN_VALUE))\n        );\n    }\n\n    @Test\n    public void toIntExactOutsideIntRange() {\n        assertAll(\"toIntExact throws ArithmeticException for values outside of int range\",\n            () -> assertThrows(ArithmeticException.class, () -> callToIntExact(((long) Integer.MAX_VALUE) + 1)),\n            () -> assertThrows(ArithmeticException.class, () -> callToIntExact(((long) Integer.MIN_VALUE) - 1))\n        );\n    }\n}"
    ]
}