{
    "project_name": "javacv",
    "file_name": "JavaCV.java",
    "relative_path": "javacv/src/main/java/org/bytedeco/javacv/JavaCV.java",
    "execute_path": "javacv",
    "package": "org.bytedeco.javacv",
    "docstring": "/**\n     * Ported to Java/OpenCV from\n     * Bill Triggs. Autocalibration from Planar Scenes. In 5th European Conference\n     * on Computer Vision (ECCV \u201998), volume I, pages 89\u2013105. Springer-Verlag, 1998.\n     */",
    "source_code": "\npublic static double homogToRt(CvMat H,\n        CvMat R1, CvMat t1, CvMat n1,\n        CvMat R2, CvMat t2, CvMat n2) {\n    CvMat S = S3x3.get(), U = U3x3.get(), V = V3x3.get();\n    cvSVD(H, S, U, V, 0);\n    double zeta = homogToRt(S, U, V, R1, t1, n1, R2, t2, n2);\n    return zeta;\n}\n",
    "class_name": "JavaCV",
    "method_name": "homogToRt",
    "arguments": [
        "CvMat H",
        "CvMat R1",
        "CvMat t1",
        "CvMat n1",
        "CvMat R2",
        "CvMat t2",
        "CvMat n2"
    ],
    "generate_test": [
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        CvMat H = CvMat.create(3, 3);\n        CvMat R1 = CvMat.create(3, 3);\n        CvMat t1 = CvMat.create(3, 1);\n        CvMat n1 = CvMat.create(3, 1);\n        CvMat R2 = CvMat.create(3, 3);\n        CvMat t2 = CvMat.create(3, 1);\n        CvMat n2 = CvMat.create(3, 1);\n\n        // Fill the matrices with some values. Real values could represent some\n        // valid transformation and its decompositions. For simplicity, we'll\n        // use arbitrary values to demonstrate the test structure.\n        H.put(0, 0, 1);\n        H.put(0, 1, 0);\n        H.put(0, 2, 0);\n        H.put(1, 0, 0);\n        H.put(1, 1, 1);\n        H.put(1, 2, 0);\n        H.put(2, 0, 0);\n        H.put(2, 1, 0);\n        H.put(2, 2, 1);\n\n        // The actual values for R1, t1, n1, R2, t2, n2 can be generated using some \n        // predefined criteria or they can be the results of some algorithm that you expect \n        // to match when passing the homography matrix H. For the test, we assume that they are \n        // already computed and we are verifying that the method produces those exact results.\n\n        // Compute the actual result\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Since the method should return a double value, we compare this value with \n        // the expected value using assertEquals. Here, we assume the expected value \n        // to be computed in some manner specific to the application.\n        double expectedZeta = 0.0; // Change to the expected value\n        assertEquals(expectedZeta, zeta, 1e-6, \"The zeta value should match the expected result.\");\n\n        // Further validation could be done to check the contents of R1, t1, n1, R2, t2, n2 \n        // if the decomposed values are indeed to be verified against expected results.\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.bytedeco.opencv.opencv_core.CvMat;\nimport org.junit.jupiter.api.*;\nimport static org.bytedeco.javacpp.opencv_core.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Assume these are valid transformation matrices compatible with the method requirements\n        CvMat H = CvMat.create(3, 3);\n        CvMat R1 = CvMat.create(3, 3);\n        CvMat t1 = CvMat.create(3, 1);\n        CvMat n1 = CvMat.create(3, 1);\n        CvMat R2 = CvMat.create(3, 3);\n        CvMat t2 = CvMat.create(3, 1);\n        CvMat n2 = CvMat.create(3, 1);\n\n        // Initialize matrices to simulate input\n        // Ideally, use real values to test against a known output\n        cvSetIdentity(H);\n        cvSetIdentity(R1);\n        cvSetZero(t1);\n        cvSetZero(n1);\n        cvSetIdentity(R2);\n        cvSetZero(t2);\n        cvSetZero(n2);\n\n        // Call the method under test\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Assert some expected properties of the result.\n        // Since we don't have the actual method implementation details or what values to test against,\n        // we'll just check basic sanity checks.\n        assertNotNull(zeta, \"The method should return a non-null value.\");\n\n        // Real tests should compare 'zeta' against expected values based on the input matrices\n        // For example:\n        // double expectedZeta = <EXPECTED_VALUE>;\n        // assertEquals(expectedZeta, zeta, <SOME_SMALL_EPSILON>, \"Zeta should match the expected value.\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.bytedeco.opencv.opencv_core.CvMat;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.bytedeco.opencv.global.opencv_core.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Create dummy matrices for H, R1, t1, n1, R2, t2, n2 using JavaCV functions (usually you would allocate and fill these matrices with meaningful data, but that is beyond this example's scope.)\n        CvMat H = cvCreateMat(3, 3, CV_64FC1);\n        CvMat R1 = cvCreateMat(3, 3, CV_64FC1);\n        CvMat t1 = cvCreateMat(3, 1, CV_64FC1);\n        CvMat n1 = cvCreateMat(3, 1, CV_64FC1);\n        CvMat R2 = cvCreateMat(3, 3, CV_64FC1);\n        CvMat t2 = cvCreateMat(3, 1, CV_64FC1);\n        CvMat n2 = cvCreateMat(3, 1, CV_64FC1);\n\n        // Set up dummy data or mock behavior as needed (depending on method details)\n        // Assume homogToRt is supposed to return a known value, such as 0.0, with dummy data\n        \n        double expectedZeta = 0.0;  // The expected result is dependent on the behavior of homogToRt\n\n        // Call the method under test\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n        \n        // Assert that the measured value matches the expected value within some tolerance\n        double delta = 0.001; // Allowable tolerance in comparison due to double precision arithmetic\n        assertEquals(expectedZeta, zeta, delta, \"The calculated value did not match the expected output.\");\n\n        // Release memory for CvMat objects\n        cvReleaseMat(H);\n        cvReleaseMat(R1);\n        cvReleaseMat(t1);\n        cvReleaseMat(n1);\n        cvReleaseMat(R2);\n        cvReleaseMat(t2);\n        cvReleaseMat(n2);\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        CvMat H = CvMat.create(3, 3);\n        CvMat R1 = CvMat.create(3, 3);\n        CvMat t1 = CvMat.create(3, 1);\n        CvMat n1 = CvMat.create(3, 1);\n        CvMat R2 = CvMat.create(3, 3);\n        CvMat t2 = CvMat.create(3, 1);\n        CvMat n2 = CvMat.create(3, 1);\n\n        // Fill H with test data.\n        H.put(0, 0, 1.0);\n        // Continue initializing H with appropriate values. \n        // H.put(..., ...);\n\n        double result = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Assertions will depend on the expected behavior of `homogToRt`\n        // For this example, let's assume that we expect the result to be a certain value.\n        double expectedZeta = // expected value based on your test data;\n        \n        // Assert that the result is as expected with a tolerance for floating-point comparisons\n        assertEquals(expectedZeta, result, 1e-6);\n\n        // Additional assertions can be made to verify R1, t1, n1, R2, t2, n2 if needed\n        // Example:\n        // assertTrue(...);\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Given\n        CvMat H = mock(CvMat.class);\n        CvMat R1 = mock(CvMat.class);\n        CvMat t1 = mock(CvMat.class);\n        CvMat n1 = mock(CvMat.class);\n        CvMat R2 = mock(CvMat.class);\n        CvMat t2 = mock(CvMat.class);\n        CvMat n2 = mock(CvMat.class);\n        CvMat S = mock(CvMat.class);\n        CvMat U = mock(CvMat.class);\n        CvMat V = mock(CvMat.class);\n\n        // When H is decomposed, assume S, U, V are correct outputs for the unit test\n        // (Real implementation would involve calculations based on the matrix H)\n        // The `JavaCV.homogToRt` static method must be modified to accommodate testing\n        // since it contains static method calls and object retrievals from ThreadLocal\n        // which are not easily mockable.\n\n        // Additionally, assuming homogToRt(S, U, V, R1, t1, n1, R2, t2, n2) returns\n        // a known value (e.g., 1.0) for the purpose of this test.\n        // This value should actually result from the method logic.\n        double expectedZeta = 1.0; \n        when(JavaCV.homogToRt(any(CvMat.class), any(CvMat.class), any(CvMat.class),\n                              any(CvMat.class), any(CvMat.class), any(CvMat.class), \n                              any(CvMat.class), any(CvMat.class), any(CvMat.class)))\n                .thenReturn(expectedZeta);\n\n        // Act\n        double actualZeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Assert\n        assertEquals(expectedZeta, actualZeta, \"The zeta value was not calculated as expected.\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.bytedeco.opencv.opencv_core.CvMat;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.bytedeco.opencv.global.opencv_core.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Initialize matrices for the input and output arguments.\n        CvMat H = CvMat.create(3, 3);\n        CvMat R1 = CvMat.create(3, 3);\n        CvMat t1 = CvMat.create(3, 1);\n        CvMat n1 = CvMat.create(3, 1);\n        CvMat R2 = CvMat.create(3, 3);\n        CvMat t2 = CvMat.create(3, 1);\n        CvMat n2 = CvMat.create(3, 1);\n\n        // Fill the input homography matrix 'H' with some test values.\n        // In real cases, these values should represent a real homography matrix.\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                H.put(i, j, i * 3 + j + 1); // Simple sequential values for demonstration purposes.\n            }\n        }\n\n        // Call the method to be tested.\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Add assertions to verify that the output matrices (R1, t1, n1, R2, t2, n2) are correctly updated.\n        // Also verify the returned value 'zeta'. Since we do not have a particular expected value,\n        // here we are just verifying that the method runs without throwing an exception.\n        // In real unit tests, expected matrices should come from manual calculations or known results.\n        assertNotNull(R1);\n        assertNotNull(t1);\n        assertNotNull(n1);\n        assertNotNull(R2);\n        assertNotNull(t2);\n        assertNotNull(n2);\n        assertNotEquals(0, zeta, \"The return value 'zeta' should not be zero if 'H' is a valid homography matrix.\");\n\n        // Optionally, if there's a known result expected, you could add more detailed assertions like:\n        // assertEquals(expectedValue, R1.get(0, 0), \"R1 has unexpected value at (0, 0)\");\n        // assertEquals(expectedValue, t1.get(0, 0), \"t1 has unexpected value at (0, 0)\");\n        // ... and so on for other matrix elements.\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n    \n    @Test\n    public void homogToRtTest() {\n        // Assuming that the homogToRt function is intended to decompose the homography matrix H into rotation matrices R1, R2, translation vectors t1, t2, and normal vectors n1, n2\n        // Here, a dummy test case is created since the actual homography matrix H and the decomposed elements are not provided.\n        \n        // Dummy homography matrix and output placeholders\n        CvMat H = CvMat.create(3, 3);\n        CvMat R1 = CvMat.create(3, 3);\n        CvMat t1 = CvMat.create(3, 1);\n        CvMat n1 = CvMat.create(3, 1);\n        CvMat R2 = CvMat.create(3, 3);\n        CvMat t2 = CvMat.create(3, 1);\n        CvMat n2 = CvMat.create(3, 1);\n        \n        // Populate H with some test values\n        H.put(0, 0, 1.0);\n        H.put(0, 1, 0.0);\n        H.put(0, 2, 0.0);\n        H.put(1, 0, 0.0);\n        H.put(1, 1, 1.0);\n        H.put(1, 2, 0.0);\n        H.put(2, 0, 0.0);\n        H.put(2, 1, 0.0);\n        H.put(2, 2, 1.0);\n        \n        // Call the method under test\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Verify the values of R1, t1, n1, R2, t2, n2, and zeta\n        // This is a sample assertion to ensure there is no exception thrown from the homogToRt method\n        // In a real scenario, one would replace these with meaningful assertions checking the expected behavior\n        \n        assertNotNull(R1);\n        assertNotNull(t1);\n        assertNotNull(n1);\n        assertNotNull(R2);\n        assertNotNull(t2);\n        assertNotNull(n2);\n        // Not a real test condition, just preventing that zeta remains unused. Replace with real conditions.\n        assertNotEquals(0, zeta); \n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.junit.jupiter.api.*;\nimport org.bytedeco.opencv.opencv_core.CvMat;\n\nimport static org.bytedeco.opencv.global.opencv_core.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JavaCVTest {\n\n    @Test\n    public void homogToRtTest() {\n        // Create test data\n        // As per the source code, this method would calculate and return a double value.\n        // Here, we create dummy CvMat objects with proper initialization,\n        // typically these would be actual matrices representing real transformation data.\n        CvMat H = CvMat.create(3, 3); // Assuming H is a 3x3 matrix.\n        CvMat R1 = CvMat.create(3, 3);\n        CvMat t1 = CvMat.create(3, 1);\n        CvMat n1 = CvMat.create(3, 1);\n        CvMat R2 = CvMat.create(3, 3);\n        CvMat t2 = CvMat.create(3, 1);\n        CvMat n2 = CvMat.create(3, 1);\n\n        // Initialize test data\n        // We'll fill the matrices with arbitrary values for testing purposes.\n        cvSetIdentity(H);\n        cvSetIdentity(R1);\n        cvSetIdentity(R2);\n        cvZero(t1);\n        cvZero(t2);\n        cvZero(n1);\n        cvZero(n2);\n        t1.put(0, 1);\n        t2.put(0, 1);\n        n1.put(0, 1);\n        n2.put(0, 1);\n\n        // Call the method under test\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Verify the result is a valid double value\n        // We cannot assert for an exact value without knowing the exact behavior of the\n        // homogToRt method and without valid input matrices.\n        // Here, we just check the returned value is not NaN or Infinite, which is a simple sanity check.\n        assertFalse(Double.isNaN(zeta), \"The value of zeta should not be NaN\");\n        assertFalse(Double.isInfinite(zeta), \"The value of zeta should not be Infinite\");\n        // Additional assertions can be added if needed, based on the expected output of the method.\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.bytedeco.opencv.opencv_core.CvMat;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.bytedeco.opencv.global.opencv_core.*;\n\npublic class JavaCVTest {\n    @Test\n    public void homogToRtTest() {\n        // Create dummy CvMat objects with arbitrary data for the test\n        CvMat H = CvMat.create(3, 3);\n        CvMat R1 = CvMat.create(3, 3);\n        CvMat t1 = CvMat.create(3, 1);\n        CvMat n1 = CvMat.create(3, 1);\n        CvMat R2 = CvMat.create(3, 3);\n        CvMat t2 = CvMat.create(3, 1);\n        CvMat n2 = CvMat.create(3, 1);\n\n        // Fill the CvMat objects with test data.\n        // This step is typically tailored to the expected transformation\n        // provided by the homogToRt function, which cannot be detailed here\n        // due to missing context on the function's internals.\n        // For a meaningful test, use representative data and expected result.\n        H.put(0, 0, 1.0); // Fill H with an example transformation matrix\n        // ... Fill the rest with appropriate values\n\n        // Perform the operation you are testing\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Assert the results based on what you expect the function to do\n        // For example, you will replace <EXPECTED_ZETA> with the actual expected value\n        double expectedZeta = <EXPECTED_ZETA>;\n        assertEquals(expectedZeta, zeta, \"The homogToRt function did not return the expected value\");\n\n        // Optionally, assert the transformations on R1, t1, n1, R2, t2, and n2\n        // have been performed correctly, assuming you know the expected results.\n        // For example:\n        // assertArrayEquals(<EXPECTED_ARRAY>, R1.data().asDoubleBuffer().array(), \"R1 matrix does not match expected values\");\n    }\n}",
        "package org.bytedeco.javacv;\n\nimport org.bytedeco.opencv.opencv_core.CvMat;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.bytedeco.opencv.global.opencv_core.*;\n\npublic class JavaCVTest {\n    \n    @Test\n    public void homogToRtTest() {\n        // Create test matrices simulating the transformation matrix (H) and \n        // the possible output matrices for rotation (R1, R2) and translation (t1, t2) and the normal (n1, n2).\n        CvMat H = cvCreateMat(3, 3, CV_64FC1);\n        CvMat R1 = cvCreateMat(3, 3, CV_64FC1);\n        CvMat t1 = cvCreateMat(3, 1, CV_64FC1);\n        CvMat n1 = cvCreateMat(3, 1, CV_64FC1);\n        CvMat R2 = cvCreateMat(3, 3, CV_64FC1);\n        CvMat t2 = cvCreateMat(3, 1, CV_64FC1);\n        CvMat n2 = cvCreateMat(3, 1, CV_64FC1);\n\n        // Initialize H with some values representing a typical homography matrix.\n        cvSetIdentity(H);\n\n        // Call the method under test\n        double zeta = JavaCV.homogToRt(H, R1, t1, n1, R2, t2, n2);\n\n        // Perform assertions to verify the behavior of the method, depending on the expected result.\n        // Here we're just checking if zeta is not NaN, as proper assertions would be based on known outcomes.\n        assertFalse(Double.isNaN(zeta));\n\n        // More detailed tests could be added here to verify that R1, t1, n1, R2, t2, and n2\n        // have been set to expected values based on the input matrix H.\n\n        // Clean up native resources\n        cvReleaseMat(H);\n        cvReleaseMat(R1);\n        cvReleaseMat(t1);\n        cvReleaseMat(n1);\n        cvReleaseMat(R2);\n        cvReleaseMat(t2);\n        cvReleaseMat(n2);\n    }\n}"
    ]
}