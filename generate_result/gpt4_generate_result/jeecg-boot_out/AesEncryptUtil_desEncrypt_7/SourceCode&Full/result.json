{
    "project_name": "jeecg-boot",
    "file_name": "AesEncryptUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/util/encryption/AesEncryptUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.util.encryption",
    "docstring": "/**\n     * \u89e3\u5bc6\u65b9\u6cd5\n     * @param data \u8981\u89e3\u5bc6\u7684\u6570\u636e\n     * @param key  \u89e3\u5bc6key\n     * @param iv \u89e3\u5bc6iv\n     * @return \u89e3\u5bc6\u7684\u7ed3\u679c\n     * @throws Exception\n     */",
    "source_code": "\npublic static String desEncrypt(String data, String key, String iv) throws Exception {\n    //update-begin-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n    byte[] encrypted1 = Base64.decode(data);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n    IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n    cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n    byte[] original = cipher.doFinal(encrypted1);\n    String originalString = new String(original);\n    //\u52a0\u5bc6\u89e3\u7801\u540e\u7684\u5b57\u7b26\u4e32\u4f1a\u51fa\u73b0\\u0000\n    return originalString.replaceAll(\"\\\\u0000\", \"\");\n    //update-end-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n}\n",
    "class_name": "AesEncryptUtil",
    "method_name": "desEncrypt",
    "arguments": [
        "String data",
        "String key",
        "String iv"
    ],
    "generate_test": [
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    private static final String KEY = \"16CharLengthKey\"; // Example key (must be 16 characters)\n    private static final String IV = \"16CharLengthIV12\"; // Example IV (must be 16 characters)\n    private static final String PLAIN_TEXT = \"PlainText1234\"; // Example plaintext (length must be a multiple of block size)\n\n    @Test\n    public void desEncryptTest() {\n        try {\n            // First, we encrypt some plaintext\n            String encryptedData = AesEncryptUtil.encrypt(PLAIN_TEXT, KEY, IV);\n\n            // Now we decrypt the encrypted data\n            String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, KEY, IV);\n\n            // The decrypted data should match the original plaintext\n            assertEquals(PLAIN_TEXT, decryptedData);\n        } catch (Exception e) {\n            fail(\"An exception was thrown during the test\", e);\n        }\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.apache.shiro.codec.Base64;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    private static final String KEY = \"0123456789abcdef\"; // Example 16-byte key for AES\n    private static final String IV = \"abcdef9876543210\";  // Example 16-byte IV for AES\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Prepare the data to encrypt and then decrypt\n        String originalData = \"Hello World!\";\n        \n        // Padding the originalData as per the source code (AES/CBC/NoPadding requires block size padding)\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        int blockSize = cipher.getBlockSize();\n        byte[] dataBytes = originalData.getBytes();\n        int plaintextLength = dataBytes.length;\n        if (plaintextLength % blockSize != 0) {\n            plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));\n        }\n        byte[] plaintext = new byte[plaintextLength];\n        System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);\n\n        // Encrypt the padded data\n        SecretKeySpec keyspec = new SecretKeySpec(KEY.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(IV.getBytes());\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        byte[] encrypted = cipher.doFinal(plaintext);\n        String base64EncodedEncryptedData = Base64.encodeToString(encrypted);\n\n        // Attempt to decrypt the data\n        String decryptedData = AesEncryptUtil.desEncrypt(base64EncodedEncryptedData, KEY, IV);\n        \n        // Assertions\n        assertNotNull(decryptedData, \"Decrypted data should not be null\");\n        assertEquals(originalData.trim(), decryptedData.trim(), \"The decrypted data should match the original data\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    private static String KEY = \"1234567890123456\"; // Replace with actual key\n    private static String IV = \"1234567890123456\"; // Replace with actual IV\n\n    @Test\n    public void desEncryptTest() {\n        String originalData = \"Hello World\";\n        String encryptedData, decryptedData;\n\n        try {\n            // Encrypt the original data\n            encryptedData = AesEncryptUtil.encrypt(originalData, KEY, IV);\n            // Decrypt the encrypted data\n            decryptedData = AesEncryptUtil.desEncrypt(encryptedData, KEY, IV);\n            \n            // Remove any potential trailing whitespace or padding\n            String trimmedDecryptedData = decryptedData.trim();\n            \n            // Make assertions\n            assertNotNull(encryptedData, \"Encrypted data should not be null\");\n            assertNotNull(decryptedData, \"Decrypted data should not be null\");\n            assertEquals(originalData, trimmedDecryptedData, \"Decrypted data should match the original data\");\n            \n        } catch (Exception e) {\n            fail(\"An exception should not be thrown during the encryption or decryption process\");\n        }\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    private static final String KEY = \"16ByteLengthKey\"; // Substitute with actual 16-byte key\n    private static final String IV = \"16ByteLengthIV\"; // Substitute with actual 16-byte IV\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        String inputString = \"Hello World!\";\n        // Pad string to match AES block size (16 bytes for AES)\n        while (inputString.length() % 16 != 0) {\n            inputString += \"\\0\";\n        }\n        \n        // Perform encryption first\n        String encryptedData = AesEncryptUtil.encrypt(inputString, KEY, IV);\n        assertNotNull(encryptedData, \"Encrypted data should not be null\");\n\n        // Now decrypt and compare to original string\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, KEY, IV).replaceAll(\"\\0\", \"\");\n        assertEquals(inputString.trim(), decryptedData, \"Decrypted string should match original\");\n    }\n}\n",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    \n    @Test\n    public void desEncryptTest() {\n        // Test data initialization\n        String inputString = \"Hello World!\";\n        String key = \"1234567812345678\";   // 16-byte key for AES\n        String iv = \"1234567812345678\";    // 16-byte initialization vector\n        \n        // Expected value is not predefined as the encryption result would be different for each run\n        // because of potential padding and other factors such as IV or randomness in the encryption process.\n        \n        try {\n            // Encrypting the inputString\n            String encryptedString = AesEncryptUtil.encrypt(inputString, key, iv);\n            assertNotNull(encryptedString, \"Encrypted string should not be null\");\n            \n            // Decrypting the encryptedString\n            String decryptedString = AesEncryptUtil.desEncrypt(encryptedString, key, iv);\n            assertNotNull(decryptedString, \"Decrypted string should not be null\");\n            \n            // The original inputString and decryptedString after desEncrypt should match\n            assertEquals(inputString, decryptedString, \"Decrypted string should match the original input\");\n        } catch (Exception e) {\n            fail(\"An exception should not be thrown during the encryption or decryption process\");\n        }\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    private static final String testKey = \"testkey123456789\"; // 16 chars for AES-128\n    private static final String testIV = \"testiv123456789\"; // 16 chars for AES-128\n\n    @BeforeEach\n    public void setUp() {\n        // Perform any setup like setting default key/iv if needed\n    }\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Given\n        String originalText = \"The quick brown fox jumps over the lazy dog\"; // Plaintext\n        String encryptedText = AesEncryptUtil.encrypt(originalText, testKey, testIV);\n\n        // When\n        String decryptedText = AesEncryptUtil.desEncrypt(encryptedText, testKey, testIV);\n\n        // Then\n        assertEquals(originalText, decryptedText, \"The decrypted text should match the original text\");\n    }\n\n    @Test\n    public void desEncryptWithInvalidDataTest() {\n        // Given\n        String invalidEncryptedData = \"InvalidBase64Data\";\n\n        // When & Then\n        assertThrows(Exception.class, () -> AesEncryptUtil.desEncrypt(invalidEncryptedData, testKey, testIV),\n                \"decrypting invalid data should throw an exception\"\n        );\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // Perform any necessary cleanup after the tests are done\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    \n    private static final String TEST_KEY = \"1234567890123456\"; // The key should be 16 chars for AES-128-CBC\n    private static final String TEST_IV = \"1234567890123456\"; // The IV should be 16 chars for AES-128-CBC\n    private static final String TEST_DATA = \"Hello World\";\n    private static final String EXPECTED_ENCRYPTED_DATA = \"Encrypted data here\"; // This should be the actual encrypted data\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Assuming encrypt() method is correct and can be used to setup our test\n        String encryptedData = AesEncryptUtil.encrypt(TEST_DATA, TEST_KEY, TEST_IV);\n        assertNotNull(encryptedData, \"Encryption returned null\");\n\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, TEST_KEY, TEST_IV);\n        assertNotNull(decryptedData, \"Decryption returned null\");\n\n        // Ensure decrypted string matches original data\n        assertEquals(TEST_DATA, decryptedData, \"Decrypted data does not match original\");\n    }\n    \n    // Additional test to ensure that the decryption of a known encrypted string works as expected\n    @Test\n    public void desEncryptKnownDataTest() throws Exception {\n        String decryptedData = AesEncryptUtil.desEncrypt(EXPECTED_ENCRYPTED_DATA, TEST_KEY, TEST_IV);\n        assertNotNull(decryptedData, \"Decryption of known data returned null\");\n\n        // Expected decrypted data should match the TEST_DATA\n        assertEquals(TEST_DATA, decryptedData, \"Decrypted known data does not match expected\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    \n    private static final String TEST_KEY = \"16byteSecretKey\"; // Example key; should be 16 bytes for AES-128\n    private static final String TEST_IV = \"16byteSecretIV!\"; // Example IV; should be 16 bytes\n    private static final String PLAIN_TEXT = \"Hello World!\";  // Plain text to encrypt and decrypt\n    private static String encryptedData;\n\n    @BeforeAll\n    public static void setUp() throws Exception {\n        // Initialize encryptedData before tests start using AesEncryptUtil.encrypt\n        encryptedData = AesEncryptUtil.encrypt(PLAIN_TEXT, TEST_KEY, TEST_IV);\n    }\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        // Decrypt the encrypted data and assert that it matches the original plain text\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, TEST_KEY, TEST_IV);\n        assertNotNull(decryptedData, \"Decrypted data should not be null.\");\n        assertEquals(PLAIN_TEXT.trim(), decryptedData.trim(), \"The decrypted text should match the original.\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    \n    private static final String KEY = \"16byteencryption\"; // key must be 16 bytes for AES-128\n    private static final String IV = \"16byteencryption\"; // iv must be 16 bytes for AES-128\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        String originalData = \"The quick brown fox\";\n        String encryptedData;\n\n        // Test encryption\n        encryptedData = AesEncryptUtil.encrypt(originalData, KEY, IV);\n        assertNotNull(encryptedData, \"Encrypted data should not be null\");\n\n        // Test decryption\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, KEY, IV);\n        assertNotNull(decryptedData, \"Decrypted data should not be null\");\n        assertEquals(originalData, decryptedData, \"Decrypted data should match the original data\");\n\n        // Test that decryption works for the data with padding\n        String paddedData = \"The quick brown fox\\u0000\\u0000\\u0000\\u0000\";\n        encryptedData = AesEncryptUtil.encrypt(paddedData, KEY, IV);\n        decryptedData = AesEncryptUtil.desEncrypt(encryptedData, KEY, IV);\n        assertEquals(originalData, decryptedData, \"Decrypted data with padding should match the original data\");\n\n        // Test decryption with wrong key\n        Exception exception = assertThrows(Exception.class, () -> {\n            AesEncryptUtil.desEncrypt(encryptedData, \"wrongkey12345678\", IV);\n        });\n        assertTrue(exception.getMessage().contains(\"Given final block not properly padded\"));\n\n        // Test decryption with wrong IV\n        exception = assertThrows(Exception.class, () -> {\n            AesEncryptUtil.desEncrypt(encryptedData, KEY, \"wrongiv12345678\");\n        });\n        assertTrue(exception.getMessage().contains(\"Given final block not properly padded\"));\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Assuming EncryptedString.key and EncryptedString.iv have been initialized properly\n        String key = EncryptedString.key; \n        String iv = EncryptedString.iv;\n        String originalData = \"This is a test string.\";\n        String encryptedData = AesEncryptUtil.encrypt(originalData, key, iv);\n        assertNotNull(encryptedData, \"Encrypted data should not be null\");\n\n        // Using key and iv to decrypt the encrypted string\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n        assertNotNull(decryptedData, \"Decrypted data should not be null\");\n        assertEquals(originalData, decryptedData, \"Decrypted string should match the original string\");\n    }\n}"
    ]
}