{
    "project_name": "jeecg-boot",
    "file_name": "AesEncryptUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/util/encryption/AesEncryptUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.util.encryption",
    "docstring": "/**\n     * \u89e3\u5bc6\u65b9\u6cd5\n     * @param data \u8981\u89e3\u5bc6\u7684\u6570\u636e\n     * @param key  \u89e3\u5bc6key\n     * @param iv \u89e3\u5bc6iv\n     * @return \u89e3\u5bc6\u7684\u7ed3\u679c\n     * @throws Exception\n     */",
    "source_code": "\npublic static String desEncrypt(String data, String key, String iv) throws Exception {\n    //update-begin-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n    byte[] encrypted1 = Base64.decode(data);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n    IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n    cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n    byte[] original = cipher.doFinal(encrypted1);\n    String originalString = new String(original);\n    //\u52a0\u5bc6\u89e3\u7801\u540e\u7684\u5b57\u7b26\u4e32\u4f1a\u51fa\u73b0\\u0000\n    return originalString.replaceAll(\"\\\\u0000\", \"\");\n    //update-end-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n}\n",
    "class_name": "AesEncryptUtil",
    "method_name": "desEncrypt",
    "arguments": [
        "String data",
        "String key",
        "String iv"
    ],
    "generate_test": [
        "package org.jeecg.common.util.encryption;\n\nimport org.apache.shiro.codec.Base64;\nimport org.junit.jupiter.api.Test;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Given\n        String originalData = \"UnitTestString\";\n        String key = \"1234567812345678\"; // AES key size (128 bit, 192 bit, 256 bit) - for tests 128 bit\n        String iv = \"1234567812345678\"; // AES block size (16 bytes)\n\n        // Encrypt data first. The provided source code only includes a method for decryption, assumed that an encryption method exists\n        String encryptedData = AesEncryptUtil.encrypt(originalData, key, iv);\n\n        // When\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n\n        // Then\n        assertEquals(originalData, decryptedData, \"The decrypted data should match the original data.\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.Test;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.shiro.codec.Base64;\nimport java.nio.charset.StandardCharsets;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class AesEncryptUtilTest {\n    @Test\n    public void desEncryptTest() {\n        String key = \"1234567890123456\"; // 16 bytes key for AES\n        String iv = \"1234567890123456\"; // 16 bytes IV for AES\n        String originalData = \"secret data\";\n        \n        try {\n            // Encrypt the data\n            String encryptedData = AesEncryptUtil.encrypt(originalData, key, iv);\n            // Now test decryption\n            String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n            \n            assertEquals(originalData, decryptedData.replaceAll(\"\\\\u0000\", \"\"), \n                \"Decrypted data should be equal to the original data\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Exception should not be thrown\");\n        }\n    }\n\n    // Optional: Adding a test for the exception scenario\n    @Test\n    public void desEncryptTestWithException() {\n        String key = \"wrong_key_size\"; // Incorrect key size\n        String iv = \"1234567890123456\"; // 16 bytes IV for AES\n        String encryptedData = \"someEncryptedBase64String\";\n\n        // Expect an exception to be thrown due to wrong key size\n        Exception exception = assertThrows(Exception.class, () -> {\n            AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n        });\n\n        String expectedMessage = \"Invalid AES key length\";\n        String actualMessage = exception.getMessage();\n\n        assertTrue(actualMessage.contains(expectedMessage),\n                \"Exception message should contain the correct error about key length\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.apache.shiro.codec.Base64;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Data to be encrypted\n        String originalData = \"Hello, World!\";\n        // Encryption Key (Ensure the key length is compatible with AES encryption)\n        String key = \"1234567890123456\"; // This is a dummy key, replace with actual key\n        // Initialization Vector (Must be 16 bytes long)\n        String iv = \"1234567890123456\"; // This is a dummy IV, replace with actual IV\n        \n        // Encrypt data\n        String encryptedData = AesEncryptUtil.encrypt(originalData, key, iv);\n        \n        // Perform Base64 encoding on the encrypted data to simulate data transfer\n        String base64EncryptedData = Base64.encodeToString(encryptedData.getBytes());\n        \n        // Decrypt the data back\n        String decryptedData = AesEncryptUtil.desEncrypt(base64EncryptedData, key, iv);\n        \n        // Verify that the decrypted data matches the original data\n        assertEquals(originalData, decryptedData);\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Given\n        String input = \"Some encrypted text\";\n        String key = \"1234567890123456\"; // Assume key and iv are 16 bytes long\n        String iv = \"1234567890123456\";\n        \n        // Encrypt the text (to obtain a base for decryption)\n        String encryptedData = AesEncryptUtil.encrypt(input, key, iv);\n        \n        // When\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n        \n        // Then\n        assertEquals(input, decryptedData, \"The decrypted text should be equal to the original text\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.apache.shiro.codec.Base64;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AesEncryptUtilTest {\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        // Given\n        final String inputString = \"Hello World!\";\n        final String key = \"1234567890123456\"; // A dummy 16-byte key\n        final String iv = \"1234567890123456\"; // A dummy 16-byte IV\n        \n        // Encrypt the string, we assume the 'encrypt' method is correctly implemented and works as the opposite of 'desEncrypt'\n        String encryptedData = AesEncryptUtil.encrypt(inputString, key, iv); \n\n        // When\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n\n        // Then\n        assertEquals(inputString, decryptedData, \"The decrypted string should match the original string\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    \n    private static final String KEY = \"1234567890123456\"; // Example key (must be 16 bytes)\n    private static final String IV = \"1234567890123456\"; // Example IV (must be 16 bytes)\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        String dataToEncrypt = \"Hello, World!\";\n        // Assuming there's a working 'encrypt' method in AesEncryptUtil\n        String encryptedData = AesEncryptUtil.encrypt(dataToEncrypt, KEY, IV);\n        assertNotNull(encryptedData, \"Encrypted data should not be null\");\n        \n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, KEY, IV);\n        assertNotNull(decryptedData, \"Decrypted data should not be null\");\n        assertEquals(dataToEncrypt, decryptedData, \"The decrypted data should match the original\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.apache.shiro.codec.Base64;\nimport org.junit.jupiter.api.Test;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Arrange\n        String key = \"0123456789abcdef\"; // Key must be of length 16, 24, or 32 bytes\n        String iv = \"abcdef9876543210\";  // IV must be 16 bytes long\n        String originalData = \"Hello World!\";\n        String encryptedData = AesEncryptUtil.encrypt(originalData, key, iv);\n\n        // Act\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n\n        // Assert\n        assertEquals(originalData, decryptedData.replaceAll(\"[\\\\u0000]\", \"\"));\n\n        // Assert exception throwing on illegal arguments (like short key or IV)\n        String shortKey = \"short\";\n        String shortIV = \"short\";\n        assertThrows(Exception.class, () -> AesEncryptUtil.desEncrypt(encryptedData, shortKey, iv));\n        assertThrows(Exception.class, () -> AesEncryptUtil.desEncrypt(encryptedData, key, shortIV));\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.apache.shiro.codec.Base64;\nimport org.junit.jupiter.api.Test;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Given\n        String inputString = \"TestString\";\n        String key = \"1234567890123456\"; // Example key, should be 16 bytes\n        String iv = \"1234567890123456\"; // Example IV, should be 16 bytes\n\n        // First, encrypt the inputString to get the encrypted data\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n        byte[] encryptedDataBytes = cipher.doFinal(inputString.getBytes());\n        String encryptedData = Base64.encodeToString(encryptedDataBytes);\n\n        // When\n        String result = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n\n        // Then\n        assertEquals(inputString.replaceAll(\"\\\\s+$\", \"\"), result, \"The decrypted string does not match the original\");\n\n        // Additionally, test for an exception when bad input is provided\n        String badInput = \"NotBase64Encoded\";\n        assertThrows(Exception.class, () -> AesEncryptUtil.desEncrypt(badInput, key, iv), \"Expected an exception to be thrown when input is not Base64 encoded\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.apache.shiro.codec.Base64;\nimport org.junit.jupiter.api.Test;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class AesEncryptUtilTest {\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Given\n        String key = \"1234567890123456\"; // 16-byte length key for AES\n        String iv = \"abcdefghabcdefgh\"; // 16-byte length initialization vector\n        String dataToEncrypt = \"Hello, World!\";\n        String encryptedData = Base64.encodeToString(dataToEncrypt.getBytes());\n\n        // When\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n\n        // Then\n        assertEquals(dataToEncrypt, decryptedData);\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    // Constants to be used for the key and IV. Their size and values would depend\n    // on the encryption algorithm requirements.\n    private static final String KEY = \"1234567890123456\"; // 16-byte key for AES\n    private static final String IV = \"1234567890123456\"; // 16-byte IV for AES\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        String inputString = \"Hello World!\";\n        String key = KEY;\n        String iv = IV;\n        \n        // Perform encryption then decryption to test the full cycle\n        String encryptedData = AesEncryptUtil.encrypt(inputString, key, iv);\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n        \n        // Assertions\n        // The decrypted data should match the original input\n        assertEquals(inputString, decryptedData);\n        \n        // Verify that encrypting a blank string doesn't cause an error\n        encryptedData = AesEncryptUtil.encrypt(\"\", key, iv);\n        decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n        assertEquals(\"\", decryptedData);\n\n        // If there are known issues (such as padding problems), you might want to add \n        // specific tests for those cases as well. \n    }\n}"
    ]
}