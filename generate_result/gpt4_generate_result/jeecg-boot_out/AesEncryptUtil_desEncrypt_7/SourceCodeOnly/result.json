{
    "project_name": "jeecg-boot",
    "file_name": "AesEncryptUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/util/encryption/AesEncryptUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.util.encryption",
    "docstring": "/**\n     * \u89e3\u5bc6\u65b9\u6cd5\n     * @param data \u8981\u89e3\u5bc6\u7684\u6570\u636e\n     * @param key  \u89e3\u5bc6key\n     * @param iv \u89e3\u5bc6iv\n     * @return \u89e3\u5bc6\u7684\u7ed3\u679c\n     * @throws Exception\n     */",
    "source_code": "\npublic static String desEncrypt(String data, String key, String iv) throws Exception {\n    //update-begin-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n    byte[] encrypted1 = Base64.decode(data);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n    IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n    cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n    byte[] original = cipher.doFinal(encrypted1);\n    String originalString = new String(original);\n    //\u52a0\u5bc6\u89e3\u7801\u540e\u7684\u5b57\u7b26\u4e32\u4f1a\u51fa\u73b0\\u0000\n    return originalString.replaceAll(\"\\\\u0000\", \"\");\n    //update-end-author:taoyan date:2022-5-23 for:VUEN-1084 \u3010vue3\u3011online\u8868\u5355\u6d4b\u8bd5\u53d1\u73b0\u7684\u65b0\u95ee\u9898 6\u3001\u89e3\u5bc6\u62a5\u9519 ---\u89e3\u7801\u5931\u8d25\u5e94\u8be5\u628a\u5f02\u5e38\u629b\u51fa\u53bb\uff0c\u5728\u5916\u9762\u5904\u7406\n}\n",
    "class_name": "AesEncryptUtil",
    "method_name": "desEncrypt",
    "arguments": [
        "String data",
        "String key",
        "String iv"
    ],
    "generate_test": [
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    // Assuming there's a class which the desEncrypt method belongs to \n    // Let's call this class EncryptUtil and we are going to use it to invoke desEncrypt\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        // Assuming we have a known plaintext and the corresponding encrypted data\n        String testData = \"EncryptedDataAsString\"; // replace with actual Base64 encrypted string\n        String testKey = \"16ByteLongKey123!\"; // an example for a 16-byte long key\n        String testIv = \"UniqueInitVector!\"; // an example for a 16-byte long IV\n\n        // The expected output after decryption (the original data)\n        String expectedOutput = \"ThePlainTextString\";\n\n        // Perform decryption\n        String decryptedOutput = EncryptUtil.desEncrypt(testData, testKey, testIv);\n\n        // Assert the decrypted output is as expected\n        assertEquals(expectedOutput, decryptedOutput);\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport java.util.Base64;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        String input = \"Test String\";\n        String key = \"1234567890123456\"; // 16-byte key for AES\n        String iv = \"abcdefghijklmnop\"; // 16-byte initialization vector\n        \n        // Let's assume the \"desEncrypt\" method is part of a class named \"EncryptionUtil\"\n        // Encrypt the input\n        byte[] inputBytes = input.getBytes(\"UTF-8\");\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes(\"UTF-8\"));\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        while(inputBytes.length % 16 != 0){ // pad with zero bytes to make it a multiple of 16 bytes\n            inputBytes = (\"Test String\" + new String(new char[] {0})).getBytes(\"UTF-8\");\n        }\n        byte[] encrypted = cipher.doFinal(inputBytes);\n        \n        // Convert the encrypted byte array to a base64 string\n        String encryptedData = Base64.getEncoder().encodeToString(encrypted);\n        \n        // Decrypt using the method we want to test\n        String decryptedData = EncryptionUtil.desEncrypt(encryptedData, key, iv);\n        \n        // Remove padding manually, for the assertion\n        String unpaddedInput = new String(inputBytes).replaceAll(\"\\\\u0000\", \"\");\n        \n        // Assertions\n        assertNotNull(decryptedData, \"The decrypted data should not be null\");\n        assertEquals(unpaddedInput, decryptedData, \"The decrypted input does not match the original input.\");\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AesEncryptUtilTest {\n    \n    // Utility method to encrypt data for testing\n    private static String encryptData(String data, String key, String iv) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        byte[] encrypted = cipher.doFinal(data.getBytes());\n\n        return Base64.getEncoder().encodeToString(encrypted);\n    }\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        String key = \"1234567890123456\"; // Example key (must be 16 bytes)\n        String iv = \"1234567890123456\"; // Example IV (must be 16 bytes)\n        String originalData = \"Secret Message\";\n\n        // Pad originalData to block size if necessary (AES block size is 16 bytes)\n        while (originalData.length() % 16 != 0) {\n            originalData += \"\\u0000\";\n        }\n\n        String encryptedData = encryptData(originalData, key, iv);\n        \n        // The actual test starts here\n        \n        // Decrypt the encrypted data\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n        \n        // Check if the decrypted string matches the original data after removing padding\n        assertEquals(originalData.replaceAll(\"\\\\u0000\", \"\"), decryptedData);\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Setup test data\n        String originalData = \"The quick brown fox jumps over the lazy dog\";\n        String key = \"1234567890123456\"; // Example key (16 characters for AES-128)\n        String iv = \"1234567890123456\"; // Example IV (16 characters)\n        \n        // Encrypt data (for the purposes of the test)\n        String encryptedData = simulateEncryptionOfData(originalData, key, iv); // Simulate encryption for test\n        \n        // Act\n        String decryptedData = AesEncryptUtil.desEncrypt(encryptedData, key, iv);\n        \n        // Assert\n        assertEquals(originalData, decryptedData, \"Decrypted data should match the original data\");\n    }\n    \n    // Simulated encryption utility (for testing purposes)\n    private String simulateEncryptionOfData(String data, String key, String iv) throws Exception {\n        // This method should actually encrypt the data using the same method that `desEncrypt` is planned to decrypt.\n        // The implementation would be similar to the real encryption process, returning a Base64 encoded encrypted string.\n        // For simplicity, let's assume such a method exists and just return a value representing encrypted data.\n        // In real-world usage, replace the below line with actual encryption code\n        return \"encryptedDataInBase64Here\"; // Placeholder encrypted string in Base64 format\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    \n    @Test\n    public void desEncryptTest() throws Exception {\n        // Prepare the data to encrypt\n        String inputString = \"This is a secret message\";\n        String key = \"1234567890123456\"; // 16-byte key for AES\n        String iv = \"1234567890123456\"; // 16-byte IV for AES\n\n        // Encrypt the data using the source code logic\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        byte[] paddedData = padString(inputString).getBytes();\n        byte[] encryptedData = cipher.doFinal(paddedData);\n        String encryptedString = Base64.getEncoder().encodeToString(encryptedData);\n        \n        // Call the method to test\n        String decryptedString = AesEncryptUtil.desEncrypt(encryptedString, key, iv);\n\n        // Remove padding manually from the string (if necessary in the case of 'NoPadding')\n        String trimmedDecryptedString = inputString.trim();\n\n        // Verify that the decrypted string matches the original input\n        assertEquals(inputString, trimmedDecryptedString, \"Decrypted string should match the original\");\n    }\n\n    private static String padString(String source) {\n        char paddingChar = '\\0';\n        int size = 16;\n        int x = source.length() % size;\n        int padLength = size - x;\n\n        for (int i = 0; i < padLength; i++) {\n            source += paddingChar;\n        }\n        return source;\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        String key = \"1234567890123456\"; // Key should be 16/24/32 bytes for AES\n        String iv = \"1234567890123456\"; // IV should be 16 bytes for AES\n        String plainText = \"The quick brown fox jumps over the lazy dog\";\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        byte[] encryptedData = cipher.doFinal(plainText.getBytes());\n        String base64Encrypted = Base64.getEncoder().encodeToString(encryptedData);\n\n        // Decrypt\n        String decryptedData = AesEncryptUtil.desEncrypt(base64Encrypted, key, iv);\n\n        // The decrypted string should match the original string after replacing trailing zeros\n        String expectedPlainText = plainText.replaceAll(\"\\\\u0000\", \"\");\n        assertEquals(expectedPlainText, decryptedData);\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n\n    private static final String ORIGINAL_STRING = \"HelloWorld\";\n    private static final String ENCODED_STRING = \"encrypted version of HelloWorld\";\n    private static final String KEY = \"1234567890123456\"; // this should be 16 bytes key\n    private static final String IV = \"1234567890123456\"; // this should be 16 bytes iv\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        String decryptedString = AesEncryptUtil.desEncrypt(ENCODED_STRING, KEY, IV);\n        assertEquals(ORIGINAL_STRING, decryptedString);\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Setup test variables\n        final String expectedOutput = \"The quick brown fox\";\n        final String key = \"1234567890123456\"; // Example key (16 chars for AES-128)\n        final String iv = \"1234567890123456\"; // Example IV (16 chars for AES-128)\n        \n        // Encoded data that we expect to decrypt, should be base64 encoded string of encrypted data.\n        final String encodedData = \"<the encoded data here>\";\n        // The above encodedData should be the result of encrypting expectedOutput with the given key and IV and then Base64 encoding it.\n\n        try {\n            // Call the method being tested\n            String result = AesEncryptUtil.desEncrypt(encodedData, key, iv);\n\n            // Run assertions\n            assertNotNull(result, \"The decrypted string should not be null.\");\n            assertEquals(expectedOutput, result, \"The decrypted string should match the expected output.\");\n        } catch (Exception e) {\n            fail(\"An exception should not have been thrown during decryption.\");\n        }\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    private static final String KEY = \"1234567890123456\"; // example key (should be 16, 24, or 32 bytes)\n    private static final String IV = \"1234567890123456\"; // example IV (must be 16 bytes)\n\n    @Test\n    public void desEncryptTest() throws Exception {\n        // Test data initialisation\n        String originalData = \"Hello World!\";\n        String data = encryptData(originalData, KEY, IV);\n\n        // Act\n        String decryptedData = AesEncryptUtil.desEncrypt(data, KEY, IV);\n\n        // Assert\n        assertEquals(originalData, decryptedData);\n    }\n\n    private String encryptData(String input, String key, String iv) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        int blockSize = cipher.getBlockSize();\n        byte[] data = input.getBytes();\n        int plaintextLength = data.length;\n        if (plaintextLength % blockSize != 0) {\n            plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));\n            byte[] plaintext = new byte[plaintextLength];\n            System.arraycopy(data, 0, plaintext, 0, data.length);\n            data = plaintext;\n        }\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        byte[] encrypted = cipher.doFinal(data);\n        return Base64.getEncoder().encodeToString(encrypted);\n    }\n}",
        "package org.jeecg.common.util.encryption;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class AesEncryptUtilTest {\n    @Test\n    public void desEncryptTest() {\n        String dataToEncrypt = \"your-base64-encoded-data\";\n        String key = \"your-encryption-key\";\n        String iv = \"your-initialization-vector\";\n\n        try {\n            String decryptedData = AesEncryptUtil.desEncrypt(dataToEncrypt, key, iv);\n            String expectedDecryptedData = \"the-expected-result-after-decryption\";\n            \n            // Verify that the decrypted string is what we expect (without null padding)\n            assertEquals(expectedDecryptedData, decryptedData);\n        } catch (Exception e) {\n            fail(\"Exception should not be thrown\");\n        }\n    }\n}"
    ]
}