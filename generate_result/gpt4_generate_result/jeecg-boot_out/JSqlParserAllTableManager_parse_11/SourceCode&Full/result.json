{
    "project_name": "jeecg-boot",
    "file_name": "JSqlParserAllTableManager.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/util/sqlparse/JSqlParserAllTableManager.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.util.sqlparse",
    "docstring": "/**\n     * \u5f00\u59cb\u89e3\u6790\n     *\n     * @return\n     * @throws JSQLParserException\n     */",
    "source_code": "\npublic Map<String, SelectSqlInfo> parse() throws JSQLParserException {\n    // 1. \u521b\u5efa\u89e3\u6790\u5668\n    CCJSqlParserManager mgr = new CCJSqlParserManager();\n    // 2. \u4f7f\u7528\u89e3\u6790\u5668\u89e3\u6790sql\u751f\u6210\u5177\u6709\u5c42\u6b21\u7ed3\u6784\u7684java\u7c7b\n    Statement stmt = mgr.parse(new StringReader(this.sql));\n    if (stmt instanceof Select) {\n        Select selectStatement = (Select) stmt;\n        SelectBody selectBody = selectStatement.getSelectBody();\n        this.parsedSql = selectBody.toString();\n        // 3. \u89e3\u6790select\u67e5\u8be2sql\u7684\u4fe1\u606f\n        if (selectBody instanceof PlainSelect) {\n            PlainSelect plainSelect = (PlainSelect) selectBody;\n            // 4. \u5408\u5e76 fromItems\n            List<FromItem> fromItems = new ArrayList<>();\n            fromItems.add(plainSelect.getFromItem());\n            // 4.1 \u5904\u7406join\u7684\u8868\n            List<Join> joins = plainSelect.getJoins();\n            if (joins != null) {\n                joins.forEach(join -> fromItems.add(join.getRightItem()));\n            }\n            // 5. \u5904\u7406 fromItems\n            for (FromItem fromItem : fromItems) {\n                // 5.1 \u901a\u8fc7\u8868\u540d\u7684\u65b9\u5f0ffrom\n                if (fromItem instanceof Table) {\n                    this.addSqlInfoByTable((Table) fromItem);\n                }\n                // 5.2 \u901a\u8fc7\u5b50\u67e5\u8be2\u7684\u65b9\u5f0ffrom\n                else if (fromItem instanceof SubSelect) {\n                    this.handleSubSelect((SubSelect) fromItem);\n                }\n            }\n            // 6. \u89e3\u6790 selectFields\n            List<SelectItem> selectItems = plainSelect.getSelectItems();\n            for (SelectItem selectItem : selectItems) {\n                // 6.1 \u67e5\u8be2\u7684\u662f\u5168\u90e8\u5b57\u6bb5\n                if (selectItem instanceof AllColumns) {\n                    // \u5f53 selectItem \u4e3a AllColumns \u65f6\uff0cfromItem \u5fc5\u5b9a\u4e3a Table\n                    String tableName = plainSelect.getFromItem(Table.class).getName();\n                    // \u6b64\u5904\u5fc5\u5b9a\u4e0d\u4e3a\u7a7a\uff0c\u56e0\u4e3a\u5728\u89e3\u6790 fromItem \u65f6\uff0c\u5df2\u7ecf\u5c06\u8868\u540d\u6dfb\u52a0\u5230 allTableMap \u4e2d\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    assert sqlInfo != null;\n                    // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                    sqlInfo.setSelectAll(true);\n                    sqlInfo.setSelectFields(null);\n                    sqlInfo.setRealSelectFields(null);\n                }\n                // 6.2 \u67e5\u8be2\u7684\u662f\u5e26\u8868\u522b\u540d\uff08 u.* )\u7684\u5168\u90e8\u5b57\u6bb5\n                else if (selectItem instanceof AllTableColumns) {\n                    AllTableColumns allTableColumns = (AllTableColumns) selectItem;\n                    String aliasName = allTableColumns.getTable().getName();\n                    // \u901a\u8fc7\u522b\u540d\u83b7\u53d6\u8868\u540d\n                    String tableName = this.tableAliasMap.get(aliasName);\n                    if (tableName == null) {\n                        tableName = aliasName;\n                    }\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    // \u5982\u679c\u6b64\u5904\u4e3a\u7a7a\uff0c\u5219\u8bf4\u660e\u8be5\u5b57\u6bb5\u662f\u901a\u8fc7\u5b50\u67e5\u8be2\u83b7\u53d6\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e0d\u5904\u7406\uff0c\u53ea\u6709\u5b9e\u9645\u8868\u624d\u9700\u8981\u5904\u7406\n                    if (sqlInfo != null) {\n                        // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                        sqlInfo.setSelectAll(true);\n                        sqlInfo.setSelectFields(null);\n                        sqlInfo.setRealSelectFields(null);\n                    }\n                }\n                // 6.3 \u5404\u79cd\u5b57\u6bb5\u8868\u8fbe\u5f0f\u5904\u7406\n                else if (selectItem instanceof SelectExpressionItem) {\n                    SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;\n                    Expression expression = selectExpressionItem.getExpression();\n                    Alias alias = selectExpressionItem.getAlias();\n                    this.handleExpression(expression, alias, plainSelect.getFromItem());\n                }\n            }\n        } else {\n            log.warn(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody: {}\", selectBody.getClass().getName());\n            throw new JeecgBootException(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody\");\n        }\n    } else {\n        // \u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\n        throw new JeecgBootException(\"\u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\");\n    }\n    return this.allTableMap;\n}\n",
    "class_name": "JSqlParserAllTableManager",
    "method_name": "parse",
    "arguments": [],
    "generate_test": [
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseSelectQueryWithSimpleTable() throws JSQLParserException {\n        // Given\n        String sql = \"SELECT * FROM my_table\";\n        JSqlParserAllTableManager parser = new JSqlParserAllTableManager(sql);\n\n        // When\n        Map<String, SelectSqlInfo> result = parser.parse();\n\n        // Then\n        assertNotNull(result, \"The result should not be null\");\n        assertTrue(result.containsKey(\"my_table\"), \"Result map should contain key 'my_table'\");\n        SelectSqlInfo selectSqlInfo = result.get(\"my_table\");\n        assertNotNull(selectSqlInfo, \"SelectSqlInfo for 'my_table' should not be null\");\n        assertEquals(\"my_table\", selectSqlInfo.getFromTableName(), \"FromTableName should be 'my_table'\");\n        assertTrue(selectSqlInfo.isSelectAll(), \"selectAll should be true for 'SELECT *' query\");\n        assertNull(selectSqlInfo.getSelectFields(), \"selectFields should be null for 'SELECT *' query\");\n        assertNull(selectSqlInfo.getRealSelectFields(), \"realSelectFields should be null for 'SELECT *' query\");\n        assertEquals(sql, selectSqlInfo.getSql(), \"Stored SQL should match the given SQL\");\n    }\n\n    @Test\n    public void parseSelectQueryWithMultipleTablesAndJoins() throws JSQLParserException {\n        // Given\n        String sql = \"SELECT a.name, b.age FROM user_table a JOIN address_table b ON a.id = b.user_id\";\n        JSqlParserAllTableManager parser = new JSqlParserAllTableManager(sql);\n\n        // When\n        Map<String, SelectSqlInfo> result = parser.parse();\n\n        // Then\n        assertNotNull(result, \"The result should not be null\");\n        assertTrue(result.containsKey(\"user_table\"), \"Result map should contain key 'user_table'\");\n        assertTrue(result.containsKey(\"address_table\"), \"Result map should contain key 'address_table'\");\n    }\n\n    @Test\n    public void parseShouldThrowExceptionForNonSelectQueries() {\n        // Given\n        String sql = \"UPDATE my_table SET name='Doe' WHERE id=1\";\n        JSqlParserAllTableManager parser = new JSqlParserAllTableManager(sql);\n\n        // When & Then\n        assertThrows(JeecgBootException.class, parser::parse, \"Non-select queries should throw JeecgBootException\");\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n    \n    @Test\n    public void parseTest() {\n        // Set up SQL to parse\n        String selectSql = \"SELECT u.id, u.name FROM user u WHERE u.status = 'active'\";\n        \n        // Instantiate JSqlParserAllTableManager with provided SQL\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(selectSql);\n        \n        try {\n            // Call parse method and get the result\n            Map<String, SelectSqlInfo> result = manager.parse();\n            \n            // Define what we expect to get\n            assertNotNull(result, \"The result map should not be null\");\n            assertTrue(result.containsKey(\"user\"), \"The result map should have 'user' table key\");\n            \n            SelectSqlInfo userData = result.get(\"user\");\n            assertNotNull(userData, \"UserData for 'user' should not be null\");\n            assertFalse(userData.isSelectAll(), \"UserData should not have selectAll as true for partial select statements\");\n            assertNotNull(userData.getSelectFields(), \"SelectFields for 'user' should not be null\");\n            assertTrue(userData.getSelectFields().containsKey(\"id\"), \"SelectFields should contain 'id'\");\n            assertTrue(userData.getSelectFields().containsKey(\"name\"), \"SelectFields should contain 'name'\");\n            assertTrue(userData.getFromTableName().equals(\"user\"), \"The fromTableName should be 'user'\");\n            \n            // If there are more specifics to check, those conditions would be added here as assertions.\n        } catch (JSQLParserException e) {\n            fail(\"Parsing threw an unexpected JSQLParserException\");\n        }\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.statement.select.SelectBody;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n    private JSqlParserAllTableManager parser;\n\n    // Setup method before each test case\n    @BeforeEach\n    public void setUp() {\n        parser = new JSqlParserAllTableManager(\"SELECT * FROM table1\");\n    }\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        Map<String, SelectSqlInfo> result = parser.parse();\n        \n        assertNotNull(result, \"The result map should not be null\");\n        assertTrue(result.containsKey(\"table1\"), \"The map should contain the 'table1' entry\");\n\n        SelectSqlInfo table1Info = result.get(\"table1\");\n        assertNotNull(table1Info, \"The SelectSqlInfo for 'table1' should not be null\");\n        assertEquals(\"table1\", table1Info.getFromTableName(), \"The from table name should match 'table1'\");\n        assertTrue(table1Info.isSelectAll(), \"The 'selectAll' flag should be true for 'table1'\");\n        assertNull(table1Info.getSelectFields(), \"The 'selectFields' for 'table1' should be null as all fields are selected\");\n        assertNull(table1Info.getRealSelectFields(), \"The 'realSelectFields' for 'table1' should be null as all fields are selected\");\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    @Test\n    public void parseTest() {\n        String sqlQuery = \"SELECT * FROM my_table\";\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(sqlQuery);\n\n        try {\n            // Execute the parse method\n            var result = manager.parse();\n\n            // We are using assertNotNull assertion as we at least expect a non-null map to be returned.\n            assertNotNull(result, \"Resulting map should not be null\");\n\n            // We expect a map with one key-value pair because we only have one table in our query.\n            assertEquals(1, result.size(), \"Resulting map should have only one entry\");\n\n            // Assert that the table name is as expected\n            assertNotNull(result.get(\"my_table\"), \"Map should contain an entry for 'my_table'\");\n\n            // Further assertions regarding SelectSqlInfo of 'my_table' can be made based on\n            // the internal behavior of the JSqlParserAllTableManager implementation.\n        } catch (JSQLParserException e) {\n            fail(\"Parsing failed with exception: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n\n    private JSqlParserAllTableManager parser;\n\n    @BeforeEach\n    public void setup() {\n        String testSql = \"SELECT u.id, u.name FROM user u WHERE u.status = 'ACTIVE'\";\n        parser = new JSqlParserAllTableManager(testSql);\n    }\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // Execute the parse method\n        Map<String, SelectSqlInfo> tableMap = parser.parse();\n\n        // Check general parsing outcome\n        assertNotNull(tableMap, \"Parsed table map should not be null\");\n        assertFalse(tableMap.isEmpty(), \"Parsed table map should not be empty\");\n\n        // Check specific parsing details\n        SelectSqlInfo userTableInfo = tableMap.get(\"user\");\n        assertNotNull(userTableInfo, \"SelectSqlInfo for user table should not be null\");\n        assertEquals(\"user\", userTableInfo.getFromTableName(), \"Table name for SelectSqlInfo should match\");\n\n        // Checking if the fields are parsed correctly, assuming the SelectSqlInfo has methods to retrieve field information.\n        assertTrue(userTableInfo.getSelectFields().containsKey(\"id\"), \"SelectSqlInfo should contain the id field\");\n        assertTrue(userTableInfo.getSelectFields().containsKey(\"name\"), \"SelectSqlInfo should contain the name field\");\n        \n        // Depending on the implementation, you may need to check other properties of SelectSqlInfo as well\n    }\n\n    @AfterEach\n    public void tearDown() {\n        parser = null;\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() {\n        String sqlString = \"SELECT u.id, u.name FROM user u\";\n        JSqlParserAllTableManager parserManager = new JSqlParserAllTableManager(sqlString);\n        Map<String, SelectSqlInfo> resultMap = null;\n        try {\n            resultMap = parserManager.parse();\n        } catch (JSQLParserException e) {\n            e.printStackTrace();\n        }\n\n        assertNotNull(resultMap, \"The resultMap should not be null\");\n        assertTrue(resultMap.containsKey(\"user\"), \"The resultMap should contain the key 'user'\");\n        \n        SelectSqlInfo selectSqlInfo = resultMap.get(\"user\");\n        assertNotNull(selectSqlInfo, \"The selectSqlInfo for 'user' should not be null\");\n        assertFalse(selectSqlInfo.isSelectAll(), \"selectAll should be false\");\n        \n        assertNotNull(selectSqlInfo.getSelectFields(), \"selectFields should not be null\");\n        assertTrue(selectSqlInfo.getSelectFields().containsKey(\"id\"), \"selectFields should contain 'id'\");\n        assertTrue(selectSqlInfo.getSelectFields().containsKey(\"name\"), \"selectFields should contain 'name'\");\n        \n        assertNull(selectSqlInfo.getRealSelectFields(), \"realSelectFields should be null given the test case\");\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.*;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() {\n        // Arrange - setting up a simple select SQL query for test\n        String sql = \"SELECT * FROM my_table\";\n        JSqlParserAllTableManager parserManager = new JSqlParserAllTableManager(sql);\n\n        // Act - parsing the SQL query\n        Map<String, SelectSqlInfo> result = null;\n        try {\n            result = parserManager.parse();\n        } catch (JSQLParserException e) {\n            fail(\"Exception thrown during parsing: \" + e.getMessage());\n        }\n\n        // Assert - verifying the result and checking no exceptions were thrown\n        assertNotNull(result, \"The result should not be null\");\n        assertTrue(result.containsKey(\"my_table\"), \"The result map should have an entry for 'my_table'\");\n        \n        SelectSqlInfo myTableInfo = result.get(\"my_table\");\n        assertNotNull(myTableInfo, \"SelectSqlInfo should not be null for 'my_table'\");\n        assertEquals(\"my_table\", myTableInfo.getFromTableName(), \"The from table name should be 'my_table'\");\n        \n        // Additional checks could include verification of the fields selected, handling of aliases, joins etc., based on the complexity of the SQL being processed\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport net.sf.jsqlparser.JSQLParserException;\n\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n    @Test\n    public void parseTest() {\n        String sql = \"SELECT u.name, p.product_name FROM users u JOIN products p ON u.id = p.owner_id WHERE u.id = 1\";\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(sql);\n        \n        assertDoesNotThrow(() -> {\n            Map<String, SelectSqlInfo> result = manager.parse();\n            \n            assertNotNull(result, \"Result map should not be null\");\n            assertTrue(result.containsKey(\"users\"), \"Result should contain 'users' table\");\n            assertTrue(result.containsKey(\"products\"), \"Result should contain 'products' table\");\n            \n            SelectSqlInfo userInfo = result.get(\"users\");\n            assertNotNull(userInfo, \"userInfo should not be null\");\n            assertEquals(\"users\", userInfo.getFromTableName());\n            assertNotNull(userInfo.getSelectFields());\n            assertTrue(userInfo.getSelectFields().containsKey(\"name\"), \"Select fields should contain 'name'\");\n            \n            SelectSqlInfo productInfo = result.get(\"products\");\n            assertNotNull(productInfo, \"productInfo should not be null\");\n            assertEquals(\"products\", productInfo.getFromTableName());\n            assertNotNull(productInfo.getSelectFields());\n            assertTrue(productInfo.getSelectFields().containsKey(\"product_name\"), \"Select fields should contain 'product_name'\");\n        }, \"Parse method should not throw an exception\");\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    @Test\n    public void parseTest() {\n        // Assuming you want to test the parse method for a basic SELECT statement\n        String selectSql = \"SELECT id, name FROM users\";\n        JSqlParserAllTableManager parserManager = new JSqlParserAllTableManager(selectSql);\n        \n        try {\n            // Act\n            Map<String, SelectSqlInfo> result = parserManager.parse();\n            \n            // Assert\n            assertNotNull(result, \"Resulting map should not be null.\");\n            assertEquals(1, result.size(), \"Resulting map should contain exactly one entry.\");\n            \n            // Get the entry for the 'users' table from the map and assert its properties\n            SelectSqlInfo selectSqlInfo = result.get(\"users\");\n            assertNotNull(selectSqlInfo, \"SelectSqlInfo for 'users' table should not be null.\");\n            assertFalse(selectSqlInfo.isSelectAll(), \"Should not select all fields.\");\n            assertNotNull(selectSqlInfo.getSelectFields(), \"Select fields should not be null.\");\n            assertEquals(2, selectSqlInfo.getSelectFields().size(), \"Two select fields were expected.\");\n            assertTrue(selectSqlInfo.getSelectFields().containsKey(\"id\"), \"Select fields should contain 'id'.\");\n            assertTrue(selectSqlInfo.getSelectFields().containsKey(\"name\"), \"Select fields should contain 'name'.\");\n        } catch (JSQLParserException e) {\n            fail(\"Parsing SQL failed with exception: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.statement.select.PlainSelect;\nimport org.junit.jupiter.api.*;\nimport org.mockito.Mockito;\n\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() {\n        // Set up a SQL string to parse\n        String sql = \"SELECT u.id, u.name FROM user u\";\n\n        // Create a new instance of JSqlParserAllTableManager with the provided SQL\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(sql);\n\n        // Create a mocked PlainSelect object as we will not be able to parse actual SQL in the unit test\n        PlainSelect mockSelect = mock(PlainSelect.class);\n\n        // Mock the behavior of the parse() method to return our mocked PlainSelect object\n        try {\n            CCJSqlParserManager mockParserManager = Mockito.spy(new CCJSqlParserManager());\n            Mockito.doReturn(mockSelect).when(mockParserManager).parse(Mockito.any());\n\n            // Inject the mocked CCJSqlParserManager into our JSqlParserAllTableManager instance\n            manager = Mockito.spy(manager);\n            Mockito.doReturn(mockParserManager).when(manager).getParserManager();\n\n            // Call the parse method which we expect to return the allTableMap with parsed info\n            Map<String, SelectSqlInfo> result = manager.parse();\n\n            // Verify that the returned map has the expected content based on the SQL\n            assertNotNull(result, \"The result should not be null.\");\n            assertTrue(result.containsKey(\"user\"), \"The result map should contain the 'user' table.\");\n            SelectSqlInfo selectSqlInfo = result.get(\"user\");\n            assertNotNull(selectSqlInfo, \"The SelectSqlInfo for 'user' should not be null.\");\n            assertEquals(sql, selectSqlInfo.getOriginalSql(), \"The original SQL should be the same as the input SQL.\");\n\n            // You can add more assertions to verify the behavior of the parse() function\n            // For instance, if you had a real SelectItem, you could assert that the fields were parsed correctly\n            // However, without actual parsing, we cannot assert on SelectItem parsing behavior in this mock setup\n\n        } catch (JSQLParserException e) {\n            fail(\"Parsing threw an exception: \" + e.getMessage());\n        }\n    }\n}"
    ]
}