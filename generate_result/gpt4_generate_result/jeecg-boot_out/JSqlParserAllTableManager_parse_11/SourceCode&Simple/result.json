{
    "project_name": "jeecg-boot",
    "file_name": "JSqlParserAllTableManager.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/util/sqlparse/JSqlParserAllTableManager.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.util.sqlparse",
    "docstring": "/**\n     * \u5f00\u59cb\u89e3\u6790\n     *\n     * @return\n     * @throws JSQLParserException\n     */",
    "source_code": "\npublic Map<String, SelectSqlInfo> parse() throws JSQLParserException {\n    // 1. \u521b\u5efa\u89e3\u6790\u5668\n    CCJSqlParserManager mgr = new CCJSqlParserManager();\n    // 2. \u4f7f\u7528\u89e3\u6790\u5668\u89e3\u6790sql\u751f\u6210\u5177\u6709\u5c42\u6b21\u7ed3\u6784\u7684java\u7c7b\n    Statement stmt = mgr.parse(new StringReader(this.sql));\n    if (stmt instanceof Select) {\n        Select selectStatement = (Select) stmt;\n        SelectBody selectBody = selectStatement.getSelectBody();\n        this.parsedSql = selectBody.toString();\n        // 3. \u89e3\u6790select\u67e5\u8be2sql\u7684\u4fe1\u606f\n        if (selectBody instanceof PlainSelect) {\n            PlainSelect plainSelect = (PlainSelect) selectBody;\n            // 4. \u5408\u5e76 fromItems\n            List<FromItem> fromItems = new ArrayList<>();\n            fromItems.add(plainSelect.getFromItem());\n            // 4.1 \u5904\u7406join\u7684\u8868\n            List<Join> joins = plainSelect.getJoins();\n            if (joins != null) {\n                joins.forEach(join -> fromItems.add(join.getRightItem()));\n            }\n            // 5. \u5904\u7406 fromItems\n            for (FromItem fromItem : fromItems) {\n                // 5.1 \u901a\u8fc7\u8868\u540d\u7684\u65b9\u5f0ffrom\n                if (fromItem instanceof Table) {\n                    this.addSqlInfoByTable((Table) fromItem);\n                }\n                // 5.2 \u901a\u8fc7\u5b50\u67e5\u8be2\u7684\u65b9\u5f0ffrom\n                else if (fromItem instanceof SubSelect) {\n                    this.handleSubSelect((SubSelect) fromItem);\n                }\n            }\n            // 6. \u89e3\u6790 selectFields\n            List<SelectItem> selectItems = plainSelect.getSelectItems();\n            for (SelectItem selectItem : selectItems) {\n                // 6.1 \u67e5\u8be2\u7684\u662f\u5168\u90e8\u5b57\u6bb5\n                if (selectItem instanceof AllColumns) {\n                    // \u5f53 selectItem \u4e3a AllColumns \u65f6\uff0cfromItem \u5fc5\u5b9a\u4e3a Table\n                    String tableName = plainSelect.getFromItem(Table.class).getName();\n                    // \u6b64\u5904\u5fc5\u5b9a\u4e0d\u4e3a\u7a7a\uff0c\u56e0\u4e3a\u5728\u89e3\u6790 fromItem \u65f6\uff0c\u5df2\u7ecf\u5c06\u8868\u540d\u6dfb\u52a0\u5230 allTableMap \u4e2d\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    assert sqlInfo != null;\n                    // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                    sqlInfo.setSelectAll(true);\n                    sqlInfo.setSelectFields(null);\n                    sqlInfo.setRealSelectFields(null);\n                }\n                // 6.2 \u67e5\u8be2\u7684\u662f\u5e26\u8868\u522b\u540d\uff08 u.* )\u7684\u5168\u90e8\u5b57\u6bb5\n                else if (selectItem instanceof AllTableColumns) {\n                    AllTableColumns allTableColumns = (AllTableColumns) selectItem;\n                    String aliasName = allTableColumns.getTable().getName();\n                    // \u901a\u8fc7\u522b\u540d\u83b7\u53d6\u8868\u540d\n                    String tableName = this.tableAliasMap.get(aliasName);\n                    if (tableName == null) {\n                        tableName = aliasName;\n                    }\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    // \u5982\u679c\u6b64\u5904\u4e3a\u7a7a\uff0c\u5219\u8bf4\u660e\u8be5\u5b57\u6bb5\u662f\u901a\u8fc7\u5b50\u67e5\u8be2\u83b7\u53d6\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e0d\u5904\u7406\uff0c\u53ea\u6709\u5b9e\u9645\u8868\u624d\u9700\u8981\u5904\u7406\n                    if (sqlInfo != null) {\n                        // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                        sqlInfo.setSelectAll(true);\n                        sqlInfo.setSelectFields(null);\n                        sqlInfo.setRealSelectFields(null);\n                    }\n                }\n                // 6.3 \u5404\u79cd\u5b57\u6bb5\u8868\u8fbe\u5f0f\u5904\u7406\n                else if (selectItem instanceof SelectExpressionItem) {\n                    SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;\n                    Expression expression = selectExpressionItem.getExpression();\n                    Alias alias = selectExpressionItem.getAlias();\n                    this.handleExpression(expression, alias, plainSelect.getFromItem());\n                }\n            }\n        } else {\n            log.warn(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody: {}\", selectBody.getClass().getName());\n            throw new JeecgBootException(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody\");\n        }\n    } else {\n        // \u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\n        throw new JeecgBootException(\"\u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\");\n    }\n    return this.allTableMap;\n}\n",
    "class_name": "JSqlParserAllTableManager",
    "method_name": "parse",
    "arguments": [],
    "generate_test": [
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() {\n        // Setup the SQL string to test.\n        String sql = \"SELECT a.field1, b.field2 FROM table1 a JOIN table2 b ON a.id=b.fk_id\";\n        \n        // Create an instance of the JSqlParserAllTableManager with the SQL string.\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(sql);\n        \n        try {\n            // Execute the parse method.\n            Map<String, SelectSqlInfo> result = manager.parse();\n            \n            // Assertions to ensure the parsing is as expected.\n            assertNotNull(result, \"Resulting map should not be null.\");\n            \n            // Assert the presence of the expected tables within the parsing result.\n            assertTrue(result.containsKey(\"table1\"), \"Map should contain an entry for table1.\");\n            assertTrue(result.containsKey(\"table2\"), \"Map should contain an entry for table2.\");\n            \n            // Additional assertions could check more detailed aspects such as selected fields,\n            // table aliases, joins, etc. Mocking may be required to test private and internal\n            // method calls and behaviors.\n\n        } catch (JSQLParserException e) {\n            // Catching the JSQLParserException to fail the test in case of parsing error.\n            fail(\"Parsing failed with the exception: \" + e.getMessage());\n        } catch (JeecgBootException e) {\n            // Catching the custom exception to handle known parse failure scenarios.\n            // Additional assertions based on the expected behavior when an exception is thrown.\n            fail(\"Custom exception occurred: \" + e.getMessage());\n        }\n    }\n\n    // Additional tests can be written to check different parts of the SQL parsing logic.\n    // For example, handling sub-selects, expressions, aliases, and more complex SQL structures.\n\n    // ...\n\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.statement.select.Select;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    \n    private JSqlParserAllTableManager manager;\n\n    @BeforeEach\n    public void setUp() {\n        // Setup code if needed, assuming passing SQL is part of the constructor\n        manager = new JSqlParserAllTableManager(\"SELECT * FROM table_name\");\n    }\n\n    @Test\n    public void parseTest() {\n        // Assuming the SQL query is correct and parse() is expected to run without exceptions\n        assertDoesNotThrow(() -> {\n            Map<String, SelectSqlInfo> result = manager.parse();\n            assertNotNull(result);\n            assertFalse(result.isEmpty());\n            // Specific test assertions should be added here based on assumptions\n            // about the input SQL and expected parse results. For example:\n            SelectSqlInfo info = result.get(\"table_name\");\n            assertNotNull(info);\n            assertTrue(info.isSelectAll());\n            assertNull(info.getSelectFields());\n            assertNull(info.getRealSelectFields());\n        });\n\n        // To test the exception handling, if needed\n        JSqlParserAllTableManager managerWithBadSql = new JSqlParserAllTableManager(\"BAD SQL\");\n        assertThrows(JSQLParserException.class, managerWithBadSql::parse);\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.statement.select.Select;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // given\n        String selectSql = \"SELECT * FROM users\";\n        JSqlParserAllTableManager parserManager = new JSqlParserAllTableManager(selectSql);\n\n        // when\n        Map<String, SelectSqlInfo> result = parserManager.parse();\n\n        // then\n        assertNotNull(result);\n        assertEquals(1, result.size());\n        assertTrue(result.containsKey(\"users\"));\n        \n        SelectSqlInfo selectSqlInfo = result.get(\"users\");\n        assertNotNull(selectSqlInfo);\n        assertTrue(selectSqlInfo.isSelectAll());\n        assertNull(selectSqlInfo.getSelectFields());\n        assertNull(selectSqlInfo.getRealSelectFields());\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n\n    private JSqlParserAllTableManager manager;\n\n    @BeforeEach\n    public void setUp() {\n        // This would typically be set to a valid SQL select statement for the test\n        String sql = \"SELECT * FROM users\";\n        manager = new JSqlParserAllTableManager(sql);\n    }\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // Given\n        String expectedTableName = \"users\";\n        boolean expectedSelectAll = true;\n\n        // When\n        Map<String, SelectSqlInfo> result = manager.parse();\n\n        // Then\n        assertTrue(result.containsKey(expectedTableName), \"Result should contain the table name.\");\n        SelectSqlInfo selectSqlInfo = result.get(expectedTableName);\n\n        assertNotNull(selectSqlInfo, \"SelectSqlInfo should not be null for the expected table.\");\n        assertEquals(expectedSelectAll, selectSqlInfo.isSelectAll(), \"SelectAll should be true, as the SQL contains 'SELECT *'.\");\n\n        // Additional assertions could be added to verify more details\n        // depending on the implementation details of SelectSqlInfo and the SQL given\n        // For example, if the SQL had WHERE conditions, JOINs, GROUP BYs, specific columns selected, etc.\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() {\n        // Given\n        String selectSql = \"SELECT * FROM users\";\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(selectSql);\n\n        // When\n        Map<String, SelectSqlInfo> result = null;\n        try {\n            result = manager.parse();\n        } catch (JSQLParserException e) {\n            fail(\"Parsing failed with JSQLParserException: \" + e.getMessage());\n        }\n\n        // Then\n        assertNotNull(result, \"The result map should not be null\");\n        assertTrue(result.containsKey(\"users\"), \"The result map should contain key 'users'\");\n        \n        SelectSqlInfo selectSqlInfo = result.get(\"users\");\n        assertNotNull(selectSqlInfo, \"SelectSqlInfo for 'users' should not be null\");\n        assertTrue(selectSqlInfo.isSelectAll(), \"'selectAll' should be true for 'users'\");\n        assertNull(selectSqlInfo.getSelectFields(), \"'selectFields' should be null when 'selectAll' is true\");\n        assertNull(selectSqlInfo.getRealSelectFields(), \"'realSelectFields' should be null when 'selectAll' is true\");\n\n        // Optionally, more assertions can be added to test other aspects of the parsed SQL such as alias handling, subselects, expression handling, etc.\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.statement.select.Select;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() {\n        String sampleSql = \"SELECT * FROM my_table\";\n        JSqlParserAllTableManager parser = new JSqlParserAllTableManager(sampleSql);\n        try {\n            Map<String, SelectSqlInfo> result = parser.parse();\n            assertNotNull(result, \"The result should not be null.\");\n            assertFalse(result.isEmpty(), \"The result map should not be empty.\");\n\n            // Assertions depend on the implementation of the `addSqlInfoByTable` method\n            // and other parser methods which are not present in the provided context.\n            // These lines below are placeholders and should be adapted accordingly.\n            assertTrue(result.containsKey(\"my_table\"), \"The result map should contain an entry for 'my_table'.\");\n            SelectSqlInfo info = result.get(\"my_table\");\n            assertNotNull(info, \"SelectSqlInfo for 'my_table' should not be null.\");\n            assertTrue(info.isSelectAll(), \"'my_table' should have selectAll set to true.\");\n\n        } catch (JSQLParserException e) {\n            fail(\"Parsing failed with an exception: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.expression.Alias;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.schema.Table;\nimport net.sf.jsqlparser.statement.Statement;\nimport net.sf.jsqlparser.statement.select.PlainSelect;\nimport net.sf.jsqlparser.statement.select.Select;\nimport net.sf.jsqlparser.statement.select.SelectBody;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.io.StringReader;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class JSqlParserAllTableManagerTest {\n\n    @InjectMocks\n    private JSqlParserAllTableManager jSqlParserAllTableManager;\n\n    @Mock\n    private CCJSqlParserManager mgr;\n\n    private final String testSql = \"SELECT * FROM my_table\";\n\n    @BeforeEach\n    public void setUp() throws JSQLParserException {\n        MockitoAnnotations.openMocks(this);\n        Statement selectStatement = new Select();\n        SelectBody selectBody = new PlainSelect();\n        ((Select) selectStatement).setSelectBody(selectBody);\n\n        when(mgr.parse(new StringReader(testSql))).thenReturn(selectStatement);\n        jSqlParserAllTableManager = new JSqlParserAllTableManager(testSql);\n    }\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // Given an SQL query string\n        String inputSql = testSql;\n        Map<String, SelectSqlInfo> expectedResult = Map.of(\"my_table\", new SelectSqlInfo());\n\n        // Mock the behavior of the method (assume there are methods for mapping)\n        doNothing().when(jSqlParserAllTableManager).addSqlInfoByTable(any(Table.class));\n\n        // When the parse method is invoked\n        Map<String, SelectSqlInfo> actualResult = jSqlParserAllTableManager.parse();\n\n        // Then verify it produces the expected output\n        assertNotNull(actualResult, \"The parsing result should not be null\");\n        assertFalse(actualResult.isEmpty(), \"The parsing result should not be empty\");\n        assertEquals(expectedResult.size(), actualResult.size(), \"The parsing result size should match the expected result size\");\n\n        // Additional detailed checks can be done on 'actualResult' if necessary\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.expression.Alias;\nimport net.sf.jsqlparser.expression.Expression;\nimport net.sf.jsqlparser.schema.Table;\nimport net.sf.jsqlparser.statement.select.SubSelect;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    \n    private JSqlParserAllTableManager parser;\n    private final String sampleSql = \"SELECT * FROM myTable\";\n\n    @BeforeEach\n    public void setup() {\n        parser = new JSqlParserAllTableManager(sampleSql);\n    }\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        Map<String, SelectSqlInfo> result = parser.parse();\n        assertNotNull(result, \"The result should not be null.\");\n        \n        // Check if 'myTable' is present in the allTableMap after parse.\n        assertTrue(result.containsKey(\"myTable\"), \"'myTable' should be present in allTableMap.\");\n        \n        // Get the SelectSqlInfo for 'myTable'\n        SelectSqlInfo selectSqlInfo = result.get(\"myTable\");\n        assertNotNull(selectSqlInfo, \"SelectSqlInfo for 'myTable' should not be null.\");\n        \n        // Since the SQL query is \"SELECT * FROM myTable\", we expect selectAll to be true.\n        assertTrue(selectSqlInfo.isSelectAll(), \"The 'selectAll' flag should be true for 'myTable'.\");\n        \n        // Expecting that no specific select fields are set, due to \"SELECT *\"\n        assertNull(selectSqlInfo.getSelectFields(), \"The 'selectFields' should be null for 'myTable'.\");\n        assertNull(selectSqlInfo.getRealSelectFields(), \"The 'realSelectFields' should be null for 'myTable'.\");\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    private JSqlParserAllTableManager parserManager;\n\n    @BeforeEach\n    public void setUp() {\n        String testSql = \"SELECT * FROM table_name\";\n        parserManager = new JSqlParserAllTableManager(testSql);\n    }\n\n    @Test\n    public void parseTest() {\n        // Expected outcomes\n        String expectedTableName = \"table_name\";\n\n        try {\n            Map<String, SelectSqlInfo> result = parserManager.parse();\n            assertNotNull(result, \"The result map should not be null\");\n\n            // Check if the table is correctly parsed\n            assertTrue(result.containsKey(expectedTableName), \"The result map should contain the expected table name\");\n\n            // Perform additional checks, such as validating the properties of the SelectSqlInfo object\n            SelectSqlInfo selectSqlInfo = result.get(expectedTableName);\n            assertNotNull(selectSqlInfo, \"The SelectSqlInfo object for the expected table name should not be null\");\n            assertTrue(selectSqlInfo.isSelectAll(), \"The select all field should be true\");\n\n        } catch (JSQLParserException e) {\n            fail(\"Parsing should not throw an exception\");\n        }\n    }\n\n    @AfterEach\n    public void tearDown() {\n        parserManager = null;\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport net.sf.jsqlparser.JSQLParserException;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    \n    private JSqlParserAllTableManager manager;\n    private static final String VALID_SELECT_SQL = \"SELECT * FROM my_table\";\n    private static final String INVALID_SELECT_SQL = \"This is not a valid SQL\";\n\n    @BeforeEach\n    public void setUp() {\n        manager = new JSqlParserAllTableManager(VALID_SELECT_SQL);\n    }\n\n    @Test\n    public void parseValidSelectSqlTest() {\n        assertDoesNotThrow(() -> {\n            Map<String, SelectSqlInfo> result = manager.parse();\n            assertNotNull(result, \"Resulting Map should not be null.\");\n            assertFalse(result.isEmpty(), \"Resulting Map should not be empty.\");\n            assertTrue(result.containsKey(\"my_table\"), \"Resulting Map should have 'my_table' as a key.\");\n        });\n    }\n\n    @Test\n    public void parseInvalidSelectSqlTest() {\n        manager = new JSqlParserAllTableManager(INVALID_SELECT_SQL);\n        assertThrows(JSQLParserException.class, () -> manager.parse(),\n                     \"Parsing an invalid SQL should throw a JSQLParserException.\");\n    }\n}"
    ]
}