{
    "project_name": "jeecg-boot",
    "file_name": "JSqlParserAllTableManager.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/util/sqlparse/JSqlParserAllTableManager.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.util.sqlparse",
    "docstring": "/**\n     * \u5f00\u59cb\u89e3\u6790\n     *\n     * @return\n     * @throws JSQLParserException\n     */",
    "source_code": "\npublic Map<String, SelectSqlInfo> parse() throws JSQLParserException {\n    // 1. \u521b\u5efa\u89e3\u6790\u5668\n    CCJSqlParserManager mgr = new CCJSqlParserManager();\n    // 2. \u4f7f\u7528\u89e3\u6790\u5668\u89e3\u6790sql\u751f\u6210\u5177\u6709\u5c42\u6b21\u7ed3\u6784\u7684java\u7c7b\n    Statement stmt = mgr.parse(new StringReader(this.sql));\n    if (stmt instanceof Select) {\n        Select selectStatement = (Select) stmt;\n        SelectBody selectBody = selectStatement.getSelectBody();\n        this.parsedSql = selectBody.toString();\n        // 3. \u89e3\u6790select\u67e5\u8be2sql\u7684\u4fe1\u606f\n        if (selectBody instanceof PlainSelect) {\n            PlainSelect plainSelect = (PlainSelect) selectBody;\n            // 4. \u5408\u5e76 fromItems\n            List<FromItem> fromItems = new ArrayList<>();\n            fromItems.add(plainSelect.getFromItem());\n            // 4.1 \u5904\u7406join\u7684\u8868\n            List<Join> joins = plainSelect.getJoins();\n            if (joins != null) {\n                joins.forEach(join -> fromItems.add(join.getRightItem()));\n            }\n            // 5. \u5904\u7406 fromItems\n            for (FromItem fromItem : fromItems) {\n                // 5.1 \u901a\u8fc7\u8868\u540d\u7684\u65b9\u5f0ffrom\n                if (fromItem instanceof Table) {\n                    this.addSqlInfoByTable((Table) fromItem);\n                }\n                // 5.2 \u901a\u8fc7\u5b50\u67e5\u8be2\u7684\u65b9\u5f0ffrom\n                else if (fromItem instanceof SubSelect) {\n                    this.handleSubSelect((SubSelect) fromItem);\n                }\n            }\n            // 6. \u89e3\u6790 selectFields\n            List<SelectItem> selectItems = plainSelect.getSelectItems();\n            for (SelectItem selectItem : selectItems) {\n                // 6.1 \u67e5\u8be2\u7684\u662f\u5168\u90e8\u5b57\u6bb5\n                if (selectItem instanceof AllColumns) {\n                    // \u5f53 selectItem \u4e3a AllColumns \u65f6\uff0cfromItem \u5fc5\u5b9a\u4e3a Table\n                    String tableName = plainSelect.getFromItem(Table.class).getName();\n                    // \u6b64\u5904\u5fc5\u5b9a\u4e0d\u4e3a\u7a7a\uff0c\u56e0\u4e3a\u5728\u89e3\u6790 fromItem \u65f6\uff0c\u5df2\u7ecf\u5c06\u8868\u540d\u6dfb\u52a0\u5230 allTableMap \u4e2d\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    assert sqlInfo != null;\n                    // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                    sqlInfo.setSelectAll(true);\n                    sqlInfo.setSelectFields(null);\n                    sqlInfo.setRealSelectFields(null);\n                }\n                // 6.2 \u67e5\u8be2\u7684\u662f\u5e26\u8868\u522b\u540d\uff08 u.* )\u7684\u5168\u90e8\u5b57\u6bb5\n                else if (selectItem instanceof AllTableColumns) {\n                    AllTableColumns allTableColumns = (AllTableColumns) selectItem;\n                    String aliasName = allTableColumns.getTable().getName();\n                    // \u901a\u8fc7\u522b\u540d\u83b7\u53d6\u8868\u540d\n                    String tableName = this.tableAliasMap.get(aliasName);\n                    if (tableName == null) {\n                        tableName = aliasName;\n                    }\n                    SelectSqlInfo sqlInfo = this.allTableMap.get(tableName);\n                    // \u5982\u679c\u6b64\u5904\u4e3a\u7a7a\uff0c\u5219\u8bf4\u660e\u8be5\u5b57\u6bb5\u662f\u901a\u8fc7\u5b50\u67e5\u8be2\u83b7\u53d6\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e0d\u5904\u7406\uff0c\u53ea\u6709\u5b9e\u9645\u8868\u624d\u9700\u8981\u5904\u7406\n                    if (sqlInfo != null) {\n                        // \u8bbe\u7f6e\u4e3a\u67e5\u8be2\u5168\u90e8\u5b57\u6bb5\n                        sqlInfo.setSelectAll(true);\n                        sqlInfo.setSelectFields(null);\n                        sqlInfo.setRealSelectFields(null);\n                    }\n                }\n                // 6.3 \u5404\u79cd\u5b57\u6bb5\u8868\u8fbe\u5f0f\u5904\u7406\n                else if (selectItem instanceof SelectExpressionItem) {\n                    SelectExpressionItem selectExpressionItem = (SelectExpressionItem) selectItem;\n                    Expression expression = selectExpressionItem.getExpression();\n                    Alias alias = selectExpressionItem.getAlias();\n                    this.handleExpression(expression, alias, plainSelect.getFromItem());\n                }\n            }\n        } else {\n            log.warn(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody: {}\", selectBody.getClass().getName());\n            throw new JeecgBootException(\"\u6682\u65f6\u5c1a\u672a\u5904\u7406\u8be5\u7c7b\u578b\u7684 SelectBody\");\n        }\n    } else {\n        // \u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\n        throw new JeecgBootException(\"\u975e select \u67e5\u8be2sql\uff0c\u4e0d\u505a\u5904\u7406\");\n    }\n    return this.allTableMap;\n}\n",
    "class_name": "JSqlParserAllTableManager",
    "method_name": "parse",
    "arguments": [],
    "generate_test": [
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.statement.select.Select;\n\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // Given\n        JSqlParserAllTableManager manager = new JSqlParserAllTableManager(\"SELECT * FROM my_table\");\n        \n        // When\n        Map<String, SelectSqlInfo> result = manager.parse();\n        \n        // Then\n        assertNotNull(result, \"The result should not be null\");\n        assertTrue(result.containsKey(\"my_table\"), \"The result should contain key 'my_table'\");\n        \n        SelectSqlInfo selectSqlInfo = result.get(\"my_table\");\n        assertNotNull(selectSqlInfo, \"The selectSqlInfo should not be null\");\n        assertTrue(selectSqlInfo.isSelectAll(), \"The selectSqlInfo should indicate selection of all columns\");\n        assertNull(selectSqlInfo.getSelectFields(), \"The selectFields should be null when selecting all columns\");\n        assertNull(selectSqlInfo.getRealSelectFields(), \"The realSelectFields should be null when selecting all columns\");\n        \n        // Add additional assertions as needed to test various parts of the parse method\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport net.sf.jsqlparser.JSQLParserException;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class JSqlParserAllTableManagerTest {\n    private JSqlParserAllTableManager manager;\n\n    @BeforeEach\n    public void setUp() {\n        manager = new JSqlParserAllTableManager();\n        // Assuming there is a method in JSqlParserAllTableManager to set the SQL\n        manager.setSql(\"SELECT * FROM my_table\");\n    }\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        Map<String, SelectSqlInfo> sqlInfoMap = manager.parse();\n\n        assertNotNull(sqlInfoMap, \"The result of parse method should not be null.\");\n        assertTrue(sqlInfoMap.containsKey(\"my_table\"), \"The map should contain a key for 'my_table'.\");\n\n        SelectSqlInfo selectSqlInfo = sqlInfoMap.get(\"my_table\");\n        assertNotNull(selectSqlInfo, \"SelectSqlInfo for 'my_table' should not be null.\");\n        assertTrue(selectSqlInfo.isSelectAll(), \"SelectSqlInfo should be set to select all fields.\");\n        assertNull(selectSqlInfo.getSelectFields(), \"SelectFields should be null when selecting all fields.\");\n        assertNull(selectSqlInfo.getRealSelectFields(), \"RealSelectFields should be null when selecting all fields.\");\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // clean up after test if needed\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.statement.Statement;\nimport net.sf.jsqlparser.statement.select.Select;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n\n    private JSqlParserAllTableManager instance;\n\n    @BeforeEach\n    public void setUp() {\n        String sql = \"SELECT * FROM my_table\";\n        instance = new JSqlParserAllTableManager(sql);\n    }\n\n    @Test\n    public void parseTest() {\n        try {\n            Map<String, SelectSqlInfo> result = instance.parse();\n            assertNotNull(result, \"The result map should not be null.\");\n            assertFalse(result.isEmpty(), \"The result map should not be empty.\");\n\n            SelectSqlInfo info = result.get(\"my_table\");\n            assertNotNull(info, \"SelectSqlInfo for 'my_table' should not be null.\");\n            assertTrue(info.isSelectAll(), \"SelectSqlInfo isSelectAll should return true when selecting with *.\");\n            assertNull(info.getSelectFields(), \"SelectSqlInfo getSelectFields should be null when selecting with *.\");\n            assertNull(info.getRealSelectFields(), \"SelectSqlInfo getRealSelectFields should be null when selecting with *.\");\n\n        } catch (JSQLParserException e) {\n            fail(\"Parsing threw an unexpected JSQLParserException.\");\n        }\n    }\n\n    // Add additional test methods if necessary...\n    \n    @AfterEach\n    public void tearDown() {\n        // Perform any necessary cleanup\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.statement.Statement;\nimport net.sf.jsqlparser.statement.select.Select;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass JSqlParserAllTableManagerTest {\n\n  @Test\n  public void parseTest() throws JSQLParserException {\n    // Given\n    String sampleSql = \"SELECT * FROM users\";\n    JSqlParserAllTableManager manager = new JSqlParserAllTableManager(sampleSql);\n\n    // When\n    Map<String, SelectSqlInfo> result = manager.parse();\n\n    // Then\n    assertNotNull(result, \"The result should not be null.\");\n    \n    // Assuming SelectSqlInfo behaves correctly and there's a way to verify its state:\n    SelectSqlInfo usersInfo = result.get(\"users\");\n    assertNotNull(usersInfo, \"SelectSqlInfo for 'users' should not be null.\");\n    assertTrue(usersInfo.isSelectAll(), \"The SelectSqlInfo should indicate select all is true for the 'users' table.\");\n  }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\n\nimport java.io.StringReader;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // Instantiate the class to be tested\n        JSqlParserAllTableManager parserAllTableManager = new JSqlParserAllTableManager();\n\n        // Set up the SQL query to be tested\n        String sql = \"SELECT * FROM my_table\";\n        parserAllTableManager.sql = sql;\n\n        // Mock the CCJSqlParserManager and its behavior\n        CCJSqlParserManager manager = mock(CCJSqlParserManager.class);\n        when(manager.parse(new StringReader(sql))).thenReturn(new Select()); // Assume we're getting a Select object back\n\n        // Inject the mocked manager into the class via reflection or some setter method if available\n        // Use reflection to set the private field 'mgr' with the mocked 'manager'\n        Field parserManagerField = JSqlParserAllTableManager.class.getDeclaredField(\"mgr\");\n        parserManagerField.setAccessible(true);\n        parserManagerField.set(parserAllTableManager, manager);\n\n        // Perform the actual test\n        Map<String, SelectSqlInfo> result = parserAllTableManager.parse();\n\n        // Assertions\n        assertNotNull(result, \"Result map should not be null\");\n        assertTrue(result.containsKey(\"my_table\"), \"Result map should contain key 'my_table' for the from table\");\n\n        // Verify that the manager's 'parse' method was called with the correct SQL reader\n        verify(manager).parse(new StringReader(sql));\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport net.sf.jsqlparser.JSQLParserException;\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n    \n    private JSqlParserAllTableManager manager;\n\n    @BeforeEach\n    public void setUp() {\n        String sql = \"SELECT * FROM my_table\";\n        manager = new JSqlParserAllTableManager(sql);\n    }\n\n    @Test\n    public void parseTest() {\n        try {\n            Map<String, SelectSqlInfo> result = manager.parse();\n            assertNotNull(result, \"The result should not be null\");\n            \n            SelectSqlInfo sqlInfo = result.get(\"my_table\");\n            assertNotNull(sqlInfo, \"The sqlInfo for 'my_table' should not be null\");\n            assertTrue(sqlInfo.isSelectAll(), \"The 'selectAll' flag for 'my_table' should be true\");\n\n            // Additional assertions could be added here based on the expected behavior \n            // of the SelectSqlInfo object and the database schema\n            \n        } catch (JSQLParserException e) {\n            fail(\"Parsing failed with an exception: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.statement.Statement;\nimport net.sf.jsqlparser.statement.select.Select;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Map;\nimport org.mockito.*;\n\npublic class JSqlParserAllTableManagerTest {\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // Given\n        String sql = \"SELECT * FROM table_name\";\n        JSqlParserAllTableManager manager = Mockito.mock(JSqlParserAllTableManager.class);\n        Mockito.when(manager.parse()).thenCallRealMethod();\n        Mockito.doCallRealMethod().when(manager).setSql(Mockito.anyString());\n        Mockito.when(manager.getSql()).thenReturn(sql);\n\n        // When\n        manager.setSql(sql);\n        Map<String, SelectSqlInfo> result = manager.parse();\n\n        // Then\n        assertNotNull(result, \"The result should not be null.\");\n        assertTrue(result.containsKey(\"table_name\"), \"The result map should have the key 'table_name'.\");\n        SelectSqlInfo info = result.get(\"table_name\");\n        assertNotNull(info, \"The SelectSqlInfo for 'table_name' should not be null.\");\n        assertTrue(info.isSelectAll(), \"The SelectSqlInfo should have 'selectAll' as true for '*'.\");\n    }\n\n    // Additional setup for other helper methods and mock behaviors would be needed\n    // depending on the parsing logic within your `JSqlParserAllTableManager` class.\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.statement.Statement;\nimport net.sf.jsqlparser.statement.select.Select;\nimport org.junit.jupiter.api.*;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.mockito.Mock;\n\nimport java.io.StringReader;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class JSqlParserAllTableManagerTest {\n\n    @Mock\n    private CCJSqlParserManager mockParserManager;\n    \n    @Mock\n    private Select mockSelect;\n    \n    // Assuming SelectSqlInfo is a class representing parsed SQL information\n    @Mock\n    private SelectSqlInfo mockSelectSqlInfo;\n\n    @InjectMocks\n    private JSqlParserAllTableManager parserAllTableManager = new JSqlParserAllTableManager();\n\n    @Test\n    public void parseTest() throws JSQLParserException {\n        // Given\n        String sql = \"SELECT * FROM my_table\";\n        parserAllTableManager.sql = sql;\n        \n        when(mockParserManager.parse(new StringReader(sql))).thenReturn(mockSelect);\n        \n        // Assumed method structure within JSqlParserAllTableManager\n        doNothing().when(parserAllTableManager).addSqlInfoByTable(any());\n        doNothing().when(parserAllTableManager).handleSubSelect(any());\n        doNothing().when(parserAllTableManager).handleExpression(any(), any(), any());\n        when(mockSelect.getSelectBody()).thenReturn(any());\n        \n        // Assume that allTableMap is properly instantiated within the class\n        parserAllTableManager.allTableMap.put(\"my_table\", mockSelectSqlInfo);\n\n        // When\n        Map<String, SelectSqlInfo> result = parserAllTableManager.parse();\n        \n        // Then\n        assertNotNull(result, \"The result should not be null.\");\n        assertTrue(result.containsKey(\"my_table\"), \"The result map should contain the key for 'my_table'.\");\n        \n        // Verify that the parserManager.parse method was called once with the given SQL Reader\n        verify(mockParserManager).parse(any(StringReader.class));\n        // Verify that other mocked methods were called as needed\n        // Note: The actual verification will depend on the structure and expectations of mocked methods\n        // e.g. verify(parserAllTableManager).addSqlInfoByTable(any());\n    }\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport org.junit.jupiter.api.*;\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.statement.Select;\nimport net.sf.jsqlparser.statement.Statement;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.io.StringReader;\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n\n    private static final String VALID_SELECT_SQL = \"SELECT * FROM table_name\";\n    // Assuming the 'parse()' method belongs to the class called 'SqlParserManager'.\n    private SqlParserManager sqlParserManager;\n\n    @BeforeEach\n    public void setup() {\n        sqlParserManager = new SqlParserManager();\n        // Assuming 'sqlParserManager' requires a SQL string to be set for proper functioning.\n        sqlParserManager.setSql(VALID_SELECT_SQL);\n    }\n\n    @Test\n    public void parseTest() {\n        // We will perform the test with a simple SELECT * FROM table_name query\n        Map<String, SelectSqlInfo> resultMap = null;\n        try {\n            resultMap = sqlParserManager.parse();\n        } catch (JSQLParserException e) {\n            fail(\"JSQLParserException should not be thrown for a valid SQL\");\n        }\n        \n        assertNotNull(resultMap, \"The result map should not be null\");\n\n        // Assuming 'SelectSqlInfo' contains the details of the parsed SQL.\n        SelectSqlInfo selectSqlInfo = resultMap.get(\"table_name\");\n        assertNotNull(selectSqlInfo, \"There should be SelectSqlInfo for 'table_name'\");\n        assertTrue(selectSqlInfo.isSelectAll(), \"The select should indicate selection of all columns\");\n\n        // Add more assertions here based on what the SelectSqlInfo object and other classes provide\n        // For the sake of this demonstration, let's assume it is enough to check if select all columns is true\n    }\n    \n    // More tests could be added to check different branches of the parse function such as aliases\n    // sub-selects, different types of select items, joins, where conditions, etc.\n}",
        "package org.jeecg.common.util.sqlparse;\n\nimport net.sf.jsqlparser.JSQLParserException;\nimport net.sf.jsqlparser.parser.CCJSqlParserManager;\nimport net.sf.jsqlparser.statement.Statement;\nimport net.sf.jsqlparser.statement.select.PlainSelect;\nimport net.sf.jsqlparser.statement.select.Select;\nimport net.sf.jsqlparser.statement.select.SelectBody;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.io.StringReader;\nimport java.util.Map;\n\npublic class JSqlParserAllTableManagerTest {\n\n    private JSqlParserAllTableManager manager;\n    private String validSelectSql = \"SELECT * FROM my_table\";\n    private String invalidSql = \"UPDATE my_table SET column = 'value'\";\n\n    @BeforeEach\n    public void setUp() {\n        manager = new JSqlParserAllTableManager(validSelectSql);\n    }\n    \n    @Test\n    public void parseTest_ValidSelect_ShouldPass() throws JSQLParserException {\n        Map<String, SelectSqlInfo> result = manager.parse();\n        assertNotNull(result);\n        assertTrue(result.containsKey(\"my_table\"), \"Map should contain key 'my_table'\");\n        \n        // Further assertions can be made depending on the structure of SelectSqlInfo\n        // For example:\n        SelectSqlInfo info = result.get(\"my_table\");\n        assertNotNull(info);\n        assertTrue(info.isSelectAll(), \"Should indicate selection of all columns\");\n    }\n\n    @Test\n    public void parseTest_InvalidSql_ShouldThrowException() {\n        // Set up a manager with invalid SQL\n        JSqlParserAllTableManager managerWithInvalidSql = new JSqlParserAllTableManager(invalidSql);\n        assertThrows(JeecgBootException.class, managerWithInvalidSql::parse, \"Parsing invalid SQL should throw an exception\");\n    }\n\n    // You can add more tests for different scenarios, such as:\n    // - A query with joins\n    // - A select with specific columns\n    // - Selections with subqueries\n    // - Select with alias and table columns\n}"
    ]
}