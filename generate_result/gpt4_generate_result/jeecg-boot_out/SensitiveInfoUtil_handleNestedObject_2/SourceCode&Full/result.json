{
    "project_name": "jeecg-boot",
    "file_name": "SensitiveInfoUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/desensitization/util/SensitiveInfoUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.desensitization.util",
    "docstring": "/**\n     * \u5904\u7406\u5d4c\u5957\u5bf9\u8c61\n     * @param obj \u65b9\u6cd5\u8fd4\u56de\u503c\n     * @param entity \u5b9e\u4f53class\n     * @param isEncode \u662f\u5426\u52a0\u5bc6\uff08true: \u52a0\u5bc6\u64cd\u4f5c / false:\u89e3\u5bc6\u64cd\u4f5c\uff09\n     * @throws IllegalAccessException\n     */",
    "source_code": "\npublic static void handleNestedObject(Object obj, Class entity, boolean isEncode) throws IllegalAccessException {\n    Field[] fields = obj.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(field.getType().isPrimitive()){\n            continue;\n        }\n        if(field.getType().equals(entity)){\n            // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n            field.setAccessible(true);\n            Object nestedObject = field.get(obj);\n            handlerObject(nestedObject, isEncode);\n            break;\n        }else{\n            // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n            if(field.getGenericType() instanceof ParameterizedType){\n                ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                if(pt.getRawType().equals(List.class)){\n                    if(pt.getActualTypeArguments()[0].equals(entity)){\n                        field.setAccessible(true);\n                        Object nestedObject = field.get(obj);\n                        handleList(nestedObject, entity, isEncode);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "class_name": "SensitiveInfoUtil",
    "method_name": "handleNestedObject",
    "arguments": [
        "Object obj",
        "Class entity",
        "boolean isEncode"
    ],
    "generate_test": [
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass MockEntity {\n    public String publicField;\n    private List<MockNestedEntity> nestedList;\n    private MockNestedEntity nestedEntity;\n\n    public MockEntity() {\n        nestedList = new ArrayList<>();\n        nestedEntity = new MockNestedEntity();\n    }\n\n    public List<MockNestedEntity> getNestedList() {\n        return nestedList;\n    }\n\n    public MockNestedEntity getNestedEntity() {\n        return nestedEntity;\n    }\n\n    public void setNestedEntity(MockNestedEntity nestedEntity) {\n        this.nestedEntity = nestedEntity;\n    }\n}\n\nclass MockNestedEntity {\n    private String sensitiveField;\n\n    public MockNestedEntity() {}\n\n    public String getSensitiveField() {\n        return sensitiveField;\n    }\n\n    public void setSensitiveField(String sensitiveField) {\n        this.sensitiveField = sensitiveField;\n    }\n}\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        // Setup test data\n        MockEntity entity = new MockEntity();\n        entity.setNestedEntity(new MockNestedEntity());\n        entity.getNestedList().add(new MockNestedEntity());\n        entity.getNestedEntity().setSensitiveField(\"Sensitive Data\");\n\n        // Run method under test\n        try {\n            SensitiveInfoUtil.handleNestedObject(entity, MockNestedEntity.class, true);\n\n            // Verify nested entity was handled\n            MockNestedEntity processedNestedEntity = entity.getNestedEntity();\n            assertNotNull(processedNestedEntity.getSensitiveField());\n            assertNotEquals(\"Sensitive Data\", processedNestedEntity.getSensitiveField());\n            \n            // Verify that the nested list was handled\n            for (MockNestedEntity item : entity.getNestedList()) {\n                assertNotNull(item.getSensitiveField());\n                assertNotEquals(\"Sensitive Data\", item.getSensitiveField());\n            }\n        } catch(IllegalAccessException e) {\n            fail(\"IllegalAccessException thrown: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n\n    public class TestEntity {\n        public int id; // Primitive type should be skipped\n        public String name;\n        public TestNestedEntity nestedEntity;\n        public List<TestNestedEntity> nestedEntityList;\n    }\n\n    public class TestNestedEntity {\n        public String sensitiveData;\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Mock a TestEntity with sensitive data in its nested object\n        TestEntity testObj = new TestEntity();\n        testObj.id = 1;\n        testObj.name = \"TestName\";\n\n        // Create nested object\n        TestNestedEntity nested = new TestNestedEntity();\n        nested.sensitiveData = \"SensitiveInfo\";\n        testObj.nestedEntity = nested;\n\n        // Create list of nested objects\n        TestNestedEntity nestedListElement = new TestNestedEntity();\n        nestedListElement.sensitiveData = \"SensitiveListInfo\";\n        testObj.nestedEntityList = Arrays.asList(nestedListElement);\n\n        // Invoke the method to be tested\n        SensitiveInfoUtil.handleNestedObject(testObj, TestNestedEntity.class, true);\n\n        // Assertions to verify the expected behaviors\n        assertNotNull(testObj.nestedEntity.sensitiveData, \"The nested entity's sensitive data should not be null after encoding.\");\n        assertNotEquals(\"SensitiveInfo\", testObj.nestedEntity.sensitiveData, \"The nested entity's sensitive data should have been changed after encoding.\");\n\n        assertNotNull(testObj.nestedEntityList.get(0).sensitiveData, \"The nested entity list's sensitive data should not be null after encoding.\");\n        assertNotEquals(\"SensitiveListInfo\", testObj.nestedEntityList.get(0).sensitiveData, \"The nested entity list's sensitive data should have been changed after encoding.\");\n\n        // Optionally, perform decoding to check if it can be reverted to the original data\n        SensitiveInfoUtil.handleNestedObject(testObj, TestNestedEntity.class, false);\n        \n        assertEquals(\"SensitiveInfo\", testObj.nestedEntity.sensitiveData, \"The nested entity's sensitive data should match the original value after decoding.\");\n        assertEquals(\"SensitiveListInfo\", testObj.nestedEntityList.get(0).sensitiveData, \"The nested entity list's sensitive data should match the original value after decoding.\");\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n\n    private static class MockEntity {\n        public String publicField;\n        private String privateField;\n        private List<MockEntity> entityList;\n        \n        public MockEntity(String publicField, String privateField) {\n            this.publicField = publicField;\n            this.privateField = privateField;\n        }\n\n        public String getPrivateField() {\n            return privateField;\n        }\n\n        public void setEntityList(List<MockEntity> entityList) {\n            this.entityList = entityList;\n        }\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Prepare mock object with nested entity list\n        MockEntity mockEntity = new MockEntity(\"publicValue\", \"privateValue\");\n        MockEntity nestedEntity1 = new MockEntity(\"nestedPublic1\", \"nestedPrivate1\");\n        MockEntity nestedEntity2 = new MockEntity(\"nestedPublic2\", \"nestedPrivate2\");\n\n        List<MockEntity> nestedEntityList = new ArrayList<>();\n        nestedEntityList.add(nestedEntity1);\n        nestedEntityList.add(nestedEntity2);\n\n        mockEntity.setEntityList(nestedEntityList);\n\n        // Call method under test\n        SensitiveInfoUtil.handleNestedObject(mockEntity, MockEntity.class, true);\n\n        // Since we do not have a definition for handlerObject or handleList, we cannot verify behavior.\n        // In a real unit test, you should insert assertions here to confirm the expected state of mockEntity based on side effects.\n\n        // Assuming handlerObject should modify the `privateField` of mockEntity:\n        assertNotNull(mockEntity.getPrivateField(), \"privateField is null after handleNestedObject call.\");\n        \n        // Verify that `privateField` is altered (for encryption or some other logic)\n        assertNotEquals(\"privateValue\", mockEntity.getPrivateField(), \"privateField was not changed by handleNestedObject.\");\n        \n        // Assuming handleList should modify the nested entities' private fields with encryption or other logic:\n        for (MockEntity entity : mockEntity.entityList) {\n            assertNotEquals(\"nestedPrivate1\", entity.getPrivateField(), \"Nested entity privateField was not changed by handleNestedObject.\");\n            assertNotEquals(\"nestedPrivate2\", entity.getPrivateField(), \"Nested entity privateField was not changed by handleNestedObject.\");\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n\n    static class ExampleEntity {\n        public String sensitiveData;\n    }\n\n    static class ExampleNestedObject {\n        public ExampleEntity nestedEntity;\n        public List<ExampleEntity> nestedEntityList;\n    }\n\n    @Test\n    public void handleNestedObjectTest() {\n        ExampleNestedObject nestedObject = new ExampleNestedObject();\n        ExampleEntity entity = new ExampleEntity();\n        entity.sensitiveData = \"Sensitive Info\";\n        \n        nestedObject.nestedEntity = entity; // Set nested entity\n        nestedObject.nestedEntityList = Arrays.asList(entity, entity); // Set nested list\n\n        try {\n            // Attempt handling a single nested object with encoding\n            SensitiveInfoUtil.handleNestedObject(nestedObject, ExampleEntity.class, true);\n            assertNotNull(nestedObject.nestedEntity.sensitiveData, \"The nested entity should have encoded data.\");\n\n            // Attempt handling a list of nested objects with encoding\n            SensitiveInfoUtil.handleNestedObject(nestedObject, ExampleEntity.class, true);\n            assertFalse(nestedObject.nestedEntityList.isEmpty(), \"The nested entity list should not be empty.\");\n            assertNotNull(nestedObject.nestedEntityList.get(0).sensitiveData, \"The nested entity in the list should have encoded data.\");\n        } catch (IllegalAccessException e) {\n            fail(\"An IllegalAccessException was thrown: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Entity {\n    // Sample entity with nested objects and lists\n    public String simpleField;\n    public Entity nestedEntity;\n    public List<Entity> entityList;\n}\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        Entity entity = new Entity();\n        entity.simpleField = \"Simple Value\";\n        entity.nestedEntity = new Entity();\n        entity.entityList = new ArrayList<>();\n\n        // Add dummy entities to the list\n        entity.entityList.add(new Entity());\n        entity.entityList.add(new Entity());\n\n        // Testing with encode=true for encoding operation\n        assertDoesNotThrow(() -> SensitiveInfoUtil.handleNestedObject(entity, Entity.class, true));\n\n        // Testing with encode=false for decoding operation\n        assertDoesNotThrow(() -> SensitiveInfoUtil.handleNestedObject(entity, Entity.class, false));\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.List;\nimport java.util.ArrayList;\n\nclass SomeEntity {\n    public String publicField;\n    private String privateField;\n    public SomeEntity nestedEntity;\n    public List<SomeEntity> entityList;\n\n    public SomeEntity() {\n        this.entityList = new ArrayList<>();\n    }\n\n    private String getPrivateField() {\n        return privateField;\n    }\n    \n    private void setPrivateField(String privateField) {\n        this.privateField = privateField;\n    }\n}\n\npublic class SensitiveInfoUtilTest {\n    \n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        SomeEntity testEntity = new SomeEntity();\n        testEntity.publicField = \"public information\";\n        testEntity.setPrivateField(\"private information\");\n        testEntity.nestedEntity = new SomeEntity();\n        testEntity.entityList.add(new SomeEntity());\n\n        // Add test logic here.\n        // Since the handleNestedObject method is static, we can call it directly\n        // without having to create an instance of SensitiveInfoUtil class.\n        SensitiveInfoUtil.handleNestedObject(testEntity, SomeEntity.class, true);\n        \n        // Assuming a hypothetical method handleList() processes entities in the list,\n        // the list should have been processed during the previous method call.\n        // As this test suite has no visibility of any encryption or encoding logic,\n        // my assertions will only ensure that field access has not thrown exceptions\n        // and field values have potentially changed.\n        \n        // Verify that the nestedEntity has been processed (in the real test, should check if encrypted/encoded)\n        assertNotNull(testEntity.nestedEntity);\n        \n        // Verify that the entityList has been processed (in the real test, should check if list items are encrypted/encoded)\n        assertFalse(testEntity.entityList.isEmpty());\n        assertNotNull(testEntity.entityList.get(0));\n        \n        // Verify that public primitive fields are ignored\n        assertEquals(\"public information\", testEntity.publicField);\n        \n        // Verify that private fields are ignored or check if they are processed if we have a means to do so\n        // Since the private field is not accessible, and there's no accessor, it would typically not be processed.\n        // We could use reflection to assert its value if needed.\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n\n    // Mock classes for testing\n    public static class TestEntity {\n        public String sensitiveData;\n\n        public TestEntity(String sensitiveData) {\n            this.sensitiveData = sensitiveData;\n        }\n    }\n\n    public static class NestedObject {\n        public TestEntity nestedEntity;\n        public List<TestEntity> entityList;\n\n        public NestedObject(TestEntity nestedEntity, List<TestEntity> entityList) {\n            this.nestedEntity = nestedEntity;\n            this.entityList = entityList;\n        }\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Arrange\n        TestEntity testEntity = new TestEntity(\"Sensitive Information\");\n        List<TestEntity> testEntityList = new ArrayList<>();\n        testEntityList.add(new TestEntity(\"List Sensitive Info 1\"));\n        testEntityList.add(new TestEntity(\"List Sensitive Info 2\"));\n        NestedObject nestedObject = new NestedObject(testEntity, testEntityList);\n\n        // Act (we're simulating encode operation)\n        SensitiveInfoUtil.handleNestedObject(nestedObject, TestEntity.class, true);\n\n        // Assert for nested entity\n        assertNotNull(nestedObject.nestedEntity);\n        // Here we'd expect the sensitiveData of the nestedEntity to be encoded\n        // We only test for non-null as actual encoding correctness requires a known algorithm and key\n        assertNotNull(nestedObject.nestedEntity.sensitiveData);\n\n        // Assert for entity list\n        assertNotNull(nestedObject.entityList);\n        assertEquals(2, nestedObject.entityList.size());\n        // Similarly, we expect all entities within the list to be encoded\n        for (TestEntity entity : nestedObject.entityList) {\n            assertNotNull(entity.sensitiveData);\n            // Here you would use an assertion to check the actual encoding if possible\n        }\n\n        // Additional conditions could also be added if necessary, such as \n        // verifying that the nested entity's sensitiveData is different due to encoding\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Person {\n    public String name;\n    public List<Person> friends;\n}\n\npublic class SensitiveInfoUtilTest {\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException, NoSuchFieldException {\n        // Create a new person with a name\n        Person person = new Person();\n        person.name = \"John Smith\";\n        \n        // Create a friend with a name\n        Person friend = new Person();\n        friend.name = \"Jane Doe\";\n        \n        // Add friend to the person's friends list\n        person.friends = new ArrayList<>();\n        person.friends.add(friend);\n        \n        // Define a class type for the Person entity\n        Class<Person> entityClass = Person.class;\n        \n        // Call the handleNestedObject method\n        SensitiveInfoUtil.handleNestedObject(person, entityClass, true);\n        \n        // Since the name field is not encrypted in the logic, it should stay the same\n        assertEquals(\"John Smith\", person.name, \"Name field should not be changed\");\n        \n        // Test that the friend's name is also unchanged as encryption method stubs are not provided in this context\n        assertEquals(\"Jane Doe\", person.friends.get(0).name, \"Friend's name field should not be changed\");\n        \n        // Handle decode case\n        SensitiveInfoUtil.handleNestedObject(person, entityClass, false);\n        \n        // Assert that no changes occurred because decoding logic is not provided\n        assertEquals(\"John Smith\", person.name, \"Name field should remain the same after decode check\");\n        assertEquals(\"Jane Doe\", person.friends.get(0).name, \"Friend's name field should remain the same after decode check\");\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.Test;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.lang.reflect.Field;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Create a test entity class with nested objects to be used for testing\n        class TestEntity {\n            public String primitiveField = \"Test\";\n            public InnerEntity sensitiveField;\n\n            public TestEntity(InnerEntity sensitiveField) {\n                this.sensitiveField = sensitiveField;\n            }\n        }\n\n        class InnerEntity {\n            public String sensitiveData = \"Sensitive Data\";\n        }\n\n        InnerEntity innerEntity = new InnerEntity();\n        TestEntity obj = new TestEntity(innerEntity);\n\n        // Set the field accessible to manipulate it in the test\n        Field sensitiveField = obj.getClass().getDeclaredField(\"sensitiveField\");\n        sensitiveField.setAccessible(true);\n\n        // Check if the nested object is not yet processed (encode/decode)\n        assertEquals(\"Sensitive Data\", ((InnerEntity)sensitiveField.get(obj)).sensitiveData);\n\n        // Call the method under test\n        SensitiveInfoUtil.handleNestedObject(obj, InnerEntity.class, true);\n\n        // Assert that the nested object's sensitive data is processed (assuming encoding changes the value)\n        assertNotEquals(\"Sensitive Data\", ((InnerEntity)sensitiveField.get(obj)).sensitiveData);\n\n        // As we do not have the actual handlerObject and handleList logic implemented,\n        // we simply check that the inner data was attempted to be manipulated, in a real\n        // unit test one would mock 'handlerObject' and 'handleList' methods, checking that\n        // they were called with the correct parameters.\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass MockEntity {\n    public String name;\n}\n\npublic class SensitiveInfoUtilTest {\n\n    private MockEntity entity;\n    private List<MockEntity> entityList;\n\n    @BeforeEach\n    void setUp() {\n        entity = new MockEntity();\n        entity.name = \"John Doe\";\n        \n        entityList = new ArrayList<>();\n        entityList.add(entity);\n        entityList.add(entity);\n    }\n\n    @Test\n    public void handleNestedObjectTest() {\n        try {\n            SensitiveInfoUtil.handleNestedObject(entity, MockEntity.class, true);\n\n            // Verify that the nested object's name has been encoded if isEncode is true\n            assertNotNull(entity.name, \"Nested object's name should not be null after encoding\");\n            assertNotEquals(\"John Doe\", entity.name, \"Nested object's name should be encoded and different from the original value\");\n            \n            // Reset name for decoding test\n            entity.name = \"John Doe\";\n            \n            SensitiveInfoUtil.handleNestedObject(entity, MockEntity.class, false);\n            \n            // Verify that the nested object's name has been decoded if isEncode is false\n            assertEquals(\"John Doe\", entity.name, \"Nested object's name should be returned to its original value after decoding\");\n            \n            // Test handling of a List containing entities\n            MockEntityListWrapper mockEntityListWrapper = new MockEntityListWrapper();\n            mockEntityListWrapper.entityList = entityList;\n\n            SensitiveInfoUtil.handleNestedObject(mockEntityListWrapper, MockEntity.class, true);\n\n            // Verify that the List's nested objects' name has been encoded\n            mockEntityListWrapper.entityList.forEach(e -> {\n                assertNotNull(e.name, \"List's nested object's name should not be null after encoding\");\n                assertNotEquals(\"John Doe\", e.name, \"List's nested object's name should be encoded\");\n            });\n        } catch (IllegalAccessException e) {\n            fail(\"IllegalAccessException should not be thrown\");\n        }\n    }\n    \n    // Helper class to simulate an object with a List of MockEntity objects\n    private static class MockEntityListWrapper {\n        public List<MockEntity> entityList;\n    }\n}"
    ]
}