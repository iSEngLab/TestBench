{
    "project_name": "jeecg-boot",
    "file_name": "SensitiveInfoUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/desensitization/util/SensitiveInfoUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.desensitization.util",
    "docstring": "/**\n     * \u5904\u7406\u5d4c\u5957\u5bf9\u8c61\n     * @param obj \u65b9\u6cd5\u8fd4\u56de\u503c\n     * @param entity \u5b9e\u4f53class\n     * @param isEncode \u662f\u5426\u52a0\u5bc6\uff08true: \u52a0\u5bc6\u64cd\u4f5c / false:\u89e3\u5bc6\u64cd\u4f5c\uff09\n     * @throws IllegalAccessException\n     */",
    "source_code": "\npublic static void handleNestedObject(Object obj, Class entity, boolean isEncode) throws IllegalAccessException {\n    Field[] fields = obj.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(field.getType().isPrimitive()){\n            continue;\n        }\n        if(field.getType().equals(entity)){\n            // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n            field.setAccessible(true);\n            Object nestedObject = field.get(obj);\n            handlerObject(nestedObject, isEncode);\n            break;\n        }else{\n            // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n            if(field.getGenericType() instanceof ParameterizedType){\n                ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                if(pt.getRawType().equals(List.class)){\n                    if(pt.getActualTypeArguments()[0].equals(entity)){\n                        field.setAccessible(true);\n                        Object nestedObject = field.get(obj);\n                        handleList(nestedObject, entity, isEncode);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "class_name": "SensitiveInfoUtil",
    "method_name": "handleNestedObject",
    "arguments": [
        "Object obj",
        "Class entity",
        "boolean isEncode"
    ],
    "generate_test": [
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n    \n    static class TestEntity {\n        private int primitiveField;\n        private TestNestedEntity nestedObj;\n        private List<TestNestedEntity> nestedList;\n        \n        // Constructor, getters, and setters for fields\n        TestEntity(int primitiveField, TestNestedEntity nestedObj, List<TestNestedEntity> nestedList) {\n            this.primitiveField = primitiveField;\n            this.nestedObj = nestedObj;\n            this.nestedList = nestedList;\n        }\n\n        public int getPrimitiveField() {\n            return primitiveField;\n        }\n\n        public TestNestedEntity getNestedObj() {\n            return nestedObj;\n        }\n\n        public List<TestNestedEntity> getNestedList() {\n            return nestedList;\n        }\n    }\n    \n    static class TestNestedEntity {\n        private String sensitiveField;\n        \n        // Constructor, getters, and setters for fields\n        TestNestedEntity(String sensitiveField) {\n            this.sensitiveField = sensitiveField;\n        }\n\n        public String getSensitiveField() {\n            return sensitiveField;\n        }\n\n        public void setSensitiveField(String sensitiveField) {\n            this.sensitiveField = sensitiveField;\n        }\n    }\n\n    @Test\n    public void handleNestedObjectTest() {\n        TestNestedEntity nestedEntity = new TestNestedEntity(\"SensitiveData\");\n        TestEntity testEntity = new TestEntity(123, nestedEntity, Arrays.asList(nestedEntity));\n        \n        try {\n            SensitiveInfoUtil.handleNestedObject(testEntity, TestNestedEntity.class, true);\n            \n            Field nestedObjField = TestEntity.class.getDeclaredField(\"nestedObj\");\n            nestedObjField.setAccessible(true);\n            TestNestedEntity testNestedEntity = (TestNestedEntity)nestedObjField.get(testEntity);\n            assertNotNull(testNestedEntity); // Verify that the nested object is not null\n            // Assert that fields are handled properly; e.g., possibly encoded\n            // Assuming handlerObject would encode sensitiveField\n            // Replace \"EncodedData\" with the expected result from handlerObject\n            assertEquals(\"EncodedData\", testNestedEntity.getSensitiveField());\n            \n            Field nestedListField = TestEntity.class.getDeclaredField(\"nestedList\");\n            nestedListField.setAccessible(true);\n            List<?> testNestedList = (List<?>)nestedListField.get(testEntity);\n            assertNotNull(testNestedList); // Verify that the nested list is not null\n            assertFalse(testNestedList.isEmpty()); // Verify the list is not empty\n            // Again, asserting the result of a hypothetically encoded field in the list\n            TestNestedEntity listItem = (TestNestedEntity) testNestedList.get(0);\n            assertEquals(\"EncodedData\", listItem.getSensitiveField()); // For list item\n            \n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            fail(\"An error occurred while trying to access fields during the test: \" + e.getMessage());\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n    public class MockEntity {\n        private int primitiveField;\n        private String entityField;\n        private List<MockEntity> entityListField;\n\n        // Getters and Setters for fields (assuming they're generated)\n    }\n    \n    @Test\n    public void handleNestedObjectTest() {\n        // Create an instance of the entity\n        MockEntity entity = new MockEntity();\n\n        // Mock the nested object (same type as the entity)\n        MockEntity nestedEntity = new MockEntity();\n        nestedEntity.entityField = \"NestedValue\";\n\n        // Mock the entity list\n        List<MockEntity> entityList = Arrays.asList(nestedEntity);\n\n        // Set the nested object and entity list to the entity\n        entity.entityField = \"ParentValue\";\n        entity.entityListField = entityList;\n\n        // Assume the static method handlerObject() encodes or decodes the entity's entityField\n        // Assume the static method handleList() encodes or decodes each entity in the list\n\n        // Call the method under test\n        try {\n            SensitiveInfoUtil.handleNestedObject(entity, MockEntity.class, true);\n            // Assert that the field in the nested entity has been encoded\n            assertEquals(\"EncodedNestedValue\", nestedEntity.entityField, \"The nested entity field should be encoded.\");\n            // Assert that the list is encoded\n            assertEquals(\"EncodedNestedValue\", entityList.get(0).entityField, \"The entities in the list should be encoded.\");\n            \n            // Repeat the test with isEncode = false (decoding), and adjusted assertions\n            SensitiveInfoUtil.handleNestedObject(entity, MockEntity.class, false);\n            // Assert that the field in the nested entity has been decoded\n            assertEquals(\"DecodedNestedValue\", nestedEntity.entityField, \"The nested entity field should be decoded.\");\n            // Assert that the list is decoded\n            assertEquals(\"DecodedNestedValue\", entityList.get(0).entityField, \"The entities in the list should be decoded.\");\n            \n        } catch (IllegalAccessException e) {\n            fail(\"IllegalAccessException should not be thrown\");\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() {\n        // Assuming 'EntityClass' is the class that we are passing to the handleNestedObject method.\n        class EntityClass {\n            public List<String> sensitiveList; // List of entities (for the sake of example)\n            public String sensitiveField; // Single entity\n            public int primitiveField;    // Primitive field that should be skipped.\n        }\n        \n        // Instantiate an object of the inner class 'EntityClass'\n        EntityClass entity = new EntityClass();\n        entity.sensitiveList = Arrays.asList(\"data1\", \"data2\");\n        entity.sensitiveField = \"sensitive data\";\n        entity.primitiveField = 10;\n        \n        // Mock the behavior of the handlerObject and handleList methods\n        // You would have mock setup here; however, I'm just illustrating with direct calls.\n        \n        try {\n            // The actual test case - we're verifying that no exceptions are thrown and\n            // the necessary methods are called correctly.\n            SensitiveInfoUtil.handleNestedObject(entity, String.class, true);\n            \n            // Now asserting the expected behavior of the handleNestedObject.\n            // Assuming that the handlerObject and handleList change the fields in some way\n            // for the sake of encode or decode operation.\n            assertEquals(\"encoded data\", entity.sensitiveField); // Assuming supposed output after encoding\n            assertIterableEquals(Arrays.asList(\"encoded data1\", \"encoded data2\"), entity.sensitiveList); // Assumed output\n            \n        } catch (IllegalAccessException e) {\n            fail(\"The method should not have thrown an IllegalAccessException\");\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.BeforeEach;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.mockito.ArgumentMatchers.anyBoolean;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.times;\n\npublic class SensitiveInfoUtilTest {\n\n    private static class TestEntity {\n        public int primitiveField;\n        public String nestedEntity;\n        public List<TestEntity> entityList;\n\n        public TestEntity(String nestedEntity) {\n            this.nestedEntity = nestedEntity;\n            this.entityList = new ArrayList<>();\n        }\n    }\n\n    private TestEntity entity;\n    private SensitiveInfoUtil mockSensitiveInfoUtil;\n\n    @BeforeEach\n    public void setUp() {\n        // Setting up a mock object for SensitiveInfoUtil to verify interactions\n        mockSensitiveInfoUtil = mock(SensitiveInfoUtil.class);\n        entity = new TestEntity(\"Nested value\");\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Assuming there's a handleNestedObject method to be tested\n        SensitiveInfoUtil.handleNestedObject(entity, TestEntity.class, true);\n        \n        // Verifying handlerObject was called for a field of type TestEntity\n        verify(mockSensitiveInfoUtil, times(1)).handlerObject(entity.nestedEntity, true);\n\n        // Also assuming that there's a String field we want to ensure is encoded/decoded\n        // If necessary, interactions with other static methods can be similarly verified.\n    }\n\n    // The test might also include cases where we test with a list of the entity, but it is\n    // not clear how handleList or handlerObject are implemented and interacted with.\n    // This is a skeletal response; additional assertions and mocks will depend on the actual implementation\n    // details of the methods in the SensitiveInfoUtil class.\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Entity { /* Assuming Entity is a placeholder for a real class */ }\n\nclass Container {\n    public List<Entity> entities;\n    public Entity entity;\n    // Other fields...\n}\n\npublic class SensitiveInfoUtilTest {\n    \n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Assume we're providing a Container class that has a nested List<Entity> and Entity\n        Container obj = new Container();\n        obj.entities = new ArrayList<>();\n        obj.entities.add(new Entity());\n        obj.entity = new Entity();\n        \n        Class<Entity> entityClass = Entity.class;\n        \n        // Assuming the handlerObject and handleList are static methods with void return\n        // using Mockito.spy to watch the actual object\n        SensitiveInfoUtil utilSpy = Mockito.spy(SensitiveInfoUtil.class);\n        \n        utilSpy.handleNestedObject(obj, entityClass, true);\n        Mockito.verify(utilSpy, Mockito.times(1)).handlerObject(Mockito.any(), Mockito.eq(true));\n        Mockito.verify(utilSpy, Mockito.times(1)).handleList(Mockito.any(), Mockito.eq(entityClass), Mockito.eq(true));\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass SomeEntity {\n    public String data;\n}\n\nclass TestObject {\n    SomeEntity entity;\n    List<SomeEntity> entityList;\n\n    public TestObject(SomeEntity entity) {\n        this.entity = entity;\n        this.entityList = new ArrayList<>();\n    }\n\n    public void addEntityToList(SomeEntity entity) {\n        this.entityList.add(entity);\n    }\n}\n\npublic class SensitiveInfoUtilTest {\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        SomeEntity nestedEntity = new SomeEntity();\n        nestedEntity.data = \"Test Data\";\n\n        TestObject testObj = new TestObject(nestedEntity);\n        SensitiveInfoUtil.handleNestedObject(testObj, SomeEntity.class, true);\n        \n        // For this test case, we'll need to create assertions based on the expected behavior\n        // of the handleNestedObject method. Since we do not have the implementation details of \"handlerObject\" and \"handleList\",\n        // below are example assertions assuming these methods modify \"data\" field to \"Encoded Test Data\" or a similar action when isEncode is true.\n        \n        assertEquals(\"Encoded Test Data\", testObj.entity.data, \"The nested entity data should be encoded\");\n\n        // Test with a list of entities\n        SomeEntity listEntity = new SomeEntity();\n        listEntity.data = \"List Test Data\";\n        testObj.addEntityToList(listEntity);\n\n        SensitiveInfoUtil.handleNestedObject(testObj, SomeEntity.class, true);\n\n        // Assuming the handleList method also modifies the data field,\n        // we'd check that the data on all entities in the list has been handled accordingly.\n        String expectedListData = \"Encoded List Test Data\";\n        for (SomeEntity entityInList : testObj.entityList) {\n            assertEquals(expectedListData, entityInList.data, \"The entity data in list should be encoded\");\n        }\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n\n    private static class MockEntity {\n        // Assuming MockEntity has a field of type List<RelatedEntity>\n        public List<RelatedEntity> relatedEntities = new ArrayList<>();\n    }\n\n    private static class RelatedEntity {\n        // Simple entity class for the sake of the example\n    }\n\n    @BeforeEach\n    void setUp() {\n        // Set up test environment if necessary\n    }\n\n    @Test\n    public void handleNestedObjectTest() {\n        MockEntity entity = new MockEntity();\n        RelatedEntity relatedEntity = new RelatedEntity();\n        entity.relatedEntities.add(relatedEntity);\n        \n        boolean isEncode = true; // Or false, depending on the test case\n        \n        // Call the method to be tested\n        try {\n            SensitiveInfoUtil.handleNestedObject(entity, RelatedEntity.class, isEncode);\n\n            // The following lines are assumptions since we don't have the actual methods or expected outcomes.\n            // For instance, you might want to verify that the `handlerObject` or `handleList` method was called properly.\n            // If those methods would change data inside the entity, you would assert those changes here,\n            // e.g., assertNotNull(entity.relatedEntities.get(0).getSomeSensitiveField());\n\n\n            // If the original fields should be unchanged/assert specific changes, assert those conditions\n            assertNotNull(entity.relatedEntities);\n            assertFalse(entity.relatedEntities.isEmpty());\n            // Further assertions go here...\n\n        } catch (IllegalAccessException e) {\n            fail(\"Method threw IllegalAccessException: \" + e.getMessage());\n        }\n    }\n\n    @AfterEach\n    void tearDown() {\n        // Clean up test environment if necessary\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.AfterEach;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Entity {\n    public String data;\n}\n\npublic class SensitiveInfoUtilTest {\n\n    private Entity entity;\n    private List<Entity> entityList;\n\n    @BeforeEach\n    public void setUp() {\n        entity = new Entity();\n        entity.data = \"Sensitive Data\";\n\n        entityList = new ArrayList<>();\n        entityList.add(entity);\n    }\n\n    @AfterEach\n    public void tearDown() {\n        entity = null;\n        entityList = null;\n    }\n\n    @Test\n    public void handleNestedObjectTest() {\n        // Setup\n        class NestedObject {\n            public Entity nestedEntity = entity;\n            public List<Entity> nestedEntityList = entityList;\n        }\n        \n        NestedObject nestedObject = new NestedObject();\n\n        // Action and Assertions\n        assertDoesNotThrow(() -> {\n            SensitiveInfoUtil.handleNestedObject(nestedObject, Entity.class, true);\n            \n            Field field = NestedObject.class.getDeclaredField(\"nestedEntity\");\n            field.setAccessible(true);\n            Entity actualEntity = (Entity)field.get(nestedObject);\n            \n            assertNotNull(actualEntity);\n            // Perform specific assertions for the nested entity after encoding here.\n            // Example (assuming the handlerObject encodes the 'data' field):\n            // assertEquals(\"Encoded Sensitive Data\", actualEntity.data);\n\n            Field listField = NestedObject.class.getDeclaredField(\"nestedEntityList\");\n            listField.setAccessible(true);\n            List<Entity> actualEntityList = (List<Entity>) listField.get(nestedObject);\n            \n            assertNotNull(actualEntityList);\n            assertFalse(actualEntityList.isEmpty());\n            // Perform specific assertions for each item in the nested entity list after encoding here.\n            // Example (assuming the handleList encodes the 'data' field of the list items):\n            // assertEquals(\"Encoded Sensitive Data\", actualEntityList.get(0).data);\n        }, \"handleNestedObject should not throw exceptions.\");\n\n        assertDoesNotThrow(() -> {\n            SensitiveInfoUtil.handleNestedObject(nestedObject, Entity.class, false);\n\n            Field field = NestedObject.class.getDeclaredField(\"nestedEntity\");\n            field.setAccessible(true);\n            Entity actualEntity = (Entity) field.get(nestedObject);\n\n            assertNotNull(actualEntity);\n            // Perform specific assertions for the nested entity after decoding here.\n            // Example (assuming the handlerObject decodes the 'data' field):\n            // assertEquals(\"Sensitive Data\", actualEntity.data);\n\n            Field listField = NestedObject.class.getDeclaredField(\"nestedEntityList\");\n            listField.setAccessible(true);\n            List<Entity> actualEntityList = (List<Entity>) listField.get(nestedObject);\n\n            assertNotNull(actualEntityList);\n            assertFalse(actualEntityList.isEmpty());\n            // Perform specific assertions for each item in the nested entity list after decoding here.\n            // Example (assuming the handleList decodes the 'data' field of the list items):\n            // assertEquals(\"Sensitive Data\", actualEntityList.get(0).data);\n        }, \"handleNestedObject should not throw exceptions when decoding.\");\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Entity {\n    // Assuming this class represents the entity that should be handled\n}\n\npublic class SensitiveInfoUtilTest {\n    \n    private SensitiveInfoUtilTestHelper helper;\n\n    @BeforeEach\n    void setUp() {\n        // Optional: initialize any helper objects if necessary\n        helper = new SensitiveInfoUtilTestHelper();\n    }\n\n    @Test\n    public void handleNestedObjectTest_handlesEntity() {\n        Entity testEntity = new Entity();\n        boolean isEncode = true;\n\n        // Assuming 'handlerObject' is a mockable method that processes the entity\n        try {\n            SensitiveInfoUtil.handleNestedObject(testEntity, Entity.class, isEncode);\n            // If successful, the entity was processed without exceptions\n            assertNotNull(testEntity, \"Entity should be not null after being processed.\");\n        } catch (IllegalAccessException e) {\n            fail(\"IllegalAccessException should not be thrown.\");\n        }\n    }\n\n    @Test\n    public void handleNestedObjectTest_handlesListOfEntities() {\n        List<Entity> entityList = new ArrayList<>();\n        entityList.add(new Entity());\n        boolean isEncode = true;\n\n        // Assuming 'handleList' is a mockable method that processes the list of entities\n        try {\n            SensitiveInfoUtil.handleNestedObject(entityList, Entity.class, isEncode);\n            // If successful, the list was processed without exceptions\n            assertFalse(entityList.isEmpty(), \"List of entities should not be empty after being processed.\");\n        } catch (IllegalAccessException e) {\n            fail(\"IllegalAccessException should not be thrown.\");\n        }\n    }\n\n    // Additional tests can be written to cover other scenarios, such as handling primitives or when no matching field is found.\n    \n    // If the code you're testing relies on static methods like handlerObject and handleList, you may also consider testing these methods\n    // separately, or use a framework such as Mockito's 'mockStatic' to mock the behavior of these static methods within your tests.\n\n    // Note: The above test cases are only meaningful if 'handlerObject' and 'handleList' have some observable effect on the input objects.\n    // Consider what assertions would be appropriate for your test; the assertNotNull and assertFalse calls may not be relevant to your actual implementation.\n\n    // Don't forget to write additional test methods to fully test the SensitiveInfoUtil.handleNestedObject method's expected behavior.\n\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class SensitiveInfoUtilTest {\n\n    static class Entity {\n        private String attribute;\n        public Entity(String attribute) {\n            this.attribute = attribute;\n        }\n    }\n\n    static class NestedEntity {\n        public Entity nestedEntity;\n        public List<Entity> nestedEntityList;\n        public NestedEntity(Entity entity, List<Entity> entityList) {\n            this.nestedEntity = entity;\n            this.nestedEntityList = entityList;\n        }\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Create mock objects for our entity and nested entity\n        Entity mockEntity = mock(Entity.class);\n        List<Entity> mockEntityList = Arrays.asList(mockEntity);\n\n        // Create an instance of NestedEntity with the mock objects\n        NestedEntity nestedEntity = new NestedEntity(mockEntity, mockEntityList);\n\n        // Mock static utility methods in SensitiveInfoUtil\n        SensitiveInfoUtil mockSensitiveInfoUtil = mock(SensitiveInfoUtil.class);\n        when(mockSensitiveInfoUtil.handlerObject(any(), anyBoolean())).thenReturn(null);\n        when(mockSensitiveInfoUtil.handleList(any(), any(), anyBoolean())).thenReturn(null);\n\n        // Call the method under test\n        SensitiveInfoUtil.handleNestedObject(nestedEntity, Entity.class, true);\n\n        // Verify that the handlerObject or handleList method is called with proper arguments\n        Field fieldEntity = NestedEntity.class.getDeclaredField(\"nestedEntity\");\n        fieldEntity.setAccessible(true);\n        verify(mockSensitiveInfoUtil).handlerObject(fieldEntity.get(nestedEntity), true);\n\n        Field fieldList = NestedEntity.class.getDeclaredField(\"nestedEntityList\");\n        fieldList.setAccessible(true);\n        verify(mockSensitiveInfoUtil).handleList(fieldList.get(nestedEntity), Entity.class, true);\n    }\n}"
    ]
}