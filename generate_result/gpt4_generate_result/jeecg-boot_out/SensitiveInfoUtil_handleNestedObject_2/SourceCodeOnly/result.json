{
    "project_name": "jeecg-boot",
    "file_name": "SensitiveInfoUtil.java",
    "relative_path": "jeecg-boot/jeecg-boot-base-core/src/main/java/org/jeecg/common/desensitization/util/SensitiveInfoUtil.java",
    "execute_path": "jeecg-boot",
    "package": "org.jeecg.common.desensitization.util",
    "docstring": "/**\n     * \u5904\u7406\u5d4c\u5957\u5bf9\u8c61\n     * @param obj \u65b9\u6cd5\u8fd4\u56de\u503c\n     * @param entity \u5b9e\u4f53class\n     * @param isEncode \u662f\u5426\u52a0\u5bc6\uff08true: \u52a0\u5bc6\u64cd\u4f5c / false:\u89e3\u5bc6\u64cd\u4f5c\uff09\n     * @throws IllegalAccessException\n     */",
    "source_code": "\npublic static void handleNestedObject(Object obj, Class entity, boolean isEncode) throws IllegalAccessException {\n    Field[] fields = obj.getClass().getDeclaredFields();\n    for (Field field : fields) {\n        if(field.getType().isPrimitive()){\n            continue;\n        }\n        if(field.getType().equals(entity)){\n            // \u5bf9\u8c61\u91cc\u9762\u662f\u5b9e\u4f53\n            field.setAccessible(true);\n            Object nestedObject = field.get(obj);\n            handlerObject(nestedObject, isEncode);\n            break;\n        }else{\n            // \u5bf9\u8c61\u91cc\u9762\u662fList<\u5b9e\u4f53>\n            if(field.getGenericType() instanceof ParameterizedType){\n                ParameterizedType pt = (ParameterizedType)field.getGenericType();\n                if(pt.getRawType().equals(List.class)){\n                    if(pt.getActualTypeArguments()[0].equals(entity)){\n                        field.setAccessible(true);\n                        Object nestedObject = field.get(obj);\n                        handleList(nestedObject, entity, isEncode);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n",
    "class_name": "SensitiveInfoUtil",
    "method_name": "handleNestedObject",
    "arguments": [
        "Object obj",
        "Class entity",
        "boolean isEncode"
    ],
    "generate_test": [
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass Entity {\n    // Assuming Entity is a simple class with some fields\n    public String data;\n\n    // Constructor, getters, and setters are omitted for brevity\n}\n\npublic class SensitiveInfoUtilTest {\n    // Helper method to create a mock object for testing\n    private Object createTestObject() throws IllegalAccessException {\n        // Define a class with fields to run the test on\n        class TestObject {\n            private Entity entity = new Entity();\n            private List<Entity> entityList = Arrays.asList(new Entity(), new Entity());\n        }\n\n        // Instantiate an object of the inner class\n        TestObject testObj = new TestObject();\n\n        // Here, we could set some values to the fields if needed for the test...\n\n        return testObj;\n    }\n\n    // The actual test method\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Arrange\n        Object testObj = createTestObject();\n        Class entityClass = Entity.class;\n        boolean isEncode = true;\n\n        // Assuming handlerObject and handleList are methods that should be tested as well\n        // Since it's not included in the snippet, we cannot write a complete test that can be executed without this code\n\n        // Act\n        // The handleNestedObject method is static so we can call it directly without an instance\n        SensitiveInfoUtil.handleNestedObject(testObj, entityClass, isEncode);\n\n        // Assert\n        // Here we would check if the expected methods have been called and if the object state has changed as expected\n        // Since we don't have the implementation for 'handlerObject' or 'handleList', the assertions are examples\n        Field entityField = testObj.getClass().getDeclaredField(\"entity\");\n        entityField.setAccessible(true);\n        Entity entity = (Entity) entityField.get(testObj);\n        // Example assertion: checking if the 'handlerObject' method has correctly set the entity data when isEncode is true\n        // assertEquals(expectedValue, entity.getData()); // expectedValue would be the expected result after encoding\n\n        Field entityListField = testObj.getClass().getDeclaredField(\"entityList\");\n        entityListField.setAccessible(true);\n        List<Entity> entityList = (List<Entity>) entityListField.get(testObj);\n        // Example assertion: checking if the 'handleList' method processed all entities in the list\n        // assertFalse(entityList.stream().anyMatch(e -> e.getData() == null or some condition)); // Verifying that all the entities in the list have been handled\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.lang.reflect.*;\nimport java.util.*;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n\n    // Note: Assuming handlerObject and handleList methods exist and are public in the same class\n    // for testing purposes, these methods need to be implemented or mocked\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        class TestEntity {\n            public int primitiveField;\n            public NestedEntity nestedEntityField;\n            public List<NestedEntity> nestedEntityList;\n        }\n        class NestedEntity {\n            // fields and methods for NestedEntity\n        }\n\n        Object obj = new TestEntity();\n        ((TestEntity) obj).primitiveField = 10;\n        ((TestEntity) obj).nestedEntityField = new NestedEntity();\n        ((TestEntity) obj).nestedEntityList = new ArrayList<>(Collections.singletonList(new NestedEntity()));\n\n        boolean isEncode = true; // Assuming 'true' means encode and 'false' means decode\n\n        // Invoke the method to be tested\n        SensitiveInfoUtil.handleNestedObject(obj, NestedEntity.class, isEncode);\n\n        // Assertions would be dependent on the actual implementation of handlerObject and handleList.\n        // You would add assertions here to verify that the nestedEntityField and nestedEntityList have been\n        // handled (encoded/decoded) properly.\n        // For example:\n        // assertTrue(condition_that_should_be_true_after_handling);\n    }\n\n    // Placeholder methods for `handlerObject` and `handleList` assuming they are\n    // part of the same class that needs to be tested. If not, they need to be appropriately mocked.\n    public static void handlerObject(Object nestedObject, boolean isEncode) {\n        // Add logic here (possibly encode/decode the object)\n    }\n\n    public static void handleList(Object listObject, Class entity, boolean isEncode) {\n        // Add logic here (possibly iterate over the list and encode/decode each item)\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n\n    private static class DummyEntity {\n        public int primitiveField;\n        public String objectField;\n        public List<DummyEntity> entitiesList;\n\n        public DummyEntity(int primitiveField, String objectField) {\n            this.primitiveField = primitiveField;\n            this.objectField = objectField;\n        }\n    }\n\n    @BeforeEach\n    public void setup() {\n        // setup resources if needed\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Assuming we're just validating that the method does not throw an exception\n        // and calls the appropriate handling method based on field type.\n        // Further mocking could be required to test the `handlerObject` and `handleList` functionality.\n        \n        DummyEntity dummyObj = new DummyEntity(1, \"test\");\n        dummyObj.entitiesList = Arrays.asList(new DummyEntity(2, \"nested1\"), new DummyEntity(3, \"nested2\"));\n\n        // Since `handleNestedObject` is static, we can call it directly without an instance\n        assertDoesNotThrow(() -> SensitiveInfoUtil.handleNestedObject(dummyObj, DummyEntity.class, true));\n        \n        // Validate internal fields handling (this would typically require some sort of \n        // mocking or spying to ensure the handlerObject and handleList are called properly, \n        // but as those methods are not provided, it's left out).\n    }\n\n    @AfterEach\n    public void tearDown() {\n        // clean up resources if needed\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.Field;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n\n    static class TestEntity {\n        public int id;\n        public String name;\n        public List<TestEntity> children;\n        public TestEntity parent;\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Prepare the object with nested TestEntity and List<TestEntity>\n        TestEntity parentEntity = new TestEntity();\n        parentEntity.id = 1;\n        parentEntity.name = \"Parent Entity\";\n\n        TestEntity childEntity = new TestEntity();\n        childEntity.id = 2;\n        childEntity.name = \"Child Entity\";\n        childEntity.parent = parentEntity;\n\n        parentEntity.children = List.of(childEntity);\n\n        // Call the method under test\n        DesensitizationUtil.handleNestedObject(parentEntity, TestEntity.class, true);\n\n        // Verify the fields after handling\n        // Since the handlerObject and handleList methods are not specified,\n        // assertions will be based on the desired outcome after handling.\n        \n        // assert some conditions based on your handleObject and handleList method behavior.\n        // For instance, if handlerObject is supposed to encode the object's string fields:\n        assertNotNull(parentEntity.name, \"Name should not be null after handling\");\n\n        // similarly, check the handled List\n        assertNotNull(parentEntity.children, \"Children list should not be null after handling\");\n        assertFalse(parentEntity.children.isEmpty(), \"Children list should not be empty\");\n\n        // Assert Child is handled as well\n        TestEntity handledChild = parentEntity.children.get(0);\n        assertNotNull(handledChild.name, \"Child name should not be null after handling\");\n\n        // Additional assertions to ensure the handling is done correctly\n        // For example, we could check if encoding is correct if isEncode was true\n        // assertEquals(\"ExpectedEncodedValue\", handledChild.name);\n        // and more based on the expected behavior of handlerObject and handleList\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SensitiveInfoUtilTest {\n\n    static class MockEntity {\n        public int primitiveField;\n        public MockEntity entityField;\n        public List<MockEntity> entityListField;\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        Object mockObj = new MockEntity();\n        Class entity = MockEntity.class;\n        boolean isEncode = true; // Example flag, actual use-case may vary\n\n        // Test handling of entity fields\n        assertDoesNotThrow(() -> SensitiveInfoUtil.handleNestedObject(mockObj, entity, isEncode));\n\n        // Assuming handleNestedObject modifies the fields as expected (e.g., encoding), you might\n        // want to assert the state of the fields if there is any modification made by the method\n\n        Field field = mockObj.getClass().getDeclaredField(\"entityField\");\n        field.setAccessible(true);\n        assertNotNull(field.get(mockObj)); // Assert the field is not null after handling\n\n        // Similar assertions for list handling\n        field = mockObj.getClass().getDeclaredField(\"entityListField\");\n        field.setAccessible(true);\n        assertNotNull(field.get(mockObj)); // Assert the list field is not null after handling\n        // If the list is expected to be modified, perform further checks on its elements\n        List<MockEntity> entityList = (List<MockEntity>) field.get(mockObj);\n        assertFalse(entityList.isEmpty()); // Assert the list is not empty\n        assertNotNull(entityList.get(0)); // Assert list elements are not null\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.Field;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n\n    static class TestEntity { // An example entity class for the test\n        public String field;\n    }\n\n    static class NestedEntity { // An example nested entity class with a List\n        public List<TestEntity> entities;\n    }\n\n    @BeforeEach\n    void setup() {\n        // Setup method here if needed\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Set up the object to be tested\n        NestedEntity nestedObject = new NestedEntity();\n        \n        // Assume setting up a mock List of TestEntity objects here\n        // ...\n\n        // Call the method to be tested with 'isEncode' set to true or false\n        boolean isEncode = true; // or false depending on the test scenario\n\n        // The entity class we are expecting to handle\n        Class<TestEntity> entityClass = TestEntity.class;\n\n        // Now call the method\n        SensitiveInfoUtil.handleNestedObject(nestedObject, entityClass, isEncode);\n\n        // Assertions will depend on the expected outcome of handlerObject and handleList\n        // Since these methods' effects are unknown, the test case cannot be completed without assumptions\n        // Here we'll just finish the test with a simple assert statement\n        // This check is just placeholder and is not testing actual functionality\n        assertNotNull(nestedObject.entities, \"Entities list should not be null after handling.\");\n\n        // If the \"handlerObject\" and \"handleList\" methods modified the entity\n        // We should verify the modified state here, possibly by inspecting `nestedObject` fields\n        // If these methods provide any return value or throw exceptions, those can be tested as well\n    }\n\n    // Additional helper methods or mock classes could be defined if necessary\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass SensitiveInfoUtilTest {\n    \n    static class DummyEntity {\n        private String field1;\n        private int primitiveField;\n        private List<DummyEntity> entityListField;\n        private DummyEntity entityField;\n\n        // Dummy getters and setters or other methods if necessary\n        public String getField1() {\n            return field1;\n        }\n\n        public void setField1(String field1) {\n            this.field1 = field1;\n        }\n\n        public List<DummyEntity> getEntityListField() {\n            return entityListField;\n        }\n\n        public void setEntityListField(List<DummyEntity> entityListField) {\n            this.entityListField = entityListField;\n        }\n\n        public DummyEntity getEntityField() {\n            return entityField;\n        }\n\n        public void setEntityField(DummyEntity entityField) {\n            this.entityField = entityField;\n        }\n    }\n\n    @Test\n    public void handleNestedObjectTest() {\n        DummyEntity testObject = new DummyEntity();\n        testObject.setField1(\"testValue\");\n        testObject.setEntityField(new DummyEntity());\n        testObject.setEntityListField(Arrays.asList(new DummyEntity(), new DummyEntity()));\n        \n        // Assume handlerObject and handleList are methods we want to verify are called.\n        // Unfortunately, without code for these methods, we can't verify their behavior.\n        \n        // Initialize the parameters for the handleNestedObject method.\n        Object obj = testObject;\n        Class<?> entity = DummyEntity.class;\n        boolean isEncode = true;\n\n        try {\n            SensitiveInfoUtils.handleNestedObject(obj, entity, isEncode);\n            \n            // After calling handleNestedObject, we may want to verify certain behaviors on obj.\n            // Since handlerObject and handleList are not defined, we can't make specific assertions.\n            \n            // As an example, we can check if the entityField is not null after handling.\n            assertNotNull(testObject.getEntityField());\n            // We could also verify that handleList has been processed if we had a method to check it.\n            \n        } catch (IllegalAccessException e) {\n            fail(\"Method should not throw an IllegalAccessException.\");\n        }\n    }\n    \n    // Additional tests could be written to handle other cases and exceptions.\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.util.List;\n\nclass MyEntity {\n    // Just a stub entity class for testing\n}\n\nclass ObjectWithNestedEntity {\n    // Assume a field that is also an entity\n    public MyEntity nestedEntity;\n    public ObjectWithNestedEntity(MyEntity nestedEntity) {\n        this.nestedEntity = nestedEntity;\n    }\n}\n\nclass ObjectWithNestedList {\n    // Assume a field that is a list of entities\n    public List<MyEntity> entityList;\n    public ObjectWithNestedList(List<MyEntity> entityList) {\n        this.entityList = entityList;\n    }\n}\n\npublic class SensitiveInfoUtilTest {\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        MyEntity entity = new MyEntity();\n        ObjectWithNestedEntity objectWithNestedEntity = new ObjectWithNestedEntity(entity);\n        ObjectWithNestedList objectWithNestedList = new ObjectWithNestedList(List.of(entity));\n\n        // This is just a stub method assuming some kind of manipulation\n        SensitiveInfoUtil.handleNestedObject(objectWithNestedEntity, MyEntity.class, true);\n        SensitiveInfoUtil.handleNestedObject(objectWithNestedList, MyEntity.class, true);\n\n        // Check if field was accessed and manipulated\n        // As there are no clear side-effects described, this is a simplistic example\n        // Asserting entity within ObjectWithNestedEntity was handled\n        assertTrue(objectWithNestedEntity.nestedEntity != null);\n\n        // Asserting list within ObjectWithNestedList was handled\n        assertFalse(objectWithNestedList.entityList.isEmpty());\n        \n        // Here you would normally add assertions to verify that `handlerObject`\n        // and `handleList` have been called and modified the objects appropriately.\n    }\n}",
        "package org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.lang.reflect.Field;\nimport java.util.List;\nimport java.util.ArrayList;\n\nclass SensitiveEntity {\n    // This field will be encoded/decoded as it is of type SensitiveEntity\n    public SensitiveEntity nestedEntity;\n\n    // This list will be encoded/decoded since it contains elements of type SensitiveEntity\n    public List<SensitiveEntity> entityList;\n}\n\npublic class SensitiveInfoUtilTest {\n    SensitiveEntity testEntity;\n\n    @BeforeEach\n    public void setUp() {\n        testEntity = new SensitiveEntity();\n        testEntity.nestedEntity = new SensitiveEntity();\n\n        testEntity.entityList = new ArrayList<>();\n        testEntity.entityList.add(new SensitiveEntity());\n    }\n\n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Instantiate the object we want to test the method on\n        testEntity.nestedEntity = new SensitiveEntity(); // Nested object\n        testEntity.entityList = new ArrayList<>(); // List of nested objects\n        testEntity.entityList.add(new SensitiveEntity());\n\n        // Assume these methods would modify the fields in some way. Here we'll just check if the fields are accessible.\n        // We need to create these mock methods to simulate their existences\n        SensitiveInfoUtil.handleList = (nestedObject, entity, isEncode) -> assertEquals(true, ((List) nestedObject).get(0) instanceof SensitiveEntity);\n        SensitiveInfoUtil.handlerObject = (nestedObject, isEncode) -> assertEquals(true, nestedObject instanceof SensitiveEntity);\n\n        // Calling the method under test\n        SensitiveInfoUtil.handleNestedObject(testEntity, SensitiveEntity.class, true);\n\n        Field[] fields = testEntity.getClass().getDeclaredFields();\n        for (Field field : fields) {\n            if (field.getType().equals(SensitiveEntity.class) || \"entityList\".equals(field.getName())) {\n                assertTrue(field.isAccessible());\n            }\n        }\n    }\n}",
        "### JUNIT Test case:\npackage org.jeecg.common.desensitization.util;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SensitiveInfoUtilTest {\n    \n    private static class TestEntity {\n        public String publicField;\n        private String privateField;\n        public TestEntity childEntity;\n        public List<TestEntity> entityList;\n        \n        public String getPrivateField() {\n            return privateField;\n        }\n        \n        public void setPrivateField(String privateField) {\n            this.privateField = privateField;\n        }\n    }\n\n    private static void handleList(Object list, Class entity, boolean isEncode) {\n        // Simulate method implementation for testing purposes\n    }\n\n    private static void handlerObject(Object object, boolean isEncode) {\n        // Simulate method implementation for testing purposes\n    }\n    \n    @Test\n    public void handleNestedObjectTest() throws IllegalAccessException {\n        // Prepare a test entity with nested data\n        TestEntity parentEntity = new TestEntity();\n        parentEntity.publicField = \"publicValue\";\n        parentEntity.setPrivateField(\"privateValue\");\n        \n        TestEntity childEntity = new TestEntity();\n        childEntity.publicField = \"childPublic\";\n        childEntity.setPrivateField(\"childPrivate\");\n        \n        parentEntity.childEntity = childEntity;\n        \n        // Prepare a list of TestEntity objects\n        List<TestEntity> entityList = new ArrayList<>();\n        entityList.add(childEntity);\n        parentEntity.entityList = entityList;\n        \n        // Call the method to be tested\n        SensitiveInfoUtil.handleNestedObject(parentEntity, TestEntity.class, true);\n        \n        // Assertions to verify the expected outcome of the method\n        assertNotNull(parentEntity.childEntity);\n        assertEquals(\"childPublic\", parentEntity.childEntity.publicField);\n        assertEquals(\"childPrivate\", parentEntity.childEntity.getPrivateField());\n        assertNotNull(parentEntity.entityList);\n        assertFalse(parentEntity.entityList.isEmpty());\n        assertEquals(\"childPublic\", parentEntity.entityList.get(0).publicField);\n        assertEquals(\"childPrivate\", parentEntity.entityList.get(0).getPrivateField());\n        \n        // In a real scenario, we might also check if encode/decode operations were carried out correctly\n        // by mocking the handleList and handlerObject methods and verifying their invocation.\n    }\n}"
    ]
}