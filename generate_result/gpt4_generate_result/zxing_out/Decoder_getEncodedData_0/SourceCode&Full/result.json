{
    "project_name": "zxing",
    "file_name": "Decoder.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.decoder",
    "docstring": "/**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */",
    "source_code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
    "class_name": "Decoder",
    "method_name": "getEncodedData",
    "arguments": [
        "boolean[] correctedBits"
    ],
    "generate_test": [
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    // Assuming that Table and other dependencies such as readCode, getCharacter, etc.,\n    // are static methods and can be accessed directly. If not, mock or helper methods are needed.\n    // Additional setup or teardown code may be required depending on the test context.\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        // Test an arbitrary case where correctedBits should correspond to the encoded data.\n        // This example involves a simplified boolean array for the sake of the example.\n        // In a real-world scenario, the array would need to match real encoded data and its length\n        // should match the data plus padding of the Aztec code.\n        boolean[] correctedBitsExample = {false, true, false, true}; // Simplified placeholder data\n        \n        // Mock behavior of readCode or getCharacter if needed\n        String expectedResult = \"Mocked Result\"; // Expected result (Placeholder)\n        \n        // Below is an example call to the static method, this would be replaced\n        // with the proper test assertions and validations.\n        String decodedData = Decoder.getEncodedData(correctedBitsExample);\n\n        // Validate the expected result, this may include testing for exceptions,\n        // different formats, corner cases, etc.\n        assertEquals(expectedResult, decodedData, \"The decoded data should match the expected result.\");\n        \n        // More test cases here...\n    }\n    \n    // Additional tests could be written to cover negative cases, for example:\n    // testGetEncodedDataWithInsufficientLength, testGetEncodedDataWithIllegalCharacters, etc.\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        // Assuming a set of boolean inputs simulating the corrected bits\n        // for a known encoded data string \"Hello, World!\". In practice, you'd want\n        // to provide a real example here that corresponds to the Aztec code being tested.\n        // This is a simplified example for demonstration purposes only.\n        boolean[] correctedBits = new boolean[]{\n                // This should correspond to the bit representation of \"Hello, World!\"\n                // which we cannot actually provide without the real encoding logic\n                /* ... */\n        };\n\n        // Execute the method to test\n        String decodedResult = Decoder.getEncodedData(correctedBits);\n\n        // The expected value would be the string we intend to decode\n        // so we will assert that the actual result matches \"Hello, World!\"\n        String expected = \"Hello, World!\";\n        assertEquals(expected, decodedResult);\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        // Simulate a known sequence of corrected bits for the UPPER table\n        boolean[] correctedBits = {\n            // Encoding for 'A' in UPPER_TABLE (binary 2)\n            false, true, false, false, false,\n            // Encoding for 'B' in UPPER_TABLE (binary 3)\n            false, true, false, false, true\n        };\n\n        // Expected output based on the correctedBits for 'AB'\n        String expected = \"AB\";\n\n        // Since getEncodedData is a private static method, we can't call it directly.\n        // For this test case, we assume it should be made package-private or public for testing purposes.\n        String result = Decoder.getEncodedData(correctedBits);\n\n        assertEquals(expected, result, \"The encoded data should match the expected output\");\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    \n    @Test\n    public void getEncodedDataTest() {\n        boolean[] correctedBits = {\n            true, false, true, false, // example data pattern for the test\n            true, true, true, true,\n            ... // extend this pattern with valid test data\n        };\n        \n        String expectedEncodedData = \"YOUR_EXPECTED_RESULT_HERE\"; // replace with the expected string\n        \n        try {\n            String actualEncodedData = Decoder.highLevelDecode(correctedBits);\n            assertEquals(expectedEncodedData, actualEncodedData);\n        } catch (FormatException e) {\n            fail(\"FormatException should not be thrown for valid data\");\n        }\n    }\n    \n    // Additional tests can be written to cover different cases, such as handling special characters,\n    // testing with invalid input patterns that should throw FormatException, etc.\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        // Assuming that the Decoder class has a visible method for testing\n        // Called `getEncodedData(boolean[] correctedBits)` which is made public for the test\n\n        // Create a sample input for the test, assuming correctedBits simulates some binary encoding\n        boolean[] sampleCorrectedBits = { /* Example test data here */ };\n\n        // Call the method under test\n        String result = Decoder.getEncodedData(sampleCorrectedBits);\n\n        // Verify the result, where the expected result is known for the given test data\n        String expected = \"Expected Decoded String\"; // Replace with the expected string for the test data\n        assertEquals(expected, result);\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n  \n    @Test\n    public void getEncodedDataTest() {\n        // Example test case. You will need real boolean arrays and expected Strings\n        // for actual testing.\n        \n        // Test with a hypothetical correctedBits array that is supposed to decode \n        // to a known string without throwing any FormatExceptions.\n        boolean[] exampleCorrectedBits = {true, false, ...}; // Should represent the encoded data\n        String expectedDecodedData = \"DecodedString\"; // The expected result. An actual example needs to be provided.\n        \n        try {\n            String result = Decoder.getEncodedData(exampleCorrectedBits);\n            assertEquals(expectedDecodedData, result);\n        } catch (FormatException fe) {\n            fail(\"FormatException should not be thrown\");\n        }\n\n        // Test the behavior when the correctedBits array would cause a FormatException\n        boolean[] incorrectCorrectedBits = {true, true, ...}; // Should represent invalid encoded data that triggers a FormatException\n        \n        assertThrows(FormatException.class, () -> {\n            Decoder.getEncodedData(incorrectCorrectedBits);\n        });\n\n        // Further tests should be added here to cover more scenarios of the getEncodedData method,\n        // including various modes and transitions between them.\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n  private final Decoder decoder = new Decoder();\n\n  @Test\n  public void getEncodedDataTest() {\n    // Example usage, assumes related methods such as `extractBits` and `correctBits` are available and working correctly\n    boolean[] correctedBitsExample = new boolean[]{ /* Provide a valid bit sequence here */ };\n    String expectedOutput = \"Expected string result\"; // The expected string result for the given input bits\n\n    // Test with some valid `correctedBits` data\n    try {\n      String result = Decoder.highLevelDecode(correctedBitsExample);\n      assertNotNull(result, \"Decoded string should not be null\");\n      assertEquals(expectedOutput, result, \"Decoded string does not match the expected output.\");\n    } catch (FormatException e) {\n      fail(\"FormatException should not be thrown for valid input data.\");\n    }\n\n    // Test with invalid `correctedBits` data where a FormatException is expected\n    boolean[] incorrectBitsExample = new boolean[]{ /* Provide an invalid bit sequence here */ };\n    assertThrows(FormatException.class, () -> {\n      Decoder.highLevelDecode(incorrectBitsExample);\n    }, \"FormatException should be thrown for invalid input data.\");\n  }\n  \n  // Add more test methods as needed...\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    // Helper method to create a boolean array from a binary string for testing purposes\n    private static boolean[] createBoolArrayFromBinaryString(String binaryString) {\n        boolean[] boolArray = new boolean[binaryString.length()];\n        for (int i = 0; i < binaryString.length(); i++) {\n            boolArray[i] = binaryString.charAt(i) == '1';\n        }\n        return boolArray;\n    }\n\n    @Test\n    public void getEncodedDataTest() {\n        // Define a test case with a known binary string input and expected output\n        // This binary string should be an appropriate representation of an Aztec code data\n        String binaryStringInput = \"101010101010\"; // Replace with actual binary string for a meaningful test\n        String expectedOutput = \"TestData\"; // Replace with the expected output for the given binary input\n\n        // Convert the binary string to a boolean array\n        boolean[] correctedBits = createBoolArrayFromBinaryString(binaryStringInput);\n\n        // Call the static method getEncodedData and assert the result\n        try {\n            String result = Decoder.getEncodedData(correctedBits);\n            assertEquals(expectedOutput, result, \"Encoded data does not match the expected output.\");\n        } catch (FormatException fe) {\n            fail(\"FormatException should not be thrown for valid input.\");\n        }\n    }\n\n    // More test methods could be added here to cover different cases such as errors, larger inputs, special characters, etc.\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    \n    @Test\n    public void getEncodedDataTest() {\n        // Given a boolean array representing corrected bits which, when decoded, should result in a specific string.\n        // In this test scenario, we are using a simple example that should decode to the string \"TEST\".\n        // Note: The setup of this test is hypothetical and may not correspond to real encoded data.\n        // You would replace the `correctedBits` and `expectedResult` with actual data relevant to your test case.\n        \n        boolean[] correctedBits = {\n            // Assume this is a valid sequence of corrected bits that decode to \"TEST\".\n        };\n        String expectedResult = \"TEST\";\n        try {\n            // When\n            String result = Decoder.highLevelDecode(correctedBits);\n            \n            // Then\n            assertEquals(expectedResult, result, \"The encoded data is not as expected.\");\n        } catch (FormatException e) {\n            fail(\"FormatException should not be thrown.\");\n        }\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    @Test\n    public void getEncodedDataTest() {\n        // Define corrected bits for a sample encoding.\n        // This is a hypothetical array of bits for the purpose of illustration.\n        boolean[] correctedBits = {\n            // This is an arbitrary sequence of bits to test the getEncodedData function\n            // They should correspond to a valid sequence in the encoding table of the Aztec code\n            // For example, let's say these bits correspond to \"HELLO\"\n            true, false, true, false, true, false, true, false, // H\n            false, true, false, true, false, true, false, true,  // E\n            true, true, false, false, true, false, true, false,  // L\n            true, true, false, false, true, false, true, false,  // L\n            true, false, false, true, false, true, false, false  // O\n        };\n\n        // Expected result string corresponding to the encoded bits.\n        // This should be the expected decoded string of the provided bits\n        String expectedString = \"HELLO\";\n\n        // Call getEncodedData and verify the result.\n        try {\n            String result = Decoder.highLevelDecode(correctedBits);\n            assertEquals(expectedString, result, \"The decoded string does not match the expected output.\");\n        } catch (FormatException e) {\n            fail(\"FormatException should not occur for valid corrected bits.\");\n        }\n    }\n}"
    ]
}