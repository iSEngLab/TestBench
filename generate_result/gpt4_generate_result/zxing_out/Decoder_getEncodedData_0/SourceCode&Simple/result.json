{
    "project_name": "zxing",
    "file_name": "Decoder.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/decoder/Decoder.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.decoder",
    "docstring": "/**\n   * Gets the string encoded in the aztec code bits\n   *\n   * @return the decoded string\n   */",
    "source_code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
    "class_name": "Decoder",
    "method_name": "getEncodedData",
    "arguments": [
        "boolean[] correctedBits"
    ],
    "generate_test": [
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport java.util.Arrays;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\npublic class DecoderTest {\n    \n    // Helper method to convert binary string to boolean array\n    private boolean[] convertStringToBoolArray(String binaryString) {\n        boolean[] boolArray = new boolean[binaryString.length()];\n        for (int i = 0; i < binaryString.length(); i++) {\n            boolArray[i] = binaryString.charAt(i) == '1';\n        }\n        return boolArray;\n    }\n\n    @Test\n    public void getEncodedDataTest() {\n        // Test with a valid binary string that can be encoded\n        String binaryTestString1 = \"011000010110001001100011\"; // \"abc\" encoded in ASCII in binary\n        boolean[] correctedBits1 = convertStringToBoolArray(binaryTestString1);\n        try {\n            String result = Decoder.getEncodedData(correctedBits1);\n            assertEquals(\"abc\", result, \"The encoded data should match the expected string.\");\n        } catch (FormatException e) {\n            fail(\"FormatException should not be thrown for valid data\");\n        }\n\n        // Test with invalid length that can't form a complete byte\n        String binaryTestString2 = \"0110000\";\n        boolean[] correctedBits2 = convertStringToBoolArray(binaryTestString2);\n        assertThrows(FormatException.class, () -> Decoder.getEncodedData(correctedBits2),\n                \"A FormatException should be thrown when the corrected bits are not correctly formatted.\");\n\n        // Test to ensure FormatException is thrown when reserved flag FLG(7) is encountered\n        String binaryTestString3 = \"00000000\" // Binary representation to trigger the special case in code\n                                + \"100\" // This corresponds to the FLG(n), which should be FLG(7) \u2192 111\n                                + \"00010011\"; // Some extra bits to make the length enough\n        boolean[] correctedBits3 = convertStringToBoolArray(binaryTestString3);\n        assertThrows(FormatException.class, () -> Decoder.getEncodedData(correctedBits3),\n                \"A FormatException should be thrown when FLG(7) is encountered.\");\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport com.google.zxing.FormatException;\n\npublic class DecoderTest {\n\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        // Setup: create a boolean array representing corrected bits for the test\n        // This should be created based on expected input/output from the Aztec code decoding\n        // For demo purposes, let's assume an arbitrary boolean array for testing.\n        boolean[] correctedBits = {\n            // Add a sequence that would decode without throwing exceptions\n            // This should match possible encoded data that the `getEncodedData` method can handle\n            // Example:\n            true, false, true, false, // A sequence which, when read, should correspond to some encoded data\n            // Note: The actual contents should be designed to match a real situation.\n            // The sequence and length here are arbitrary and for illustrating purposes only.\n            // ...\n        };\n    \n        // Expected result of the decoding, to be used in the assertEquals to verify correct functionality\n        String expectedDecodedData = \"EXPECTED_DECODED_DATA\"; // Replace with actual expected string result\n    \n        // Perform test\n        String actualDecodedData = Decoder.getEncodedData(correctedBits);\n\n        // Verify result\n        assertEquals(expectedDecodedData, actualDecodedData, \"The decoded data should match the expected result.\");\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    @Test\n    public void getEncodedDataTest() {\n        // Assuming readCode and getCharacter are fully working methods.\n        // You would mock these if you don't want to perform an integration test.\n        \n        boolean[] correctedBits = new boolean[] {\n            // This is an example bit sequence which should be replaced by a real test case\n            true, false, true, false, // etc...\n        };\n\n        try {\n            String result = Decoder.getEncodedData(correctedBits);\n            // Assert the expected result against your function output\n            assertEquals(\"expected decoded string\", result);\n        } catch (FormatException e) {\n            fail(\"FormatException thrown: \" + e.getMessage());\n        }\n    }\n\n    @Test\n    public void getEncodedDataWithFormatExceptionTest() {\n        // Assuming the test should handle the case which throws FormatException.\n        \n        boolean[] correctedBitsForException = new boolean[] {\n            // This is an example bit sequence that should cause a FormatException\n            // Again, please replace this with a real bit sequence for a proper test case\n            true, false, true // etc...\n        };\n\n        assertThrows(FormatException.class, () -> {\n            Decoder.getEncodedData(correctedBitsForException);\n        });\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    \n    @Test\n    public void getEncodedDataTest() {\n        // Assuming we have a valid boolean array representing corrected bits\n        // and a string representing the expected result:\n        boolean[] correctedBits = {true, false, true, false, true, false, true, false, true, false};\n        String expectedResult = \"Encoded Data\";\n\n        // Since 'getEncodedData' is a private static method, we may have to use reflection to test it,\n        // or change its visibility to package-private or public for testing purposes.\n        \n        // If reflection is needed:\n        try {\n            // Get the method with reflection\n            java.lang.reflect.Method method = Decoder.class.getDeclaredMethod(\"getEncodedData\", boolean[].class);\n            method.setAccessible(true);\n            \n            // Invoke the method on a null instance because it is static\n            String result = (String) method.invoke(null, (Object) correctedBits);\n            \n            // Assert that the result is as expected\n            assertEquals(expectedResult, result);\n        } catch (Exception e) {\n            fail(\"Exception thrown during the test: \" + e.getMessage());\n        }\n        \n        // If the method visibility is changed for testing:\n        /*\n        try {\n            String result = Decoder.getEncodedData(correctedBits);\n            assertEquals(expectedResult, result);\n        } catch (FormatException e) {\n            fail(\"FormatException should not be thrown\");\n        }\n        */\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    \n    // A mock implementation of readCode to simulate reading bits from an array\n    // Note: readCode should be implemented or mocked appropriately for the test scenario.\n    private static int readCode(boolean[] rawbits, int startIndex, int length) {\n        // This is a mock implementation and should be modified to match the expected behavior\n        // For simplicity, let's assume it returns the number of \"true\" bits as the code\n        int count = 0;\n        for (int i = startIndex; i < startIndex + length && i < rawbits.length; i++) {\n            if (rawbits[i]) {\n                count++;\n            }\n        }\n        return count;\n    }\n    \n    @Test\n    public void getEncodedDataTest() {\n        // Set up a scenario with an array of correctedBits\n        boolean[] correctedBits =  { true, false, true, false, true, false, true, false };\n        \n        // Call the method under test\n        String result = null;\n        try {\n            result = Decoder.getEncodedData(correctedBits);\n        } catch (FormatException e) {\n            fail(\"FormatException was not expected.\");\n        }\n        \n        // Assert that the resulting string matches the expected decoded value\n        // The expected value should correspond to the actual implementation and expected output\n        // For this test, let's assume \"TEST\" is the expected result; this may vary in a real scenario\n        assertEquals(\"TEST\", result, \"The encoded data should match the expected output.\");\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.Test;\nimport com.google.zxing.FormatException;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        boolean[] correctedBits1 = new boolean[] {};  // Empty bit array for base case\n        String result1 = Decoder.getEncodedData(correctedBits1);\n        assertEquals(\"\", result1);\n\n        boolean[] correctedBits2 = { true, false, true, true, false, true, false, false, true, true, false, true}; // Example bit array\n        // Assuming specific implementation for readCode, getTable, getCharacter methods, and the result expected\n        String expectedResult2 = \"expectedResult\";  // Replace with the expected string result of the encoded bits\n        String result2 = Decoder.getEncodedData(correctedBits2);\n        assertEquals(expectedResult2, result2);\n\n        boolean[] correctedBits3 = { false, true, true, true, false, true, true, true, false, true }; // Bit array that throws FormatException\n        assertThrows(FormatException.class, () -> {\n            Decoder.getEncodedData(correctedBits3);\n        });\n        \n        // ... additional test cases including edge cases and instances where FormatException is expected\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.*;\nimport java.util.Arrays;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    @Test\n    public void getEncodedDataTest() throws FormatException {\n        // Given: using dummy data for the boolean array\n        boolean[] correctedBits = new boolean[]{true, false, true, false, true, true, true}; // replace with actual corrected data\n        \n        // When: encoding data - Exception expected for incorrect input\n        // Assumption: The getEncodedData method is made accessible for testing, or accessed via reflection.\n\n        // Then: verify proper handling of data\n        // This could throw a FormatException if the input is not correct as expected\n        Throwable exception = assertThrows(FormatException.class, () -> {\n            String result = Decoder.getEncodedData(correctedBits);\n            // If needed, this is where you could additionally check the result\n        });\n\n        // Optionally, if you expect a result, you could assert it as follows:\n        // String expected = \"ExpectedEncodedString\";\n        // String result = Decoder.getEncodedData(correctedBits);\n        // assertEquals(expected, result);\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    @Test\n    public void getEncodedDataTest() {\n        // Test case with a known binary sequence that should decode to a specific string\n        boolean[] correctedBitsForKnownString = {/* provide a specific binary sequence that decodes to a known string */};\n        String expectedOutputForKnownString = /* the expected decoded string */;\n        try {\n            String result = Decoder.getEncodedData(correctedBitsForKnownString);\n            assertEquals(expectedOutputForKnownString, result);\n        } catch (FormatException e) {\n            fail(\"FormatException should not have occurred for a valid input\");\n        }\n\n        // Test case where a FormatException is expected (e.g., FLG(7) which is reserved)\n        boolean[] correctedBitsForFormatException = {/* provide a specific binary sequence that triggers FormatException */};\n        assertThrows(FormatException.class, () -> {\n            Decoder.getEncodedData(correctedBitsForFormatException);\n        });\n\n        // You could add additional test cases to cover more paths, such as valid binary sequences that decode to various supported character sets and their expected outputs\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n\n    @Test\n    public void getEncodedDataTest() {\n        // Simplest case, expect an empty string on empty input\n        boolean[] correctedBitsEmpty = new boolean[0];\n        try {\n            String resultEmpty = Decoder.getEncodedData(correctedBitsEmpty);\n            assertEquals(\"\", resultEmpty, \"Encoded data should be an empty string.\");\n        } catch (FormatException e) {\n            fail(\"FormatException should not be thrown for empty input.\");\n        }\n\n        // Case with FLG(7) which should throw FormatException\n        // Assuming FLG(7) triggers when `readCode(correctedBits, index, 3)` returns 7\n        // and `getTable(char t)` is able to return a valid `Table` instance.\n        // Here the exact setup of the array `correctedBitsIllegalFLG` would be dependent on the implementation details\n        // of `readCode` and other related methods.\n        boolean[] correctedBitsIllegalFLG = {\n            // Assuming this array will be interpreted as having FLG(7) at the correct position\n            true, false, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>, <FILL>\n            // <FILL> with actual values to reflect FLG(7)\n        };\n        assertThrows(FormatException.class, () -> {\n            Decoder.getEncodedData(correctedBitsIllegalFLG);\n        }, \"FormatException should be thrown for FLG(7).\");\n\n        // Additional cases would be needed to test other parts of the functionality.\n        // They should setup correctedBits arrays to trigger different parts of the code and\n        // check for correct outputs and/or exceptions as appropriate.\n    }\n}",
        "package com.google.zxing.aztec.decoder;\n\nimport com.google.zxing.FormatException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class DecoderTest {\n    @Test\n    public void getEncodedDataTest() {\n        // the correctedBits array should represent a valid sequence of bits to decode\n        boolean[] correctedBits = { /* Fill this with the actual bit sequence for a test. \n                                       For example, this could represent the bits for the letters \"ABCD\" in Upper Table encoding. \n                                       The specific bits are not given in the context and thus will need to be supplied as part of the test setup. */ };\n\n        try {\n            // Act: decode the provided bits\n            String decodedData = Decoder.getEncodedData(correctedBits);\n\n            // Assert: Check that the method returns the correct decoded string\n            // Replace \"expectedResult\" with the actual expected result string based on the input correctedBits\n            String expectedResult = \"ABCD\"; // Replace with the actual expected result\n            assertEquals(expectedResult, decodedData);\n\n        } catch (FormatException e) {\n            // Assert: If a FormatException is expected, you can assert that here,\n            // or remove this catch block if a FormatException should not occur during this test.\n            fail(\"FormatException thrown during decoding: \" + e.getMessage());\n        }\n    }\n}"
    ]
}