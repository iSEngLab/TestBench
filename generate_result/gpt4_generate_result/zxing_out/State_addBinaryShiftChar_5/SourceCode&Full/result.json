{
    "project_name": "zxing",
    "file_name": "State.java",
    "relative_path": "zxing/core/src/main/java/com/google/zxing/aztec/encoder/State.java",
    "execute_path": "zxing",
    "package": "com.google.zxing.aztec.encoder",
    "docstring": null,
    "source_code": "// Create a new state representing this state, but an additional character\n// output in Binary Shift mode.\nState addBinaryShiftChar(int index) {\n  Token token = this.token;\n  int mode = this.mode;\n  int bitCount = this.bitCount;\n  if (this.mode == HighLevelEncoder.MODE_PUNCT || this.mode == HighLevelEncoder.MODE_DIGIT) {\n    int latch = HighLevelEncoder.LATCH_TABLE[mode][HighLevelEncoder.MODE_UPPER];\n    token = token.add(latch & 0xFFFF, latch >> 16);\n    bitCount += latch >> 16;\n    mode = HighLevelEncoder.MODE_UPPER;\n  }\n  int deltaBitCount =\n      (binaryShiftByteCount == 0 || binaryShiftByteCount == 31) ? 18 :\n      (binaryShiftByteCount == 62) ? 9 : 8;\n  State result = new State(token, mode, binaryShiftByteCount + 1, bitCount + deltaBitCount);\n  if (result.binaryShiftByteCount == 2047 + 31) {\n    // The string is as long as it's allowed to be.  We should end it.\n    result = result.endBinaryShift(index + 1);\n  }\n  return result;\n}\n",
    "class_name": "State",
    "method_name": "addBinaryShiftChar",
    "arguments": [
        "int index"
    ],
    "generate_test": [
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        // Start with the initial state\n        State initialState = State.INITIAL_STATE;\n        int index = 0;\n\n        // Add a binary shift character\n        State shiftedState = initialState.addBinaryShiftChar(index);\n\n        // Verify that the binary shift count has been incremented\n        assertEquals(1, shiftedState.getBinaryShiftByteCount(), \"Binary shift count should be incremented.\");\n\n        // Verify that the mode remains the same as the initial state\n        assertEquals(initialState.getMode(), shiftedState.getMode(), \"Mode should remain the same after binary shift.\");\n\n        // Test bit count increases correctly\n        int expectedBitCount = initialState.getBitCount();\n        expectedBitCount += (shiftedState.getBinaryShiftByteCount() == 1 || shiftedState.getBinaryShiftByteCount() == 31) ? 18 : 8;\n        assertEquals(expectedBitCount, shiftedState.getBitCount(), \"Bit count should increase correctly after binary shift.\");\n\n        // Test the logic when binary shift byte count hits the maximum allowed value (needs to end the binary shift)\n        for (int i = 1; i <= 2078; i++) {\n            shiftedState = shiftedState.addBinaryShiftChar(i);\n        }\n        assertNotEquals(2047 + 31, shiftedState.getBinaryShiftByteCount(), \"Binary shift should have ended when max length was exceeded.\");\n\n        // Now test that a call to addBinaryShiftChar correctly ends the binary shift mode\n        State nonShiftedState = shiftedState.addBinaryShiftChar(2079);\n        assertEquals(0, nonShiftedState.getBinaryShiftByteCount(), \"Binary shift byte count should reset to 0 when ended.\");\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        // Initialize a state in PUNCT mode with a certain binary shift byte count and bit count\n        State initialState = new State(Token.EMPTY, HighLevelEncoder.MODE_PUNCT, 10, 100);\n        int index = 5;\n\n        // Call addBinaryShiftChar on the initial state with the given index\n        State newState = initialState.addBinaryShiftChar(index);\n\n        // Since the initial mode is PUNCT and we have a binary shift byte count greater than 0,\n        // we expect a latch to UPPER mode followed by a binary shift for one extra byte.\n        // We need to calculate the expected bit count after this operation.\n        int expectedBinaryShiftByteCount = initialState.getBinaryShiftByteCount() + 1;\n        int expectedBitCount = initialState.getBitCount();\n        // The latch from PUNCT to UPPER has a constant size\n        int latchSize = HighLevelEncoder.LATCH_TABLE[HighLevelEncoder.MODE_PUNCT][HighLevelEncoder.MODE_UPPER] >> 16;\n        expectedBitCount += latchSize;\n        // Delta bit count based on the binary shift byte count\n        int deltaBitCount = expectedBinaryShiftByteCount == 31 ? 18 : 8;\n        expectedBitCount += deltaBitCount;\n\n        // Verify that the resulting state has the correct binary shift byte count and bit count\n        assertEquals(expectedBinaryShiftByteCount, newState.getBinaryShiftByteCount(), \"Binary shift byte count should be correct.\");\n        assertEquals(expectedBitCount, newState.getBitCount(), \"Bit count should be correct after adding a binary shift character.\");\n\n        // Handling the special case where the binary shift byte count reaches the allowed maximum\n        // In such case, we should end the binary shift.\n        if (expectedBinaryShiftByteCount == 2047 + 31) {\n            State maxedOutState = initialState.addBinaryShiftChar(2047);\n            State endBinaryShiftState = maxedOutState.endBinaryShift(index + 1);\n            assertEquals(0, endBinaryShiftState.getBinaryShiftByteCount(), \"Binary shift should end when the max byte count is reached.\");\n        }\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StateTest {\n\n    @Test\n    public void addBinaryShiftCharTest() {\n        State state = State.INITIAL_STATE;\n        \n        // Test binary shift for different index values\n        State shiftStateOne = state.addBinaryShiftChar(0);\n        State shiftStateTwo = state.addBinaryShiftChar(31);\n        State shiftStateThree = state.addBinaryShiftChar(62);\n        State shiftStateFour = state.addBinaryShiftChar(2078);  // index that triggers the maximum binaryShiftByteCount\n\n        // Assertions to verify the proper binary shift and mode changes\n        assertEquals(HighLevelEncoder.MODE_UPPER, shiftStateOne.getMode(), \"MODE_UPPER should be active after shifting\");\n        assertEquals(1, shiftStateOne.getBinaryShiftByteCount(), \"Binary shift byte count should be incremented\");\n        assertEquals(18, shiftStateOne.getBitCount(), \"Bit count should increase by 18 for the first or after 31 bytes shift\");\n\n        assertEquals(HighLevelEncoder.MODE_UPPER, shiftStateTwo.getMode(), \"MODE_UPPER should be active after shifting\");\n        assertEquals(32, shiftStateTwo.getBinaryShiftByteCount(), \"Binary shift byte count should be incremented to 32\");\n        assertEquals(18 * 2, shiftStateTwo.getBitCount(), \"Bit count should increase by 18 again for the 32nd byte shift\");\n\n        assertEquals(HighLevelEncoder.MODE_UPPER, shiftStateThree.getMode(), \"MODE_UPPER should be active after shifting\");\n        assertEquals(63, shiftStateThree.getBinaryShiftByteCount(), \"Binary shift byte count should be incremented to 63\");\n        assertEquals(18 * 2 + 9, shiftStateThree.getBitCount(), \"Bit count should increase by 9 for the 63rd byte shift\");\n\n        assertEquals(HighLevelEncoder.MODE_PUNCT, shiftStateFour.getMode(), \"MODE_PUNCT should be set after ending binary shift at upper limit\");\n        assertEquals(0, shiftStateFour.getBinaryShiftByteCount(), \"Binary shift byte count should be reset after reaching the maximum for binary shifts\");\n    }\n\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StateTest {\n\n    @Test\n    public void addBinaryShiftCharTest() {\n        // Setup initial state with mode = MODE_UPPER and an empty token\n        State initialState = State.INITIAL_STATE;\n\n        // Test adding binary shift character when binaryShiftByteCount is 0\n        State stateAfterFirstShift = initialState.addBinaryShiftChar(0);\n        assertEquals(18, stateAfterFirstShift.getBitCount(), \"Bit count should be 18 for first binary shift\");\n        assertEquals(1, stateAfterFirstShift.getBinaryShiftByteCount(), \"Binary shift byte count should be 1 for first binary shift\");\n\n        // Test adding another binary shift character (binaryShiftByteCount is 1, so bit count increase should be 8)\n        State stateAfterSecondShift = stateAfterFirstShift.addBinaryShiftChar(1);\n        assertEquals(26, stateAfterSecondShift.getBitCount(), \"Bit count should be 26 after second binary shift\");\n        assertEquals(2, stateAfterSecondShift.getBinaryShiftByteCount(), \"Binary shift byte count should be 2 after second binary shift\");\n\n        // Test adding a binary shift character when binaryShiftByteCount is 31 (causes 18 bit increase due to change in encoding)\n        for (int i = 2; i <= 31; i++) {\n            stateAfterSecondShift = stateAfterSecondShift.addBinaryShiftChar(i);\n        }\n        State stateAfterThirtyTwoShifts = stateAfterSecondShift.addBinaryShiftChar(31);\n        assertEquals(282, stateAfterThirtyTwoShifts.getBitCount(), \"Bit count should increase by 18 when binary shift byte count is 31\");\n        assertEquals(32, stateAfterThirtyTwoShifts.getBinaryShiftByteCount(), \"Binary shift byte count should be 32 after thirty-two shifts\");\n\n        // Test maximum binary shift count situation where binaryShiftByteCount is 62\n        for (int i = 31; i < 62; i++) {\n            stateAfterThirtyTwoShifts = stateAfterThirtyTwoShifts.addBinaryShiftChar(i);\n        }\n        State stateAfterSixtyThreeShifts = stateAfterThirtyTwoShifts.addBinaryShiftChar(62);\n        assertEquals(427, stateAfterSixtyThreeShifts.getBitCount(), \"Bit count should be 427 after sixty-three shifts (includes one 9 bit increase)\");\n        assertEquals(63, stateAfterSixtyThreeShifts.getBinaryShiftByteCount(), \"Binary shift byte count should be 63 after sixty-three shifts\");\n\n        // Test binary shift end behavior\n        State stateAfterEndShift = stateAfterSixtyThreeShifts.endBinaryShift(64);\n        assertEquals(427, stateAfterEndShift.getBitCount(), \"Bit count should remain the same after ending binary shift\");\n        assertEquals(0, stateAfterEndShift.getBinaryShiftByteCount(), \"Binary shift byte count should return to 0 after ending the shift\");\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        // Setup the initial state for the test, starting with the high-level encoder's initial state.\n        State initialState = State.INITIAL_STATE;\n        \n        // Invoke the addBinaryShiftChar method with a sample index.\n        int sampleIndex = 0;\n        State newState = initialState.addBinaryShiftChar(sampleIndex);\n        \n        // Verify the properties of the returned state.\n        // Since we're adding a binary shift character to an initial state, these values are based\n        // on the initial conditions defined in the State.INITIAL_STATE constant.\n        \n        // The mode should remain the same because we're not providing any indication to switch modes.\n        assertEquals(HighLevelEncoder.MODE_UPPER, newState.getMode());\n        \n        // The bitCount should be updated according to the deltaBitCount logic in the addBinaryShiftChar method.\n        int expectedBitCount = initialState.getBitCount() + \n            ((initialState.getBinaryShiftByteCount() == 0 || initialState.getBinaryShiftByteCount() == 31) \n                ? 18 : 8);\n        assertEquals(expectedBitCount, newState.getBitCount());\n        \n        // The binaryShiftByteCount should be incremented by one from the initialState.\n        int expectedBinaryShiftByteCount = initialState.getBinaryShiftByteCount() + 1;\n        assertEquals(expectedBinaryShiftByteCount, newState.getBinaryShiftByteCount());\n        \n        // Additionally, you can test edge cases, such as when the binary shift byte count reaches the maximum.\n        // In this test example, since we're starting from an initial state where the binary shift byte count is 0,\n        // we're not reaching the maximum and thus don't need to test that behavior here. \n        // However, additional tests should be written to cover that scenario.\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        // Initial state with UPPER mode\n        State state = State.INITIAL_STATE;\n        \n        // Verify the initial variables of the state\n        assertEquals(HighLevelEncoder.MODE_UPPER, state.getMode());\n        assertEquals(0, state.getBinaryShiftByteCount());\n        assertEquals(0, state.getBitCount());\n\n        // Apply binary shift on the first character\n        int bitCountAfterFirstShift = state.getBitCount() + 18; // Starting binary shift has bit count of 18\n        State shiftedState = state.addBinaryShiftChar(0);\n        \n        // Verify the state after applying binary shift\n        assertEquals(HighLevelEncoder.MODE_UPPER, shiftedState.getMode()); // Mode should still be UPPER after the shift\n        assertEquals(1, shiftedState.getBinaryShiftByteCount()); // Binary shift count should now be 1\n        assertEquals(bitCountAfterFirstShift, shiftedState.getBitCount()); // Verify the bit count after the shift\n\n        // Apply binary shift on the second character\n        int bitCountAfterSecondShift = shiftedState.getBitCount() + 8; // Subsequent binary shift has bit count of 8\n        State secondShiftedState = shiftedState.addBinaryShiftChar(1);\n        \n        // Verify the state after applying the second binary shift\n        assertEquals(HighLevelEncoder.MODE_UPPER, secondShiftedState.getMode()); // Mode should still be UPPER\n        assertEquals(2, secondShiftedState.getBinaryShiftByteCount()); // Binary shift count should now be 2\n        assertEquals(bitCountAfterSecondShift, secondShiftedState.getBitCount()); // Verify the bit count after the second shift\n\n        // Test adding the last possible binary shift character (at the 2047 + 31 boundary)\n        State boundaryState = new State(state.getToken(), state.getMode(), 2047, state.getBitCount());\n        State endShiftedState = boundaryState.addBinaryShiftChar(0);\n\n        // Verify behavior at the boundary of binary shift byte count limit\n        assertEquals(0, endShiftedState.getBinaryShiftByteCount()); // Binary shift should end\n        assertTrue(endShiftedState.getBitCount() > boundaryState.getBitCount()); // Bit count should still increase\n        // The given source doesn't allow us to validate the bit count accurately because endBinaryShift method is not completely shown. Assuming it handles boundary.\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        Token initialToken = Token.EMPTY;\n        int initialMode = HighLevelEncoder.MODE_UPPER;\n        int initialBinaryBytes = 0;\n        int initialBitCount = 0;\n        State initialState = new State(initialToken, initialMode, initialBinaryBytes, initialBitCount);\n\n        int index = 100; // Example index to input\n        State newState = initialState.addBinaryShiftChar(index);\n\n        // Test that mode has not changed\n        assertEquals(initialState.getMode(), newState.getMode(), \"The modes should be the same after adding Binary Shift Char.\");\n        // Test that binaryShiftByteCount is incremented\n        assertEquals(initialState.getBinaryShiftByteCount() + 1, newState.getBinaryShiftByteCount(), \"Binary Shift Byte Count should be incremented by 1.\");\n        // Check if additional bits for the character are added\n        int expectedAdditionalBits = (initialState.getBinaryShiftByteCount() == 0 || initialState.getBinaryShiftByteCount() == 31) ? 18 : 8;\n        assertEquals(initialState.getBitCount() + expectedAdditionalBits, newState.getBitCount(), \"Additional bits for binary shift character should be added to the total bit count.\");\n        // Test binaryShiftCost\n        int expectedBinaryShiftCost = State.calculateBinaryShiftCost(newState.getBinaryShiftByteCount());\n        // Test what happens when the binaryShiftByteCount would overflow it's allowed value\n        State overflowState = new State(initialToken, initialMode, 2047 + 31 - 1, initialBitCount).addBinaryShiftChar(index);\n        assertEquals(0, overflowState.getBinaryShiftByteCount(), \"Overflow should reset the binaryShiftByteCount.\");\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        // Setup: Create an initial State with default values\n        State initialState = State.INITIAL_STATE;\n        \n        // Act: Add a binary shift character to the state\n        int indexToAdd = 5; // example index for binary shift\n        State updatedState = initialState.addBinaryShiftChar(indexToAdd);\n        \n        // Assert: Check the results of adding binary shift character\n        assertEquals(HighLevelEncoder.MODE_UPPER, updatedState.getMode(), \"Mode should switch to UPPER mode after adding binary shift character from PUNCT or DIGIT.\");\n        assertEquals(initialState.getBinaryShiftByteCount() + 1, updatedState.getBinaryShiftByteCount(), \"Binary shift byte count should increment by 1.\");\n        \n        // Bit counts vary depending on the binary shift byte count thresholds, so test a range of conditions\n        if (initialState.getBinaryShiftByteCount() == 0 || initialState.getBinaryShiftByteCount() == 31) {\n            assertEquals(initialState.getBitCount() + 18, updatedState.getBitCount(), \"Bit count should increase by 18 for first or after 31st binary shift char.\");\n        } else if (initialState.getBinaryShiftByteCount() == 62) {\n            assertEquals(initialState.getBitCount() + 9, updatedState.getBitCount(), \"Bit count should increase by 9 after the 62nd binary shift char.\");\n        } else {\n            assertEquals(initialState.getBitCount() + 8, updatedState.getBitCount(), \"Bit count should increase by 8 for other binary shift chars.\");\n        }\n        \n        // When the binary shift byte count reaches its maximum limit (2047+31), the state should end the binary shift\n        if (updatedState.getBinaryShiftByteCount() == 2047 + 31) {\n            assertEquals(0, updatedState.getBinaryShiftByteCount(), \"Binary shift should end when reaching the limit.\");\n        }\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport org.junit.jupiter.api.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        State initialState = State.INITIAL_STATE;\n\n        // Test case where binaryShiftByteCount is 0 should yield a deltaBitCount of 18\n        State newState = initialState.addBinaryShiftChar(0);\n        assertEquals(HighLevelEncoder.MODE_UPPER, newState.getMode());\n        assertEquals(1, newState.getBinaryShiftByteCount());\n        assertEquals(18, newState.getBitCount());\n\n        // Test case where binaryShiftByteCount is 31 should yield a deltaBitCount of 18\n        State thirtyOneByteState = new State(Token.EMPTY, HighLevelEncoder.MODE_UPPER, 31, 0);\n        newState = thirtyOneByteState.addBinaryShiftChar(0);\n        assertEquals(HighLevelEncoder.MODE_UPPER, newState.getMode());\n        assertEquals(32, newState.getBinaryShiftByteCount());\n        assertEquals(18, newState.getBitCount());\n\n        // Test case where binaryShiftByteCount is 62 should yield a deltaBitCount of 9\n        State sixtyTwoByteState = new State(Token.EMPTY, HighLevelEncoder.MODE_UPPER, 62, 0);\n        newState = sixtyTwoByteState.addBinaryShiftChar(0);\n        assertEquals(HighLevelEncoder.MODE_UPPER, newState.getMode());\n        assertEquals(63, newState.getBinaryShiftByteCount());\n        assertEquals(9, newState.getBitCount());\n\n        // Test case where binaryShiftByteCount is 2037 (maximum allowed) should trigger endBinaryShift\n        State maxByteState = new State(Token.EMPTY, HighLevelEncoder.MODE_UPPER, 2047 + 31 - 1, 0);\n        newState = maxByteState.addBinaryShiftChar(0);\n        assertEquals(0, newState.getBinaryShiftByteCount()); // endBinaryShift resets the byte count to 0\n        assertTrue(newState.getBitCount() > 0); // Bit count should still be positive due to the binary shift\n\n        // Test cases where mode is not HighLevelEncoder.MODE_PUNCT or HighLevelEncoder.MODE_DIGIT\n        // should not change mode or add any bits associated with a mode change\n        State upperModeState = new State(Token.EMPTY, HighLevelEncoder.MODE_UPPER, 0, 0);\n        newState = upperModeState.addBinaryShiftChar(0);\n        assertEquals(HighLevelEncoder.MODE_UPPER, newState.getMode());\n        assertEquals(1, newState.getBinaryShiftByteCount());\n        assertEquals(18, newState.getBitCount());\n\n        State byteModeState = new State(Token.EMPTY, HighLevelEncoder.MODE_BYTE, 0, 0);\n        newState = byteModeState.addBinaryShiftChar(0);\n        assertEquals(HighLevelEncoder.MODE_BYTE, newState.getMode());\n        assertEquals(1, newState.getBinaryShiftByteCount());\n        assertEquals(18, newState.getBitCount());\n    }\n}",
        "package com.google.zxing.aztec.encoder;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class StateTest {\n    @Test\n    public void addBinaryShiftCharTest() {\n        State state = State.INITIAL_STATE;\n\n        // Ensure initial state is as expected\n        assertEquals(HighLevelEncoder.MODE_UPPER, state.getMode());\n        assertEquals(0, state.getBinaryShiftByteCount());\n        assertEquals(0, state.getBitCount());\n\n        // Adding first binary shift character\n        State shiftedState = state.addBinaryShiftChar(0);\n        assertEquals(HighLevelEncoder.MODE_UPPER, shiftedState.getMode());\n        assertEquals(1, shiftedState.getBinaryShiftByteCount());\n        assertEquals(18, shiftedState.getBitCount()); // Initial cost of 18 bits for the first character\n\n        // Adding another character; second binary shift should cost an additional 8 bits\n        shiftedState = shiftedState.addBinaryShiftChar(1);\n        assertEquals(2, shiftedState.getBinaryShiftByteCount());\n        assertEquals(26, shiftedState.getBitCount()); // 18 + 8 = 26\n\n        // Simulating addition of many binary shift characters to test the boundary at 31 characters\n        for (int i = 2; i <= 31; i++) {\n            shiftedState = shiftedState.addBinaryShiftChar(i);\n        }\n        assertEquals(31, shiftedState.getBinaryShiftByteCount());\n        // 18 for the first, plus 8 bits for each additional character\n        int expectedBitCount = 18 + (30 * 8);\n        assertEquals(expectedBitCount, shiftedState.getBitCount());\n        \n        // Adding the 32nd character triggers another binary shift cost (18 bits for the second shift sequence)\n        shiftedState = shiftedState.addBinaryShiftChar(31);\n        assertEquals(32, shiftedState.getBinaryShiftByteCount());\n        assertEquals(expectedBitCount + 18, shiftedState.getBitCount());\n        \n        // Continue to add characters until we reach a special case test where binary shifts cost 9 bits\n        for (int i = 32; i < 62; i++) {\n            shiftedState = shiftedState.addBinaryShiftChar(i);\n        }\n        assertEquals(62, shiftedState.getBinaryShiftByteCount());\n        // Account for the new sequence of binary shifts at index 31 which cost an additional 18 bits\n        expectedBitCount += (30 * 8) + 18;\n\n        // Add the 63rd character (binary shift count 62) which costs 9 bits instead of 8\n        shiftedState = shiftedState.addBinaryShiftChar(62);\n        assertEquals(63, shiftedState.getBinaryShiftByteCount());\n        assertEquals(expectedBitCount + 9, shiftedState.getBitCount());\n    }\n}"
    ]
}