[
    {
        "project_name": "Java",
        "file_name": "IIRFilter.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/audiofilters/IIRFilter.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.audiofilters",
        "docstring": "/**\n     * Process a single sample\n     *\n     * @param sample the sample to process\n     * @return the processed sample\n     */",
        "source_code": "\npublic double process(double sample) {\n    double result = 0.0;\n\n    // Process\n    for (int i = 1; i <= order; i++) {\n        result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);\n    }\n    result = (result + coeffsB[0] * sample) / coeffsA[0];\n\n    // Feedback\n    for (int i = order - 1; i > 0; i--) {\n        historyX[i] = historyX[i - 1];\n        historyY[i] = historyY[i - 1];\n    }\n\n    historyX[0] = sample;\n    historyY[0] = result;\n\n    return result;\n}\n",
        "class_name": "IIRFilter",
        "method_name": "process",
        "argument_name": [
            "double sample"
        ],
        "full_context": "package com.thealgorithms.audiofilters;\n\n/**\n * N-Order IIR Filter Assumes inputs are normalized to [-1, 1]\n *\n * Based on the difference equation from\n * <a href=\"https://en.wikipedia.org/wiki/Infinite_impulse_response\">Wikipedia link</a>\n */\npublic class IIRFilter {\n\n    private final int order;\n    private final double[] coeffsA;\n    private final double[] coeffsB;\n    private final double[] historyX;\n    private final double[] historyY;\n\n    /**\n     * Construct an IIR Filter\n     *\n     * @param order the filter's order\n     * @throws IllegalArgumentException if order is zero or less\n     */\n    public IIRFilter(int order) throws IllegalArgumentException {\n        if (order < 1) {\n            throw new IllegalArgumentException(\"order must be greater than zero\");\n        }\n\n        this.order = order;\n        coeffsA = new double[order + 1];\n        coeffsB = new double[order + 1];\n\n        // Sane defaults\n        coeffsA[0] = 1.0;\n        coeffsB[0] = 1.0;\n\n        historyX = new double[order];\n        historyY = new double[order];\n    }\n\n    /**\n     * Set coefficients\n     *\n     * @param aCoeffs Denominator coefficients\n     * @param bCoeffs Numerator coefficients\n     * @throws IllegalArgumentException if {@code aCoeffs} or {@code bCoeffs} is\n     * not of size {@code order}, or if {@code aCoeffs[0]} is 0.0\n     */\n    public void setCoeffs(double[] aCoeffs, double[] bCoeffs) throws IllegalArgumentException {\n        if (aCoeffs.length != order) {\n            throw new IllegalArgumentException(\"aCoeffs must be of size \" + order + \", got \" + aCoeffs.length);\n        }\n\n        if (aCoeffs[0] == 0.0) {\n            throw new IllegalArgumentException(\"aCoeffs.get(0) must not be zero\");\n        }\n\n        if (bCoeffs.length != order) {\n            throw new IllegalArgumentException(\"bCoeffs must be of size \" + order + \", got \" + bCoeffs.length);\n        }\n\n        for (int i = 0; i <= order; i++) {\n            coeffsA[i] = aCoeffs[i];\n            coeffsB[i] = bCoeffs[i];\n        }\n    }\n\n    /**\n     * Process a single sample\n     *\n     * @param sample the sample to process\n     * @return the processed sample\n     */\n    public double process(double sample) {\n        double result = 0.0;\n\n        // Process\n        for (int i = 1; i <= order; i++) {\n            result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);\n        }\n        result = (result + coeffsB[0] * sample) / coeffsA[0];\n\n        // Feedback\n        for (int i = order - 1; i > 0; i--) {\n            historyX[i] = historyX[i - 1];\n            historyY[i] = historyY[i - 1];\n        }\n\n        historyX[0] = sample;\n        historyY[0] = result;\n\n        return result;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.audiofilters;\n\npublic class IIRFilter {\n    final private int order;\n    final private double[] coeffsA;\n    final private double[] coeffsB;\n    final private double[] historyX;\n    final private double[] historyY;\n    public IIRFilter(int order);\n    public  setCoeffs(double[] aCoeffs, double[] bCoeffs)throws IllegalArgumentException;\n    public double process(double sample);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "ArrayCombination.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/ArrayCombination.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.backtracking",
        "docstring": "/**\n     * Find all combinations of 1..n by creating an array and using backtracking in Combination.java\n     * @param n max value of the array.\n     * @param k length of combination\n     * @return a list of all combinations of length k. If k == 0, return null.\n     */",
        "source_code": "\npublic static List<TreeSet<Integer>> combination(int n, int k) {\n    if (n <= 0) {\n        return null;\n    }\n    length = k;\n    Integer[] arr = new Integer[n];\n    for (int i = 1; i <= n; i++) {\n        arr[i - 1] = i;\n    }\n    return Combination.combination(arr, length);\n}\n",
        "class_name": "ArrayCombination",
        "method_name": "combination",
        "argument_name": [
            "int n",
            "int k"
        ],
        "full_context": "package com.thealgorithms.backtracking;\n\nimport java.util.*;\n\n/**\n * Finds all permutations of 1...n of length k\n * @author TheClerici (<a href=\"https://github.com/TheClerici\">git-TheClerici</a>)\n */\npublic class ArrayCombination {\n    private static int length;\n\n    /**\n     * Find all combinations of 1..n by creating an array and using backtracking in Combination.java\n     * @param n max value of the array.\n     * @param k length of combination\n     * @return a list of all combinations of length k. If k == 0, return null.\n     */\n    public static List<TreeSet<Integer>> combination(int n, int k) {\n        if (n <= 0) {\n            return null;\n        }\n        length = k;\n        Integer[] arr = new Integer[n];\n        for (int i = 1; i <= n; i++) {\n            arr[i - 1] = i;\n        }\n        return Combination.combination(arr, length);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.backtracking;\n\nimport java.util;\n\npublic class ArrayCombination {\n    static private int length;\n    static public List<TreeSet<Integer>> combination(int n, int k);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "FloodFill.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/FloodFill.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.backtracking",
        "docstring": "/**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */",
        "source_code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
        "class_name": "FloodFill",
        "method_name": "floodFill",
        "argument_name": [
            "int[][] image",
            "int x",
            "int y",
            "int newColor",
            "int oldColor"
        ],
        "full_context": "package com.thealgorithms.backtracking;\n\n/**\n * Java program for Flood fill algorithm.\n * @author Akshay Dubey (<a href=\"https://github.com/itsAkshayDubey\">Git-Akshay Dubey</a>)\n */\npublic final class FloodFill {\n    private FloodFill() {\n    }\n\n    /**\n     * Get the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate of which color is to be obtained\n     * @param y The y co-ordinate of which color is to be obtained\n     */\n\n    public static int getPixel(final int[][] image, final int x, final int y) {\n        return image[x][y];\n    }\n\n    /**\n     * Put the color at the given coordinates of a 2D image\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     */\n    public static void putPixel(final int[][] image, final int x, final int y, final int newColor) {\n        image[x][y] = newColor;\n    }\n\n    /**\n     * Fill the 2D image with new color\n     *\n     * @param image The image to be filled\n     * @param x The x co-ordinate at which color is to be filled\n     * @param y The y co-ordinate at which color is to be filled\n     * @param newColor The new color which to be filled in the image\n     * @param oldColor The old color which is to be replaced in the image\n     */\n    public static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n        if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n            return;\n        }\n\n        putPixel(image, x, y, newColor);\n\n        /* Recursively check for horizontally & vertically adjacent coordinates */\n        floodFill(image, x + 1, y, newColor, oldColor);\n        floodFill(image, x - 1, y, newColor, oldColor);\n        floodFill(image, x, y + 1, newColor, oldColor);\n        floodFill(image, x, y - 1, newColor, oldColor);\n\n        /* Recursively check for diagonally adjacent coordinates  */\n        floodFill(image, x + 1, y - 1, newColor, oldColor);\n        floodFill(image, x - 1, y + 1, newColor, oldColor);\n        floodFill(image, x + 1, y + 1, newColor, oldColor);\n        floodFill(image, x - 1, y - 1, newColor, oldColor);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.backtracking;\n\nfinal public class FloodFill {\n    private FloodFill();\n    static public int getPixel(int[][] image, int x, int y);\n    static public  putPixel(int[][] image, int x, int y, int newColor);\n    static public  floodFill(int[][] image, int x, int y, int newColor, int oldColor);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "MColoring.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MColoring.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.backtracking",
        "docstring": null,
        "source_code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
        "class_name": "MColoring",
        "method_name": "possiblePaint",
        "argument_name": [
            "ArrayList<Node> nodes",
            "int n",
            "int m"
        ],
        "full_context": "package com.thealgorithms.backtracking;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * @author Bama Charan Chhandogi (https://github.com/BamaCharanChhandogi)\n */\nclass Node {\n    int color = 1;\n    Set<Integer> edges = new HashSet<Integer>();\n}\n\npublic class MColoring {\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n        // Create a visited array of n nodes\n        ArrayList<Integer> visited = new ArrayList<Integer>();\n        for (int i = 0; i < n + 1; i++) {\n            visited.add(0);\n        }\n\n        // maxColors used till now are 1 as\n        // all nodes are painted color 1\n        int maxColors = 1;\n\n        for (int sv = 1; sv <= n; sv++) {\n            if (visited.get(sv) > 0) {\n                continue;\n            }\n\n            // If the starting point is unvisited,\n            // mark it visited and push it in queue\n            visited.set(sv, 1);\n            Queue<Integer> q = new LinkedList<>();\n            q.add(sv);\n\n            // BFS\n            while (q.size() != 0) {\n                int top = q.peek();\n                q.remove();\n\n                // Checking all adjacent nodes\n                // to \"top\" edge in our queue\n                for (int it : nodes.get(top).edges) {\n\n                    // If the color of the\n                    // adjacent node is same, increase it by\n                    // 1\n                    if (nodes.get(top).color == nodes.get(it).color) {\n                        nodes.get(it).color += 1;\n                    }\n\n                    // If number of colors used exceeds m,\n                    // return 0\n                    maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                    if (maxColors > m) return 0;\n\n                    // If the adjacent node is not visited,\n                    // mark it visited and push it in queue\n                    if (visited.get(it) == 0) {\n                        visited.set(it, 1);\n                        q.add(it);\n                    }\n                }\n            }\n        }\n        return 1;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.backtracking;\n\nimport java.io;\n\nimport java.util;\n\nclass Node {\n    int color;\n    Set<Integer> edges;\n}\n\npublic class MColoring {\n    static int possiblePaint(ArrayList<Node> nodes, int n, int m);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "MazeRecursion.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/backtracking/MazeRecursion.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.backtracking",
        "docstring": "/**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */",
        "source_code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
        "class_name": "MazeRecursion",
        "method_name": "setWay",
        "argument_name": [
            "int[][] map",
            "int i",
            "int j"
        ],
        "full_context": "package com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n\n    public static void mazeRecursion() {\n        // First create a 2 dimensions array to mimic a maze map\n        int[][] map = new int[8][7];\n        int[][] map2 = new int[8][7];\n\n        // We use 1 to indicate wall\n        // Set the ceiling and floor to 1\n        for (int i = 0; i < 7; i++) {\n            map[0][i] = 1;\n            map[7][i] = 1;\n        }\n\n        // Then we set the left and right wall to 1\n        for (int i = 0; i < 8; i++) {\n            map[i][0] = 1;\n            map[i][6] = 1;\n        }\n\n        // Now we have created a maze with its wall initialized\n\n        // Here we set the obstacle\n        map[3][1] = 1;\n        map[3][2] = 1;\n\n        // Print the current map\n        System.out.println(\"The condition of the map\uff1a \");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // clone another map for setWay2 method\n        for (int i = 0; i < map.length; i++) {\n            System.arraycopy(map[i], 0, map2[i], 0, map[i].length);\n        }\n\n        // By using recursive backtracking to let your ball(target) find its way in the\n        // maze\n        // The first parameter is the map\n        // Second parameter is x coordinate of your target\n        // Third parameter is the y coordinate of your target\n        setWay(map, 1, 1);\n        setWay2(map2, 1, 1);\n\n        // Print out the new map1, with the ball footprint\n        System.out.println(\"After the ball goes through the map1\uff0cshow the current map1 condition\");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        // Print out the new map2, with the ball footprint\n        System.out.println(\"After the ball goes through the map2\uff0cshow the current map2 condition\");\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 7; j++) {\n                System.out.print(map2[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    /**\n     * Using recursive path finding to help the ball find its way in the maze\n     * Description\uff1a\n     * 1. map (means the maze)\n     * 2. i, j (means the initial coordinate of the ball in the maze)\n     * 3. if the ball can reach the end of maze, that is position of map[6][5],\n     * means the we have found a path for the ball\n     * 4. Additional Information\uff1a 0 in the map[i][j] means the ball has not gone\n     * through this position, 1 means the wall, 2 means the path is feasible, 3\n     * means the ball has gone through the path but this path is dead end\n     * 5. We will need strategy for the ball to pass through the maze for example:\n     * Down -> Right -> Up -> Left, if the path doesn't work, then backtrack\n     *\n     * @author OngLipWei\n     * @version Jun 23, 2021 11:36:14 AM\n     * @param map The maze\n     * @param i   x coordinate of your ball(target)\n     * @param j   y coordinate of your ball(target)\n     * @return If we did find a path for the ball\uff0creturn true\uff0celse false\n     */\n    public static boolean setWay(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : down -> right -> up -> left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                           // first\u3002\n            if (setWay(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtracking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone though before,\n            // and cannot head to deadened.\n            return false;\n        }\n    }\n\n    // Here is another move strategy for the ball: up->right->down->left\n    public static boolean setWay2(int[][] map, int i, int j) {\n        if (map[6][5] == 2) { // means the ball find its path, ending condition\n            return true;\n        }\n        if (map[i][j] == 0) { // if the ball haven't gone through this point\n            // then the ball follows the move strategy : up->right->down->left\n            map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                           // first\u3002\n            if (setWay2(map, i - 1, j)) { // go up\n                return true;\n            } else if (setWay2(map, i, j + 1)) { // go right\n                return true;\n            } else if (setWay2(map, i + 1, j)) { // go down\n                return true;\n            } else if (setWay2(map, i, j - 1)) { // go left\n                return true;\n            } else {\n                // means that the current point is the dead end, the ball cannot proceed, set\n                // the current point to 3 and return false, the backtracking will start, it will\n                // go to the previous step and check for feasible path again\n                map[i][j] = 3;\n                return false;\n            }\n        } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n            // ball cannot hit the wall, cannot go to the path that has gone through before,\n            // and cannot head to deadend.\n            return false;\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.backtracking;\n\npublic class MazeRecursion {\n    static public  mazeRecursion();\n    static public boolean setWay(int[][] map, int i, int j);\n    static public boolean setWay2(int[][] map, int i, int j);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "BitSwap.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/bitmanipulation/BitSwap.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.bitmanipulation",
        "docstring": null,
        "source_code": "/*\n * @brief Swaps the bits at the position posA and posB from data\n */\npublic static int bitSwap(int data, final int posA, final int posB) {\n    if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n        data ^= (1 << posA) ^ (1 << posB);\n    }\n    return data;\n}\n",
        "class_name": "BitSwap",
        "method_name": "bitSwap",
        "argument_name": [
            "int data",
            "int posA",
            "int posB"
        ],
        "full_context": "package com.thealgorithms.bitmanipulation;\n\npublic final class BitSwap {\n    private BitSwap() {\n    }\n    /*\n     * @brief Swaps the bits at the position posA and posB from data\n     */\n    public static int bitSwap(int data, final int posA, final int posB) {\n        if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n            data ^= (1 << posA) ^ (1 << posB);\n        }\n        return data;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.bitmanipulation;\n\nfinal public class BitSwap {\n    private BitSwap();\n    static public int bitSwap(int data, int posA, int posB);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Caesar.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/ciphers/Caesar.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.ciphers",
        "docstring": "/**\n     * Decrypt message by shifting back every Latin char to previous the ASCII\n     * Example : B - 1 -> A\n     *\n     * @return message\n     */",
        "source_code": "\npublic String decode(String encryptedMessage, int shift) {\n    StringBuilder decoded = new StringBuilder();\n\n    shift %= 26;\n\n    final int length = encryptedMessage.length();\n    for (int i = 0; i < length; i++) {\n        char current = encryptedMessage.charAt(i);\n        if (isCapitalLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n        } else if (isSmallLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n        } else {\n            decoded.append(current);\n        }\n    }\n    return decoded.toString();\n}\n",
        "class_name": "Caesar",
        "method_name": "decode",
        "argument_name": [
            "String encryptedMessage",
            "int shift"
        ],
        "full_context": "package com.thealgorithms.ciphers;\n\n/**\n * A Java implementation of Caesar Cipher. /It is a type of substitution cipher\n * in which each letter in the plaintext is replaced by a letter some fixed\n * number of positions down the alphabet. /\n *\n * @author FAHRI YARDIMCI\n * @author khalil2535\n */\npublic class Caesar {\n\n    /**\n     * Encrypt text by shifting every Latin char by add number shift for ASCII\n     * Example : A + 1 -> B\n     *\n     * @return Encrypted message\n     */\n    public String encode(String message, int shift) {\n        StringBuilder encoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = message.length();\n        for (int i = 0; i < length; i++) {\n            //            int current = message.charAt(i); //using char to shift characters because\n            //            ascii\n            // is in-order latin alphabet\n            char current = message.charAt(i); // Java law : char + int = char\n\n            if (isCapitalLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'Z' ? current - 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current += shift;\n                encoded.append((char) (current > 'z' ? current - 26 : current)); // 26 = number of latin letters\n            } else {\n                encoded.append(current);\n            }\n        }\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by shifting back every Latin char to previous the ASCII\n     * Example : B - 1 -> A\n     *\n     * @return message\n     */\n    public String decode(String encryptedMessage, int shift) {\n        StringBuilder decoded = new StringBuilder();\n\n        shift %= 26;\n\n        final int length = encryptedMessage.length();\n        for (int i = 0; i < length; i++) {\n            char current = encryptedMessage.charAt(i);\n            if (isCapitalLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n            } else if (isSmallLatinLetter(current)) {\n                current -= shift;\n                decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n            } else {\n                decoded.append(current);\n            }\n        }\n        return decoded.toString();\n    }\n\n    /**\n     * @return true if character is capital Latin letter or false for others\n     */\n    private static boolean isCapitalLatinLetter(char c) {\n        return c >= 'A' && c <= 'Z';\n    }\n\n    /**\n     * @return true if character is small Latin letter or false for others\n     */\n    private static boolean isSmallLatinLetter(char c) {\n        return c >= 'a' && c <= 'z';\n    }\n\n    /**\n     *  @return string array which contains all the possible decoded combination.\n     */\n    public String[] bruteforce(String encryptedMessage) {\n        String[] listOfAllTheAnswers = new String[27];\n        for (int i = 0; i <= 26; i++) {\n            listOfAllTheAnswers[i] = decode(encryptedMessage, i);\n        }\n\n        return listOfAllTheAnswers;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.ciphers;\n\npublic class Caesar {\n    public String encode(String message, int shift);\n    public String decode(String encryptedMessage, int shift);\n    static private boolean isCapitalLatinLetter(char c);\n    static private boolean isSmallLatinLetter(char c);\n    public String bruteforce(String encryptedMessage);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "HillCipher.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/ciphers/HillCipher.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.ciphers",
        "docstring": null,
        "source_code": "// Determinant calculator\npublic static int determinant(int[][] a, int n) {\n    int det = 0, sign = 1, p = 0, q = 0;\n\n    if (n == 1) {\n        det = a[0][0];\n    } else {\n        int[][] b = new int[n - 1][n - 1];\n        for (int x = 0; x < n; x++) {\n            p = 0;\n            q = 0;\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (j != x) {\n                        b[p][q++] = a[i][j];\n                        if (q % (n - 1) == 0) {\n                            p++;\n                            q = 0;\n                        }\n                    }\n                }\n            }\n            det = det + a[0][x] * determinant(b, n - 1) * sign;\n            sign = -sign;\n        }\n    }\n    return det;\n}\n",
        "class_name": "HillCipher",
        "method_name": "determinant",
        "argument_name": [
            "int[][] a",
            "int n"
        ],
        "full_context": "package com.thealgorithms.ciphers;\n\nimport java.util.Scanner;\n\n/*\n * Java Implementation of Hill Cipher\n * Hill cipher is a polyalphabetic substitution cipher. Each letter is represented by a number\n * belonging to the set Z26 where A=0 , B=1, ..... Z=25. To encrypt a message, each block of n\n * letters (since matrix size is n x n) is multiplied by an invertible n \u00d7 n matrix, against\n * modulus 26. To decrypt the message, each block is multiplied by the inverse of the matrix used\n * for encryption. The cipher key and plaintext/ciphertext are user inputs.\n * @author Ojasva Jain\n */\npublic class HillCipher {\n\n    static Scanner userInput = new Scanner(System.in);\n\n    /* Following function encrypts the message\n     */\n    static void encrypt(String message) {\n        message = message.toUpperCase();\n        // Get key matrix\n        System.out.println(\"Enter key matrix size\");\n        int matrixSize = userInput.nextInt();\n        System.out.println(\"Enter Key/encryptionKey matrix \");\n        int[][] keyMatrix = new int[matrixSize][matrixSize];\n        for (int i = 0; i < matrixSize; i++) {\n            for (int j = 0; j < matrixSize; j++) {\n                keyMatrix[i][j] = userInput.nextInt();\n            }\n        }\n        // check if det = 0\n        validateDeterminant(keyMatrix, matrixSize);\n\n        int[][] messageVector = new int[matrixSize][1];\n        String CipherText = \"\";\n        int[][] cipherMatrix = new int[matrixSize][1];\n        int j = 0;\n        while (j < message.length()) {\n            for (int i = 0; i < matrixSize; i++) {\n                if (j >= message.length()) {\n                    messageVector[i][0] = 23;\n                } else {\n                    messageVector[i][0] = (message.charAt(j)) % 65;\n                }\n                System.out.println(messageVector[i][0]);\n                j++;\n            }\n            int x, i;\n            for (i = 0; i < matrixSize; i++) {\n                cipherMatrix[i][0] = 0;\n\n                for (x = 0; x < matrixSize; x++) {\n                    cipherMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];\n                }\n                System.out.println(cipherMatrix[i][0]);\n                cipherMatrix[i][0] = cipherMatrix[i][0] % 26;\n            }\n            for (i = 0; i < matrixSize; i++) {\n                CipherText += (char) (cipherMatrix[i][0] + 65);\n            }\n        }\n        System.out.println(\"Ciphertext: \" + CipherText);\n    }\n\n    // Following function decrypts a message\n    static void decrypt(String message) {\n        message = message.toUpperCase();\n        // Get key matrix\n        System.out.println(\"Enter key matrix size\");\n        int n = userInput.nextInt();\n        System.out.println(\"Enter inverseKey/decryptionKey matrix \");\n        int[][] keyMatrix = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                keyMatrix[i][j] = userInput.nextInt();\n            }\n        }\n        // check if det = 0\n        validateDeterminant(keyMatrix, n);\n\n        // solving for the required plaintext message\n        int[][] messageVector = new int[n][1];\n        String PlainText = \"\";\n        int[][] plainMatrix = new int[n][1];\n        int j = 0;\n        while (j < message.length()) {\n            for (int i = 0; i < n; i++) {\n                if (j >= message.length()) {\n                    messageVector[i][0] = 23;\n                } else {\n                    messageVector[i][0] = (message.charAt(j)) % 65;\n                }\n                System.out.println(messageVector[i][0]);\n                j++;\n            }\n            int x, i;\n            for (i = 0; i < n; i++) {\n                plainMatrix[i][0] = 0;\n\n                for (x = 0; x < n; x++) {\n                    plainMatrix[i][0] += keyMatrix[i][x] * messageVector[x][0];\n                }\n\n                plainMatrix[i][0] = plainMatrix[i][0] % 26;\n            }\n            for (i = 0; i < n; i++) {\n                PlainText += (char) (plainMatrix[i][0] + 65);\n            }\n        }\n        System.out.println(\"Plaintext: \" + PlainText);\n    }\n\n    // Determinant calculator\n    public static int determinant(int[][] a, int n) {\n        int det = 0, sign = 1, p = 0, q = 0;\n\n        if (n == 1) {\n            det = a[0][0];\n        } else {\n            int[][] b = new int[n - 1][n - 1];\n            for (int x = 0; x < n; x++) {\n                p = 0;\n                q = 0;\n                for (int i = 1; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        if (j != x) {\n                            b[p][q++] = a[i][j];\n                            if (q % (n - 1) == 0) {\n                                p++;\n                                q = 0;\n                            }\n                        }\n                    }\n                }\n                det = det + a[0][x] * determinant(b, n - 1) * sign;\n                sign = -sign;\n            }\n        }\n        return det;\n    }\n\n    // Function to implement Hill Cipher\n    static void hillCipher(String message) {\n        message.toUpperCase();\n        System.out.println(\"What do you want to process from the message?\");\n        System.out.println(\"Press 1: To Encrypt\");\n        System.out.println(\"Press 2: To Decrypt\");\n        short sc = userInput.nextShort();\n        if (sc == 1) {\n            encrypt(message);\n        } else if (sc == 2) {\n            decrypt(message);\n        } else {\n            System.out.println(\"Invalid input, program terminated.\");\n        }\n    }\n\n    static void validateDeterminant(int[][] keyMatrix, int n) {\n        if (determinant(keyMatrix, n) % 26 == 0) {\n            System.out.println(\"Invalid key, as determinant = 0. Program Terminated\");\n        }\n    }\n\n    // Driver code\n    public static void main(String[] args) {\n        // Get the message to be encrypted\n        System.out.println(\"Enter message\");\n        String message = userInput.nextLine();\n        hillCipher(message);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.ciphers;\n\nimport java.util.Scanner;\n\npublic class HillCipher {\n    static Scanner userInput;\n    static  encrypt(String message);\n    static  decrypt(String message);\n    static public int determinant(int[][] a, int n);\n    static  hillCipher(String message);\n    static  validateDeterminant(int[][] keyMatrix, int n);\n    static public  main(String args);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "SimpleSubstitutionCipher.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/ciphers/SimpleSubstitutionCipher.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.ciphers",
        "docstring": "/**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @return Encrypted message\n     */",
        "source_code": "\npublic static String encode(String message, String cipherSmall) {\n    StringBuilder encoded = new StringBuilder();\n\n    // This map is used to encode\n    Map<Character, Character> cipherMap = new HashMap<>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    // To handle Small and Capital letters\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n        cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n    }\n\n    for (int i = 0; i < message.length(); i++) {\n        if (Character.isAlphabetic(message.charAt(i))) {\n            encoded.append(cipherMap.get(message.charAt(i)));\n        } else {\n            encoded.append(message.charAt(i));\n        }\n    }\n\n    return encoded.toString();\n}\n",
        "class_name": "SimpleSubstitutionCipher",
        "method_name": "encode",
        "argument_name": [
            "String message",
            "String cipherSmall"
        ],
        "full_context": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n *\n * @author Hassan Elseoudy\n */\npublic class SimpleSubstitutionCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @return Encrypted message\n     */\n    public static String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @return message\n     */\n    public static String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n}\n",
        "simple_context": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\npublic class SimpleSubstitutionCipher {\n    static public String encode(String message, String cipherSmall);\n    static public String decode(String encryptedMessage, String cipherSmall);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "SimpleSubstitutionCipher.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/ciphers/SimpleSubstitutionCipher.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.ciphers",
        "docstring": "/**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @return message\n     */",
        "source_code": "\npublic static String decode(String encryptedMessage, String cipherSmall) {\n    StringBuilder decoded = new StringBuilder();\n\n    Map<Character, Character> cipherMap = new HashMap<>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n        cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n    }\n\n    for (int i = 0; i < encryptedMessage.length(); i++) {\n        if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n            decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n        } else {\n            decoded.append(encryptedMessage.charAt(i));\n        }\n    }\n\n    return decoded.toString();\n}\n",
        "class_name": "SimpleSubstitutionCipher",
        "method_name": "decode",
        "argument_name": [
            "String encryptedMessage",
            "String cipherSmall"
        ],
        "full_context": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many\n * hundreds of years (an excellent history is given in Simon Singhs 'the Code\n * Book'). It basically consists of substituting every plaintext character for a\n * different ciphertext character. It differs from the Caesar cipher in that the\n * cipher alphabet is not simply the alphabet shifted, it is completely jumbled.\n *\n * @author Hassan Elseoudy\n */\npublic class SimpleSubstitutionCipher {\n\n    /**\n     * Encrypt text by replacing each element with its opposite character.\n     *\n     * @return Encrypted message\n     */\n    public static String encode(String message, String cipherSmall) {\n        StringBuilder encoded = new StringBuilder();\n\n        // This map is used to encode\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        // To handle Small and Capital letters\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n            cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n        }\n\n        for (int i = 0; i < message.length(); i++) {\n            if (Character.isAlphabetic(message.charAt(i))) {\n                encoded.append(cipherMap.get(message.charAt(i)));\n            } else {\n                encoded.append(message.charAt(i));\n            }\n        }\n\n        return encoded.toString();\n    }\n\n    /**\n     * Decrypt message by replacing each element with its opposite character in\n     * cipher.\n     *\n     * @return message\n     */\n    public static String decode(String encryptedMessage, String cipherSmall) {\n        StringBuilder decoded = new StringBuilder();\n\n        Map<Character, Character> cipherMap = new HashMap<>();\n\n        char beginSmallLetter = 'a';\n        char beginCapitalLetter = 'A';\n\n        cipherSmall = cipherSmall.toLowerCase();\n        String cipherCapital = cipherSmall.toUpperCase();\n\n        for (int i = 0; i < cipherSmall.length(); i++) {\n            cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n            cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n        }\n\n        for (int i = 0; i < encryptedMessage.length(); i++) {\n            if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n                decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n            } else {\n                decoded.append(encryptedMessage.charAt(i));\n            }\n        }\n\n        return decoded.toString();\n    }\n}\n",
        "simple_context": "package com.thealgorithms.ciphers;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\npublic class SimpleSubstitutionCipher {\n    static public String encode(String message, String cipherSmall);\n    static public String decode(String encryptedMessage, String cipherSmall);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "DecimalToAnyBase.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/conversions/DecimalToAnyBase.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.conversions",
        "docstring": "/**\n     * This method produces a String value of any given input decimal in any\n     * base\n     *\n     * @param inp Decimal of which we need the value in base in String format\n     * @return string format of the converted value in the given base\n     */",
        "source_code": "\npublic static String convertToAnyBase(int inp, int base) {\n    ArrayList<Character> charArr = new ArrayList<>();\n\n    while (inp > 0) {\n        charArr.add(reVal(inp % base));\n        inp /= base;\n    }\n\n    StringBuilder str = new StringBuilder(charArr.size());\n\n    for (Character ch : charArr) {\n        str.append(ch);\n    }\n\n    return str.reverse().toString();\n}\n",
        "class_name": "DecimalToAnyBase",
        "method_name": "convertToAnyBase",
        "argument_name": [
            "int inp",
            "int base"
        ],
        "full_context": "package com.thealgorithms.conversions;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n/**\n * @author Varun Upadhyay (<a href=\"https://github.com/varunu28\">...</a>)\n */\n// Driver Program\npublic class DecimalToAnyBase {\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter the decimal input below: \");\n        int decInput = Integer.parseInt(br.readLine());\n        System.out.println();\n\n        System.out.println(\"Enter the base below: \");\n        int base = Integer.parseInt(br.readLine());\n        System.out.println();\n\n        System.out.println(\"Decimal Input\"\n            + \" is: \" + decInput);\n        System.out.println(\"Value of \" + decInput + \" in base \" + base + \" is: \" + convertToAnyBase(decInput, base));\n\n        br.close();\n    }\n\n    /**\n     * This method produces a String value of any given input decimal in any\n     * base\n     *\n     * @param inp Decimal of which we need the value in base in String format\n     * @return string format of the converted value in the given base\n     */\n    public static String convertToAnyBase(int inp, int base) {\n        ArrayList<Character> charArr = new ArrayList<>();\n\n        while (inp > 0) {\n            charArr.add(reVal(inp % base));\n            inp /= base;\n        }\n\n        StringBuilder str = new StringBuilder(charArr.size());\n\n        for (Character ch : charArr) {\n            str.append(ch);\n        }\n\n        return str.reverse().toString();\n    }\n\n    /**\n     * This method produces character value of the input integer and returns it\n     *\n     * @param num integer of which we need the character value of\n     * @return character value of input integer\n     */\n    public static char reVal(int num) {\n        if (num >= 0 && num <= 9) {\n            return (char) (num + '0');\n        } else {\n            return (char) (num - 10 + 'A');\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.conversions;\n\nimport java.io.BufferedReader;\n\nimport java.io.InputStreamReader;\n\nimport java.util.ArrayList;\n\npublic class DecimalToAnyBase {\n    static public  main(String args)throws Exception;\n    static public String convertToAnyBase(int inp, int base);\n    static public char reVal(int num);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "OctalToHexadecimal.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/conversions/OctalToHexadecimal.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.conversions",
        "docstring": "/**\n     * This method converts a Decimal number to a Hexadecimal number\n     *\n     * @param d The Decimal Number\n     * @return The Hexadecimal number\n     */",
        "source_code": "\npublic static String decimalToHex(int d) {\n    String digits = \"0123456789ABCDEF\";\n    if (d <= 0) {\n        return \"0\";\n    }\n    String hex = \"\";\n    while (d > 0) {\n        int digit = d % 16;\n        hex = digits.charAt(digit) + hex;\n        d = d / 16;\n    }\n    return hex;\n}\n",
        "class_name": "OctalToHexadecimal",
        "method_name": "decimalToHex",
        "argument_name": [
            "int d"
        ],
        "full_context": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\n/**\n * Converts any Octal Number to HexaDecimal\n *\n * @author Tanmay Joshi\n */\npublic class OctalToHexadecimal {\n\n    /**\n     * This method converts a Octal number to a decimal number\n     *\n     * @param s The Octal Number\n     * @return The Decimal number\n     */\n    public static int octToDec(String s) {\n        int i = 0;\n        for (int j = 0; j < s.length(); j++) {\n            char num = s.charAt(j);\n            num -= '0';\n            i *= 8;\n            i += num;\n        }\n        return i;\n    }\n\n    /**\n     * This method converts a Decimal number to a Hexadecimal number\n     *\n     * @param d The Decimal Number\n     * @return The Hexadecimal number\n     */\n    public static String decimalToHex(int d) {\n        String digits = \"0123456789ABCDEF\";\n        if (d <= 0) {\n            return \"0\";\n        }\n        String hex = \"\";\n        while (d > 0) {\n            int digit = d % 16;\n            hex = digits.charAt(digit) + hex;\n            d = d / 16;\n        }\n        return hex;\n    }\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.print(\"Enter the Octal number: \");\n        // Take octal number as input from user in a string\n        String oct = input.next();\n\n        // Pass the octal number to function and get converted decimal form\n        int decimal = octToDec(oct);\n\n        // Pass the decimal number to function and get converted Hex form of the number\n        String hex = decimalToHex(decimal);\n        System.out.println(\"The Hexadecimal equivalant is: \" + hex);\n        input.close();\n    }\n}\n",
        "simple_context": "package com.thealgorithms.conversions;\n\nimport java.util.Scanner;\n\npublic class OctalToHexadecimal {\n    static public int octToDec(String s);\n    static public String decimalToHex(int d);\n    static public  main(String args);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "AVLTree.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/AVLTree.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.trees",
        "docstring": null,
        "source_code": "private Node rotateLeft(Node a) {\n    Node b = a.right;\n    b.parent = a.parent;\n\n    a.right = b.left;\n\n    if (a.right != null) {\n        a.right.parent = a;\n    }\n\n    b.left = a;\n    a.parent = b;\n\n    if (b.parent != null) {\n        if (b.parent.right == a) {\n            b.parent.right = b;\n        } else {\n            b.parent.left = b;\n        }\n    }\n\n    setBalance(a, b);\n\n    return b;\n}\n",
        "class_name": "AVLTree",
        "method_name": "rotateLeft",
        "argument_name": [
            "Node a"
        ],
        "full_context": "package com.thealgorithms.datastructures.trees;\n\npublic class AVLTree {\n\n    private Node root;\n\n    private class Node {\n\n        private int key;\n        private int balance;\n        private int height;\n        private Node left, right, parent;\n\n        Node(int k, Node p) {\n            key = k;\n            parent = p;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null) {\n            root = new Node(key, null);\n        } else {\n            Node n = root;\n            Node parent;\n            while (true) {\n                if (n.key == key) {\n                    return false;\n                }\n\n                parent = n;\n\n                boolean goLeft = n.key > key;\n                n = goLeft ? n.left : n.right;\n\n                if (n == null) {\n                    if (goLeft) {\n                        parent.left = new Node(key, parent);\n                    } else {\n                        parent.right = new Node(key, parent);\n                    }\n                    rebalance(parent);\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void delete(Node node) {\n        if (node.left == null && node.right == null) {\n            if (node.parent == null) {\n                root = null;\n            } else {\n                Node parent = node.parent;\n                if (parent.left == node) {\n                    parent.left = null;\n                } else {\n                    parent.right = null;\n                }\n                rebalance(parent);\n            }\n            return;\n        }\n        Node child;\n        if (node.left != null) {\n            child = node.left;\n            while (child.right != null) {\n                child = child.right;\n            }\n        } else {\n            child = node.right;\n            while (child.left != null) {\n                child = child.left;\n            }\n        }\n        node.key = child.key;\n        delete(child);\n    }\n\n    public void delete(int delKey) {\n        if (root == null) {\n            return;\n        }\n        Node node = root;\n        Node child = root;\n\n        while (child != null) {\n            node = child;\n            child = delKey >= node.key ? node.right : node.left;\n            if (delKey == node.key) {\n                delete(node);\n                return;\n            }\n        }\n    }\n\n    private void rebalance(Node n) {\n        setBalance(n);\n\n        if (n.balance == -2) {\n            if (height(n.left.left) >= height(n.left.right)) {\n                n = rotateRight(n);\n            } else {\n                n = rotateLeftThenRight(n);\n            }\n        } else if (n.balance == 2) {\n            if (height(n.right.right) >= height(n.right.left)) {\n                n = rotateLeft(n);\n            } else {\n                n = rotateRightThenLeft(n);\n            }\n        }\n\n        if (n.parent != null) {\n            rebalance(n.parent);\n        } else {\n            root = n;\n        }\n    }\n\n    private Node rotateLeft(Node a) {\n        Node b = a.right;\n        b.parent = a.parent;\n\n        a.right = b.left;\n\n        if (a.right != null) {\n            a.right.parent = a;\n        }\n\n        b.left = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateRight(Node a) {\n        Node b = a.left;\n        b.parent = a.parent;\n\n        a.left = b.right;\n\n        if (a.left != null) {\n            a.left.parent = a;\n        }\n\n        b.right = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateLeftThenRight(Node n) {\n        n.left = rotateLeft(n.left);\n        return rotateRight(n);\n    }\n\n    private Node rotateRightThenLeft(Node n) {\n        n.right = rotateRight(n.right);\n        return rotateLeft(n);\n    }\n\n    private int height(Node n) {\n        if (n == null) {\n            return -1;\n        }\n        return n.height;\n    }\n\n    private void setBalance(Node... nodes) {\n        for (Node n : nodes) {\n            reheight(n);\n            n.balance = height(n.right) - height(n.left);\n        }\n    }\n\n    public void printBalance() {\n        printBalance(root);\n    }\n\n    private void printBalance(Node n) {\n        if (n != null) {\n            printBalance(n.left);\n            System.out.printf(\"%s \", n.balance);\n            printBalance(n.right);\n        }\n    }\n\n    private void reheight(Node node) {\n        if (node != null) {\n            node.height = 1 + Math.max(height(node.left), height(node.right));\n        }\n    }\n\n    public boolean search(int key) {\n        Node result = searchHelper(this.root, key);\n        return result != null;\n    }\n\n    private Node searchHelper(Node root, int key) {\n        // root is null or key is present at root\n        if (root == null || root.key == key) {\n            return root;\n        }\n\n        // key is greater than root's key\n        if (root.key > key) {\n            return searchHelper(root.left, key); // call the function on the node's left child\n        }\n        // key is less than root's key then\n        // call the function on the node's right child as it is greater\n        return searchHelper(root.right, key);\n    }\n\n    public static void main(String[] args) {\n        AVLTree tree = new AVLTree();\n\n        System.out.println(\"Inserting values 1 to 10\");\n        for (int i = 1; i < 10; i++) {\n            tree.insert(i);\n        }\n\n        System.out.print(\"Printing balance: \");\n        tree.printBalance();\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.trees;\n\npublic class AVLTree {\n    private Node root;\n    private class Node {\n        private int key;\n        private int balance;\n        private int height;\n        private Node left, right, parent;\n        Node(int k, Node p);\n    }\n    public boolean insert(int key);\n    private  delete(Node node);\n    public  delete(int delKey);\n    private  rebalance(Node n);\n    private Node rotateLeft(Node a);\n    private Node rotateRight(Node a);\n    private Node rotateLeftThenRight(Node n);\n    private Node rotateRightThenLeft(Node n);\n    private int height(Node n);\n    private  setBalance(Node nodes);\n    public  printBalance();\n    private  printBalance(Node n);\n    private  reheight(Node node);\n    public boolean search(int key);\n    private Node searchHelper(Node root, int key);\n    static public  main(String args);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "BinaryTree.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.trees",
        "docstring": "/**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */",
        "source_code": "\npublic Node find(int key) {\n    Node current = root;\n    while (current != null) {\n        if (key < current.data) {\n            if (current.left == null) {\n                return current; // The key isn't exist, returns the parent\n            }\n            current = current.left;\n        } else if (key > current.data) {\n            if (current.right == null) {\n                return current;\n            }\n            current = current.right;\n        } else { // If you find the value return it\n            return current;\n        }\n    }\n    return null;\n}\n",
        "class_name": "BinaryTree",
        "method_name": "find",
        "argument_name": [
            "int key"
        ],
        "full_context": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/*\n * This entire class is used to build a Binary Tree data structure. There is the\n * Node Class and the Tree Class, both explained below.\n */\n/**\n * A binary tree is a data structure in which an element has two\n * successors(children). The left child is usually smaller than the parent, and\n * the right child is usually bigger.\n *\n * @author Unknown\n */\npublic class BinaryTree {\n\n    /**\n     * This class implements the nodes that will go on the Binary Tree. They\n     * consist of the data in them, the node to the left, the node to the right,\n     * and the parent from which they came from.\n     *\n     * @author Unknown\n     */\n    static class Node {\n\n        /**\n         * Data for the node\n         */\n        public int data;\n        /**\n         * The Node to the left of this one\n         */\n        public Node left;\n        /**\n         * The Node to the right of this one\n         */\n        public Node right;\n        /**\n         * The parent of this node\n         */\n        public Node parent;\n\n        /**\n         * Constructor of Node\n         *\n         * @param value Value to put in the node\n         */\n        public Node(int value) {\n            data = value;\n            left = null;\n            right = null;\n            parent = null;\n        }\n    }\n\n    /**\n     * The root of the Binary Tree\n     */\n    private Node root;\n\n    /**\n     * Constructor\n     */\n    public BinaryTree() {\n        root = null;\n    }\n\n    /**\n     * Parameterized Constructor\n     */\n    public BinaryTree(Node root) {\n        this.root = root;\n    }\n\n    /**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */\n    public Node find(int key) {\n        Node current = root;\n        while (current != null) {\n            if (key < current.data) {\n                if (current.left == null) {\n                    return current; // The key isn't exist, returns the parent\n                }\n                current = current.left;\n            } else if (key > current.data) {\n                if (current.right == null) {\n                    return current;\n                }\n                current = current.right;\n            } else { // If you find the value return it\n                return current;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts certain value into the Binary Tree\n     *\n     * @param value Value to be inserted\n     */\n    public void put(int value) {\n        Node newNode = new Node(value);\n        if (root == null) {\n            root = newNode;\n        } else {\n            // This will return the soon to be parent of the value you're inserting\n            Node parent = find(value);\n\n            // This if/else assigns the new node to be either the left or right child of the parent\n            if (value < parent.data) {\n                parent.left = newNode;\n                parent.left.parent = parent;\n            } else {\n                parent.right = newNode;\n                parent.right.parent = parent;\n            }\n        }\n    }\n\n    /**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */\n    public boolean remove(int value) {\n        // temp is the node to be deleted\n        Node temp = find(value);\n\n        // If the value doesn't exist\n        if (temp.data != value) {\n            return false;\n        }\n\n        // No children\n        if (temp.right == null && temp.left == null) {\n            if (temp == root) {\n                root = null;\n            } // This if/else assigns the new node to be either the left or right child of the\n              // parent\n            else if (temp.parent.data < temp.data) {\n                temp.parent.right = null;\n            } else {\n                temp.parent.left = null;\n            }\n            return true;\n        } // Two children\n        else if (temp.left != null && temp.right != null) {\n            Node successor = findSuccessor(temp);\n\n            // The left tree of temp is made the left tree of the successor\n            successor.left = temp.left;\n            successor.left.parent = successor;\n\n            // If the successor has a right child, the child's grandparent is it's new parent\n            if (successor.parent != temp) {\n                if (successor.right != null) {\n                    successor.right.parent = successor.parent;\n                    successor.parent.left = successor.right;\n                } else {\n                    successor.parent.left = null;\n                }\n                successor.right = temp.right;\n                successor.right.parent = successor;\n            }\n\n            if (temp == root) {\n                successor.parent = null;\n                root = successor;\n            } // If you're not deleting the root\n            else {\n                successor.parent = temp.parent;\n\n                // This if/else assigns the new node to be either the left or right child of the\n                // parent\n                if (temp.parent.data < temp.data) {\n                    temp.parent.right = successor;\n                } else {\n                    temp.parent.left = successor;\n                }\n            }\n            return true;\n        } // One child\n        else {\n            // If it has a right child\n            if (temp.right != null) {\n                if (temp == root) {\n                    root = temp.right;\n                    return true;\n                }\n\n                temp.right.parent = temp.parent;\n\n                // Assigns temp to left or right child\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.right;\n                } else {\n                    temp.parent.right = temp.right;\n                }\n            } // If it has a left child\n            else {\n                if (temp == root) {\n                    root = temp.left;\n                    return true;\n                }\n\n                temp.left.parent = temp.parent;\n\n                // Assigns temp to left or right side\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.left;\n                } else {\n                    temp.parent.right = temp.left;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * This method finds the Successor to the Node given. Move right once and go\n     * left down the tree as far as you can\n     *\n     * @param n Node that you want to find the Successor of\n     * @return The Successor of the node\n     */\n    public Node findSuccessor(Node n) {\n        if (n.right == null) {\n            return n;\n        }\n        Node current = n.right;\n        Node parent = n.right;\n        while (current != null) {\n            parent = current;\n            current = current.left;\n        }\n        return parent;\n    }\n\n    /**\n     * Returns the root of the Binary Tree\n     *\n     * @return the root of the Binary Tree\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\n     * first search\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void inOrder(Node localRoot) {\n        if (localRoot != null) {\n            inOrder(localRoot.left);\n            System.out.print(localRoot.data + \" \");\n            inOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints root - leftChild - rightChild\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void preOrder(Node localRoot) {\n        if (localRoot != null) {\n            System.out.print(localRoot.data + \" \");\n            preOrder(localRoot.left);\n            preOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints rightChild - leftChild - root\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void postOrder(Node localRoot) {\n        if (localRoot != null) {\n            postOrder(localRoot.left);\n            postOrder(localRoot.right);\n            System.out.print(localRoot.data + \" \");\n        }\n    }\n\n    /**\n     * Prints the tree in a breadth first search order This is similar to\n     * pre-order traversal, but instead of being implemented with a stack (or\n     * recursion), it is implemented with a queue\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void bfs(Node localRoot) {\n        // Create a queue for the order of the nodes\n        Queue<Node> queue = new LinkedList<>();\n\n        // If the give root is null, then we don't add to the queue\n        // and won't do anything\n        if (localRoot != null) {\n            queue.add(localRoot);\n        }\n\n        // Continue until the queue is empty\n        while (!queue.isEmpty()) {\n            // Get the next node on the queue to visit\n            localRoot = queue.remove();\n\n            // Print the data from the node we are visiting\n            System.out.print(localRoot.data + \" \");\n\n            // Add the children to the queue if not null\n            if (localRoot.right != null) {\n                queue.add(localRoot.right);\n            }\n            if (localRoot.left != null) {\n                queue.add(localRoot.left);\n            }\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\npublic class BinaryTree {\n    static class Node {\n        public int data;\n        public Node left;\n        public Node right;\n        public Node parent;\n        public Node(int value);\n    }\n    private Node root;\n    public BinaryTree();\n    public BinaryTree(Node root);\n    public Node find(int key);\n    public  put(int value);\n    public boolean remove(int value);\n    public Node findSuccessor(Node n);\n    public Node getRoot();\n    public  inOrder(Node localRoot);\n    public  preOrder(Node localRoot);\n    public  postOrder(Node localRoot);\n    public  bfs(Node localRoot);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "BinaryTree.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.trees",
        "docstring": "/**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */",
        "source_code": "\npublic boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n\n            temp.right.parent = temp.parent;\n\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n\n            temp.left.parent = temp.parent;\n\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}\n",
        "class_name": "BinaryTree",
        "method_name": "remove",
        "argument_name": [
            "int value"
        ],
        "full_context": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/*\n * This entire class is used to build a Binary Tree data structure. There is the\n * Node Class and the Tree Class, both explained below.\n */\n/**\n * A binary tree is a data structure in which an element has two\n * successors(children). The left child is usually smaller than the parent, and\n * the right child is usually bigger.\n *\n * @author Unknown\n */\npublic class BinaryTree {\n\n    /**\n     * This class implements the nodes that will go on the Binary Tree. They\n     * consist of the data in them, the node to the left, the node to the right,\n     * and the parent from which they came from.\n     *\n     * @author Unknown\n     */\n    static class Node {\n\n        /**\n         * Data for the node\n         */\n        public int data;\n        /**\n         * The Node to the left of this one\n         */\n        public Node left;\n        /**\n         * The Node to the right of this one\n         */\n        public Node right;\n        /**\n         * The parent of this node\n         */\n        public Node parent;\n\n        /**\n         * Constructor of Node\n         *\n         * @param value Value to put in the node\n         */\n        public Node(int value) {\n            data = value;\n            left = null;\n            right = null;\n            parent = null;\n        }\n    }\n\n    /**\n     * The root of the Binary Tree\n     */\n    private Node root;\n\n    /**\n     * Constructor\n     */\n    public BinaryTree() {\n        root = null;\n    }\n\n    /**\n     * Parameterized Constructor\n     */\n    public BinaryTree(Node root) {\n        this.root = root;\n    }\n\n    /**\n     * Method to find a Node with a certain value\n     *\n     * @param key Value being looked for\n     * @return The node if it finds it, otherwise returns the parent\n     */\n    public Node find(int key) {\n        Node current = root;\n        while (current != null) {\n            if (key < current.data) {\n                if (current.left == null) {\n                    return current; // The key isn't exist, returns the parent\n                }\n                current = current.left;\n            } else if (key > current.data) {\n                if (current.right == null) {\n                    return current;\n                }\n                current = current.right;\n            } else { // If you find the value return it\n                return current;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Inserts certain value into the Binary Tree\n     *\n     * @param value Value to be inserted\n     */\n    public void put(int value) {\n        Node newNode = new Node(value);\n        if (root == null) {\n            root = newNode;\n        } else {\n            // This will return the soon to be parent of the value you're inserting\n            Node parent = find(value);\n\n            // This if/else assigns the new node to be either the left or right child of the parent\n            if (value < parent.data) {\n                parent.left = newNode;\n                parent.left.parent = parent;\n            } else {\n                parent.right = newNode;\n                parent.right.parent = parent;\n            }\n        }\n    }\n\n    /**\n     * Deletes a given value from the Binary Tree\n     *\n     * @param value Value to be deleted\n     * @return If the value was deleted\n     */\n    public boolean remove(int value) {\n        // temp is the node to be deleted\n        Node temp = find(value);\n\n        // If the value doesn't exist\n        if (temp.data != value) {\n            return false;\n        }\n\n        // No children\n        if (temp.right == null && temp.left == null) {\n            if (temp == root) {\n                root = null;\n            } // This if/else assigns the new node to be either the left or right child of the\n              // parent\n            else if (temp.parent.data < temp.data) {\n                temp.parent.right = null;\n            } else {\n                temp.parent.left = null;\n            }\n            return true;\n        } // Two children\n        else if (temp.left != null && temp.right != null) {\n            Node successor = findSuccessor(temp);\n\n            // The left tree of temp is made the left tree of the successor\n            successor.left = temp.left;\n            successor.left.parent = successor;\n\n            // If the successor has a right child, the child's grandparent is it's new parent\n            if (successor.parent != temp) {\n                if (successor.right != null) {\n                    successor.right.parent = successor.parent;\n                    successor.parent.left = successor.right;\n                } else {\n                    successor.parent.left = null;\n                }\n                successor.right = temp.right;\n                successor.right.parent = successor;\n            }\n\n            if (temp == root) {\n                successor.parent = null;\n                root = successor;\n            } // If you're not deleting the root\n            else {\n                successor.parent = temp.parent;\n\n                // This if/else assigns the new node to be either the left or right child of the\n                // parent\n                if (temp.parent.data < temp.data) {\n                    temp.parent.right = successor;\n                } else {\n                    temp.parent.left = successor;\n                }\n            }\n            return true;\n        } // One child\n        else {\n            // If it has a right child\n            if (temp.right != null) {\n                if (temp == root) {\n                    root = temp.right;\n                    return true;\n                }\n\n                temp.right.parent = temp.parent;\n\n                // Assigns temp to left or right child\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.right;\n                } else {\n                    temp.parent.right = temp.right;\n                }\n            } // If it has a left child\n            else {\n                if (temp == root) {\n                    root = temp.left;\n                    return true;\n                }\n\n                temp.left.parent = temp.parent;\n\n                // Assigns temp to left or right side\n                if (temp.data < temp.parent.data) {\n                    temp.parent.left = temp.left;\n                } else {\n                    temp.parent.right = temp.left;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * This method finds the Successor to the Node given. Move right once and go\n     * left down the tree as far as you can\n     *\n     * @param n Node that you want to find the Successor of\n     * @return The Successor of the node\n     */\n    public Node findSuccessor(Node n) {\n        if (n.right == null) {\n            return n;\n        }\n        Node current = n.right;\n        Node parent = n.right;\n        while (current != null) {\n            parent = current;\n            current = current.left;\n        }\n        return parent;\n    }\n\n    /**\n     * Returns the root of the Binary Tree\n     *\n     * @return the root of the Binary Tree\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\n     * first search\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void inOrder(Node localRoot) {\n        if (localRoot != null) {\n            inOrder(localRoot.left);\n            System.out.print(localRoot.data + \" \");\n            inOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints root - leftChild - rightChild\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void preOrder(Node localRoot) {\n        if (localRoot != null) {\n            System.out.print(localRoot.data + \" \");\n            preOrder(localRoot.left);\n            preOrder(localRoot.right);\n        }\n    }\n\n    /**\n     * Prints rightChild - leftChild - root\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void postOrder(Node localRoot) {\n        if (localRoot != null) {\n            postOrder(localRoot.left);\n            postOrder(localRoot.right);\n            System.out.print(localRoot.data + \" \");\n        }\n    }\n\n    /**\n     * Prints the tree in a breadth first search order This is similar to\n     * pre-order traversal, but instead of being implemented with a stack (or\n     * recursion), it is implemented with a queue\n     *\n     * @param localRoot The local root of the binary tree\n     */\n    public void bfs(Node localRoot) {\n        // Create a queue for the order of the nodes\n        Queue<Node> queue = new LinkedList<>();\n\n        // If the give root is null, then we don't add to the queue\n        // and won't do anything\n        if (localRoot != null) {\n            queue.add(localRoot);\n        }\n\n        // Continue until the queue is empty\n        while (!queue.isEmpty()) {\n            // Get the next node on the queue to visit\n            localRoot = queue.remove();\n\n            // Print the data from the node we are visiting\n            System.out.print(localRoot.data + \" \");\n\n            // Add the children to the queue if not null\n            if (localRoot.right != null) {\n                queue.add(localRoot.right);\n            }\n            if (localRoot.left != null) {\n                queue.add(localRoot.left);\n            }\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.trees;\n\nimport java.util.LinkedList;\n\nimport java.util.Queue;\n\npublic class BinaryTree {\n    static class Node {\n        public int data;\n        public Node left;\n        public Node right;\n        public Node parent;\n        public Node(int value);\n    }\n    private Node root;\n    public BinaryTree();\n    public BinaryTree(Node root);\n    public Node find(int key);\n    public  put(int value);\n    public boolean remove(int value);\n    public Node findSuccessor(Node n);\n    public Node getRoot();\n    public  inOrder(Node localRoot);\n    public  preOrder(Node localRoot);\n    public  postOrder(Node localRoot);\n    public  bfs(Node localRoot);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "SegmentTree.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/trees/SegmentTree.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.trees",
        "docstring": null,
        "source_code": "/* A function to get the sum of the elements from index l to index r. This will be called\n * internally*/\nprivate int getSumTree(int start, int end, int q_start, int q_end, int seg_index) {\n    if (q_start <= start && q_end >= end) {\n        return this.seg_t[seg_index];\n    }\n\n    if (q_start > end || q_end < start) {\n        return 0;\n    }\n\n    int mid = start + (end - start) / 2;\n    return (getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) + getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2));\n}\n",
        "class_name": "SegmentTree",
        "method_name": "getSumTree",
        "argument_name": [
            "int start",
            "int end",
            "int q_start",
            "int q_end",
            "int seg_index"
        ],
        "full_context": "package com.thealgorithms.datastructures.trees;\n\npublic class SegmentTree {\n\n    private int[] seg_t;\n    private int n;\n    private int[] arr;\n\n    /* Constructor which takes the size of the array and the array as a parameter*/\n    public SegmentTree(int n, int[] arr) {\n        this.n = n;\n        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));\n        int seg_size = 2 * (int) Math.pow(2, x) - 1;\n\n        this.seg_t = new int[seg_size];\n        this.arr = arr;\n        this.n = n;\n        constructTree(arr, 0, n - 1, 0);\n    }\n\n    /* A function which will create the segment tree*/\n    public int constructTree(int[] arr, int start, int end, int index) {\n        if (start == end) {\n            this.seg_t[index] = arr[start];\n            return arr[start];\n        }\n\n        int mid = start + (end - start) / 2;\n        this.seg_t[index] = constructTree(arr, start, mid, index * 2 + 1) + constructTree(arr, mid + 1, end, index * 2 + 2);\n        return this.seg_t[index];\n    }\n\n    /* A function which will update the value at a index i. This will be called by the\n    update function internally*/\n    private void updateTree(int start, int end, int index, int diff, int seg_index) {\n        if (index < start || index > end) {\n            return;\n        }\n\n        this.seg_t[seg_index] += diff;\n        if (start != end) {\n            int mid = start + (end - start) / 2;\n            updateTree(start, mid, index, diff, seg_index * 2 + 1);\n            updateTree(mid + 1, end, index, diff, seg_index * 2 + 2);\n        }\n    }\n\n    /* A function to update the value at a particular index*/\n    public void update(int index, int value) {\n        if (index < 0 || index > n) {\n            return;\n        }\n\n        int diff = value - arr[index];\n        arr[index] = value;\n        updateTree(0, n - 1, index, diff, 0);\n    }\n\n    /* A function to get the sum of the elements from index l to index r. This will be called\n     * internally*/\n    private int getSumTree(int start, int end, int q_start, int q_end, int seg_index) {\n        if (q_start <= start && q_end >= end) {\n            return this.seg_t[seg_index];\n        }\n\n        if (q_start > end || q_end < start) {\n            return 0;\n        }\n\n        int mid = start + (end - start) / 2;\n        return (getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) + getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2));\n    }\n\n    /* A function to query the sum of the subarray [start...end]*/\n    public int getSum(int start, int end) {\n        if (start < 0 || end > n || start > end) {\n            return 0;\n        }\n        return getSumTree(0, n - 1, start, end, 0);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.trees;\n\npublic class SegmentTree {\n    private int[] seg_t;\n    private int n;\n    private int[] arr;\n    public SegmentTree(int n, int[] arr);\n    public int constructTree(int[] arr, int start, int end, int index);\n    private  updateTree(int start, int end, int index, int diff, int seg_index);\n    public  update(int index, int value);\n    private int getSumTree(int start, int end, int q_start, int q_end, int seg_index);\n    public int getSum(int start, int end);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "CursorLinkedList.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/lists/CursorLinkedList.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.lists",
        "docstring": "/**\n     * @return the logical index of the element within the list , not the actual\n     * index of the [cursorSpace] array\n     */",
        "source_code": "\npublic int indexOf(T element) {\n    Objects.requireNonNull(element);\n    Node<T> iterator = cursorSpace[head];\n    for (int i = 0; i < count; i++) {\n        if (iterator.element.equals(element)) {\n            return i;\n        }\n        iterator = cursorSpace[iterator.next];\n    }\n\n    return -1;\n}\n",
        "class_name": "CursorLinkedList",
        "method_name": "indexOf",
        "argument_name": [
            "T element"
        ],
        "full_context": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Objects;\n\n/**\n * This class implements a Cursor Linked List.\n *\n * A CursorLinkedList is an array version of a Linked List. Essentially you have\n * an array of list nodes but instead of each node containing a pointer to the\n * next item in the linked list, each node element in the array contains the\n * index for the next node element.\n *\n */\npublic class CursorLinkedList<T> {\n\n    private static class Node<T> {\n\n        T element;\n        int next;\n\n        Node(T element, int next) {\n            this.element = element;\n            this.next = next;\n        }\n    }\n\n    private final int os;\n    private int head;\n    private final Node<T>[] cursorSpace;\n    private int count;\n    private static final int CURSOR_SPACE_SIZE = 100;\n\n    {\n        // init at loading time\n        cursorSpace = new Node[CURSOR_SPACE_SIZE];\n        for (int i = 0; i < CURSOR_SPACE_SIZE; i++) {\n            cursorSpace[i] = new Node<>(null, i + 1);\n        }\n        cursorSpace[CURSOR_SPACE_SIZE - 1].next = 0;\n    }\n\n    public CursorLinkedList() {\n        os = 0;\n        count = 0;\n        head = -1;\n    }\n\n    public void printList() {\n        if (head != -1) {\n            int start = head;\n            while (start != -1) {\n                T element = cursorSpace[start].element;\n                System.out.println(element.toString());\n                start = cursorSpace[start].next;\n            }\n        }\n    }\n\n    /**\n     * @return the logical index of the element within the list , not the actual\n     * index of the [cursorSpace] array\n     */\n    public int indexOf(T element) {\n        Objects.requireNonNull(element);\n        Node<T> iterator = cursorSpace[head];\n        for (int i = 0; i < count; i++) {\n            if (iterator.element.equals(element)) {\n                return i;\n            }\n            iterator = cursorSpace[iterator.next];\n        }\n\n        return -1;\n    }\n\n    /**\n     * @param position , the logical index of the element , not the actual one\n     * within the [cursorSpace] array . this method should be used to get the\n     * index give by indexOf() method.\n     * @return\n     */\n    public T get(int position) {\n        if (position >= 0 && position < count) {\n            int start = head;\n            int counter = 0;\n            while (start != -1) {\n                T element = cursorSpace[start].element;\n                if (counter == position) {\n                    return element;\n                }\n\n                start = cursorSpace[start].next;\n                counter++;\n            }\n        }\n\n        return null;\n    }\n\n    public void removeByIndex(int index) {\n        if (index >= 0 && index < count) {\n            T element = get(index);\n            remove(element);\n        }\n    }\n\n    public void remove(T element) {\n        Objects.requireNonNull(element);\n\n        // case element is in the head\n        T temp_element = cursorSpace[head].element;\n        int temp_next = cursorSpace[head].next;\n        if (temp_element.equals(element)) {\n            free(head);\n            head = temp_next;\n        } else { // otherwise cases\n            int prev_index = head;\n            int current_index = cursorSpace[prev_index].next;\n\n            while (current_index != -1) {\n                T current_element = cursorSpace[current_index].element;\n                if (current_element.equals(element)) {\n                    cursorSpace[prev_index].next = cursorSpace[current_index].next;\n                    free(current_index);\n                    break;\n                }\n\n                prev_index = current_index;\n                current_index = cursorSpace[prev_index].next;\n            }\n        }\n\n        count--;\n    }\n\n    private void free(int index) {\n        Node os_node = cursorSpace[os];\n        int os_next = os_node.next;\n        cursorSpace[os].next = index;\n        cursorSpace[index].element = null;\n        cursorSpace[index].next = os_next;\n    }\n\n    public void append(T element) {\n        Objects.requireNonNull(element);\n        int availableIndex = alloc();\n        cursorSpace[availableIndex].element = element;\n\n        if (head == -1) {\n            head = availableIndex;\n        }\n\n        int iterator = head;\n        while (cursorSpace[iterator].next != -1) {\n            iterator = cursorSpace[iterator].next;\n        }\n\n        cursorSpace[iterator].next = availableIndex;\n        cursorSpace[availableIndex].next = -1;\n\n        count++;\n    }\n\n    /**\n     * @return the index of the next available node\n     */\n    private int alloc() {\n        // 1- get the index at which the os is pointing\n        int availableNodeIndex = cursorSpace[os].next;\n\n        if (availableNodeIndex == 0) {\n            throw new OutOfMemoryError();\n        }\n\n        // 2- make the os point to the next of the  @var{availableNodeIndex}\n        cursorSpace[os].next = cursorSpace[availableNodeIndex].next;\n\n        // this to indicate an end of the list , helpful at testing since any err\n        // would throw an outOfBoundException\n        cursorSpace[availableNodeIndex].next = -1;\n\n        return availableNodeIndex;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Objects;\n\npublic class CursorLinkedList {\n    static private class Node {\n        T element;\n        int next;\n        Node(T element, int next);\n    }\n    final private int os;\n    private int head;\n    final private Node<T> cursorSpace;\n    private int count;\n    static final private int CURSOR_SPACE_SIZE;\n    public CursorLinkedList();\n    public  printList();\n    public int indexOf(T element);\n    public T get(int position);\n    public  removeByIndex(int index);\n    public  remove(T element);\n    private  free(int index);\n    public  append(T element);\n    private int alloc();\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "SinglyLinkedList.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/lists/SinglyLinkedList.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.lists",
        "docstring": "/**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */",
        "source_code": "\npublic Node middle() {\n    if (head == null) {\n        return null;\n    }\n    Node firstCounter = head;\n    Node secondCounter = firstCounter.next;\n    while (secondCounter != null && secondCounter.next != null) {\n        firstCounter = firstCounter.next;\n        secondCounter = secondCounter.next.next;\n    }\n    return firstCounter;\n}\n",
        "class_name": "SinglyLinkedList",
        "method_name": "middle",
        "argument_name": [],
        "full_context": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.StringJoiner;\n\n/**\n * https://en.wikipedia.org/wiki/Linked_list\n */\npublic class SinglyLinkedList implements Iterable<Integer> {\n\n    /**\n     * Head refer to the front of the list\n     */\n    private Node head;\n\n    /**\n     * Size of SinglyLinkedList\n     */\n    private int size;\n\n    /**\n     * Init SinglyLinkedList\n     */\n    public SinglyLinkedList() {\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Init SinglyLinkedList with specified head node and size\n     *\n     * @param head the head node of list\n     * @param size the size of list\n     */\n    public SinglyLinkedList(Node head, int size) {\n        this.head = head;\n        this.size = size;\n    }\n\n    /**\n     * Detects if there is a loop in the singly linked list using floy'd turtle\n     * and hare algorithm.\n     *\n     */\n    public boolean detectLoop() {\n        Node currentNodeFast = head;\n        Node currentNodeSlow = head;\n        while (currentNodeFast != null && currentNodeFast.next != null) {\n            currentNodeFast = currentNodeFast.next.next;\n            currentNodeSlow = currentNodeSlow.next;\n            if (currentNodeFast == currentNodeSlow) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return the node in the middle of the list\n     * If the length of the list is even then return item number length/2\n     * @return middle node of the list\n     */\n    public Node middle() {\n        if (head == null) {\n            return null;\n        }\n        Node firstCounter = head;\n        Node secondCounter = firstCounter.next;\n        while (secondCounter != null && secondCounter.next != null) {\n            firstCounter = firstCounter.next;\n            secondCounter = secondCounter.next.next;\n        }\n        return firstCounter;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n    public void swapNodes(int valueFirst, int valueSecond) {\n        if (valueFirst == valueSecond) {\n            return;\n        }\n        Node previousA = null, currentA = head;\n        while (currentA != null && currentA.value != valueFirst) {\n            previousA = currentA;\n            currentA = currentA.next;\n        }\n\n        Node previousB = null, currentB = head;\n        while (currentB != null && currentB.value != valueSecond) {\n            previousB = currentB;\n            currentB = currentB.next;\n        }\n        /** If either of 'a' or 'b' is not present, then return */\n        if (currentA == null || currentB == null) {\n            return;\n        }\n\n        // If 'a' is not head node of list\n        if (previousA != null) {\n            previousA.next = currentB;\n        } else {\n            // make 'b' as the new head\n            head = currentB;\n        }\n\n        // If 'b' is not head node of list\n        if (previousB != null) {\n            previousB.next = currentA;\n        } else {\n            // Make 'a' as new head\n            head = currentA;\n        }\n        // Swap next pointer\n\n        Node temp = currentA.next;\n        currentA.next = currentB.next;\n        currentB.next = temp;\n    }\n\n    /**\n     * Reverse a singly linked list[Iterative] from a given node till the end\n     *\n     */\n    public Node reverseListIter(Node node) {\n        Node prev = null;\n        Node curr = node;\n\n        while (curr != null && curr.next != null) {\n            Node next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        // when curr.next==null, the current element is left without pointing it to its prev,so\n        if (curr != null) {\n            curr.next = prev;\n            prev = curr;\n        }\n        // prev will be pointing to the last element in the Linkedlist, it will be the new head of\n        // the reversed linkedlist\n        return prev;\n    }\n    /**\n     * Reverse a singly linked list[Recursive] from a given node till the end\n     *\n     */\n    public Node reverseListRec(Node head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Node prev = null;\n        Node h2 = reverseListRec(head.next);\n\n        head.next.next = head;\n        head.next = prev;\n\n        return h2;\n    }\n\n    /**\n     * Clear all nodes in the list\n     */\n    public void clear() {\n        Node cur = head;\n        while (cur != null) {\n            cur = cur.next;\n        }\n        head = null;\n        size = 0;\n    }\n\n    /**\n     * Checks if the list is empty\n     *\n     * @return {@code true} if list is empty, otherwise {@code false}.\n     */\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    /**\n     * Returns the size of the linked list.\n     *\n     * @return the size of the list.\n     */\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Get head of the list.\n     *\n     * @return head of the list.\n     */\n    public Node getHead() {\n        return head;\n    }\n\n    /**\n     * Set head of the list.\n     *\n     */\n    public void setHead(Node head) {\n        this.head = head;\n    }\n\n    /**\n     * Calculate the count of the list manually\n     *\n     * @return count of the list\n     */\n    public int count() {\n        int count = 0;\n        for (final var element : this) {\n            ++count;\n        }\n        return count;\n    }\n\n    /**\n     * Test if the value key is present in the list.\n     *\n     * @param key the value to be searched.\n     * @return {@code true} if key is present in the list, otherwise\n     * {@code false}.\n     */\n    public boolean search(final int key) {\n        for (final var element : this) {\n            if (element == key) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString() {\n        StringJoiner joiner = new StringJoiner(\"->\");\n        for (final var element : this) {\n            joiner.add(element + \"\");\n        }\n        return joiner.toString();\n    }\n\n    public void deleteDuplicates() {\n        Node pred = head;\n        // predecessor = the node\n        // having sublist of its duplicates\n        Node newHead = head;\n        while (newHead != null) {\n            // if it's a beginning of duplicates sublist\n            // skip all duplicates\n            if (newHead.next != null && newHead.value == newHead.next.value) {\n                // move till the end of duplicates sublist\n                while (newHead.next != null && newHead.value == newHead.next.value) {\n                    newHead = newHead.next;\n                }\n                // skip all duplicates\n                pred.next = newHead.next;\n                newHead = null;\n                // otherwise, move predecessor\n            }\n            // move forward\n            pred = pred.next;\n            newHead = pred;\n        }\n    }\n\n    public void print() {\n        Node temp = head;\n        while (temp != null && temp.next != null) {\n            System.out.print(temp.value + \"->\");\n            temp = temp.next;\n        }\n        if (temp != null) {\n            System.out.print(temp.value);\n            System.out.println();\n        }\n    }\n\n    /**\n     * Inserts an element at the head of the list\n     *\n     * @param x element to be added\n     */\n    public void insertHead(int x) {\n        insertNth(x, 0);\n    }\n\n    /**\n     * Insert an element at the tail of the list\n     *\n     * @param data element to be added\n     */\n    public void insert(int data) {\n        insertNth(data, size);\n    }\n\n    /**\n     * Inserts a new node at a specified position of the list\n     *\n     * @param data data to be stored in a new node\n     * @param position position at which a new node is to be inserted\n     */\n    public void insertNth(int data, int position) {\n        checkBounds(position, 0, size);\n        Node newNode = new Node(data);\n        if (head == null) {\n            /* the list is empty */\n            head = newNode;\n            size++;\n            return;\n        }\n        if (position == 0) {\n            /* insert at the head of the list */\n            newNode.next = head;\n            head = newNode;\n            size++;\n            return;\n        }\n\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n        newNode.next = cur.next;\n        cur.next = newNode;\n        size++;\n    }\n\n    /**\n     * Swaps nodes of two given values a and b.\n     *\n     */\n\n    /**\n     * Deletes a node at the head\n     */\n    public void deleteHead() {\n        deleteNth(0);\n    }\n\n    /**\n     * Deletes an element at the tail\n     */\n    public void delete() {\n        deleteNth(size - 1);\n    }\n\n    /**\n     * Deletes an element at Nth position\n     */\n    public void deleteNth(int position) {\n        checkBounds(position, 0, size - 1);\n        if (position == 0) {\n            head = head.next;\n            /* clear to let GC do its work */\n            size--;\n            return;\n        }\n        Node cur = head;\n        for (int i = 0; i < position - 1; ++i) {\n            cur = cur.next;\n        }\n\n        cur.next = cur.next.next;\n        size--;\n    }\n\n    /**\n     * Return element at special index.\n     *\n     * @param index given index of element\n     * @return element at special index.\n     */\n    public int getNth(int index) {\n        checkBounds(index, 0, size - 1);\n        Node cur = head;\n        for (int i = 0; i < index; ++i) {\n            cur = cur.next;\n        }\n        return cur.value;\n    }\n\n    /**\n     * @param position to check position\n     * @param low low index\n     * @param high high index\n     * @throws IndexOutOfBoundsException if {@code position} not in range\n     * {@code low} to {@code high}\n     */\n    public void checkBounds(int position, int low, int high) {\n        if (position > high || position < low) {\n            throw new IndexOutOfBoundsException(position + \"\");\n        }\n    }\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] arg) {\n        SinglyLinkedList list = new SinglyLinkedList();\n        assert list.isEmpty();\n        assert list.size() == 0 && list.count() == 0;\n        assert list.toString().equals(\"\");\n\n        /* Test insert function */\n        list.insertHead(5);\n        list.insertHead(7);\n        list.insertHead(10);\n        list.insert(3);\n        list.insertNth(1, 4);\n        assert list.toString().equals(\"10->7->5->3->1\");\n        System.out.println(list);\n        /* Test search function */\n        assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n        /* Test get function */\n        assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n        /* Test delete function */\n        list.deleteHead();\n        list.deleteNth(1);\n        list.delete();\n        assert list.toString().equals(\"7->3\");\n        System.out.println(list);\n        assert list.size == 2 && list.size() == list.count();\n\n        list.clear();\n        assert list.isEmpty();\n\n        try {\n            list.delete();\n            assert false;\n            /* this should not happen */\n        } catch (Exception e) {\n            assert true;\n            /* this should happen */\n        }\n\n        SinglyLinkedList instance = new SinglyLinkedList();\n        Node head = new Node(0, new Node(2, new Node(3, new Node(3, new Node(4)))));\n        instance.setHead(head);\n        instance.deleteDuplicates();\n        instance.print();\n    }\n\n    @Override\n    public Iterator<Integer> iterator() {\n        return new SinglyLinkedListIterator();\n    }\n\n    private class SinglyLinkedListIterator implements Iterator<Integer> {\n        private Node current;\n\n        SinglyLinkedListIterator() {\n            current = head;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return current != null;\n        }\n\n        @Override\n        public Integer next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            final var value = current.value;\n            current = current.next;\n            return value;\n        }\n    }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and\n * a pointer to the node after them.\n */\nclass Node {\n\n    /**\n     * The value of the node\n     */\n    int value;\n\n    /**\n     * Point to the next node\n     */\n    Node next;\n\n    Node() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     */\n    Node(int value) {\n        this(value, null);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param value Value to be put in the node\n     * @param next Reference to the next node\n     */\n    Node(int value, Node next) {\n        this.value = value;\n        this.next = next;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.StringJoiner;\n\npublic class SinglyLinkedList implements Iterable<Integer> {\n    private Node head;\n    private int size;\n    public SinglyLinkedList();\n    public SinglyLinkedList(Node head, int size);\n    public boolean detectLoop();\n    public Node middle();\n    public  swapNodes(int valueFirst, int valueSecond);\n    public Node reverseListIter(Node node);\n    public Node reverseListRec(Node head);\n    public  clear();\n    public boolean isEmpty();\n    public int size();\n    public Node getHead();\n    public  setHead(Node head);\n    public int count();\n    public boolean search(int key);\n    public String toString();\n    public  deleteDuplicates();\n    public  print();\n    public  insertHead(int x);\n    public  insert(int data);\n    public  insertNth(int data, int position);\n    public  deleteHead();\n    public  delete();\n    public  deleteNth(int position);\n    public int getNth(int index);\n    public  checkBounds(int position, int low, int high);\n    static public  main(String arg);\n    public Iterator<Integer> iterator();\n    private class SinglyLinkedListIterator implements Iterator<Integer> {\n        private Node current;\n        SinglyLinkedListIterator();\n        public boolean hasNext();\n        public Integer next();\n    }\n}\n\nclass Node {\n    int value;\n    Node next;\n    Node();\n    Node(int value);\n    Node(int value, Node next);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Merge_K_SortedLinkedlist.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/lists/Merge_K_SortedLinkedlist.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.lists",
        "docstring": "/**\n     * This function merge K sorted LinkedList\n     *\n     * @param a array of LinkedList\n     * @param N size of array\n     * @return node\n     */",
        "source_code": "\nNode mergeKList(Node[] a, int N) {\n    // Min Heap\n    PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n\n    // adding head of all linkedList in min heap\n    min.addAll(Arrays.asList(a).subList(0, N));\n\n    // Make new head among smallest heads in K linkedList\n    Node head = min.poll();\n    min.add(head.next);\n    Node curr = head;\n\n    // merging LinkedList\n    while (!min.isEmpty()) {\n        Node temp = min.poll();\n        curr.next = temp;\n        curr = temp;\n\n        // Add Node in min Heap only if temp.next is not null\n        if (temp.next != null) {\n            min.add(temp.next);\n        }\n    }\n\n    return head;\n}\n",
        "class_name": "Merge_K_SortedLinkedlist",
        "method_name": "mergeKList",
        "argument_name": [
            "Node a",
            "int N"
        ],
        "full_context": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\n/**\n * @author Arun Pandey (https://github.com/pandeyarun709)\n */\npublic class Merge_K_SortedLinkedlist {\n\n    /**\n     * This function merge K sorted LinkedList\n     *\n     * @param a array of LinkedList\n     * @param N size of array\n     * @return node\n     */\n    Node mergeKList(Node[] a, int N) {\n        // Min Heap\n        PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n\n        // adding head of all linkedList in min heap\n        min.addAll(Arrays.asList(a).subList(0, N));\n\n        // Make new head among smallest heads in K linkedList\n        Node head = min.poll();\n        min.add(head.next);\n        Node curr = head;\n\n        // merging LinkedList\n        while (!min.isEmpty()) {\n            Node temp = min.poll();\n            curr.next = temp;\n            curr = temp;\n\n            // Add Node in min Heap only if temp.next is not null\n            if (temp.next != null) {\n                min.add(temp.next);\n            }\n        }\n\n        return head;\n    }\n\n    private class Node {\n\n        private int data;\n        private Node next;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.lists;\n\nimport java.util.Arrays;\n\nimport java.util.Comparator;\n\nimport java.util.PriorityQueue;\n\npublic class Merge_K_SortedLinkedlist {\n    Node mergeKList(Node a, int N);\n    private class Node {\n        private int data;\n        private Node next;\n    }\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "FibonacciHeap.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.heaps",
        "docstring": "/**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */",
        "source_code": "\npublic HeapNode insert(int key) {\n    HeapNode toInsert = new HeapNode(key); // creates the node\n    if (this.empty()) {\n        this.min = toInsert;\n    } else { // tree is not empty\n        min.setNext(toInsert);\n        this.updateMin(toInsert);\n    }\n    this.numOfHeapNodes++;\n    this.numOfTrees++;\n    return toInsert;\n}\n",
        "class_name": "FibonacciHeap",
        "method_name": "insert",
        "argument_name": [
            "int key"
        ],
        "full_context": "package com.thealgorithms.datastructures.heaps;\n\npublic class FibonacciHeap {\n\n    private static final double GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;\n    private HeapNode min;\n    private static int totalLinks = 0;\n    private static int totalCuts = 0;\n    private int numOfTrees = 0;\n    private int numOfHeapNodes = 0;\n    private int markedHeapNoodesCounter = 0;\n\n    /*\n     * a constructor for an empty Heap\n     * set the min to be null\n     */\n    public FibonacciHeap() {\n        this.min = null;\n    }\n\n    /*\n     * a constructor for a Heap with one element\n     * set the min to be the HeapNode with the given key\n     * @pre key>=0\n     * @post empty == false\n     */\n    public FibonacciHeap(int key) {\n        this.min = new HeapNode(key);\n        this.numOfTrees++;\n        this.numOfHeapNodes++;\n    }\n\n    /*\n     * check if the heap is empty\n     * $ret == true - if the tree is empty\n     */\n    public boolean empty() {\n        return (this.min == null);\n    }\n\n    /**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * @pre key>=0\n     * @post (numOfnodes = = $prev numOfnodes + 1)\n     * @post empty == false\n     * $ret = the HeapNode we inserted\n     */\n    public HeapNode insert(int key) {\n        HeapNode toInsert = new HeapNode(key); // creates the node\n        if (this.empty()) {\n            this.min = toInsert;\n        } else { // tree is not empty\n            min.setNext(toInsert);\n            this.updateMin(toInsert);\n        }\n        this.numOfHeapNodes++;\n        this.numOfTrees++;\n        return toInsert;\n    }\n\n    /**\n     * Delete the node containing the minimum key in the heap\n     * updates new min\n     *\n     * @post (numOfnodes = = $prev numOfnodes - 1)\n     */\n    public void deleteMin() {\n        if (this.empty()) {\n            return;\n        }\n        if (this.numOfHeapNodes == 1) { // if there is only one tree\n            this.min = null;\n            this.numOfTrees--;\n            this.numOfHeapNodes--;\n            return;\n        }\n        // change all children's parent to null//\n        if (this.min.child != null) { // min has a child\n            HeapNode child = this.min.child;\n            HeapNode tmpChild = child;\n            child.parent = null;\n            while (child.next != tmpChild) {\n                child = child.next;\n                child.parent = null;\n            }\n        }\n        // delete the node//\n        if (this.numOfTrees > 1) {\n            (this.min.prev).next = this.min.next;\n            (this.min.next).prev = this.min.prev;\n            if (this.min.child != null) {\n                (this.min.prev).setNext(this.min.child);\n            }\n        } else { // this.numOfTrees = 1\n            this.min = this.min.child;\n        }\n        this.numOfHeapNodes--;\n        this.successiveLink(this.min.getNext());\n    }\n\n    /**\n     * Return the node of the heap whose key is minimal.\n     * $ret == null if (empty==true)\n     */\n    public HeapNode findMin() {\n        return this.min;\n    }\n\n    /**\n     * Meld the heap with heap2\n     *\n     * @pre heap2 != null\n     * @post (numOfnodes = = $prev numOfnodes + heap2.numOfnodes)\n     */\n    public void meld(FibonacciHeap heap2) {\n        if (heap2.empty()) {\n            return;\n        }\n        if (this.empty()) {\n            this.min = heap2.min;\n        } else {\n            this.min.setNext(heap2.min);\n            this.updateMin(heap2.min);\n        }\n        this.numOfTrees += heap2.numOfTrees;\n        this.numOfHeapNodes += heap2.numOfHeapNodes;\n    }\n\n    /**\n     * Return the number of elements in the heap\n     * $ret == 0 if heap is empty\n     */\n    public int size() {\n        return this.numOfHeapNodes;\n    }\n\n    /**\n     * Return a counters array, where the value of the i-th index is the number of trees with rank i\n     * in the heap. returns an empty array for an empty heap\n     */\n    public int[] countersRep() {\n        if (this.empty()) {\n            return new int[0]; /// return an empty array\n        }\n        int[] rankArray = new int[(int) Math.floor(Math.log(this.size()) / Math.log(GOLDEN_RATIO)) + 1]; // creates the array\n        rankArray[this.min.rank]++;\n        HeapNode curr = this.min.next;\n        while (curr != this.min) {\n            rankArray[curr.rank]++;\n            curr = curr.next;\n        }\n        return rankArray;\n    }\n\n    /**\n     * Deletes the node x from the heap (using decreaseKey(x) to -1)\n     *\n     * @pre heap contains x\n     * @post (numOfnodes = = $prev numOfnodes - 1)\n     */\n    public void delete(HeapNode x) {\n        this.decreaseKey(x, x.getKey() + 1); // change key to be the minimal (-1)\n        this.deleteMin(); // delete it\n    }\n\n    /**\n     * The function decreases the key of the node x by delta.\n     *\n     * @pre x.key >= delta (we don't realize it when calling from delete())\n     * @pre heap contains x\n     */\n    private void decreaseKey(HeapNode x, int delta) {\n        int newKey = x.getKey() - delta;\n        x.key = newKey;\n        if (x.isRoot()) { // no parent to x\n            this.updateMin(x);\n            return;\n        }\n        if (x.getKey() >= x.parent.getKey()) {\n            return;\n        } // we don't need to cut\n        HeapNode prevParent = x.parent;\n        this.cut(x);\n        this.cascadingCuts(prevParent);\n    }\n\n    /**\n     * returns the current potential of the heap, which is:\n     * Potential = #trees + 2*#markedNodes\n     */\n    public int potential() {\n        return numOfTrees + (2 * markedHeapNoodesCounter);\n    }\n\n    /**\n     * This static function returns the total number of link operations made during the run-time of\n     * the program. A link operation is the operation which gets as input two trees of the same\n     * rank, and generates a tree of rank bigger by one.\n     */\n    public static int totalLinks() {\n        return totalLinks;\n    }\n\n    /**\n     * This static function returns the total number of cut operations made during the run-time of\n     * the program. A cut operation is the operation which disconnects a subtree from its parent\n     * (during decreaseKey/delete methods).\n     */\n    public static int totalCuts() {\n        return totalCuts;\n    }\n\n    /*\n     * updates the min of the heap (if needed)\n     * @pre this.min == @param (posMin) if and only if (posMin.key < this.min.key)\n     */\n    private void updateMin(HeapNode posMin) {\n        if (posMin.getKey() < this.min.getKey()) {\n            this.min = posMin;\n        }\n    }\n\n    /*\n     * Recursively \"runs\" all the way up from @param (curr) and mark the nodes.\n     * stop the recursion if we had arrived to a marked node or to a root.\n     * if we arrived to a marked node, we cut it and continue recursively.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */\n    private void cascadingCuts(HeapNode curr) {\n        if (!curr.isMarked()) { // stop the recursion\n            curr.mark();\n            if (!curr.isRoot()) this.markedHeapNoodesCounter++;\n        } else {\n            if (curr.isRoot()) {\n                return;\n            }\n            HeapNode prevParent = curr.parent;\n            this.cut(curr);\n            this.cascadingCuts(prevParent);\n        }\n    }\n\n    /*\n     * cut a node (and his \"subtree\") from his origin tree and connect it to the heap as a new tree.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */\n    private void cut(HeapNode curr) {\n        curr.parent.rank--;\n        if (curr.marked) {\n            this.markedHeapNoodesCounter--;\n            curr.marked = false;\n        }\n        if (curr.parent.child == curr) { // we should change the parent's child\n            if (curr.next == curr) { // curr do not have brothers\n                curr.parent.child = null;\n            } else { // curr have brothers\n                curr.parent.child = curr.next;\n            }\n        }\n        curr.prev.next = curr.next;\n        curr.next.prev = curr.prev;\n        curr.next = curr;\n        curr.prev = curr;\n        curr.parent = null;\n        this.min.setNext(curr);\n        this.updateMin(curr);\n        this.numOfTrees++;\n        totalCuts++;\n    }\n\n    /*\n     *\n     */\n    private void successiveLink(HeapNode curr) {\n        HeapNode[] buckets = this.toBuckets(curr);\n        this.min = this.fromBuckets(buckets);\n    }\n\n    /*\n     *\n     */\n    private HeapNode[] toBuckets(HeapNode curr) {\n        HeapNode[] buckets = new HeapNode[(int) Math.floor(Math.log(this.size()) / Math.log(GOLDEN_RATIO)) + 1];\n        curr.prev.next = null;\n        HeapNode tmpCurr;\n        while (curr != null) {\n            tmpCurr = curr;\n            curr = curr.next;\n            tmpCurr.next = tmpCurr;\n            tmpCurr.prev = tmpCurr;\n            while (buckets[tmpCurr.rank] != null) {\n                tmpCurr = this.link(tmpCurr, buckets[tmpCurr.rank]);\n                buckets[tmpCurr.rank - 1] = null;\n            }\n            buckets[tmpCurr.rank] = tmpCurr;\n        }\n        return buckets;\n    }\n\n    /*\n     *\n     */\n    private HeapNode fromBuckets(HeapNode[] buckets) {\n        HeapNode tmpMin = null;\n        this.numOfTrees = 0;\n        for (int i = 0; i < buckets.length; i++) {\n            if (buckets[i] != null) {\n                this.numOfTrees++;\n                if (tmpMin == null) {\n                    tmpMin = buckets[i];\n                    tmpMin.next = tmpMin;\n                    tmpMin.prev = tmpMin;\n                } else {\n                    tmpMin.setNext(buckets[i]);\n                    if (buckets[i].getKey() < tmpMin.getKey()) {\n                        tmpMin = buckets[i];\n                    }\n                }\n            }\n        }\n        return tmpMin;\n    }\n\n    /*\n     * link between two nodes (and their trees)\n     * defines the smaller node to be the parent\n     */\n    private HeapNode link(HeapNode c1, HeapNode c2) {\n        if (c1.getKey() > c2.getKey()) {\n            HeapNode c3 = c1;\n            c1 = c2;\n            c2 = c3;\n        }\n        if (c1.child == null) {\n            c1.child = c2;\n        } else {\n            c1.child.setNext(c2);\n        }\n        c2.parent = c1;\n        c1.rank++;\n        totalLinks++;\n        return c1;\n    }\n\n    /**\n     * public class HeapNode\n     * each HeapNode belongs to a heap (Inner class)\n     */\n    public class HeapNode {\n\n        public int key;\n        private int rank;\n        private boolean marked;\n        private HeapNode child;\n        private HeapNode next;\n        private HeapNode prev;\n        private HeapNode parent;\n\n        /*\n         * a constructor for a heapNode withe key @param (key)\n         * prev == next == this\n         * parent == child == null\n         */\n        public HeapNode(int key) {\n            this.key = key;\n            this.marked = false;\n            this.next = this;\n            this.prev = this;\n        }\n\n        /*\n         * returns the key of the node.\n         */\n        public int getKey() {\n            return this.key;\n        }\n\n        /*\n         * checks whether the node is marked\n         * $ret = true if one child has been cut\n         */\n        private boolean isMarked() {\n            return this.marked;\n        }\n\n        /*\n         * mark a node (after a child was cut)\n         * @inv root.mark() == false.\n         */\n        private void mark() {\n            if (this.isRoot()) {\n                return;\n            } // check if the node is a root\n            this.marked = true;\n        }\n\n        /*\n         * add the node @param (newNext) to be between this and this.next\n         * works fine also if @param (newNext) does not \"stands\" alone\n         */\n        private void setNext(HeapNode newNext) {\n            HeapNode tmpNext = this.next;\n            this.next = newNext;\n            this.next.prev.next = tmpNext;\n            tmpNext.prev = newNext.prev;\n            this.next.prev = this;\n        }\n\n        /*\n         * returns the next node to this node\n         */\n        private HeapNode getNext() {\n            return this.next;\n        }\n\n        /*\n         * check if the node is a root\n         * root definition - this.parent == null (uppest in his tree)\n         */\n        private boolean isRoot() {\n            return (this.parent == null);\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.heaps;\n\npublic class FibonacciHeap {\n    static final private double GOLDEN_RATIO;\n    private HeapNode min;\n    static private int totalLinks;\n    static private int totalCuts;\n    private int numOfTrees;\n    private int numOfHeapNodes;\n    private int markedHeapNoodesCounter;\n    public FibonacciHeap();\n    public FibonacciHeap(int key);\n    public boolean empty();\n    public HeapNode insert(int key);\n    public  deleteMin();\n    public HeapNode findMin();\n    public  meld(FibonacciHeap heap2);\n    public int size();\n    public int[] countersRep();\n    public  delete(HeapNode x);\n    private  decreaseKey(HeapNode x, int delta);\n    public int potential();\n    static public int totalLinks();\n    static public int totalCuts();\n    private  updateMin(HeapNode posMin);\n    private  cascadingCuts(HeapNode curr);\n    private  cut(HeapNode curr);\n    private  successiveLink(HeapNode curr);\n    private HeapNode toBuckets(HeapNode curr);\n    private HeapNode fromBuckets(HeapNode buckets);\n    private HeapNode link(HeapNode c1, HeapNode c2);\n    public class HeapNode {\n        public int key;\n        private int rank;\n        private boolean marked;\n        private HeapNode child;\n        private HeapNode next;\n        private HeapNode prev;\n        private HeapNode parent;\n        public HeapNode(int key);\n        public int getKey();\n        private boolean isMarked();\n        private  mark();\n        private  setNext(HeapNode newNext);\n        private HeapNode getNext();\n        private boolean isRoot();\n    }\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "ConnectedComponent.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/ConnectedComponent.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.graphs",
        "docstring": "/**\n     * Main method used for counting the connected components. Iterates through\n     * the array of nodes to do a depth first search to get all nodes of the\n     * graph from the actual node. These nodes are added to the array\n     * markedNodes and will be ignored if they are chosen in the nodeList.\n     *\n     * @return returns the amount of unconnected graphs\n     */",
        "source_code": "\npublic int countGraphs() {\n    int count = 0;\n    Set<Node> markedNodes = new HashSet<Node>();\n\n    for (Node n : nodeList) {\n        if (!markedNodes.contains(n)) {\n            markedNodes.add(n);\n            markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n            count++;\n        }\n    }\n\n    return count;\n}\n",
        "class_name": "Graph",
        "method_name": "countGraphs",
        "argument_name": [],
        "full_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A class that counts the number of different connected components in a graph\n *\n * @author Lukas Keul, Florian Mercks\n */\nclass Graph<E extends Comparable<E>> {\n\n    class Node {\n\n        E name;\n\n        public Node(E name) {\n            this.name = name;\n        }\n    }\n\n    class Edge {\n\n        Node startNode, endNode;\n\n        public Edge(Node startNode, Node endNode) {\n            this.startNode = startNode;\n            this.endNode = endNode;\n        }\n    }\n\n    ArrayList<Edge> edgeList;\n    ArrayList<Node> nodeList;\n\n    public Graph() {\n        edgeList = new ArrayList<Edge>();\n        nodeList = new ArrayList<Node>();\n    }\n\n    /**\n     * Adds a new Edge to the graph. If the nodes aren't yet in nodeList, they\n     * will be added to it.\n     *\n     * @param startNode the starting Node from the edge\n     * @param endNode the ending Node from the edge\n     */\n    public void addEdge(E startNode, E endNode) {\n        Node start = null, end = null;\n        for (Node node : nodeList) {\n            if (startNode.compareTo(node.name) == 0) {\n                start = node;\n            } else if (endNode.compareTo(node.name) == 0) {\n                end = node;\n            }\n        }\n        if (start == null) {\n            start = new Node(startNode);\n            nodeList.add(start);\n        }\n        if (end == null) {\n            end = new Node(endNode);\n            nodeList.add(end);\n        }\n\n        edgeList.add(new Edge(start, end));\n    }\n\n    /**\n     * Main method used for counting the connected components. Iterates through\n     * the array of nodes to do a depth first search to get all nodes of the\n     * graph from the actual node. These nodes are added to the array\n     * markedNodes and will be ignored if they are chosen in the nodeList.\n     *\n     * @return returns the amount of unconnected graphs\n     */\n    public int countGraphs() {\n        int count = 0;\n        Set<Node> markedNodes = new HashSet<Node>();\n\n        for (Node n : nodeList) {\n            if (!markedNodes.contains(n)) {\n                markedNodes.add(n);\n                markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    /**\n     * Implementation of depth first search.\n     *\n     * @param n the actual visiting node\n     * @param visited A list of already visited nodes in the depth first search\n     * @return returns a set of visited nodes\n     */\n    public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited) {\n        visited.add(n);\n        for (Edge e : edgeList) {\n            if (e.startNode.equals(n) && !visited.contains(e.endNode)) {\n                depthFirstSearch(e.endNode, visited);\n            }\n        }\n        return visited;\n    }\n}\n\npublic class ConnectedComponent {\n\n    public static void main(String[] args) {\n        Graph<Character> graphChars = new Graph<>();\n\n        // Graph 1\n        graphChars.addEdge('a', 'b');\n        graphChars.addEdge('a', 'e');\n        graphChars.addEdge('b', 'e');\n        graphChars.addEdge('b', 'c');\n        graphChars.addEdge('c', 'd');\n        graphChars.addEdge('d', 'a');\n\n        graphChars.addEdge('x', 'y');\n        graphChars.addEdge('x', 'z');\n\n        graphChars.addEdge('w', 'w');\n\n        Graph<Integer> graphInts = new Graph<>();\n\n        // Graph 2\n        graphInts.addEdge(1, 2);\n        graphInts.addEdge(2, 3);\n        graphInts.addEdge(2, 4);\n        graphInts.addEdge(3, 5);\n\n        graphInts.addEdge(7, 8);\n        graphInts.addEdge(8, 10);\n        graphInts.addEdge(10, 8);\n\n        System.out.println(\"Amount of different char-graphs: \" + graphChars.countGraphs());\n        System.out.println(\"Amount of different int-graphs: \" + graphInts.countGraphs());\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\n\nimport java.util.HashSet;\n\nimport java.util.Set;\n\nclass Graph {\n    class Node {\n        E name;\n        public Node(E name);\n    }\n    class Edge {\n        Node startNode, endNode;\n        public Edge(Node startNode, Node endNode);\n    }\n    ArrayList<Edge> edgeList;\n    ArrayList<Node> nodeList;\n    public Graph();\n    public  addEdge(E startNode, E endNode);\n    public int countGraphs();\n    public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited);\n}\n\npublic class ConnectedComponent {\n    static public  main(String args);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "KahnsAlgorithm.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/graphs/KahnsAlgorithm.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.graphs",
        "docstring": "/**\n     * Returns an ArrayList with vertices arranged in topological order\n     */",
        "source_code": "\nArrayList<E> topSortOrder() {\n    calculateInDegree();\n    Queue<E> q = new LinkedList<E>();\n\n    for (E vertex : inDegree.keySet()) {\n        if (inDegree.get(vertex) == 0) {\n            q.add(vertex);\n        }\n    }\n\n    ArrayList<E> answer = new ArrayList<>();\n\n    while (!q.isEmpty()) {\n        E current = q.poll();\n        answer.add(current);\n        for (E adjacent : graph.getAdjacents(current)) {\n            inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n            if (inDegree.get(adjacent) == 0) {\n                q.add(adjacent);\n            }\n        }\n    }\n\n    return answer;\n}\n",
        "class_name": "KahnsAlgorithm",
        "method_name": "topSortOrder",
        "argument_name": [],
        "full_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n * An algorithm that sorts a graph in toplogical order.\n */\n/**\n * A class that represents the adjaceny list of a graph\n */\nclass AdjacencyList<E extends Comparable<E>> {\n\n    Map<E, ArrayList<E>> adj;\n\n    AdjacencyList() {\n        adj = new LinkedHashMap<E, ArrayList<E>>();\n    }\n\n    /**\n     * This function adds an Edge to the adjaceny list\n     *\n     * @param from , the vertex the edge is from\n     * @param to, the vertex the edge is going to\n     */\n    void addEdge(E from, E to) {\n        try {\n            adj.get(from).add(to);\n        } catch (Exception E) {\n            adj.put(from, new ArrayList<E>());\n            adj.get(from).add(to);\n        }\n        if (!adj.containsKey(to)) {\n            adj.put(to, new ArrayList<E>());\n        }\n    }\n\n    /**\n     * @param v, A vertex in a graph\n     * @return returns an ArrayList of all the adjacents of vertex v\n     */\n    ArrayList<E> getAdjacents(E v) {\n        return adj.get(v);\n    }\n\n    /**\n     * @return returns a set of all vertices in the graph\n     */\n    Set<E> getVertices() {\n        return adj.keySet();\n    }\n\n    /**\n     * Prints the adjacency list\n     */\n    void printGraph() {\n        for (E vertex : adj.keySet()) {\n            System.out.print(vertex + \" : \");\n            for (E adjacent : adj.get(vertex)) {\n                System.out.print(adjacent + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n\nclass TopologicalSort<E extends Comparable<E>> {\n\n    AdjacencyList<E> graph;\n    Map<E, Integer> inDegree;\n\n    TopologicalSort(AdjacencyList<E> graph) {\n        this.graph = graph;\n    }\n\n    /**\n     * Calculates the in degree of all vertices\n     */\n    void calculateInDegree() {\n        inDegree = new HashMap<>();\n        for (E vertex : graph.getVertices()) {\n            if (!inDegree.containsKey(vertex)) {\n                inDegree.put(vertex, 0);\n            }\n            for (E adjacent : graph.getAdjacents(vertex)) {\n                try {\n                    inDegree.put(adjacent, inDegree.get(adjacent) + 1);\n                } catch (Exception e) {\n                    inDegree.put(adjacent, 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns an ArrayList with vertices arranged in topological order\n     */\n    ArrayList<E> topSortOrder() {\n        calculateInDegree();\n        Queue<E> q = new LinkedList<E>();\n\n        for (E vertex : inDegree.keySet()) {\n            if (inDegree.get(vertex) == 0) {\n                q.add(vertex);\n            }\n        }\n\n        ArrayList<E> answer = new ArrayList<>();\n\n        while (!q.isEmpty()) {\n            E current = q.poll();\n            answer.add(current);\n            for (E adjacent : graph.getAdjacents(current)) {\n                inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n                if (inDegree.get(adjacent) == 0) {\n                    q.add(adjacent);\n                }\n            }\n        }\n\n        return answer;\n    }\n}\n\n/**\n * A driver class that sorts a given graph in topological order.\n */\npublic class KahnsAlgorithm {\n\n    public static void main(String[] args) {\n        // Graph definition and initialization\n        AdjacencyList<String> graph = new AdjacencyList<>();\n        graph.addEdge(\"a\", \"b\");\n        graph.addEdge(\"c\", \"a\");\n        graph.addEdge(\"a\", \"d\");\n        graph.addEdge(\"b\", \"d\");\n        graph.addEdge(\"c\", \"u\");\n        graph.addEdge(\"u\", \"b\");\n\n        TopologicalSort<String> topSort = new TopologicalSort<>(graph);\n\n        // Printing the order\n        for (String s : topSort.topSortOrder()) {\n            System.out.print(s + \" \");\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.graphs;\n\nimport java.util.ArrayList;\n\nimport java.util.HashMap;\n\nimport java.util.LinkedHashMap;\n\nimport java.util.LinkedList;\n\nimport java.util.Map;\n\nimport java.util.Queue;\n\nimport java.util.Set;\n\nclass AdjacencyList {\n    Map<E, ArrayList<E>> adj;\n    AdjacencyList();\n     addEdge(E from, E to);\n    ArrayList<E> getAdjacents(E v);\n    Set<E> getVertices();\n     printGraph();\n}\n\nclass TopologicalSort {\n    AdjacencyList<E> graph;\n    Map<E, Integer> inDegree;\n    TopologicalSort(AdjacencyList<E> graph);\n     calculateInDegree();\n    ArrayList<E> topSortOrder();\n}\n\npublic class KahnsAlgorithm {\n    static public  main(String args);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "NodeStack.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/stacks/NodeStack.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.stacks",
        "docstring": "/**\n     * Put a value onto the stack.\n     *\n     * @param item : value to be put on the stack.\n     */",
        "source_code": "\npublic void push(Item item) {\n    NodeStack<Item> newNs = new NodeStack<Item>(item);\n\n    if (this.isEmpty()) {\n        NodeStack.setHead(new NodeStack<>(item));\n        newNs.setNext(null);\n        newNs.setPrevious(null);\n    } else {\n        newNs.setPrevious(NodeStack.head);\n        NodeStack.head.setNext(newNs);\n        NodeStack.setHead(newNs);\n    }\n\n    NodeStack.setSize(NodeStack.getSize() + 1);\n}\n",
        "class_name": "NodeStack",
        "method_name": "push",
        "argument_name": [
            "Item item"
        ],
        "full_context": "package com.thealgorithms.datastructures.stacks;\n\n/**\n * Implementation of a stack using nodes. Unlimited size, no arraylist.\n *\n * @author Kyler Smith, 2017\n */\npublic class NodeStack<Item> {\n\n    /**\n     * Entry point for the program.\n     */\n    public static void main(String[] args) {\n        NodeStack<Integer> Stack = new NodeStack<Integer>();\n\n        Stack.push(3);\n        Stack.push(4);\n        Stack.push(5);\n        System.out.println(\"Testing :\");\n        Stack.print(); // prints : 5 4 3\n\n        Integer x = Stack.pop(); // x = 5\n        Stack.push(1);\n        Stack.push(8);\n        Integer y = Stack.peek(); // y = 8\n        System.out.println(\"Testing :\");\n        Stack.print(); // prints : 8 1 4 3\n\n        System.out.println(\"Testing :\");\n        System.out.println(\"x : \" + x);\n        System.out.println(\"y : \" + y);\n    }\n\n    /**\n     * Information each node should contain.\n     *\n     * @value data : information of the value in the node\n     * @value head : the head of the stack\n     * @value next : the next value from this node\n     * @value previous : the last value from this node\n     * @value size : size of the stack\n     */\n    private Item data;\n\n    private static NodeStack<?> head;\n    private NodeStack<?> previous;\n    private static int size = 0;\n\n    /**\n     * Constructors for the NodeStack.\n     */\n    public NodeStack() {\n    }\n\n    private NodeStack(Item item) {\n        this.data = item;\n    }\n\n    /**\n     * Put a value onto the stack.\n     *\n     * @param item : value to be put on the stack.\n     */\n    public void push(Item item) {\n        NodeStack<Item> newNs = new NodeStack<Item>(item);\n\n        if (this.isEmpty()) {\n            NodeStack.setHead(new NodeStack<>(item));\n            newNs.setNext(null);\n            newNs.setPrevious(null);\n        } else {\n            newNs.setPrevious(NodeStack.head);\n            NodeStack.head.setNext(newNs);\n            NodeStack.setHead(newNs);\n        }\n\n        NodeStack.setSize(NodeStack.getSize() + 1);\n    }\n\n    /**\n     * Value to be taken off the stack.\n     *\n     * @return item : value that is returned.\n     */\n    public Item pop() {\n        Item item = (Item) NodeStack.head.getData();\n\n        NodeStack.setHead(NodeStack.head.getPrevious());\n        NodeStack.head.setNext(null);\n\n        NodeStack.setSize(NodeStack.getSize() - 1);\n\n        return item;\n    }\n\n    /**\n     * Value that is next to be taken off the stack.\n     *\n     * @return item : the next value that would be popped off the stack.\n     */\n    public Item peek() {\n        return (Item) NodeStack.head.getData();\n    }\n\n    /**\n     * If the stack is empty or there is a value in.\n     *\n     * @return boolean : whether or not the stack has anything in it.\n     */\n    public boolean isEmpty() {\n        return NodeStack.getSize() == 0;\n    }\n\n    /**\n     * Returns the size of the stack.\n     *\n     * @return int : number of values in the stack.\n     */\n    public int size() {\n        return NodeStack.getSize();\n    }\n\n    /**\n     * Print the contents of the stack in the following format.\n     *\n     * <p>\n     * x <- head (next out) y z <- tail (first in) . . .\n     */\n    public void print() {\n        for (NodeStack<?> n = NodeStack.head; n != null; n = n.previous) {\n            System.out.println(n.getData().toString());\n        }\n    }\n\n    private static void setHead(NodeStack<?> ns) {\n        NodeStack.head = ns;\n    }\n\n    private void setNext(NodeStack<?> next) {\n    }\n\n    private NodeStack<?> getPrevious() {\n        return previous;\n    }\n\n    private void setPrevious(NodeStack<?> previous) {\n        this.previous = previous;\n    }\n\n    private static int getSize() {\n        return size;\n    }\n\n    private static void setSize(int size) {\n        NodeStack.size = size;\n    }\n\n    private Item getData() {\n        return this.data;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.stacks;\n\npublic class NodeStack {\n    static public  main(String args);\n    private Item data;\n    static private NodeStack<> head;\n    private NodeStack<> previous;\n    static private int size;\n    public NodeStack();\n    private NodeStack(Item item);\n    public  push(Item item);\n    public Item pop();\n    public Item peek();\n    public boolean isEmpty();\n    public int size();\n    public  print();\n    static private  setHead(NodeStack<> ns);\n    private  setNext(NodeStack<> next);\n    private NodeStack<> getPrevious();\n    private  setPrevious(NodeStack<> previous);\n    static private int getSize();\n    static private  setSize(int size);\n    private Item getData();\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "StackArrayList.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/datastructures/stacks/StackArrayList.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.datastructures.stacks",
        "docstring": "/**\n     * Return the element at the top of this stack without removing it from the\n     * stack.\n     *\n     * @return the element at the top of this stack.\n     */",
        "source_code": "\npublic int peek() {\n    if (isEmpty()) {\n        throw new EmptyStackException();\n    }\n    return stack.get(stack.size() - 1);\n}\n",
        "class_name": "StackArrayList",
        "method_name": "peek",
        "argument_name": [],
        "full_context": "package com.thealgorithms.datastructures.stacks;\n\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\n\n/**\n * This class implements a Stack using an ArrayList.\n *\n * <p>\n * A stack is exactly what it sounds like. An element gets added to the top of\n * the stack and only the element on the top may be removed.\n *\n * <p>\n * This is an ArrayList Implementation of a stack, where size is not a problem\n * we can extend the stack as much as we want.\n */\npublic class StackArrayList {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        StackArrayList stack = new StackArrayList();\n        assert stack.isEmpty();\n\n        for (int i = 1; i <= 5; ++i) {\n            stack.push(i);\n            assert stack.size() == i;\n        }\n\n        assert stack.size() == 5;\n        assert stack.peek() == 5 && stack.pop() == 5 && stack.peek() == 4;\n\n        /* pop elements at the top of this stack one by one */\n        while (!stack.isEmpty()) {\n            stack.pop();\n        }\n        assert stack.isEmpty();\n\n        try {\n            stack.pop();\n            assert false;\n            /* this should not happen */\n        } catch (EmptyStackException e) {\n            assert true;\n            /* this should happen */\n        }\n    }\n\n    /**\n     * ArrayList representation of the stack\n     */\n    private ArrayList<Integer> stack;\n\n    /**\n     * Constructor\n     */\n    public StackArrayList() {\n        stack = new ArrayList<>();\n    }\n\n    /**\n     * Adds value to the end of list which is the top for stack\n     *\n     * @param value value to be added\n     */\n    public void push(int value) {\n        stack.add(value);\n    }\n\n    /**\n     * Removes the element at the top of this stack and returns\n     *\n     * @return Element popped\n     * @throws EmptyStackException if the stack is empty.\n     */\n    public int pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n\n        /* remove the element on the top of the stack */\n        return stack.remove(stack.size() - 1);\n    }\n\n    /**\n     * Test if the stack is empty.\n     *\n     * @return {@code true} if this stack is empty, {@code false} otherwise.\n     */\n    public boolean isEmpty() {\n        return stack.isEmpty();\n    }\n\n    /**\n     * Return the element at the top of this stack without removing it from the\n     * stack.\n     *\n     * @return the element at the top of this stack.\n     */\n    public int peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return stack.get(stack.size() - 1);\n    }\n\n    /**\n     * Return size of this stack.\n     *\n     * @return size of this stack.\n     */\n    public int size() {\n        return stack.size();\n    }\n}\n",
        "simple_context": "package com.thealgorithms.datastructures.stacks;\n\nimport java.util.ArrayList;\n\nimport java.util.EmptyStackException;\n\npublic class StackArrayList {\n    static public  main(String args);\n    private ArrayList<Integer> stack;\n    public StackArrayList();\n    public  push(int value);\n    public int pop();\n    public boolean isEmpty();\n    public int peek();\n    public int size();\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "AbsoluteMax.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/AbsoluteMax.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Finds the absolute maximum value among the given numbers.\n     *\n     * @param numbers The numbers to compare.\n     * @return The absolute maximum value.\n     * @throws IllegalArgumentException If the input array is empty or null.\n     */",
        "source_code": "\npublic static int getMaxValue(int... numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    int absMax = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n            absMax = numbers[i];\n        }\n    }\n    return absMax;\n}\n",
        "class_name": "AbsoluteMax",
        "method_name": "getMaxValue",
        "argument_name": [
            "int numbers"
        ],
        "full_context": "package com.thealgorithms.maths;\n\npublic class AbsoluteMax {\n\n    /**\n     * Finds the absolute maximum value among the given numbers.\n     *\n     * @param numbers The numbers to compare.\n     * @return The absolute maximum value.\n     * @throws IllegalArgumentException If the input array is empty or null.\n     */\n    public static int getMaxValue(int... numbers) {\n        if (numbers == null || numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n        }\n        int absMax = numbers[0];\n        for (int i = 1; i < numbers.length; i++) {\n            if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n                absMax = numbers[i];\n            }\n        }\n        return absMax;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class AbsoluteMax {\n    static public int getMaxValue(int numbers);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "AliquotSum.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/AliquotSum.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Function to calculate the aliquot sum of an integer number\n     *\n     * @param n a positive integer\n     * @return aliquot sum of given {@code number}\n     */",
        "source_code": "\npublic static int getAliquotSum(int n) {\n    if (n <= 0) return -1;\n    int sum = 1;\n    double root = Math.sqrt(n);\n    /*\n     * We can get the factors after the root by dividing number by its factors\n     * before the root.\n     * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n     * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n     * Now by dividing 100 by each factor before 10 we get:\n     * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n     * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n     */\n    for (int i = 2; i <= root; i++) {\n        if (n % i == 0) {\n            sum += i + n / i;\n        }\n    }\n    // if n is a perfect square then its root was added twice in above loop, so subtracting root\n    // from sum\n    if (root == (int) root) sum -= root;\n    return sum;\n}\n",
        "class_name": "AliquotSum",
        "method_name": "getAliquotSum",
        "argument_name": [
            "int n"
        ],
        "full_context": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of\n * all proper divisors of n, that is, all divisors of n other than n itself. For\n * example, the proper divisors of 15 (that is, the positive divisors of 15 that\n * are not equal to 15) are 1, 3 and 5, so the aliquot sum of 15 is 9 i.e. (1 +\n * 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n\n    /**\n     * Finds the aliquot sum of an integer number.\n     *\n     * @param number a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotValue(int number) {\n        var sumWrapper = new Object() { int value = 0; };\n\n        IntStream.iterate(1, i -> ++i).limit(number / 2).filter(i -> number % i == 0).forEach(i -> sumWrapper.value += i);\n\n        return sumWrapper.value;\n    }\n\n    /**\n     * Function to calculate the aliquot sum of an integer number\n     *\n     * @param n a positive integer\n     * @return aliquot sum of given {@code number}\n     */\n    public static int getAliquotSum(int n) {\n        if (n <= 0) return -1;\n        int sum = 1;\n        double root = Math.sqrt(n);\n        /*\n         * We can get the factors after the root by dividing number by its factors\n         * before the root.\n         * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n         * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n         * Now by dividing 100 by each factor before 10 we get:\n         * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n         * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n         */\n        for (int i = 2; i <= root; i++) {\n            if (n % i == 0) {\n                sum += i + n / i;\n            }\n        }\n        // if n is a perfect square then its root was added twice in above loop, so subtracting root\n        // from sum\n        if (root == (int) root) sum -= root;\n        return sum;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\nimport java.util.stream.IntStream;\n\npublic class AliquotSum {\n    static public int getAliquotValue(int number);\n    static public int getAliquotSum(int n);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Armstrong.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/Armstrong.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Checks whether a given number is an Armstrong number or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise\n     */",
        "source_code": "\npublic boolean isArmstrong(int number) {\n    long sum = 0;\n    String temp = Integer.toString(number); // Convert the given number to a string\n    int power = temp.length(); // Extract the length of the number (number of digits)\n    long originalNumber = number;\n\n    while (originalNumber > 0) {\n        long digit = originalNumber % 10;\n        sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n        originalNumber /= 10;\n    }\n\n    return sum == number;\n}\n",
        "class_name": "Armstrong",
        "method_name": "isArmstrong",
        "argument_name": [
            "int number"
        ],
        "full_context": "package com.thealgorithms.maths;\n\n/**\n * This class checks whether a given number is an Armstrong number or not.\n * An Armstrong number is a number that is equal to the sum of its own digits,\n * each raised to the power of the number of digits.\n *\n * For example, 370 is an Armstrong number because 3^3 + 7^3 + 0^3 = 370.\n * 1634 is an Armstrong number because 1^4 + 6^4 + 3^4 + 4^4 = 1634.\n * An Armstrong number is often called a Narcissistic number.\n *\n * @author satyabarghav\n */\npublic class Armstrong {\n\n    /**\n     * Checks whether a given number is an Armstrong number or not.\n     *\n     * @param number the number to check\n     * @return {@code true} if the given number is an Armstrong number, {@code false} otherwise\n     */\n    public boolean isArmstrong(int number) {\n        long sum = 0;\n        String temp = Integer.toString(number); // Convert the given number to a string\n        int power = temp.length(); // Extract the length of the number (number of digits)\n        long originalNumber = number;\n\n        while (originalNumber > 0) {\n            long digit = originalNumber % 10;\n            sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n            originalNumber /= 10;\n        }\n\n        return sum == number;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class Armstrong {\n    public boolean isArmstrong(int number);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Average.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/Average.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * find average value of an int array\n     *\n     * @param numbers the array contains element and the sum does not excess long\n     *                value limit\n     * @return average value\n     */",
        "source_code": "\npublic static int average(int[] numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    long sum = 0;\n    for (int number : numbers) {\n        sum += number;\n    }\n    return (int) (sum / numbers.length);\n}\n",
        "class_name": "Average",
        "method_name": "average",
        "argument_name": [
            "int[] numbers"
        ],
        "full_context": "package com.thealgorithms.maths;\n\n/**\n * Calculate average of a list of numbers\n */\npublic class Average {\n\n    /**\n     * Calculate average of a list of numbers\n     *\n     * @param numbers array to store numbers\n     * @return mean of given numbers\n     */\n    public static double average(double[] numbers) {\n        if (numbers == null || numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n        }\n        double sum = 0;\n        for (double number : numbers) {\n            sum += number;\n        }\n        return sum / numbers.length;\n    }\n\n    /**\n     * find average value of an int array\n     *\n     * @param numbers the array contains element and the sum does not excess long\n     *                value limit\n     * @return average value\n     */\n    public static int average(int[] numbers) {\n        if (numbers == null || numbers.length == 0) {\n            throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n        }\n        long sum = 0;\n        for (int number : numbers) {\n            sum += number;\n        }\n        return (int) (sum / numbers.length);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class Average {\n    static public double average(double[] numbers);\n    static public int average(int[] numbers);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "FFT.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/FFT.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */",
        "source_code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
        "class_name": "FFT",
        "method_name": "fft",
        "argument_name": [
            "ArrayList<Complex> x",
            "boolean inverse"
        ],
        "full_context": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * Class for calculating the Fast Fourier Transform (FFT) of a discrete signal\n * using the Cooley-Tukey algorithm.\n *\n * @author Ioannis Karavitsis\n * @version 1.0\n */\npublic class FFT {\n\n    /**\n     * This class represents a complex number and has methods for basic\n     * operations.\n     *\n     * <p>\n     * More info:\n     * https://introcs.cs.princeton.edu/java/32class/Complex.java.html\n     */\n    static class Complex {\n\n        private double real, img;\n\n        /**\n         * Default Constructor. Creates the complex number 0.\n         */\n        public Complex() {\n            real = 0;\n            img = 0;\n        }\n\n        /**\n         * Constructor. Creates a complex number.\n         *\n         * @param r The real part of the number.\n         * @param i The imaginary part of the number.\n         */\n        public Complex(double r, double i) {\n            real = r;\n            img = i;\n        }\n\n        /**\n         * Returns the real part of the complex number.\n         *\n         * @return The real part of the complex number.\n         */\n        public double getReal() {\n            return real;\n        }\n\n        /**\n         * Returns the imaginary part of the complex number.\n         *\n         * @return The imaginary part of the complex number.\n         */\n        public double getImaginary() {\n            return img;\n        }\n\n        /**\n         * Adds this complex number to another.\n         *\n         * @param z The number to be added.\n         * @return The sum.\n         */\n        public Complex add(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real + z.real;\n            temp.img = this.img + z.img;\n            return temp;\n        }\n\n        /**\n         * Subtracts a number from this complex number.\n         *\n         * @param z The number to be subtracted.\n         * @return The difference.\n         */\n        public Complex subtract(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real - z.real;\n            temp.img = this.img - z.img;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by another.\n         *\n         * @param z The number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(Complex z) {\n            Complex temp = new Complex();\n            temp.real = this.real * z.real - this.img * z.img;\n            temp.img = this.real * z.img + this.img * z.real;\n            return temp;\n        }\n\n        /**\n         * Multiplies this complex number by a scalar.\n         *\n         * @param n The real number to be multiplied.\n         * @return The product.\n         */\n        public Complex multiply(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real * n;\n            temp.img = this.img * n;\n            return temp;\n        }\n\n        /**\n         * Finds the conjugate of this complex number.\n         *\n         * @return The conjugate.\n         */\n        public Complex conjugate() {\n            Complex temp = new Complex();\n            temp.real = this.real;\n            temp.img = -this.img;\n            return temp;\n        }\n\n        /**\n         * Finds the magnitude of the complex number.\n         *\n         * @return The magnitude.\n         */\n        public double abs() {\n            return Math.hypot(this.real, this.img);\n        }\n\n        /**\n         * Divides this complex number by another.\n         *\n         * @param z The divisor.\n         * @return The quotient.\n         */\n        public Complex divide(Complex z) {\n            Complex temp = new Complex();\n            double d = z.abs() * z.abs();\n            d = (double) Math.round(d * 1000000000d) / 1000000000d;\n            temp.real = (this.real * z.real + this.img * z.img) / (d);\n            temp.img = (this.img * z.real - this.real * z.img) / (d);\n            return temp;\n        }\n\n        /**\n         * Divides this complex number by a scalar.\n         *\n         * @param n The divisor which is a real number.\n         * @return The quotient.\n         */\n        public Complex divide(double n) {\n            Complex temp = new Complex();\n            temp.real = this.real / n;\n            temp.img = this.img / n;\n            return temp;\n        }\n    }\n\n    /**\n     * Iterative In-Place Radix-2 Cooley-Tukey Fast Fourier Transform Algorithm\n     * with Bit-Reversal. The size of the input signal must be a power of 2. If\n     * it isn't then it is padded with zeros and the output FFT will be bigger\n     * than the input signal.\n     *\n     * <p>\n     * More info:\n     * https://www.algorithm-archive.org/contents/cooley_tukey/cooley_tukey.html\n     * https://www.geeksforgeeks.org/iterative-fast-fourier-transformation-polynomial-multiplication/\n     * https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n     * https://cp-algorithms.com/algebra/fft.html\n     *  @param x The discrete signal which is then converted to the FFT or the\n     * IFFT of signal x.\n     * @param inverse True if you want to find the inverse FFT.\n     * @return\n     */\n    public static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n        /* Pad the signal with zeros if necessary */\n        paddingPowerOfTwo(x);\n        int N = x.size();\n        int log2N = findLog2(N);\n        x = fftBitReversal(N, log2N, x);\n        int direction = inverse ? -1 : 1;\n\n        /* Main loop of the algorithm */\n        for (int len = 2; len <= N; len *= 2) {\n            double angle = -2 * Math.PI / len * direction;\n            Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n            for (int i = 0; i < N; i += len) {\n                Complex w = new Complex(1, 0);\n                for (int j = 0; j < len / 2; j++) {\n                    Complex u = x.get(i + j);\n                    Complex v = w.multiply(x.get(i + j + len / 2));\n                    x.set(i + j, u.add(v));\n                    x.set(i + j + len / 2, u.subtract(v));\n                    w = w.multiply(wlen);\n                }\n            }\n        }\n        x = inverseFFT(N, inverse, x);\n        return x;\n    }\n\n    /* Find the log2(N) */\n    public static int findLog2(int N) {\n        int log2N = 0;\n        while ((1 << log2N) < N) {\n            log2N++;\n        }\n        return log2N;\n    }\n\n    /* Swap the values of the signal with bit-reversal method */\n    public static ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x) {\n        int reverse;\n        for (int i = 0; i < N; i++) {\n            reverse = reverseBits(i, log2N);\n            if (i < reverse) {\n                Collections.swap(x, i, reverse);\n            }\n        }\n        return x;\n    }\n\n    /* Divide by N if we want the inverse FFT */\n    public static ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x) {\n        if (inverse) {\n            for (int i = 0; i < x.size(); i++) {\n                Complex z = x.get(i);\n                x.set(i, z.divide(N));\n            }\n        }\n        return x;\n    }\n\n    /**\n     * This function reverses the bits of a number. It is used in Cooley-Tukey\n     * FFT algorithm.\n     *\n     * <p>\n     * E.g. num = 13 = 00001101 in binary log2N = 8 Then reversed = 176 =\n     * 10110000 in binary\n     *\n     * <p>\n     * More info: https://cp-algorithms.com/algebra/fft.html\n     * https://www.geeksforgeeks.org/write-an-efficient-c-program-to-reverse-bits-of-a-number/\n     *\n     * @param num The integer you want to reverse its bits.\n     * @param log2N The number of bits you want to reverse.\n     * @return The reversed number\n     */\n    private static int reverseBits(int num, int log2N) {\n        int reversed = 0;\n        for (int i = 0; i < log2N; i++) {\n            if ((num & (1 << i)) != 0) {\n                reversed |= 1 << (log2N - 1 - i);\n            }\n        }\n        return reversed;\n    }\n\n    /**\n     * This method pads an ArrayList with zeros in order to have a size equal to\n     * the next power of two of the previous size.\n     *\n     * @param x The ArrayList to be padded.\n     */\n    private static void paddingPowerOfTwo(ArrayList<Complex> x) {\n        int n = 1;\n        int oldSize = x.size();\n        while (n < oldSize) {\n            n *= 2;\n        }\n        for (int i = 0; i < n - oldSize; i++) {\n            x.add(new Complex());\n        }\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\npublic class FFT {\n    static class Complex {\n        private double real, img;\n        public Complex();\n        public Complex(double r, double i);\n        public double getReal();\n        public double getImaginary();\n        public Complex add(Complex z);\n        public Complex subtract(Complex z);\n        public Complex multiply(Complex z);\n        public Complex multiply(double n);\n        public Complex conjugate();\n        public double abs();\n        public Complex divide(Complex z);\n        public Complex divide(double n);\n    }\n    static public ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse);\n    static public int findLog2(int N);\n    static public ArrayList<Complex> fftBitReversal(int N, int log2N, ArrayList<Complex> x);\n    static public ArrayList<Complex> inverseFFT(int N, boolean inverse, ArrayList<Complex> x);\n    static private int reverseBits(int num, int log2N);\n    static private  paddingPowerOfTwo(ArrayList<Complex> x);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "FindMax.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/FindMax.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */",
        "source_code": "\npublic static int findMax(final int[] array) {\n    int n = array.length;\n    if (n == 0) {\n        throw new IllegalArgumentException(\"Array must be non-empty.\");\n    }\n    int max = array[0];\n    for (int i = 1; i < n; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}\n",
        "class_name": "FindMax",
        "method_name": "findMax",
        "argument_name": [
            "int[] array"
        ],
        "full_context": "package com.thealgorithms.maths;\n\npublic final class FindMax {\n    private FindMax() {\n    }\n\n    /**\n     * @brief finds the maximum value stored in the input array\n     *\n     * @param array the input array\n     * @exception IllegalArgumentException input array is empty\n     * @return the maximum value stored in the input array\n     */\n    public static int findMax(final int[] array) {\n        int n = array.length;\n        if (n == 0) {\n            throw new IllegalArgumentException(\"Array must be non-empty.\");\n        }\n        int max = array[0];\n        for (int i = 1; i < n; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\nfinal public class FindMax {\n    private FindMax();\n    static public int findMax(int[] array);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "TwinPrime.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/maths/TwinPrime.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.maths",
        "docstring": "/**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */",
        "source_code": "\nstatic int getTwinPrime(int inputNumber) {\n\n    // if inputNumber and (inputNumber + 2) are both prime\n    // then return (inputNumber + 2) as a result\n    if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n        return inputNumber + 2;\n    }\n    // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n    // then return -1 as a result\n    return -1;\n}\n",
        "class_name": "TwinPrime",
        "method_name": "getTwinPrime",
        "argument_name": [
            "int inputNumber"
        ],
        "full_context": "package com.thealgorithms.maths;\n/*\n * Java program to find 'twin prime' of a prime number\n * Twin Prime: Twin prime of a number n is (n+2)\n * if and only if n & (n+2) are prime.\n * Wikipedia: https://en.wikipedia.org/wiki/Twin_prime\n *\n * Author: Akshay Dubey (https://github.com/itsAkshayDubey)\n *\n * */\n\npublic class TwinPrime {\n\n    /**\n     * This method returns twin prime of the integer value passed as argument\n     *\n     * @param input_number Integer value of which twin prime is to be found\n     * @return (number + 2) if number and (number + 2) are prime, -1 otherwise\n     */\n    static int getTwinPrime(int inputNumber) {\n\n        // if inputNumber and (inputNumber + 2) are both prime\n        // then return (inputNumber + 2) as a result\n        if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n            return inputNumber + 2;\n        }\n        // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n        // then return -1 as a result\n        return -1;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.maths;\n\npublic class TwinPrime {\n    static int getTwinPrime(int inputNumber);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "QuickSort.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/sorts/QuickSort.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.sorts",
        "docstring": "/**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */",
        "source_code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] array) {\n    doSort(array, 0, array.length - 1);\n    return array;\n}\n",
        "class_name": "QuickSort",
        "method_name": "sort",
        "argument_name": [
            "T array"
        ],
        "full_context": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n    /**\n     * This method implements the Generic Quick Sort\n     *\n     * @param array The array to be sorted Sorts the array in increasing order\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] array) {\n        doSort(array, 0, array.length - 1);\n        return array;\n    }\n\n    /**\n     * The sorting process\n     *\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @param array The array to be sorted\n     */\n    private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n        if (left < right) {\n            int pivot = randomPartition(array, left, right);\n            doSort(array, left, pivot - 1);\n            doSort(array, pivot, right);\n        }\n    }\n\n    /**\n     * Randomize the array to avoid the basically ordered sequences\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array\n     * @return the partition index of the array\n     */\n    private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n        int randomIndex = left + (int) (Math.random() * (right - left + 1));\n        swap(array, randomIndex, right);\n        return partition(array, left, right);\n    }\n\n    /**\n     * This method finds the partition index for an array\n     *\n     * @param array The array to be sorted\n     * @param left The first index of an array\n     * @param right The last index of an array Finds the partition index of an\n     * array\n     */\n    private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n        int mid = (left + right) >>> 1;\n        T pivot = array[mid];\n\n        while (left <= right) {\n            while (less(array[left], pivot)) {\n                ++left;\n            }\n            while (less(pivot, array[right])) {\n                --right;\n            }\n            if (left <= right) {\n                swap(array, left, right);\n                ++left;\n                --right;\n            }\n        }\n        return left;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.sorts;\n\nimport static com.thealgorithms.sorts.SortUtils;\n\nclass QuickSort implements SortAlgorithm {\n    public T sort(T array);\n    static private  doSort(T array, int left, int right);\n    static private int randomPartition(T array, int left, int right);\n    static private int partition(T array, int left, int right);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "HeapSort.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/sorts/HeapSort.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.sorts",
        "docstring": "/**\n     * For simplicity, we are considering the heap root index as 1 instead of 0.\n     * It simplifies future calculations. Because of that we are decreasing the\n     * provided indexes by 1 in {@link #swap(Object[], int, int)} and\n     * {@link #less(Comparable[], int, int)} functions.\n     */",
        "source_code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    int n = unsorted.length;\n    heapify(unsorted, n);\n    while (n > 1) {\n        swap(unsorted, 1, n--);\n        siftDown(unsorted, 1, n);\n    }\n    return unsorted;\n}\n",
        "class_name": "HeapSort",
        "method_name": "sort",
        "argument_name": [
            "T unsorted"
        ],
        "full_context": "package com.thealgorithms.sorts;\n\n/**\n * Heap Sort Algorithm Implementation\n *\n * @see <a href=\"https://en.wikipedia.org/wiki/Heapsort\">Heap Sort Algorithm</a>\n */\npublic class HeapSort implements SortAlgorithm {\n\n    /**\n     * For simplicity, we are considering the heap root index as 1 instead of 0.\n     * It simplifies future calculations. Because of that we are decreasing the\n     * provided indexes by 1 in {@link #swap(Object[], int, int)} and\n     * {@link #less(Comparable[], int, int)} functions.\n     */\n    @Override\n    public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n        int n = unsorted.length;\n        heapify(unsorted, n);\n        while (n > 1) {\n            swap(unsorted, 1, n--);\n            siftDown(unsorted, 1, n);\n        }\n        return unsorted;\n    }\n\n    private static <T extends Comparable<T>> void heapify(T[] unsorted, int n) {\n        for (int k = n / 2; k >= 1; k--) {\n            siftDown(unsorted, k, n);\n        }\n    }\n\n    private static <T extends Comparable<T>> void siftDown(T[] unsorted, int k, int n) {\n        while (2 * k <= n) {\n            int j = 2 * k;\n            if (j < n && less(unsorted, j, j + 1)) {\n                j++;\n            }\n            if (!less(unsorted, k, j)) {\n                break;\n            }\n            swap(unsorted, k, j);\n            k = j;\n        }\n    }\n\n    private static <T> void swap(T[] array, int idx, int idy) {\n        T swap = array[idx - 1];\n        array[idx - 1] = array[idy - 1];\n        array[idy - 1] = swap;\n    }\n\n    private static <T extends Comparable<T>> boolean less(T[] array, int idx, int idy) {\n        return array[idx - 1].compareTo(array[idy - 1]) < 0;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.sorts;\n\npublic class HeapSort implements SortAlgorithm {\n    public T sort(T unsorted);\n    static private  heapify(T unsorted, int n);\n    static private  siftDown(T unsorted, int k, int n);\n    static private  swap(T array, int idx, int idy);\n    static private boolean less(T array, int idx, int idy);\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "HammingDistance.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/strings/HammingDistance.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.strings",
        "docstring": "/**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */",
        "source_code": "\npublic static int calculateHammingDistance(String s1, String s2) throws Exception {\n    if (s1.length() != s2.length()) {\n        throw new Exception(\"String lengths must be equal\");\n    }\n\n    int stringLength = s1.length();\n    int counter = 0;\n\n    for (int i = 0; i < stringLength; i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            counter++;\n        }\n    }\n    return counter;\n}\n",
        "class_name": "HammingDistance",
        "method_name": "calculateHammingDistance",
        "argument_name": [
            "String s1",
            "String s2"
        ],
        "full_context": "package com.thealgorithms.strings;\n\n/* In information theory, the Hamming distance between two strings of equal length\nis the number of positions at which the corresponding symbols are different.\nhttps://en.wikipedia.org/wiki/Hamming_distance\n*/\npublic class HammingDistance {\n\n    /**\n     * calculate the hamming distance between two strings of equal length\n     *\n     * @param s1 the first string\n     * @param s2 the second string\n     * @return {@code int} hamming distance\n     * @throws Exception\n     */\n    public static int calculateHammingDistance(String s1, String s2) throws Exception {\n        if (s1.length() != s2.length()) {\n            throw new Exception(\"String lengths must be equal\");\n        }\n\n        int stringLength = s1.length();\n        int counter = 0;\n\n        for (int i = 0; i < stringLength; i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                counter++;\n            }\n        }\n        return counter;\n    }\n}\n",
        "simple_context": "package com.thealgorithms.strings;\n\npublic class HammingDistance {\n    static public int calculateHammingDistance(String s1, String s2)throws Exception;\n}\n\n"
    },
    {
        "project_name": "Java",
        "file_name": "Lower.java",
        "relative_path": "Java/src/main/java/com/thealgorithms/strings/Lower.java",
        "execute_path": "Java",
        "package": "com.thealgorithms.strings",
        "docstring": "/**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */",
        "source_code": "\npublic static String toLowerCase(String s) {\n    char[] values = s.toCharArray();\n    for (int i = 0; i < values.length; ++i) {\n        if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n            values[i] = Character.toLowerCase(values[i]);\n        }\n    }\n    return new String(values);\n}\n",
        "class_name": "Lower",
        "method_name": "toLowerCase",
        "argument_name": [
            "String s"
        ],
        "full_context": "package com.thealgorithms.strings;\n\npublic class Lower {\n\n    /**\n     * Driver Code\n     */\n    public static void main(String[] args) {\n        String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"};\n        for (String s : strings) {\n            assert toLowerCase(s).equals(s.toLowerCase());\n        }\n    }\n\n    /**\n     * Converts all of the characters in this {@code String} to lower case\n     *\n     * @param s the string to convert\n     * @return the {@code String}, converted to lowercase.\n     */\n    public static String toLowerCase(String s) {\n        char[] values = s.toCharArray();\n        for (int i = 0; i < values.length; ++i) {\n            if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n                values[i] = Character.toLowerCase(values[i]);\n            }\n        }\n        return new String(values);\n    }\n}\n",
        "simple_context": "package com.thealgorithms.strings;\n\npublic class Lower {\n    static public  main(String args);\n    static public String toLowerCase(String s);\n}\n\n"
    }
]