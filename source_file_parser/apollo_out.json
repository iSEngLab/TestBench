[
    {
        "project_name": "apollo",
        "file_name": "AdminServiceAuthenticationFilter.java",
        "relative_path": "apollo/apollo-adminservice/src/main/java/com/ctrip/framework/apollo/adminservice/filter/AdminServiceAuthenticationFilter.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.adminservice.filter",
        "docstring": null,
        "source_code": "private boolean checkAccessToken(String token) {\n  String accessTokens = bizConfig.getAdminServiceAccessTokens();\n\n  // if user forget to configure access tokens, then default to pass\n  if (Strings.isNullOrEmpty(accessTokens)) {\n    return true;\n  }\n\n  // no need to check\n  if (Strings.isNullOrEmpty(token)) {\n    return false;\n  }\n\n  // update cache\n  if (!accessTokens.equals(lastAccessTokens)) {\n    synchronized (this) {\n      accessTokenList = ACCESS_TOKEN_SPLITTER.splitToList(accessTokens);\n      lastAccessTokens = accessTokens;\n    }\n  }\n\n  return accessTokenList.contains(token);\n}\n",
        "class_name": "AdminServiceAuthenticationFilter",
        "method_name": "checkAccessToken",
        "argument_name": [
            "String token"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.adminservice.filter;\n\nimport com.ctrip.framework.apollo.biz.config.BizConfig;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport java.io.IOException;\nimport java.util.List;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpHeaders;\n\npublic class AdminServiceAuthenticationFilter implements Filter {\n\n  private static final Logger logger = LoggerFactory\n      .getLogger(AdminServiceAuthenticationFilter.class);\n  private static final Splitter ACCESS_TOKEN_SPLITTER = Splitter.on(\",\").omitEmptyStrings()\n      .trimResults();\n\n  private final BizConfig bizConfig;\n  private volatile String lastAccessTokens;\n  private volatile List<String> accessTokenList;\n\n  public AdminServiceAuthenticationFilter(BizConfig bizConfig) {\n    this.bizConfig = bizConfig;\n  }\n\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException {\n\n  }\n\n  @Override\n  public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)\n      throws IOException, ServletException {\n    if (bizConfig.isAdminServiceAccessControlEnabled()) {\n      HttpServletRequest request = (HttpServletRequest) req;\n      HttpServletResponse response = (HttpServletResponse) resp;\n\n      String token = request.getHeader(HttpHeaders.AUTHORIZATION);\n\n      if (!checkAccessToken(token)) {\n        logger.warn(\"Invalid access token: {} for uri: {}\", token, request.getRequestURI());\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n        return;\n      }\n    }\n\n    chain.doFilter(req, resp);\n  }\n\n  private boolean checkAccessToken(String token) {\n    String accessTokens = bizConfig.getAdminServiceAccessTokens();\n\n    // if user forget to configure access tokens, then default to pass\n    if (Strings.isNullOrEmpty(accessTokens)) {\n      return true;\n    }\n\n    // no need to check\n    if (Strings.isNullOrEmpty(token)) {\n      return false;\n    }\n\n    // update cache\n    if (!accessTokens.equals(lastAccessTokens)) {\n      synchronized (this) {\n        accessTokenList = ACCESS_TOKEN_SPLITTER.splitToList(accessTokens);\n        lastAccessTokens = accessTokens;\n      }\n    }\n\n    return accessTokenList.contains(token);\n  }\n\n  @Override\n  public void destroy() {\n\n  }\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.adminservice.filter;\n\nimport com.ctrip.framework.apollo.biz.config.BizConfig;\n\nimport com.google.common.base.Splitter;\n\nimport com.google.common.base.Strings;\n\nimport java.io.IOException;\n\nimport java.util.List;\n\nimport javax.servlet.Filter;\n\nimport javax.servlet.FilterChain;\n\nimport javax.servlet.FilterConfig;\n\nimport javax.servlet.ServletException;\n\nimport javax.servlet.ServletRequest;\n\nimport javax.servlet.ServletResponse;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport org.springframework.http.HttpHeaders;\n\npublic class AdminServiceAuthenticationFilter implements Filter {\n    static final private Logger logger;\n    static final private Splitter ACCESS_TOKEN_SPLITTER;\n    final private BizConfig bizConfig;\n    volatile private String lastAccessTokens;\n    volatile private List<String> accessTokenList;\n    public AdminServiceAuthenticationFilter(BizConfig bizConfig);\n    public  init(FilterConfig filterConfig)throws ServletException;\n    public  doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)throws IOException, ServletException;\n    private boolean checkAccessToken(String token);\n    public  destroy();\n}\n\n"
    },
    {
        "project_name": "apollo",
        "file_name": "ApolloEurekaClientConfig.java",
        "relative_path": "apollo/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/eureka/ApolloEurekaClientConfig.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.biz.eureka",
        "docstring": "/**\n   * Assert only one zone: defaultZone, but multiple environments.\n   */",
        "source_code": "\n@Override\npublic List<String> getEurekaServerServiceUrls(String myZone) {\n  List<String> urls = bizConfig.eurekaServiceUrls();\n  return CollectionUtils.isEmpty(urls) ? super.getEurekaServerServiceUrls(myZone) : urls;\n}\n",
        "class_name": "ApolloEurekaClientConfig",
        "method_name": "getEurekaServerServiceUrls",
        "argument_name": [
            "String myZone"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.biz.eureka;\n\n\nimport com.ctrip.framework.apollo.biz.config.BizConfig;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.event.ApplicationReadyEvent;\nimport org.springframework.cloud.context.scope.refresh.RefreshScope;\nimport org.springframework.cloud.netflix.eureka.EurekaClientConfigBean;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport java.util.List;\n\n@Component\n@Primary\n@ConditionalOnProperty(value = {\"eureka.client.enabled\"}, havingValue = \"true\", matchIfMissing = true)\npublic class ApolloEurekaClientConfig extends EurekaClientConfigBean {\n\n  private final BizConfig bizConfig;\n  private final RefreshScope refreshScope;\n  private static final String EUREKA_CLIENT_BEAN_NAME = \"eurekaClient\";\n\n  public ApolloEurekaClientConfig(final BizConfig bizConfig, final RefreshScope refreshScope) {\n    this.bizConfig = bizConfig;\n    this.refreshScope = refreshScope;\n  }\n\n  /**\n   * Assert only one zone: defaultZone, but multiple environments.\n   */\n  @Override\n  public List<String> getEurekaServerServiceUrls(String myZone) {\n    List<String> urls = bizConfig.eurekaServiceUrls();\n    return CollectionUtils.isEmpty(urls) ? super.getEurekaServerServiceUrls(myZone) : urls;\n  }\n\n  @EventListener\n  public void listenApplicationReadyEvent(ApplicationReadyEvent event) {\n    this.refreshEurekaClient();\n  }\n\n  private void refreshEurekaClient() {\n    if (!super.isFetchRegistry()) {\n        super.setFetchRegistry(true);\n        super.setRegisterWithEureka(true);\n        refreshScope.refresh(EUREKA_CLIENT_BEAN_NAME);\n    }\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    return super.equals(o);\n  }\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.biz.eureka;\n\nimport com.ctrip.framework.apollo.biz.config.BizConfig;\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n\nimport org.springframework.boot.context.event.ApplicationReadyEvent;\n\nimport org.springframework.cloud.context.scope.refresh.RefreshScope;\n\nimport org.springframework.cloud.netflix.eureka.EurekaClientConfigBean;\n\nimport org.springframework.context.annotation.Primary;\n\nimport org.springframework.context.event.EventListener;\n\nimport org.springframework.stereotype.Component;\n\nimport org.springframework.util.CollectionUtils;\n\nimport java.util.List;\n\npublic class ApolloEurekaClientConfig extends EurekaClientConfigBean {\n    final private BizConfig bizConfig;\n    final private RefreshScope refreshScope;\n    static final private String EUREKA_CLIENT_BEAN_NAME;\n    public ApolloEurekaClientConfig(BizConfig bizConfig, RefreshScope refreshScope);\n    public List<String> getEurekaServerServiceUrls(String myZone);\n    public  listenApplicationReadyEvent(ApplicationReadyEvent event);\n    private  refreshEurekaClient();\n    public boolean equals(Object o);\n}\n\n"
    },
    {
        "project_name": "apollo",
        "file_name": "DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.java",
        "relative_path": "apollo/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/registry/DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.biz.registry",
        "docstring": "/**\n   * if the serviceName is same with self, always return self's instance\n   * @return never be empty list when serviceName is same with self\n   */",
        "source_code": "\n@Override\npublic List<ServiceInstance> getInstances(String serviceName) {\n  if (Objects.equals(serviceName, this.selfInstance.getServiceName())) {\n    List<ServiceInstance> serviceInstances = this.delegate.getInstances(serviceName);\n    if (containSelf(serviceInstances, this.selfInstance)) {\n      // contains self instance already\n      return serviceInstances;\n    }\n\n    // add self instance to result\n    List<ServiceInstance> result = new ArrayList<>(serviceInstances.size() + 1);\n    result.add(this.selfInstance);\n    result.addAll(serviceInstances);\n    return result;\n  } else {\n    return this.delegate.getInstances(serviceName);\n  }\n}\n",
        "class_name": "DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl",
        "method_name": "getInstances",
        "argument_name": [
            "String serviceName"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.biz.registry;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * decorator pattern\n * <p>\n * when database crash, even cannot register self instance to database,\n * <p>\n * this decorator will ensure return's result contains self instance.\n */\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl\n  implements DatabaseDiscoveryClient {\n\n  private final DatabaseDiscoveryClient delegate;\n\n  private final ServiceInstance selfInstance;\n\n  public DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(\n      DatabaseDiscoveryClient delegate,\n      ServiceInstance selfInstance\n  ) {\n    this.delegate = delegate;\n    this.selfInstance = selfInstance;\n  }\n\n  static boolean containSelf(List<ServiceInstance> serviceInstances, ServiceInstance selfInstance) {\n    final String selfServiceName = selfInstance.getServiceName();\n    final URI selfUri = selfInstance.getUri();\n    final String cluster = selfInstance.getCluster();\n    for (ServiceInstance serviceInstance : serviceInstances) {\n      if (Objects.equals(selfServiceName, serviceInstance.getServiceName())) {\n        if (Objects.equals(selfUri, serviceInstance.getUri())) {\n          if (Objects.equals(cluster, serviceInstance.getCluster())) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * if the serviceName is same with self, always return self's instance\n   * @return never be empty list when serviceName is same with self\n   */\n  @Override\n  public List<ServiceInstance> getInstances(String serviceName) {\n    if (Objects.equals(serviceName, this.selfInstance.getServiceName())) {\n      List<ServiceInstance> serviceInstances = this.delegate.getInstances(serviceName);\n      if (containSelf(serviceInstances, this.selfInstance)) {\n        // contains self instance already\n        return serviceInstances;\n      }\n\n      // add self instance to result\n      List<ServiceInstance> result = new ArrayList<>(serviceInstances.size() + 1);\n      result.add(this.selfInstance);\n      result.addAll(serviceInstances);\n      return result;\n    } else {\n      return this.delegate.getInstances(serviceName);\n    }\n  }\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.biz.registry;\n\nimport java.net.URI;\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\nimport java.util.Objects;\n\npublic class DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl implements DatabaseDiscoveryClient {\n    final private DatabaseDiscoveryClient delegate;\n    final private ServiceInstance selfInstance;\n    public DatabaseDiscoveryClientAlwaysAddSelfInstanceDecoratorImpl(DatabaseDiscoveryClient delegate, ServiceInstance selfInstance);\n    static boolean containSelf(List<ServiceInstance> serviceInstances, ServiceInstance selfInstance);\n    public List<ServiceInstance> getInstances(String serviceName);\n}\n\n"
    },
    {
        "project_name": "apollo",
        "file_name": "NamespaceBranchService.java",
        "relative_path": "apollo/apollo-biz/src/main/java/com/ctrip/framework/apollo/biz/service/NamespaceBranchService.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.biz.service",
        "docstring": null,
        "source_code": "@Transactional\npublic GrayReleaseRule updateRulesReleaseId(String appId, String clusterName,\n                                 String namespaceName, String branchName,\n                                 long latestReleaseId, String operator) {\n  GrayReleaseRule oldRules = grayReleaseRuleRepository.\n      findTopByAppIdAndClusterNameAndNamespaceNameAndBranchNameOrderByIdDesc(appId, clusterName, namespaceName, branchName);\n\n  if (oldRules == null) {\n    return null;\n  }\n\n  GrayReleaseRule newRules = new GrayReleaseRule();\n  newRules.setBranchStatus(NamespaceBranchStatus.ACTIVE);\n  newRules.setReleaseId(latestReleaseId);\n  newRules.setRules(oldRules.getRules());\n  newRules.setAppId(oldRules.getAppId());\n  newRules.setClusterName(oldRules.getClusterName());\n  newRules.setNamespaceName(oldRules.getNamespaceName());\n  newRules.setBranchName(oldRules.getBranchName());\n  newRules.setDataChangeCreatedBy(operator);\n  newRules.setDataChangeLastModifiedBy(operator);\n\n  grayReleaseRuleRepository.save(newRules);\n\n  grayReleaseRuleRepository.delete(oldRules);\n\n  return newRules;\n}\n",
        "class_name": "NamespaceBranchService",
        "method_name": "updateRulesReleaseId",
        "argument_name": [
            "String appId",
            "String clusterName",
            "String namespaceName",
            "String branchName",
            "long latestReleaseId",
            "String operator"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.biz.service;\n\nimport com.ctrip.framework.apollo.biz.entity.Audit;\nimport com.ctrip.framework.apollo.biz.entity.Cluster;\nimport com.ctrip.framework.apollo.biz.entity.GrayReleaseRule;\nimport com.ctrip.framework.apollo.biz.entity.Namespace;\nimport com.ctrip.framework.apollo.biz.entity.Release;\nimport com.ctrip.framework.apollo.biz.repository.GrayReleaseRuleRepository;\nimport com.ctrip.framework.apollo.common.constants.NamespaceBranchStatus;\nimport com.ctrip.framework.apollo.common.constants.ReleaseOperation;\nimport com.ctrip.framework.apollo.common.constants.ReleaseOperationContext;\nimport com.ctrip.framework.apollo.common.exception.BadRequestException;\nimport com.ctrip.framework.apollo.common.utils.GrayReleaseRuleItemTransformer;\nimport com.ctrip.framework.apollo.common.utils.UniqueKeyGenerator;\nimport com.google.common.collect.Maps;\nimport org.springframework.context.annotation.Lazy;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Map;\n\n@Service\npublic class NamespaceBranchService {\n\n  private final AuditService auditService;\n  private final GrayReleaseRuleRepository grayReleaseRuleRepository;\n  private final ClusterService clusterService;\n  private final ReleaseService releaseService;\n  private final NamespaceService namespaceService;\n  private final ReleaseHistoryService releaseHistoryService;\n\n  public NamespaceBranchService(\n      final AuditService auditService,\n      final GrayReleaseRuleRepository grayReleaseRuleRepository,\n      final ClusterService clusterService,\n      final @Lazy ReleaseService releaseService,\n      final NamespaceService namespaceService,\n      final ReleaseHistoryService releaseHistoryService) {\n    this.auditService = auditService;\n    this.grayReleaseRuleRepository = grayReleaseRuleRepository;\n    this.clusterService = clusterService;\n    this.releaseService = releaseService;\n    this.namespaceService = namespaceService;\n    this.releaseHistoryService = releaseHistoryService;\n  }\n\n  @Transactional\n  public Namespace createBranch(String appId, String parentClusterName, String namespaceName, String operator){\n    Namespace childNamespace = findBranch(appId, parentClusterName, namespaceName);\n    if (childNamespace != null){\n      throw BadRequestException.namespaceNotExists(appId, parentClusterName, namespaceName);\n    }\n\n    Cluster parentCluster = clusterService.findOne(appId, parentClusterName);\n    if (parentCluster == null || parentCluster.getParentClusterId() != 0) {\n      throw BadRequestException.clusterNotExists(parentClusterName);\n    }\n\n    //create child cluster\n    Cluster childCluster = createChildCluster(appId, parentCluster, namespaceName, operator);\n\n    Cluster createdChildCluster = clusterService.saveWithoutInstanceOfAppNamespaces(childCluster);\n\n    //create child namespace\n    childNamespace = createNamespaceBranch(appId, createdChildCluster.getName(),\n                                                        namespaceName, operator);\n    return namespaceService.save(childNamespace);\n  }\n\n  public Namespace findBranch(String appId, String parentClusterName, String namespaceName) {\n    return namespaceService.findChildNamespace(appId, parentClusterName, namespaceName);\n  }\n\n  public GrayReleaseRule findBranchGrayRules(String appId, String clusterName, String namespaceName,\n                                             String branchName) {\n    return grayReleaseRuleRepository\n        .findTopByAppIdAndClusterNameAndNamespaceNameAndBranchNameOrderByIdDesc(appId, clusterName, namespaceName, branchName);\n  }\n\n  @Transactional\n  public void updateBranchGrayRules(String appId, String clusterName, String namespaceName,\n                                    String branchName, GrayReleaseRule newRules) {\n    doUpdateBranchGrayRules(appId, clusterName, namespaceName, branchName, newRules, true, ReleaseOperation.APPLY_GRAY_RULES);\n  }\n\n  private void doUpdateBranchGrayRules(String appId, String clusterName, String namespaceName,\n                                              String branchName, GrayReleaseRule newRules, boolean recordReleaseHistory, int releaseOperation) {\n    GrayReleaseRule oldRules = grayReleaseRuleRepository\n        .findTopByAppIdAndClusterNameAndNamespaceNameAndBranchNameOrderByIdDesc(appId, clusterName, namespaceName, branchName);\n\n    Release latestBranchRelease = releaseService.findLatestActiveRelease(appId, branchName, namespaceName);\n\n    long latestBranchReleaseId = latestBranchRelease != null ? latestBranchRelease.getId() : 0;\n\n    newRules.setReleaseId(latestBranchReleaseId);\n\n    grayReleaseRuleRepository.save(newRules);\n\n    //delete old rules\n    if (oldRules != null) {\n      grayReleaseRuleRepository.delete(oldRules);\n    }\n\n    if (recordReleaseHistory) {\n      Map<String, Object> releaseOperationContext = Maps.newHashMap();\n      releaseOperationContext.put(ReleaseOperationContext.RULES, GrayReleaseRuleItemTransformer\n          .batchTransformFromJSON(newRules.getRules()));\n      if (oldRules != null) {\n        releaseOperationContext.put(ReleaseOperationContext.OLD_RULES,\n            GrayReleaseRuleItemTransformer.batchTransformFromJSON(oldRules.getRules()));\n      }\n      releaseHistoryService.createReleaseHistory(appId, clusterName, namespaceName, branchName, latestBranchReleaseId,\n          latestBranchReleaseId, releaseOperation, releaseOperationContext, newRules.getDataChangeLastModifiedBy());\n    }\n  }\n\n  @Transactional\n  public GrayReleaseRule updateRulesReleaseId(String appId, String clusterName,\n                                   String namespaceName, String branchName,\n                                   long latestReleaseId, String operator) {\n    GrayReleaseRule oldRules = grayReleaseRuleRepository.\n        findTopByAppIdAndClusterNameAndNamespaceNameAndBranchNameOrderByIdDesc(appId, clusterName, namespaceName, branchName);\n\n    if (oldRules == null) {\n      return null;\n    }\n\n    GrayReleaseRule newRules = new GrayReleaseRule();\n    newRules.setBranchStatus(NamespaceBranchStatus.ACTIVE);\n    newRules.setReleaseId(latestReleaseId);\n    newRules.setRules(oldRules.getRules());\n    newRules.setAppId(oldRules.getAppId());\n    newRules.setClusterName(oldRules.getClusterName());\n    newRules.setNamespaceName(oldRules.getNamespaceName());\n    newRules.setBranchName(oldRules.getBranchName());\n    newRules.setDataChangeCreatedBy(operator);\n    newRules.setDataChangeLastModifiedBy(operator);\n\n    grayReleaseRuleRepository.save(newRules);\n\n    grayReleaseRuleRepository.delete(oldRules);\n\n    return newRules;\n  }\n\n  @Transactional\n  public void deleteBranch(String appId, String clusterName, String namespaceName,\n                           String branchName, int branchStatus, String operator) {\n    Cluster toDeleteCluster = clusterService.findOne(appId, branchName);\n    if (toDeleteCluster == null) {\n      return;\n    }\n\n    Release latestBranchRelease = releaseService.findLatestActiveRelease(appId, branchName, namespaceName);\n\n    long latestBranchReleaseId = latestBranchRelease != null ? latestBranchRelease.getId() : 0;\n\n    //update branch rules\n    GrayReleaseRule deleteRule = new GrayReleaseRule();\n    deleteRule.setRules(\"[]\");\n    deleteRule.setAppId(appId);\n    deleteRule.setClusterName(clusterName);\n    deleteRule.setNamespaceName(namespaceName);\n    deleteRule.setBranchName(branchName);\n    deleteRule.setBranchStatus(branchStatus);\n    deleteRule.setDataChangeLastModifiedBy(operator);\n    deleteRule.setDataChangeCreatedBy(operator);\n\n    doUpdateBranchGrayRules(appId, clusterName, namespaceName, branchName, deleteRule, false, -1);\n\n    //delete branch cluster\n    clusterService.delete(toDeleteCluster.getId(), operator);\n\n    int releaseOperation = branchStatus == NamespaceBranchStatus.MERGED ? ReleaseOperation\n        .GRAY_RELEASE_DELETED_AFTER_MERGE : ReleaseOperation.ABANDON_GRAY_RELEASE;\n\n    releaseHistoryService.createReleaseHistory(appId, clusterName, namespaceName, branchName, latestBranchReleaseId,\n        latestBranchReleaseId, releaseOperation, null, operator);\n\n    auditService.audit(\"Branch\", toDeleteCluster.getId(), Audit.OP.DELETE, operator);\n  }\n\n  private Cluster createChildCluster(String appId, Cluster parentCluster,\n                                     String namespaceName, String operator) {\n\n    Cluster childCluster = new Cluster();\n    childCluster.setAppId(appId);\n    childCluster.setParentClusterId(parentCluster.getId());\n    childCluster.setName(UniqueKeyGenerator.generate(appId, parentCluster.getName(), namespaceName));\n    childCluster.setDataChangeCreatedBy(operator);\n    childCluster.setDataChangeLastModifiedBy(operator);\n\n    return childCluster;\n  }\n\n\n  private Namespace createNamespaceBranch(String appId, String clusterName, String namespaceName, String operator) {\n    Namespace childNamespace = new Namespace();\n    childNamespace.setAppId(appId);\n    childNamespace.setClusterName(clusterName);\n    childNamespace.setNamespaceName(namespaceName);\n    childNamespace.setDataChangeLastModifiedBy(operator);\n    childNamespace.setDataChangeCreatedBy(operator);\n    return childNamespace;\n  }\n\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.biz.service;\n\nimport com.ctrip.framework.apollo.biz.entity.Audit;\n\nimport com.ctrip.framework.apollo.biz.entity.Cluster;\n\nimport com.ctrip.framework.apollo.biz.entity.GrayReleaseRule;\n\nimport com.ctrip.framework.apollo.biz.entity.Namespace;\n\nimport com.ctrip.framework.apollo.biz.entity.Release;\n\nimport com.ctrip.framework.apollo.biz.repository.GrayReleaseRuleRepository;\n\nimport com.ctrip.framework.apollo.common.constants.NamespaceBranchStatus;\n\nimport com.ctrip.framework.apollo.common.constants.ReleaseOperation;\n\nimport com.ctrip.framework.apollo.common.constants.ReleaseOperationContext;\n\nimport com.ctrip.framework.apollo.common.exception.BadRequestException;\n\nimport com.ctrip.framework.apollo.common.utils.GrayReleaseRuleItemTransformer;\n\nimport com.ctrip.framework.apollo.common.utils.UniqueKeyGenerator;\n\nimport com.google.common.collect.Maps;\n\nimport org.springframework.context.annotation.Lazy;\n\nimport org.springframework.stereotype.Service;\n\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.Map;\n\npublic class NamespaceBranchService {\n    final private AuditService auditService;\n    final private GrayReleaseRuleRepository grayReleaseRuleRepository;\n    final private ClusterService clusterService;\n    final private ReleaseService releaseService;\n    final private NamespaceService namespaceService;\n    final private ReleaseHistoryService releaseHistoryService;\n    public NamespaceBranchService(AuditService auditService, GrayReleaseRuleRepository grayReleaseRuleRepository, ClusterService clusterService, ReleaseService releaseService, NamespaceService namespaceService, ReleaseHistoryService releaseHistoryService);\n    public Namespace createBranch(String appId, String parentClusterName, String namespaceName, String operator);\n    public Namespace findBranch(String appId, String parentClusterName, String namespaceName);\n    public GrayReleaseRule findBranchGrayRules(String appId, String clusterName, String namespaceName, String branchName);\n    public  updateBranchGrayRules(String appId, String clusterName, String namespaceName, String branchName, GrayReleaseRule newRules);\n    private  doUpdateBranchGrayRules(String appId, String clusterName, String namespaceName, String branchName, GrayReleaseRule newRules, boolean recordReleaseHistory, int releaseOperation);\n    public GrayReleaseRule updateRulesReleaseId(String appId, String clusterName, String namespaceName, String branchName, long latestReleaseId, String operator);\n    public  deleteBranch(String appId, String clusterName, String namespaceName, String branchName, int branchStatus, String operator);\n    private Cluster createChildCluster(String appId, Cluster parentCluster, String namespaceName, String operator);\n    private Namespace createNamespaceBranch(String appId, String clusterName, String namespaceName, String operator);\n}\n\n"
    },
    {
        "project_name": "apollo",
        "file_name": "GlobalDefaultExceptionHandler.java",
        "relative_path": "apollo/apollo-common/src/main/java/com/ctrip/framework/apollo/common/controller/GlobalDefaultExceptionHandler.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.common.controller",
        "docstring": null,
        "source_code": "//\u6253\u5370\u65e5\u5fd7, \u5176\u4e2dlogLevel\u4e3a\u65e5\u5fd7\u7ea7\u522b: ERROR/WARN/DEBUG/INFO/TRACE\nprivate void printLog(String message, Throwable ex, Level logLevel) {\n  switch (logLevel) {\n    case ERROR:\n      logger.error(message, ex);\n      break;\n    case WARN:\n      logger.warn(message, ex);\n      break;\n    case DEBUG:\n      logger.debug(message, ex);\n      break;\n    case INFO:\n      logger.info(message, ex);\n      break;\n    case TRACE:\n      logger.trace(message, ex);\n      break;\n  }\n\n  Tracer.logError(ex);\n}\n",
        "class_name": "GlobalDefaultExceptionHandler",
        "method_name": "printLog",
        "argument_name": [
            "String message",
            "Throwable ex",
            "Level logLevel"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.common.controller;\n\nimport com.ctrip.framework.apollo.common.exception.AbstractApolloHttpException;\nimport com.ctrip.framework.apollo.common.exception.BadRequestException;\nimport com.ctrip.framework.apollo.tracer.Tracer;\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport java.lang.reflect.Type;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.validation.ConstraintViolationException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.slf4j.event.Level;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.validation.ObjectError;\nimport org.springframework.web.HttpMediaTypeException;\nimport org.springframework.web.HttpRequestMethodNotSupportedException;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.client.HttpStatusCodeException;\nimport static org.slf4j.event.Level.ERROR;\nimport static org.slf4j.event.Level.WARN;\nimport static org.springframework.http.HttpStatus.BAD_REQUEST;\nimport static org.springframework.http.HttpStatus.FORBIDDEN;\nimport static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;\n\n@ControllerAdvice\npublic class GlobalDefaultExceptionHandler {\n  private Gson gson = new Gson();\n  private static Type mapType = new TypeToken<Map<String, Object>>() {\n  }.getType();\n\n  private static final Logger logger = LoggerFactory.getLogger(GlobalDefaultExceptionHandler.class);\n\n  //\u5904\u7406\u7cfb\u7edf\u5185\u7f6e\u7684Exception\n  @ExceptionHandler(Throwable.class)\n  public ResponseEntity<Map<String, Object>> exception(HttpServletRequest request, Throwable ex) {\n    return handleError(request, INTERNAL_SERVER_ERROR, ex);\n  }\n\n  @ExceptionHandler({HttpRequestMethodNotSupportedException.class, HttpMediaTypeException.class})\n  public ResponseEntity<Map<String, Object>> badRequest(HttpServletRequest request,\n                                                        ServletException ex) {\n    return handleError(request, BAD_REQUEST, ex, WARN);\n  }\n\n  @ExceptionHandler(HttpStatusCodeException.class)\n  public ResponseEntity<Map<String, Object>> restTemplateException(HttpServletRequest request,\n                                                                   HttpStatusCodeException ex) {\n    return handleError(request, ex.getStatusCode(), ex);\n  }\n\n  @ExceptionHandler(AccessDeniedException.class)\n  public ResponseEntity<Map<String, Object>> accessDeny(HttpServletRequest request,\n                                                        AccessDeniedException ex) {\n    return handleError(request, FORBIDDEN, ex);\n  }\n\n  //\u5904\u7406\u81ea\u5b9a\u4e49Exception\n  @ExceptionHandler({AbstractApolloHttpException.class})\n  public ResponseEntity<Map<String, Object>> badRequest(HttpServletRequest request, AbstractApolloHttpException ex) {\n    return handleError(request, ex.getHttpStatus(), ex);\n  }\n\n  @ExceptionHandler(MethodArgumentNotValidException.class)\n  public ResponseEntity<Map<String, Object>> handleMethodArgumentNotValidException(\n      HttpServletRequest request, MethodArgumentNotValidException ex\n  ) {\n    final Optional<ObjectError> firstError = ex.getBindingResult().getAllErrors().stream().findFirst();\n    if (firstError.isPresent()) {\n      final String firstErrorMessage = firstError.get().getDefaultMessage();\n      return handleError(request, BAD_REQUEST, new BadRequestException(firstErrorMessage));\n    }\n    return handleError(request, BAD_REQUEST, ex);\n  }\n\n  @ExceptionHandler(ConstraintViolationException.class)\n  public ResponseEntity<Map<String, Object>> handleConstraintViolationException(\n      HttpServletRequest request, ConstraintViolationException ex\n  ) {\n    return handleError(request, BAD_REQUEST, new BadRequestException(ex.getMessage()));\n  }\n\n  private ResponseEntity<Map<String, Object>> handleError(HttpServletRequest request,\n                                                          HttpStatus status, Throwable ex) {\n    return handleError(request, status, ex, ERROR);\n  }\n\n  private ResponseEntity<Map<String, Object>> handleError(HttpServletRequest request,\n                                                          HttpStatus status, Throwable ex, Level logLevel) {\n    String message = ex.getMessage();\n    printLog(message, ex, logLevel);\n\n    Map<String, Object> errorAttributes = new HashMap<>();\n    boolean errorHandled = false;\n\n    if (ex instanceof HttpStatusCodeException) {\n      try {\n        //try to extract the original error info if it is thrown from apollo programs, e.g. admin service\n        errorAttributes = gson.fromJson(((HttpStatusCodeException) ex).getResponseBodyAsString(), mapType);\n        status = ((HttpStatusCodeException) ex).getStatusCode();\n        errorHandled = true;\n      } catch (Throwable th) {\n        //ignore\n      }\n    }\n\n    if (!errorHandled) {\n      errorAttributes.put(\"status\", status.value());\n      errorAttributes.put(\"message\", message);\n      errorAttributes.put(\"timestamp\",\n          LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));\n      errorAttributes.put(\"exception\", ex.getClass().getName());\n\n    }\n\n    HttpHeaders headers = new HttpHeaders();\n    headers.setContentType(MediaType.APPLICATION_JSON_UTF8);\n    return new ResponseEntity<>(errorAttributes, headers, status);\n  }\n\n  //\u6253\u5370\u65e5\u5fd7, \u5176\u4e2dlogLevel\u4e3a\u65e5\u5fd7\u7ea7\u522b: ERROR/WARN/DEBUG/INFO/TRACE\n  private void printLog(String message, Throwable ex, Level logLevel) {\n    switch (logLevel) {\n      case ERROR:\n        logger.error(message, ex);\n        break;\n      case WARN:\n        logger.warn(message, ex);\n        break;\n      case DEBUG:\n        logger.debug(message, ex);\n        break;\n      case INFO:\n        logger.info(message, ex);\n        break;\n      case TRACE:\n        logger.trace(message, ex);\n        break;\n    }\n\n    Tracer.logError(ex);\n  }\n\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.common.controller;\n\nimport com.ctrip.framework.apollo.common.exception.AbstractApolloHttpException;\n\nimport com.ctrip.framework.apollo.common.exception.BadRequestException;\n\nimport com.ctrip.framework.apollo.tracer.Tracer;\n\nimport com.google.gson.Gson;\n\nimport com.google.gson.reflect.TypeToken;\n\nimport java.lang.reflect.Type;\n\nimport java.time.LocalDateTime;\n\nimport java.time.format.DateTimeFormatter;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\nimport java.util.Optional;\n\nimport javax.servlet.ServletException;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport javax.validation.ConstraintViolationException;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport org.slf4j.event.Level;\n\nimport org.springframework.http.HttpHeaders;\n\nimport org.springframework.http.HttpStatus;\n\nimport org.springframework.http.MediaType;\n\nimport org.springframework.http.ResponseEntity;\n\nimport org.springframework.security.access.AccessDeniedException;\n\nimport org.springframework.validation.ObjectError;\n\nimport org.springframework.web.HttpMediaTypeException;\n\nimport org.springframework.web.HttpRequestMethodNotSupportedException;\n\nimport org.springframework.web.bind.MethodArgumentNotValidException;\n\nimport org.springframework.web.bind.annotation.ControllerAdvice;\n\nimport org.springframework.web.bind.annotation.ExceptionHandler;\n\nimport org.springframework.web.client.HttpStatusCodeException;\n\nimport static org.slf4j.event.Level.ERROR;\n\nimport static org.slf4j.event.Level.WARN;\n\nimport static org.springframework.http.HttpStatus.BAD_REQUEST;\n\nimport static org.springframework.http.HttpStatus.FORBIDDEN;\n\nimport static org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR;\n\npublic class GlobalDefaultExceptionHandler {\n    private Gson gson;\n    static private Type mapType;\n    static final private Logger logger;\n    public ResponseEntity<Map<String, Object>> exception(HttpServletRequest request, Throwable ex);\n    public ResponseEntity<Map<String, Object>> badRequest(HttpServletRequest request, ServletException ex);\n    public ResponseEntity<Map<String, Object>> restTemplateException(HttpServletRequest request, HttpStatusCodeException ex);\n    public ResponseEntity<Map<String, Object>> accessDeny(HttpServletRequest request, AccessDeniedException ex);\n    public ResponseEntity<Map<String, Object>> badRequest(HttpServletRequest request, AbstractApolloHttpException ex);\n    public ResponseEntity<Map<String, Object>> handleMethodArgumentNotValidException(HttpServletRequest request, MethodArgumentNotValidException ex);\n    public ResponseEntity<Map<String, Object>> handleConstraintViolationException(HttpServletRequest request, ConstraintViolationException ex);\n    private ResponseEntity<Map<String, Object>> handleError(HttpServletRequest request, HttpStatus status, Throwable ex);\n    private ResponseEntity<Map<String, Object>> handleError(HttpServletRequest request, HttpStatus status, Throwable ex, Level logLevel);\n    private  printLog(String message, Throwable ex, Level logLevel);\n}\n\n"
    },
    {
        "project_name": "apollo",
        "file_name": "BeanUtils.java",
        "relative_path": "apollo/apollo-common/src/main/java/com/ctrip/framework/apollo/common/utils/BeanUtils.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.common.utils",
        "docstring": "/**\n   * \u7528\u4e8e\u5c06\u4e00\u4e2a\u5217\u8868\u8f6c\u6362\u4e3a\u5217\u8868\u4e2d\u7684\u5bf9\u8c61\u7684\u67d0\u4e2a\u5c5e\u6027\u6620\u5c04\u5230\u5217\u8868\u4e2d\u7684\u5bf9\u8c61\n   *\n   * <pre>\n   *      List<UserDTO> userList = userService.queryUsers();\n   *      Map<Integer, userDTO> userIdToUser = BeanUtil.mapByKey(\"userId\", userList);\n   * </pre>\n   *\n   * @param key \u5c5e\u6027\u540d\n   */",
        "source_code": "\n@SuppressWarnings(\"unchecked\")\npublic static <K, V> Map<K, V> mapByKey(String key, List<?> list) {\n  Map<K, V> map = new HashMap<>();\n  if (CollectionUtils.isEmpty(list)) {\n    return map;\n  }\n  try {\n    Class<?> clazz = list.get(0).getClass();\n    Field field = deepFindField(clazz, key);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Could not find the key\");\n    }\n    field.setAccessible(true);\n    for (Object o : list) {\n      map.put((K) field.get(o), (V) o);\n    }\n  } catch (Exception e) {\n    throw new BeanUtilsException(e);\n  }\n  return map;\n}\n",
        "class_name": "BeanUtils",
        "method_name": "mapByKey",
        "argument_name": [
            "String key",
            "List<> list"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.common.utils;\n\nimport com.ctrip.framework.apollo.common.exception.BeanUtilsException;\n\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.BeanWrapperImpl;\nimport org.springframework.util.CollectionUtils;\n\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\npublic class BeanUtils {\n\n  /**\n   * <pre>\n   *     List<UserBean> userBeans = userDao.queryUsers();\n   *     List<UserDTO> userDTOs = BeanUtil.batchTransform(UserDTO.class, userBeans);\n   * </pre>\n   */\n  public static <T> List<T> batchTransform(final Class<T> clazz, List<?> srcList) {\n    if (CollectionUtils.isEmpty(srcList)) {\n      return Collections.emptyList();\n    }\n\n    List<T> result = new ArrayList<>(srcList.size());\n    for (Object srcObject : srcList) {\n      result.add(transform(clazz, srcObject));\n    }\n    return result;\n  }\n\n  /**\n   * \u5c01\u88c5{@link org.springframework.beans.BeanUtils#copyProperties}\uff0c\u60ef\u7528\u4e0e\u76f4\u63a5\u5c06\u8f6c\u6362\u7ed3\u679c\u8fd4\u56de\n   *\n   * <pre>\n   *      UserBean userBean = new UserBean(\"username\");\n   *      return BeanUtil.transform(UserDTO.class, userBean);\n   * </pre>\n   */\n  public static <T> T transform(Class<T> clazz, Object src) {\n    if (src == null) {\n      return null;\n    }\n    T instance;\n    try {\n      instance = clazz.newInstance();\n    } catch (Exception e) {\n      throw new BeanUtilsException(e);\n    }\n    org.springframework.beans.BeanUtils.copyProperties(src, instance, getNullPropertyNames(src));\n    return instance;\n  }\n\n  private static String[] getNullPropertyNames(Object source) {\n    final BeanWrapper src = new BeanWrapperImpl(source);\n    PropertyDescriptor[] pds = src.getPropertyDescriptors();\n\n    Set<String> emptyNames = new HashSet<>();\n    for (PropertyDescriptor pd : pds) {\n      Object srcValue = src.getPropertyValue(pd.getName());\n      if (srcValue == null) {\n          emptyNames.add(pd.getName());\n      }\n    }\n    String[] result = new String[emptyNames.size()];\n    return emptyNames.toArray(result);\n  }\n\n  /**\n   * \u7528\u4e8e\u5c06\u4e00\u4e2a\u5217\u8868\u8f6c\u6362\u4e3a\u5217\u8868\u4e2d\u7684\u5bf9\u8c61\u7684\u67d0\u4e2a\u5c5e\u6027\u6620\u5c04\u5230\u5217\u8868\u4e2d\u7684\u5bf9\u8c61\n   *\n   * <pre>\n   *      List<UserDTO> userList = userService.queryUsers();\n   *      Map<Integer, userDTO> userIdToUser = BeanUtil.mapByKey(\"userId\", userList);\n   * </pre>\n   *\n   * @param key \u5c5e\u6027\u540d\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static <K, V> Map<K, V> mapByKey(String key, List<?> list) {\n    Map<K, V> map = new HashMap<>();\n    if (CollectionUtils.isEmpty(list)) {\n      return map;\n    }\n    try {\n      Class<?> clazz = list.get(0).getClass();\n      Field field = deepFindField(clazz, key);\n      if (field == null) {\n          throw new IllegalArgumentException(\"Could not find the key\");\n      }\n      field.setAccessible(true);\n      for (Object o : list) {\n        map.put((K) field.get(o), (V) o);\n      }\n    } catch (Exception e) {\n      throw new BeanUtilsException(e);\n    }\n    return map;\n  }\n\n  /**\n   * \u6839\u636e\u5217\u8868\u91cc\u9762\u7684\u5c5e\u6027\u805a\u5408\n   *\n   * <pre>\n   *       List<ShopDTO> shopList = shopService.queryShops();\n   *       Map<Integer, List<ShopDTO>> city2Shops = BeanUtil.aggByKeyToList(\"cityId\", shopList);\n   * </pre>\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static <K, V> Map<K, List<V>> aggByKeyToList(String key, List<?> list) {\n    Map<K, List<V>> map = new HashMap<>();\n    if (CollectionUtils.isEmpty(list)) {// \u9632\u6b62\u5916\u9762\u4f20\u5165\u7a7alist\n      return map;\n    }\n    try {\n      Class<?> clazz = list.get(0).getClass();\n      Field field = deepFindField(clazz, key);\n      if (field == null) {\n          throw new IllegalArgumentException(\"Could not find the key\");\n      }\n      field.setAccessible(true);\n      for (Object o : list) {\n        K k = (K) field.get(o);\n        map.computeIfAbsent(k, k1 -> new ArrayList<>());\n        map.get(k).add((V) o);\n      }\n    } catch (Exception e) {\n      throw new BeanUtilsException(e);\n    }\n    return map;\n  }\n\n  /**\n   * \u7528\u4e8e\u5c06\u4e00\u4e2a\u5bf9\u8c61\u7684\u5217\u8868\u8f6c\u6362\u4e3a\u5217\u8868\u4e2d\u5bf9\u8c61\u7684\u5c5e\u6027\u96c6\u5408\n   *\n   * <pre>\n   *     List<UserDTO> userList = userService.queryUsers();\n   *     Set<Integer> userIds = BeanUtil.toPropertySet(\"userId\", userList);\n   * </pre>\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static <K> Set<K> toPropertySet(String key, List<?> list) {\n    Set<K> set = new HashSet<>();\n    if (CollectionUtils.isEmpty(list)) {// \u9632\u6b62\u5916\u9762\u4f20\u5165\u7a7alist\n      return set;\n    }\n    try {\n      Class<?> clazz = list.get(0).getClass();\n      Field field = deepFindField(clazz, key);\n      if (field == null) {\n          throw new IllegalArgumentException(\"Could not find the key\");\n      }\n      field.setAccessible(true);\n      for (Object o : list) {\n        set.add((K)field.get(o));\n      }\n    } catch (Exception e) {\n      throw new BeanUtilsException(e);\n    }\n    return set;\n  }\n\n\n  private static Field deepFindField(Class<?> clazz, String key) {\n    Field field = null;\n    while (!clazz.getName().equals(Object.class.getName())) {\n      try {\n        field = clazz.getDeclaredField(key);\n        if (field != null) {\n          break;\n        }\n      } catch (Exception e) {\n        clazz = clazz.getSuperclass();\n      }\n    }\n    return field;\n  }\n\n  /**\n   * \u83b7\u53d6\u67d0\u4e2a\u5bf9\u8c61\u7684\u67d0\u4e2a\u5c5e\u6027\n   */\n  public static Object getProperty(Object obj, String fieldName) {\n    try {\n      Field field = deepFindField(obj.getClass(), fieldName);\n      if (field != null) {\n        field.setAccessible(true);\n        return field.get(obj);\n      }\n    } catch (Exception e) {\n      throw new BeanUtilsException(e);\n    }\n    return null;\n  }\n\n  /**\n   * \u8bbe\u7f6e\u67d0\u4e2a\u5bf9\u8c61\u7684\u67d0\u4e2a\u5c5e\u6027\n   */\n  public static void setProperty(Object obj, String fieldName, Object value) {\n    try {\n      Field field = deepFindField(obj.getClass(), fieldName);\n      if (field != null) {\n        field.setAccessible(true);\n        field.set(obj, value);\n      }\n    } catch (Exception e) {\n      throw new BeanUtilsException(e);\n    }\n  }\n\n  /**\n   *\n   * @param source\n   * @param target\n   */\n  public static void copyProperties(Object source, Object target, String... ignoreProperties) {\n    org.springframework.beans.BeanUtils.copyProperties(source, target, ignoreProperties);\n  }\n\n  /**\n   * The copy will ignore <em>BaseEntity</em> field\n   *\n   * @param source\n   * @param target\n   */\n  public static void copyEntityProperties(Object source, Object target) {\n    org.springframework.beans.BeanUtils.copyProperties(source, target, COPY_IGNORED_PROPERTIES);\n  }\n\n  private static final String[] COPY_IGNORED_PROPERTIES = {\"id\", \"dataChangeCreatedBy\", \"dataChangeCreatedTime\", \"dataChangeLastModifiedTime\"};\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.common.utils;\n\nimport com.ctrip.framework.apollo.common.exception.BeanUtilsException;\n\nimport org.springframework.beans.BeanWrapper;\n\nimport org.springframework.beans.BeanWrapperImpl;\n\nimport org.springframework.util.CollectionUtils;\n\nimport java.beans.PropertyDescriptor;\n\nimport java.lang.reflect.Field;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Set;\n\npublic class BeanUtils {\n    static public List<T> batchTransform(Class<T> clazz, List<> srcList);\n    static public T transform(Class<T> clazz, Object src);\n    static private String getNullPropertyNames(Object source);\n    static public Map<K, V> mapByKey(String key, List<> list);\n    static public Map<K, List<V>> aggByKeyToList(String key, List<> list);\n    static public Set<K> toPropertySet(String key, List<> list);\n    static private Field deepFindField(Class<> clazz, String key);\n    static public Object getProperty(Object obj, String fieldName);\n    static public  setProperty(Object obj, String fieldName, Object value);\n    static public  copyProperties(Object source, Object target, String ignoreProperties);\n    static public  copyEntityProperties(Object source, Object target);\n    static final private String COPY_IGNORED_PROPERTIES;\n}\n\n"
    },
    {
        "project_name": "apollo",
        "file_name": "AppController.java",
        "relative_path": "apollo/apollo-portal/src/main/java/com/ctrip/framework/apollo/openapi/v1/controller/AppController.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.openapi.v1.controller",
        "docstring": "/**\n   * @see com.ctrip.framework.apollo.portal.controller.AppController#create(AppModel)\n   */",
        "source_code": "\n@Transactional\n@PreAuthorize(value = \"@consumerPermissionValidator.hasCreateApplicationPermission(#request)\")\n@PostMapping(value = \"/apps\")\npublic void createApp(\n    @RequestBody OpenCreateAppDTO req,\n    HttpServletRequest request\n) {\n  if (null == req.getApp()) {\n    throw new BadRequestException(\"App is null\");\n  }\n  final OpenAppDTO app = req.getApp();\n  if (null == app.getAppId()) {\n    throw new BadRequestException(\"AppId is null\");\n  }\n  // create app\n  this.appOpenApiService.createApp(req);\n  if (req.isAssignAppRoleToSelf()) {\n    long consumerId = this.consumerAuthUtil.retrieveConsumerId(request);\n    consumerService.assignAppRoleToConsumer(consumerId, app.getAppId());\n  }\n}\n",
        "class_name": "AppController",
        "method_name": "createApp",
        "argument_name": [
            "OpenCreateAppDTO req",
            "HttpServletRequest request"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.openapi.v1.controller;\n\nimport com.ctrip.framework.apollo.common.exception.BadRequestException;\nimport com.ctrip.framework.apollo.openapi.api.AppOpenApiService;\nimport com.ctrip.framework.apollo.openapi.dto.OpenCreateAppDTO;\nimport com.ctrip.framework.apollo.openapi.service.ConsumerService;\nimport com.ctrip.framework.apollo.openapi.util.ConsumerAuthUtil;\nimport com.ctrip.framework.apollo.openapi.dto.OpenAppDTO;\nimport com.ctrip.framework.apollo.openapi.dto.OpenEnvClusterDTO;\nimport com.ctrip.framework.apollo.portal.entity.model.AppModel;\nimport java.util.Arrays;\nimport java.util.Set;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.transaction.Transactional;\nimport org.springframework.security.access.prepost.PreAuthorize;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@RestController(\"openapiAppController\")\n@RequestMapping(\"/openapi/v1\")\npublic class AppController {\n\n  private final ConsumerAuthUtil consumerAuthUtil;\n  private final ConsumerService consumerService;\n  private final AppOpenApiService appOpenApiService;\n\n  public AppController(\n      final ConsumerAuthUtil consumerAuthUtil,\n      final ConsumerService consumerService,\n      AppOpenApiService appOpenApiService) {\n    this.consumerAuthUtil = consumerAuthUtil;\n    this.consumerService = consumerService;\n    this.appOpenApiService = appOpenApiService;\n  }\n\n  /**\n   * @see com.ctrip.framework.apollo.portal.controller.AppController#create(AppModel)\n   */\n  @Transactional\n  @PreAuthorize(value = \"@consumerPermissionValidator.hasCreateApplicationPermission(#request)\")\n  @PostMapping(value = \"/apps\")\n  public void createApp(\n      @RequestBody OpenCreateAppDTO req,\n      HttpServletRequest request\n  ) {\n    if (null == req.getApp()) {\n      throw new BadRequestException(\"App is null\");\n    }\n    final OpenAppDTO app = req.getApp();\n    if (null == app.getAppId()) {\n      throw new BadRequestException(\"AppId is null\");\n    }\n    // create app\n    this.appOpenApiService.createApp(req);\n    if (req.isAssignAppRoleToSelf()) {\n      long consumerId = this.consumerAuthUtil.retrieveConsumerId(request);\n      consumerService.assignAppRoleToConsumer(consumerId, app.getAppId());\n    }\n  }\n\n  @GetMapping(value = \"/apps/{appId}/envclusters\")\n  public List<OpenEnvClusterDTO> getEnvClusterInfo(@PathVariable String appId){\n    return this.appOpenApiService.getEnvClusterInfo(appId);\n  }\n\n  @GetMapping(\"/apps\")\n  public List<OpenAppDTO> findApps(@RequestParam(value = \"appIds\", required = false) String appIds) {\n    if (StringUtils.hasText(appIds)) {\n      return this.appOpenApiService.getAppsInfo(Arrays.asList(appIds.split(\",\")));\n    } else {\n      return this.appOpenApiService.getAllApps();\n    }\n  }\n\n  /**\n   * @return which apps can be operated by open api\n   */\n  @GetMapping(\"/apps/authorized\")\n  public List<OpenAppDTO> findAppsAuthorized(HttpServletRequest request) {\n    long consumerId = this.consumerAuthUtil.retrieveConsumerId(request);\n\n    Set<String> appIds = this.consumerService.findAppIdsAuthorizedByConsumerId(consumerId);\n\n    return this.appOpenApiService.getAppsInfo(new ArrayList<>(appIds));\n  }\n\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.openapi.v1.controller;\n\nimport com.ctrip.framework.apollo.common.exception.BadRequestException;\n\nimport com.ctrip.framework.apollo.openapi.api.AppOpenApiService;\n\nimport com.ctrip.framework.apollo.openapi.dto.OpenCreateAppDTO;\n\nimport com.ctrip.framework.apollo.openapi.service.ConsumerService;\n\nimport com.ctrip.framework.apollo.openapi.util.ConsumerAuthUtil;\n\nimport com.ctrip.framework.apollo.openapi.dto.OpenAppDTO;\n\nimport com.ctrip.framework.apollo.openapi.dto.OpenEnvClusterDTO;\n\nimport com.ctrip.framework.apollo.portal.entity.model.AppModel;\n\nimport java.util.Arrays;\n\nimport java.util.Set;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport javax.transaction.Transactional;\n\nimport org.springframework.security.access.prepost.PreAuthorize;\n\nimport org.springframework.util.StringUtils;\n\nimport org.springframework.web.bind.annotation;\n\nimport java.util.ArrayList;\n\nimport java.util.List;\n\npublic class AppController {\n    final private ConsumerAuthUtil consumerAuthUtil;\n    final private ConsumerService consumerService;\n    final private AppOpenApiService appOpenApiService;\n    public AppController(ConsumerAuthUtil consumerAuthUtil, ConsumerService consumerService, AppOpenApiService appOpenApiService);\n    public  createApp(OpenCreateAppDTO req, HttpServletRequest request);\n    public List<OpenEnvClusterDTO> getEnvClusterInfo(String appId);\n    public List<OpenAppDTO> findApps(String appIds);\n    public List<OpenAppDTO> findAppsAuthorized(HttpServletRequest request);\n}\n\n"
    },
    {
        "project_name": "apollo",
        "file_name": "Env.java",
        "relative_path": "apollo/apollo-portal/src/main/java/com/ctrip/framework/apollo/portal/environment/Env.java",
        "execute_path": "apollo",
        "package": "com.ctrip.framework.apollo.portal.environment",
        "docstring": "/**\n   * add some change to environment name trim and to upper\n   *\n   * @param envName\n   * @return\n   */",
        "source_code": "\nprivate static String getWellFormName(String envName) {\n  if (StringUtils.isBlank(envName)) {\n    return \"\";\n  }\n\n  String envWellFormName = envName.trim().toUpperCase();\n\n  // special case for production in case of typo\n  if (\"PROD\".equals(envWellFormName)) {\n    return Env.PRO.name;\n  }\n\n  // special case that FAT & FWS should map to FAT\n  if (\"FWS\".equals(envWellFormName)) {\n    return Env.FAT.name;\n  }\n\n  return envWellFormName;\n}\n",
        "class_name": "Env",
        "method_name": "getWellFormName",
        "argument_name": [
            "String envName"
        ],
        "full_context": "/*\n * Copyright 2023 Apollo Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\npackage com.ctrip.framework.apollo.portal.environment;\n\nimport com.ctrip.framework.apollo.core.utils.StringUtils;\nimport com.google.common.base.Preconditions;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class provides functionalities to manage and hold all environments of the portal. By default\n * all the Env from {@link com.ctrip.framework.apollo.core.enums.Env} are included.\n *\n * @author wxq\n * @author Diego Krupitza(info@diegokrupitza.com)\n */\npublic class Env {\n\n  private static final Logger logger = LoggerFactory.getLogger(Env.class);\n  // use to cache Env\n  private static final Map<String, Env> STRING_ENV_MAP = new ConcurrentHashMap<>();\n  // default environments\n  public static final Env LOCAL = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.LOCAL.name());\n  public static final Env DEV = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.DEV.name());\n  public static final Env FAT = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.FAT.name());\n  public static final Env FWS = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.FWS.name());\n  public static final Env UAT = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.UAT.name());\n  public static final Env LPT = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.LPT.name());\n  public static final Env PRO = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.PRO.name());\n  public static final Env TOOLS = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.TOOLS.name());\n  public static final Env UNKNOWN = addEnvironment(\n      com.ctrip.framework.apollo.core.enums.Env.UNKNOWN.name());\n  // name of environment, cannot be null\n  private final String name;\n\n  /**\n   * Cannot create by other\n   *\n   * @param name\n   */\n  private Env(String name) {\n    this.name = name;\n  }\n\n  /**\n   * add some change to environment name trim and to upper\n   *\n   * @param envName\n   * @return\n   */\n  private static String getWellFormName(String envName) {\n    if (StringUtils.isBlank(envName)) {\n      return \"\";\n    }\n\n    String envWellFormName = envName.trim().toUpperCase();\n\n    // special case for production in case of typo\n    if (\"PROD\".equals(envWellFormName)) {\n      return Env.PRO.name;\n    }\n\n    // special case that FAT & FWS should map to FAT\n    if (\"FWS\".equals(envWellFormName)) {\n      return Env.FAT.name;\n    }\n\n    return envWellFormName;\n  }\n\n  /**\n   * logic same as {@link com.ctrip.framework.apollo.core.enums.EnvUtils#transformEnv}\n   *\n   * @param envName the name we want to transform\n   * @return the env object matching the <code>envName</code>\n   */\n  public static Env transformEnv(String envName) {\n    final String envWellFormName = getWellFormName(envName);\n\n    if (Env.exists(envWellFormName)) {\n      return Env.valueOf(envWellFormName);\n    }\n    // cannot be found or blank name\n    return Env.UNKNOWN;\n  }\n\n  /**\n   * a environment name exist or not\n   *\n   * @param name the name we want to check if it exists\n   * @return does the env name exists or not\n   */\n  public static boolean exists(String name) {\n    name = getWellFormName(name);\n    return STRING_ENV_MAP.containsKey(name);\n  }\n\n  /**\n   * add an environment\n   *\n   * @param name the name of the environment to add\n   * @return the newly created environment\n   */\n  public static Env addEnvironment(String name) {\n    if (StringUtils.isBlank(name)) {\n      throw new RuntimeException(\"Cannot add a blank environment: \" + \"[\" + name + \"]\");\n    }\n\n    name = getWellFormName(name);\n    if (STRING_ENV_MAP.containsKey(name)) {\n      // has been existed\n      logger.debug(\"{} already exists.\", name);\n    } else {\n      // not existed\n      STRING_ENV_MAP.put(name, new Env(name));\n    }\n    return STRING_ENV_MAP.get(name);\n  }\n\n  /**\n   * replace valueOf in enum But what would happened if environment not exist?\n   *\n   * @param name\n   * @return\n   * @throws IllegalArgumentException if this existed environment has no Env with the specified\n   *                                  name\n   */\n  public static Env valueOf(String name) {\n    name = getWellFormName(name);\n    if (exists(name)) {\n      return STRING_ENV_MAP.get(name);\n    } else {\n      throw new IllegalArgumentException(name + \" not exist\");\n    }\n  }\n\n  /**\n   * Please use {@code Env.valueOf} instead this method\n   *\n   * @param env\n   * @return\n   */\n  @Deprecated\n  public static Env fromString(String env) {\n    Env environment = transformEnv(env);\n    Preconditions.checkArgument(environment != UNKNOWN, String.format(\"Env %s is invalid\", env));\n    return environment;\n  }\n\n  /**\n   * conversion key from {@link String} to {@link Env}\n   *\n   * @param metaServerAddresses key is environment, value is environment's meta server address\n   * @return relationship between {@link Env} and meta server address\n   */\n  static Map<Env, String> transformToEnvMap(Map<String, String> metaServerAddresses) {\n    // add to domain\n    Map<Env, String> map = new ConcurrentHashMap<>();\n    for (Map.Entry<String, String> entry : metaServerAddresses.entrySet()) {\n      // add new environment\n      Env env = Env.addEnvironment(entry.getKey());\n      // get meta server address value\n      String value = entry.getValue();\n      // put pair (Env, meta server address)\n      map.put(env, value);\n    }\n    return map;\n  }\n\n  /**\n   * Not just name in Env, the address of Env must be same, or it will throw {@code\n   * RuntimeException}\n   *\n   * @param o\n   * @return\n   * @throws RuntimeException When same name but different address\n   */\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Env env = (Env) o;\n    if (getName().equals(env.getName())) {\n      throw new RuntimeException(getName() + \" is same environment name, but their Env not same\");\n    } else {\n      return false;\n    }\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(getName());\n  }\n\n  /**\n   * a Env convert to string, ie its name.\n   *\n   * @return\n   */\n  @Override\n  public String toString() {\n    return name;\n  }\n\n  public String getName() {\n    return name;\n  }\n}\n",
        "simple_context": "package com.ctrip.framework.apollo.portal.environment;\n\nimport com.ctrip.framework.apollo.core.utils.StringUtils;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\npublic class Env {\n    static final private Logger logger;\n    static final private Map<String, Env> STRING_ENV_MAP;\n    static public final Env LOCAL;\n    static public final Env DEV;\n    static public final Env FAT;\n    static public final Env FWS;\n    static public final Env UAT;\n    static public final Env LPT;\n    static public final Env PRO;\n    static public final Env TOOLS;\n    static public final Env UNKNOWN;\n    final private String name;\n    private Env(String name);\n    static private String getWellFormName(String envName);\n    static public Env transformEnv(String envName);\n    static public boolean exists(String name);\n    static public Env addEnvironment(String name);\n    static public Env valueOf(String name);\n    static public Env fromString(String env);\n    static Map<Env, String> transformToEnvMap(Map<String, String> metaServerAddresses);\n    public boolean equals(Object o);\n    public int hashCode();\n    public String toString();\n    public String getName();\n}\n\n"
    }
]