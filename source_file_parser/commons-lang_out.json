[
    {
        "project_name": "commons-lang",
        "file_name": "CompareToBuilder.java",
        "relative_path": "commons-lang/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java",
        "execute_path": "commons-lang",
        "package": "org.apache.commons.lang3.builder",
        "docstring": "/**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code boolean} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */",
        "source_code": "\npublic CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "argument_name": [
            "boolean[] lhs",
            "boolean[] rhs"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ObjectUtils;\n\n/**\n * Assists in implementing {@link Comparable#compareTo(Object)} methods.\n *\n * <p>It is consistent with {@code equals(Object)} and\n * {@code hashCode()} built with {@link EqualsBuilder} and\n * {@link HashCodeBuilder}.</p>\n *\n * <p>Two Objects that compare equal using {@code equals(Object)} should normally\n * also compare equal using {@code compareTo(Object)}.</p>\n *\n * <p>All relevant fields should be included in the calculation of the\n * comparison. Derived fields may be ignored. The same fields, in the same\n * order, should be used in both {@code compareTo(Object)} and\n * {@code equals(Object)}.</p>\n *\n * <p>To use this class write code as follows:</p>\n *\n * <pre>\n * public class MyClass {\n *   String field1;\n *   int field2;\n *   boolean field3;\n *\n *   ...\n *\n *   public int compareTo(Object o) {\n *     MyClass myClass = (MyClass) o;\n *     return new CompareToBuilder()\n *       .appendSuper(super.compareTo(o)\n *       .append(this.field1, myClass.field1)\n *       .append(this.field2, myClass.field2)\n *       .append(this.field3, myClass.field3)\n *       .toComparison();\n *   }\n * }\n * </pre>\n *\n * <p>Values are compared in the order they are appended to the builder. If any comparison returns\n * a non-zero result, then that value will be the result returned by {@code toComparison()} and all\n * subsequent comparisons are skipped.</p>\n *\n * <p>Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use\n * reflection to determine the fields to append. Because fields can be private,\n * {@code reflectionCompare} uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to\n * bypass normal access control checks. This will fail under a security manager,\n * unless the appropriate permissions are set up correctly. It is also\n * slower than appending explicitly.</p>\n *\n * <p>A typical implementation of {@code compareTo(Object)} using\n * {@code reflectionCompare} looks like:</p>\n\n * <pre>\n * public int compareTo(Object o) {\n *   return CompareToBuilder.reflectionCompare(this, o);\n * }\n * </pre>\n *\n * <p>The reflective methods compare object fields in the order returned by\n * {@link Class#getDeclaredFields()}. The fields of the class are compared first, followed by those\n * of its parent classes (in order from the bottom to the top of the class hierarchy).</p>\n *\n * @see Comparable\n * @see Object#equals(Object)\n * @see Object#hashCode()\n * @see EqualsBuilder\n * @see HashCodeBuilder\n * @since 1.0\n */\npublic class CompareToBuilder implements Builder<Integer> {\n\n    /**\n     * Appends to {@code builder} the comparison of {@code lhs}\n     * to {@code rhs} using the fields defined in {@code clazz}.\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param clazz  {@link Class} that defines fields to be compared\n     * @param builder  {@link CompareToBuilder} to append to\n     * @param useTransients  whether to compare transient fields\n     * @param excludeFields  fields to exclude\n     */\n    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field field = fields[i];\n            if (!ArrayUtils.contains(excludeFields, field.getName())\n                && !field.getName().contains(\"$\")\n                && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                && !Modifier.isStatic(field.getModifiers())) {\n                // IllegalAccessException can't happen. Would get a Security exception instead.\n                // Throw a runtime exception in case the impossible happens.\n                builder.append(Reflection.getUnchecked(field, lhs), Reflection.getUnchecked(field, rhs));\n            }\n        }\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>Transient members will be not be compared, as they are likely derived\n     *     fields</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either (but not both) parameters are\n     *  {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs) {\n        return reflectionCompare(lhs, rhs, false, null);\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param compareTransients  whether to compare transient fields\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) {\n        return reflectionCompare(lhs, rhs, compareTransients, null);\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If the {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Compares superclass fields up to and including {@code reflectUpToClass}.\n     *     If {@code reflectUpToClass} is {@code null}, compares all superclass fields.</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param compareTransients  whether to compare transient fields\n     * @param reflectUpToClass  last superclass for which fields are compared\n     * @param excludeFields  fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2 (2.0 as {@code reflectionCompare(Object, Object, boolean, Class)})\n     */\n    public static int reflectionCompare(\n        final Object lhs,\n        final Object rhs,\n        final boolean compareTransients,\n        final Class<?> reflectUpToClass,\n        final String... excludeFields) {\n\n        if (lhs == rhs) {\n            return 0;\n        }\n        Objects.requireNonNull(lhs, \"lhs\");\n        Objects.requireNonNull(rhs, \"rhs\");\n\n        Class<?> lhsClazz = lhs.getClass();\n        if (!lhsClazz.isInstance(rhs)) {\n            throw new ClassCastException();\n        }\n        final CompareToBuilder compareToBuilder = new CompareToBuilder();\n        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n            lhsClazz = lhsClazz.getSuperclass();\n            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        }\n        return compareToBuilder.toComparison();\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param excludeFields  Collection of String fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields) {\n        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param excludeFields  array of fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields) {\n        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n    }\n\n    /**\n     * Current state of the comparison as appended fields are checked.\n     */\n    private int comparison;\n\n    /**\n     * Constructor for CompareToBuilder.\n     *\n     * <p>Starts off assuming that the objects are equal. Multiple calls are\n     * then made to the various append methods, followed by a call to\n     * {@link #toComparison} to get the result.</p>\n     */\n    public CompareToBuilder() {\n        comparison = 0;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code booleans}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n      */\n    public CompareToBuilder append(final boolean lhs, final boolean rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs) {\n            comparison = 1;\n        } else {\n            comparison = -1;\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code boolean} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code byte}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final byte lhs, final byte rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Byte.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code byte} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code char}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final char lhs, final char rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Character.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code char} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(char, char)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final char[] lhs, final char[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code double}s.\n     *\n     * <p>This handles NaNs, Infinities, and {@code -0.0}.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * {@link HashCodeBuilder}.</p>\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final double lhs, final double rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Double.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code double} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(double, double)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final double[] lhs, final double[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code float}s.\n     *\n     * <p>This handles NaNs, Infinities, and {@code -0.0}.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * {@link HashCodeBuilder}.</p>\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final float lhs, final float rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Float.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code float} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(float, float)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final float[] lhs, final float[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code int}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final int lhs, final int rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Integer.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code int} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(int, int)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final int[] lhs, final int[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code long}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final long lhs, final long rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Long.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code long} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(long, long)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final long[] lhs, final long[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@link Object}s.\n     *\n     * <ol>\n     * <li>Check if {@code lhs == rhs}</li>\n     * <li>Check if either {@code lhs} or {@code rhs} is {@code null},\n     *     a {@code null} object is less than a non-{@code null} object</li>\n     * <li>Check the object contents</li>\n     * </ol>\n     *\n     * <p>{@code lhs} must either be an array or implement {@link Comparable}.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public CompareToBuilder append(final Object lhs, final Object rhs) {\n        return append(lhs, rhs, null);\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@link Object}s.\n     *\n     * <ol>\n     * <li>Check if {@code lhs == rhs}</li>\n     * <li>Check if either {@code lhs} or {@code rhs} is {@code null},\n     *     a {@code null} object is less than a non-{@code null} object</li>\n     * <li>Check the object contents</li>\n     * </ol>\n     *\n     * <p>If {@code lhs} is an array, array comparison methods will be used.\n     * Otherwise {@code comparator} will be used to compare the objects.\n     * If {@code comparator} is {@code null}, {@code lhs} must\n     * implement {@link Comparable} instead.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param comparator  {@link Comparator} used to compare the objects,\n     *  {@code null} means treat lhs as {@link Comparable}\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.0\n     */\n    public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (ObjectUtils.isArray(lhs)) {\n            // factor out array case in order to keep method small enough to be inlined\n            appendArray(lhs, rhs, comparator);\n        } else // the simple case, not an array, just test the element\n        if (comparator == null) {\n            @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n            final Comparable<Object> comparable = (Comparable<Object>) lhs;\n            comparison = comparable.compareTo(rhs);\n        } else {\n            @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n            final Comparator<Object> comparator2 = (Comparator<Object>) comparator;\n            comparison = comparator2.compare(lhs, rhs);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@link Object} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a short length array is less than a long length array</li>\n     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n     * </ol>\n     *\n     * <p>This method will also will be called for the top level of multi-dimensional,\n     * ragged, and multi-typed arrays.</p>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs) {\n        return append(lhs, rhs, null);\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@link Object} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a short length array is less than a long length array</li>\n     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n     * </ol>\n     *\n     * <p>This method will also will be called for the top level of multi-dimensional,\n     * ragged, and multi-typed arrays.</p>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @param comparator  {@link Comparator} to use to compare the array elements,\n     *  {@code null} means to treat {@code lhs} elements as {@link Comparable}.\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.0\n     */\n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i], comparator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code short}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final short lhs, final short rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Short.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code short} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(short, short)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final short[] lhs, final short[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    private void appendArray(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        // switch on type of array, to dispatch to the correct handler\n        // handles multidimensional arrays\n        // throws a ClassCastException if rhs is not the correct array type\n        if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // not an array of primitives\n            // throws a ClassCastException if rhs is not an array\n            append((Object[]) lhs, (Object[]) rhs, comparator);\n        }\n    }\n\n    /**\n     * Appends to the {@code builder} the {@code compareTo(Object)}\n     * result of the superclass.\n     *\n     * @param superCompareTo  result of calling {@code super.compareTo(Object)}\n     * @return this\n     * @since 2.0\n     */\n    public CompareToBuilder appendSuper(final int superCompareTo) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = superCompareTo;\n        return this;\n    }\n\n    /**\n     * Returns a negative Integer, a positive Integer, or zero as\n     * the {@code builder} has judged the \"left-hand\" side\n     * as less than, greater than, or equal to the \"right-hand\"\n     * side.\n     *\n     * @return final comparison result as an Integer\n     * @see #toComparison()\n     * @since 3.0\n     */\n    @Override\n    public Integer build() {\n        return Integer.valueOf(toComparison());\n    }\n\n    /**\n     * Returns a negative integer, a positive integer, or zero as\n     * the {@code builder} has judged the \"left-hand\" side\n     * as less than, greater than, or equal to the \"right-hand\"\n     * side.\n     *\n     * @return final comparison result\n     * @see #build()\n     */\n    public int toComparison() {\n        return comparison;\n    }\n}\n\n",
        "simple_context": "package org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Collection;\n\nimport java.util.Comparator;\n\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\npublic class CompareToBuilder implements Builder<Integer> {\n    static private  reflectionAppend(Object lhs, Object rhs, Class<> clazz, CompareToBuilder builder, boolean useTransients, String excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs);\n    static public int reflectionCompare(Object lhs, Object rhs, boolean compareTransients);\n    static public int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, Class<> reflectUpToClass, String excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs, Collection<String> excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs, String excludeFields);\n    private int comparison;\n    public CompareToBuilder();\n    public CompareToBuilder append(boolean lhs, boolean rhs);\n    public CompareToBuilder append(boolean[] lhs, boolean[] rhs);\n    public CompareToBuilder append(byte lhs, byte rhs);\n    public CompareToBuilder append(byte[] lhs, byte[] rhs);\n    public CompareToBuilder append(char lhs, char rhs);\n    public CompareToBuilder append(char[] lhs, char[] rhs);\n    public CompareToBuilder append(double lhs, double rhs);\n    public CompareToBuilder append(double[] lhs, double[] rhs);\n    public CompareToBuilder append(float lhs, float rhs);\n    public CompareToBuilder append(float[] lhs, float[] rhs);\n    public CompareToBuilder append(int lhs, int rhs);\n    public CompareToBuilder append(int[] lhs, int[] rhs);\n    public CompareToBuilder append(long lhs, long rhs);\n    public CompareToBuilder append(long[] lhs, long[] rhs);\n    public CompareToBuilder append(Object lhs, Object rhs);\n    public CompareToBuilder append(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder append(Object lhs, Object rhs);\n    public CompareToBuilder append(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder append(short lhs, short rhs);\n    public CompareToBuilder append(short[] lhs, short[] rhs);\n    private  appendArray(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder appendSuper(int superCompareTo);\n    public Integer build();\n    public int toComparison();\n}\n\n"
    },
    {
        "project_name": "commons-lang",
        "file_name": "CompareToBuilder.java",
        "relative_path": "commons-lang/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java",
        "execute_path": "commons-lang",
        "package": "org.apache.commons.lang3.builder",
        "docstring": "/**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code byte} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */",
        "source_code": "\npublic CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "argument_name": [
            "byte[] lhs",
            "byte[] rhs"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ObjectUtils;\n\n/**\n * Assists in implementing {@link Comparable#compareTo(Object)} methods.\n *\n * <p>It is consistent with {@code equals(Object)} and\n * {@code hashCode()} built with {@link EqualsBuilder} and\n * {@link HashCodeBuilder}.</p>\n *\n * <p>Two Objects that compare equal using {@code equals(Object)} should normally\n * also compare equal using {@code compareTo(Object)}.</p>\n *\n * <p>All relevant fields should be included in the calculation of the\n * comparison. Derived fields may be ignored. The same fields, in the same\n * order, should be used in both {@code compareTo(Object)} and\n * {@code equals(Object)}.</p>\n *\n * <p>To use this class write code as follows:</p>\n *\n * <pre>\n * public class MyClass {\n *   String field1;\n *   int field2;\n *   boolean field3;\n *\n *   ...\n *\n *   public int compareTo(Object o) {\n *     MyClass myClass = (MyClass) o;\n *     return new CompareToBuilder()\n *       .appendSuper(super.compareTo(o)\n *       .append(this.field1, myClass.field1)\n *       .append(this.field2, myClass.field2)\n *       .append(this.field3, myClass.field3)\n *       .toComparison();\n *   }\n * }\n * </pre>\n *\n * <p>Values are compared in the order they are appended to the builder. If any comparison returns\n * a non-zero result, then that value will be the result returned by {@code toComparison()} and all\n * subsequent comparisons are skipped.</p>\n *\n * <p>Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use\n * reflection to determine the fields to append. Because fields can be private,\n * {@code reflectionCompare} uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to\n * bypass normal access control checks. This will fail under a security manager,\n * unless the appropriate permissions are set up correctly. It is also\n * slower than appending explicitly.</p>\n *\n * <p>A typical implementation of {@code compareTo(Object)} using\n * {@code reflectionCompare} looks like:</p>\n\n * <pre>\n * public int compareTo(Object o) {\n *   return CompareToBuilder.reflectionCompare(this, o);\n * }\n * </pre>\n *\n * <p>The reflective methods compare object fields in the order returned by\n * {@link Class#getDeclaredFields()}. The fields of the class are compared first, followed by those\n * of its parent classes (in order from the bottom to the top of the class hierarchy).</p>\n *\n * @see Comparable\n * @see Object#equals(Object)\n * @see Object#hashCode()\n * @see EqualsBuilder\n * @see HashCodeBuilder\n * @since 1.0\n */\npublic class CompareToBuilder implements Builder<Integer> {\n\n    /**\n     * Appends to {@code builder} the comparison of {@code lhs}\n     * to {@code rhs} using the fields defined in {@code clazz}.\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param clazz  {@link Class} that defines fields to be compared\n     * @param builder  {@link CompareToBuilder} to append to\n     * @param useTransients  whether to compare transient fields\n     * @param excludeFields  fields to exclude\n     */\n    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field field = fields[i];\n            if (!ArrayUtils.contains(excludeFields, field.getName())\n                && !field.getName().contains(\"$\")\n                && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                && !Modifier.isStatic(field.getModifiers())) {\n                // IllegalAccessException can't happen. Would get a Security exception instead.\n                // Throw a runtime exception in case the impossible happens.\n                builder.append(Reflection.getUnchecked(field, lhs), Reflection.getUnchecked(field, rhs));\n            }\n        }\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>Transient members will be not be compared, as they are likely derived\n     *     fields</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either (but not both) parameters are\n     *  {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs) {\n        return reflectionCompare(lhs, rhs, false, null);\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param compareTransients  whether to compare transient fields\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) {\n        return reflectionCompare(lhs, rhs, compareTransients, null);\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If the {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Compares superclass fields up to and including {@code reflectUpToClass}.\n     *     If {@code reflectUpToClass} is {@code null}, compares all superclass fields.</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param compareTransients  whether to compare transient fields\n     * @param reflectUpToClass  last superclass for which fields are compared\n     * @param excludeFields  fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2 (2.0 as {@code reflectionCompare(Object, Object, boolean, Class)})\n     */\n    public static int reflectionCompare(\n        final Object lhs,\n        final Object rhs,\n        final boolean compareTransients,\n        final Class<?> reflectUpToClass,\n        final String... excludeFields) {\n\n        if (lhs == rhs) {\n            return 0;\n        }\n        Objects.requireNonNull(lhs, \"lhs\");\n        Objects.requireNonNull(rhs, \"rhs\");\n\n        Class<?> lhsClazz = lhs.getClass();\n        if (!lhsClazz.isInstance(rhs)) {\n            throw new ClassCastException();\n        }\n        final CompareToBuilder compareToBuilder = new CompareToBuilder();\n        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n            lhsClazz = lhsClazz.getSuperclass();\n            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        }\n        return compareToBuilder.toComparison();\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param excludeFields  Collection of String fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields) {\n        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param excludeFields  array of fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields) {\n        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n    }\n\n    /**\n     * Current state of the comparison as appended fields are checked.\n     */\n    private int comparison;\n\n    /**\n     * Constructor for CompareToBuilder.\n     *\n     * <p>Starts off assuming that the objects are equal. Multiple calls are\n     * then made to the various append methods, followed by a call to\n     * {@link #toComparison} to get the result.</p>\n     */\n    public CompareToBuilder() {\n        comparison = 0;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code booleans}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n      */\n    public CompareToBuilder append(final boolean lhs, final boolean rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs) {\n            comparison = 1;\n        } else {\n            comparison = -1;\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code boolean} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code byte}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final byte lhs, final byte rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Byte.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code byte} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code char}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final char lhs, final char rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Character.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code char} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(char, char)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final char[] lhs, final char[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code double}s.\n     *\n     * <p>This handles NaNs, Infinities, and {@code -0.0}.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * {@link HashCodeBuilder}.</p>\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final double lhs, final double rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Double.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code double} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(double, double)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final double[] lhs, final double[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code float}s.\n     *\n     * <p>This handles NaNs, Infinities, and {@code -0.0}.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * {@link HashCodeBuilder}.</p>\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final float lhs, final float rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Float.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code float} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(float, float)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final float[] lhs, final float[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code int}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final int lhs, final int rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Integer.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code int} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(int, int)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final int[] lhs, final int[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code long}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final long lhs, final long rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Long.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code long} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(long, long)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final long[] lhs, final long[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@link Object}s.\n     *\n     * <ol>\n     * <li>Check if {@code lhs == rhs}</li>\n     * <li>Check if either {@code lhs} or {@code rhs} is {@code null},\n     *     a {@code null} object is less than a non-{@code null} object</li>\n     * <li>Check the object contents</li>\n     * </ol>\n     *\n     * <p>{@code lhs} must either be an array or implement {@link Comparable}.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public CompareToBuilder append(final Object lhs, final Object rhs) {\n        return append(lhs, rhs, null);\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@link Object}s.\n     *\n     * <ol>\n     * <li>Check if {@code lhs == rhs}</li>\n     * <li>Check if either {@code lhs} or {@code rhs} is {@code null},\n     *     a {@code null} object is less than a non-{@code null} object</li>\n     * <li>Check the object contents</li>\n     * </ol>\n     *\n     * <p>If {@code lhs} is an array, array comparison methods will be used.\n     * Otherwise {@code comparator} will be used to compare the objects.\n     * If {@code comparator} is {@code null}, {@code lhs} must\n     * implement {@link Comparable} instead.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param comparator  {@link Comparator} used to compare the objects,\n     *  {@code null} means treat lhs as {@link Comparable}\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.0\n     */\n    public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (ObjectUtils.isArray(lhs)) {\n            // factor out array case in order to keep method small enough to be inlined\n            appendArray(lhs, rhs, comparator);\n        } else // the simple case, not an array, just test the element\n        if (comparator == null) {\n            @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n            final Comparable<Object> comparable = (Comparable<Object>) lhs;\n            comparison = comparable.compareTo(rhs);\n        } else {\n            @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n            final Comparator<Object> comparator2 = (Comparator<Object>) comparator;\n            comparison = comparator2.compare(lhs, rhs);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@link Object} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a short length array is less than a long length array</li>\n     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n     * </ol>\n     *\n     * <p>This method will also will be called for the top level of multi-dimensional,\n     * ragged, and multi-typed arrays.</p>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs) {\n        return append(lhs, rhs, null);\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@link Object} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a short length array is less than a long length array</li>\n     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n     * </ol>\n     *\n     * <p>This method will also will be called for the top level of multi-dimensional,\n     * ragged, and multi-typed arrays.</p>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @param comparator  {@link Comparator} to use to compare the array elements,\n     *  {@code null} means to treat {@code lhs} elements as {@link Comparable}.\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.0\n     */\n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i], comparator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code short}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final short lhs, final short rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Short.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code short} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(short, short)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final short[] lhs, final short[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    private void appendArray(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        // switch on type of array, to dispatch to the correct handler\n        // handles multidimensional arrays\n        // throws a ClassCastException if rhs is not the correct array type\n        if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // not an array of primitives\n            // throws a ClassCastException if rhs is not an array\n            append((Object[]) lhs, (Object[]) rhs, comparator);\n        }\n    }\n\n    /**\n     * Appends to the {@code builder} the {@code compareTo(Object)}\n     * result of the superclass.\n     *\n     * @param superCompareTo  result of calling {@code super.compareTo(Object)}\n     * @return this\n     * @since 2.0\n     */\n    public CompareToBuilder appendSuper(final int superCompareTo) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = superCompareTo;\n        return this;\n    }\n\n    /**\n     * Returns a negative Integer, a positive Integer, or zero as\n     * the {@code builder} has judged the \"left-hand\" side\n     * as less than, greater than, or equal to the \"right-hand\"\n     * side.\n     *\n     * @return final comparison result as an Integer\n     * @see #toComparison()\n     * @since 3.0\n     */\n    @Override\n    public Integer build() {\n        return Integer.valueOf(toComparison());\n    }\n\n    /**\n     * Returns a negative integer, a positive integer, or zero as\n     * the {@code builder} has judged the \"left-hand\" side\n     * as less than, greater than, or equal to the \"right-hand\"\n     * side.\n     *\n     * @return final comparison result\n     * @see #build()\n     */\n    public int toComparison() {\n        return comparison;\n    }\n}\n\n",
        "simple_context": "package org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Collection;\n\nimport java.util.Comparator;\n\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\npublic class CompareToBuilder implements Builder<Integer> {\n    static private  reflectionAppend(Object lhs, Object rhs, Class<> clazz, CompareToBuilder builder, boolean useTransients, String excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs);\n    static public int reflectionCompare(Object lhs, Object rhs, boolean compareTransients);\n    static public int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, Class<> reflectUpToClass, String excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs, Collection<String> excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs, String excludeFields);\n    private int comparison;\n    public CompareToBuilder();\n    public CompareToBuilder append(boolean lhs, boolean rhs);\n    public CompareToBuilder append(boolean[] lhs, boolean[] rhs);\n    public CompareToBuilder append(byte lhs, byte rhs);\n    public CompareToBuilder append(byte[] lhs, byte[] rhs);\n    public CompareToBuilder append(char lhs, char rhs);\n    public CompareToBuilder append(char[] lhs, char[] rhs);\n    public CompareToBuilder append(double lhs, double rhs);\n    public CompareToBuilder append(double[] lhs, double[] rhs);\n    public CompareToBuilder append(float lhs, float rhs);\n    public CompareToBuilder append(float[] lhs, float[] rhs);\n    public CompareToBuilder append(int lhs, int rhs);\n    public CompareToBuilder append(int[] lhs, int[] rhs);\n    public CompareToBuilder append(long lhs, long rhs);\n    public CompareToBuilder append(long[] lhs, long[] rhs);\n    public CompareToBuilder append(Object lhs, Object rhs);\n    public CompareToBuilder append(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder append(Object lhs, Object rhs);\n    public CompareToBuilder append(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder append(short lhs, short rhs);\n    public CompareToBuilder append(short[] lhs, short[] rhs);\n    private  appendArray(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder appendSuper(int superCompareTo);\n    public Integer build();\n    public int toComparison();\n}\n\n"
    },
    {
        "project_name": "commons-lang",
        "file_name": "CompareToBuilder.java",
        "relative_path": "commons-lang/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java",
        "execute_path": "commons-lang",
        "package": "org.apache.commons.lang3.builder",
        "docstring": "/**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code double} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(double, double)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */",
        "source_code": "\npublic CompareToBuilder append(final double[] lhs, final double[] rhs) {\n    if (comparison != 0) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null) {\n        comparison = -1;\n        return this;\n    }\n    if (rhs == null) {\n        comparison = 1;\n        return this;\n    }\n    if (lhs.length != rhs.length) {\n        comparison = lhs.length < rhs.length ? -1 : 1;\n        return this;\n    }\n    for (int i = 0; i < lhs.length && comparison == 0; i++) {\n        append(lhs[i], rhs[i]);\n    }\n    return this;\n}\n",
        "class_name": "CompareToBuilder",
        "method_name": "append",
        "argument_name": [
            "double[] lhs",
            "double[] rhs"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ObjectUtils;\n\n/**\n * Assists in implementing {@link Comparable#compareTo(Object)} methods.\n *\n * <p>It is consistent with {@code equals(Object)} and\n * {@code hashCode()} built with {@link EqualsBuilder} and\n * {@link HashCodeBuilder}.</p>\n *\n * <p>Two Objects that compare equal using {@code equals(Object)} should normally\n * also compare equal using {@code compareTo(Object)}.</p>\n *\n * <p>All relevant fields should be included in the calculation of the\n * comparison. Derived fields may be ignored. The same fields, in the same\n * order, should be used in both {@code compareTo(Object)} and\n * {@code equals(Object)}.</p>\n *\n * <p>To use this class write code as follows:</p>\n *\n * <pre>\n * public class MyClass {\n *   String field1;\n *   int field2;\n *   boolean field3;\n *\n *   ...\n *\n *   public int compareTo(Object o) {\n *     MyClass myClass = (MyClass) o;\n *     return new CompareToBuilder()\n *       .appendSuper(super.compareTo(o)\n *       .append(this.field1, myClass.field1)\n *       .append(this.field2, myClass.field2)\n *       .append(this.field3, myClass.field3)\n *       .toComparison();\n *   }\n * }\n * </pre>\n *\n * <p>Values are compared in the order they are appended to the builder. If any comparison returns\n * a non-zero result, then that value will be the result returned by {@code toComparison()} and all\n * subsequent comparisons are skipped.</p>\n *\n * <p>Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use\n * reflection to determine the fields to append. Because fields can be private,\n * {@code reflectionCompare} uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to\n * bypass normal access control checks. This will fail under a security manager,\n * unless the appropriate permissions are set up correctly. It is also\n * slower than appending explicitly.</p>\n *\n * <p>A typical implementation of {@code compareTo(Object)} using\n * {@code reflectionCompare} looks like:</p>\n\n * <pre>\n * public int compareTo(Object o) {\n *   return CompareToBuilder.reflectionCompare(this, o);\n * }\n * </pre>\n *\n * <p>The reflective methods compare object fields in the order returned by\n * {@link Class#getDeclaredFields()}. The fields of the class are compared first, followed by those\n * of its parent classes (in order from the bottom to the top of the class hierarchy).</p>\n *\n * @see Comparable\n * @see Object#equals(Object)\n * @see Object#hashCode()\n * @see EqualsBuilder\n * @see HashCodeBuilder\n * @since 1.0\n */\npublic class CompareToBuilder implements Builder<Integer> {\n\n    /**\n     * Appends to {@code builder} the comparison of {@code lhs}\n     * to {@code rhs} using the fields defined in {@code clazz}.\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param clazz  {@link Class} that defines fields to be compared\n     * @param builder  {@link CompareToBuilder} to append to\n     * @param useTransients  whether to compare transient fields\n     * @param excludeFields  fields to exclude\n     */\n    private static void reflectionAppend(\n        final Object lhs,\n        final Object rhs,\n        final Class<?> clazz,\n        final CompareToBuilder builder,\n        final boolean useTransients,\n        final String[] excludeFields) {\n\n        final Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n            final Field field = fields[i];\n            if (!ArrayUtils.contains(excludeFields, field.getName())\n                && !field.getName().contains(\"$\")\n                && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                && !Modifier.isStatic(field.getModifiers())) {\n                // IllegalAccessException can't happen. Would get a Security exception instead.\n                // Throw a runtime exception in case the impossible happens.\n                builder.append(Reflection.getUnchecked(field, lhs), Reflection.getUnchecked(field, rhs));\n            }\n        }\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>Transient members will be not be compared, as they are likely derived\n     *     fields</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either (but not both) parameters are\n     *  {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs) {\n        return reflectionCompare(lhs, rhs, false, null);\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param compareTransients  whether to compare transient fields\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients) {\n        return reflectionCompare(lhs, rhs, compareTransients, null);\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If the {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Compares superclass fields up to and including {@code reflectUpToClass}.\n     *     If {@code reflectUpToClass} is {@code null}, compares all superclass fields.</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param compareTransients  whether to compare transient fields\n     * @param reflectUpToClass  last superclass for which fields are compared\n     * @param excludeFields  fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2 (2.0 as {@code reflectionCompare(Object, Object, boolean, Class)})\n     */\n    public static int reflectionCompare(\n        final Object lhs,\n        final Object rhs,\n        final boolean compareTransients,\n        final Class<?> reflectUpToClass,\n        final String... excludeFields) {\n\n        if (lhs == rhs) {\n            return 0;\n        }\n        Objects.requireNonNull(lhs, \"lhs\");\n        Objects.requireNonNull(rhs, \"rhs\");\n\n        Class<?> lhsClazz = lhs.getClass();\n        if (!lhsClazz.isInstance(rhs)) {\n            throw new ClassCastException();\n        }\n        final CompareToBuilder compareToBuilder = new CompareToBuilder();\n        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n            lhsClazz = lhsClazz.getSuperclass();\n            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n        }\n        return compareToBuilder.toComparison();\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param excludeFields  Collection of String fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields) {\n        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n    }\n\n    /**\n     * Compares two {@link Object}s via reflection.\n     *\n     * <p>Fields can be private, thus {@code AccessibleObject.setAccessible}\n     * is used to bypass normal access control checks. This will fail under a\n     * security manager unless the appropriate permissions are set.</p>\n     *\n     * <ul>\n     * <li>Static fields will not be compared</li>\n     * <li>If {@code compareTransients} is {@code true},\n     *     compares transient members.  Otherwise ignores them, as they\n     *     are likely derived fields.</li>\n     * <li>Superclass fields will be compared</li>\n     * </ul>\n     *\n     * <p>If both {@code lhs} and {@code rhs} are {@code null},\n     * they are considered equal.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param excludeFields  array of fields to exclude\n     * @return a negative integer, zero, or a positive integer as {@code lhs}\n     *  is less than, equal to, or greater than {@code rhs}\n     * @throws NullPointerException  if either {@code lhs} or {@code rhs}\n     *  (but not both) is {@code null}\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.2\n     */\n    public static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields) {\n        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n    }\n\n    /**\n     * Current state of the comparison as appended fields are checked.\n     */\n    private int comparison;\n\n    /**\n     * Constructor for CompareToBuilder.\n     *\n     * <p>Starts off assuming that the objects are equal. Multiple calls are\n     * then made to the various append methods, followed by a call to\n     * {@link #toComparison} to get the result.</p>\n     */\n    public CompareToBuilder() {\n        comparison = 0;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code booleans}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n      */\n    public CompareToBuilder append(final boolean lhs, final boolean rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs) {\n            comparison = 1;\n        } else {\n            comparison = -1;\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code boolean} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final boolean[] lhs, final boolean[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code byte}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final byte lhs, final byte rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Byte.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code byte} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final byte[] lhs, final byte[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code char}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final char lhs, final char rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Character.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code char} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(char, char)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final char[] lhs, final char[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code double}s.\n     *\n     * <p>This handles NaNs, Infinities, and {@code -0.0}.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * {@link HashCodeBuilder}.</p>\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final double lhs, final double rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Double.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code double} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(double, double)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final double[] lhs, final double[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code float}s.\n     *\n     * <p>This handles NaNs, Infinities, and {@code -0.0}.</p>\n     *\n     * <p>It is compatible with the hash code generated by\n     * {@link HashCodeBuilder}.</p>\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final float lhs, final float rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Float.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code float} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(float, float)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final float[] lhs, final float[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code int}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final int lhs, final int rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Integer.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code int} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(int, int)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final int[] lhs, final int[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code long}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final long lhs, final long rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Long.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code long} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(long, long)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final long[] lhs, final long[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@link Object}s.\n     *\n     * <ol>\n     * <li>Check if {@code lhs == rhs}</li>\n     * <li>Check if either {@code lhs} or {@code rhs} is {@code null},\n     *     a {@code null} object is less than a non-{@code null} object</li>\n     * <li>Check the object contents</li>\n     * </ol>\n     *\n     * <p>{@code lhs} must either be an array or implement {@link Comparable}.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public CompareToBuilder append(final Object lhs, final Object rhs) {\n        return append(lhs, rhs, null);\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@link Object}s.\n     *\n     * <ol>\n     * <li>Check if {@code lhs == rhs}</li>\n     * <li>Check if either {@code lhs} or {@code rhs} is {@code null},\n     *     a {@code null} object is less than a non-{@code null} object</li>\n     * <li>Check the object contents</li>\n     * </ol>\n     *\n     * <p>If {@code lhs} is an array, array comparison methods will be used.\n     * Otherwise {@code comparator} will be used to compare the objects.\n     * If {@code comparator} is {@code null}, {@code lhs} must\n     * implement {@link Comparable} instead.</p>\n     *\n     * @param lhs  left-hand side object\n     * @param rhs  right-hand side object\n     * @param comparator  {@link Comparator} used to compare the objects,\n     *  {@code null} means treat lhs as {@link Comparable}\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.0\n     */\n    public CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (ObjectUtils.isArray(lhs)) {\n            // factor out array case in order to keep method small enough to be inlined\n            appendArray(lhs, rhs, comparator);\n        } else // the simple case, not an array, just test the element\n        if (comparator == null) {\n            @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n            final Comparable<Object> comparable = (Comparable<Object>) lhs;\n            comparison = comparable.compareTo(rhs);\n        } else {\n            @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n            final Comparator<Object> comparator2 = (Comparator<Object>) comparator;\n            comparison = comparator2.compare(lhs, rhs);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@link Object} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a short length array is less than a long length array</li>\n     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n     * </ol>\n     *\n     * <p>This method will also will be called for the top level of multi-dimensional,\n     * ragged, and multi-typed arrays.</p>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     */\n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs) {\n        return append(lhs, rhs, null);\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@link Object} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a short length array is less than a long length array</li>\n     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n     * </ol>\n     *\n     * <p>This method will also will be called for the top level of multi-dimensional,\n     * ragged, and multi-typed arrays.</p>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @param comparator  {@link Comparator} to use to compare the array elements,\n     *  {@code null} means to treat {@code lhs} elements as {@link Comparable}.\n     * @return this\n     * @throws ClassCastException  if {@code rhs} is not assignment-compatible\n     *  with {@code lhs}\n     * @since 2.0\n     */\n    public CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i], comparator);\n        }\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the comparison of\n     * two {@code short}s.\n     *\n     * @param lhs  left-hand side value\n     * @param rhs  right-hand side value\n     * @return this\n     */\n    public CompareToBuilder append(final short lhs, final short rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = Short.compare(lhs, rhs);\n        return this;\n    }\n\n    /**\n     * Appends to the {@code builder} the deep comparison of\n     * two {@code short} arrays.\n     *\n     * <ol>\n     *  <li>Check if arrays are the same using {@code ==}</li>\n     *  <li>Check if for {@code null}, {@code null} is less than non-{@code null}</li>\n     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n     *  <li>Check array contents element by element using {@link #append(short, short)}</li>\n     * </ol>\n     *\n     * @param lhs  left-hand side array\n     * @param rhs  right-hand side array\n     * @return this\n     */\n    public CompareToBuilder append(final short[] lhs, final short[] rhs) {\n        if (comparison != 0) {\n            return this;\n        }\n        if (lhs == rhs) {\n            return this;\n        }\n        if (lhs == null) {\n            comparison = -1;\n            return this;\n        }\n        if (rhs == null) {\n            comparison = 1;\n            return this;\n        }\n        if (lhs.length != rhs.length) {\n            comparison = lhs.length < rhs.length ? -1 : 1;\n            return this;\n        }\n        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n            append(lhs[i], rhs[i]);\n        }\n        return this;\n    }\n\n    private void appendArray(final Object lhs, final Object rhs, final Comparator<?> comparator) {\n        // switch on type of array, to dispatch to the correct handler\n        // handles multidimensional arrays\n        // throws a ClassCastException if rhs is not the correct array type\n        if (lhs instanceof long[]) {\n            append((long[]) lhs, (long[]) rhs);\n        } else if (lhs instanceof int[]) {\n            append((int[]) lhs, (int[]) rhs);\n        } else if (lhs instanceof short[]) {\n            append((short[]) lhs, (short[]) rhs);\n        } else if (lhs instanceof char[]) {\n            append((char[]) lhs, (char[]) rhs);\n        } else if (lhs instanceof byte[]) {\n            append((byte[]) lhs, (byte[]) rhs);\n        } else if (lhs instanceof double[]) {\n            append((double[]) lhs, (double[]) rhs);\n        } else if (lhs instanceof float[]) {\n            append((float[]) lhs, (float[]) rhs);\n        } else if (lhs instanceof boolean[]) {\n            append((boolean[]) lhs, (boolean[]) rhs);\n        } else {\n            // not an array of primitives\n            // throws a ClassCastException if rhs is not an array\n            append((Object[]) lhs, (Object[]) rhs, comparator);\n        }\n    }\n\n    /**\n     * Appends to the {@code builder} the {@code compareTo(Object)}\n     * result of the superclass.\n     *\n     * @param superCompareTo  result of calling {@code super.compareTo(Object)}\n     * @return this\n     * @since 2.0\n     */\n    public CompareToBuilder appendSuper(final int superCompareTo) {\n        if (comparison != 0) {\n            return this;\n        }\n        comparison = superCompareTo;\n        return this;\n    }\n\n    /**\n     * Returns a negative Integer, a positive Integer, or zero as\n     * the {@code builder} has judged the \"left-hand\" side\n     * as less than, greater than, or equal to the \"right-hand\"\n     * side.\n     *\n     * @return final comparison result as an Integer\n     * @see #toComparison()\n     * @since 3.0\n     */\n    @Override\n    public Integer build() {\n        return Integer.valueOf(toComparison());\n    }\n\n    /**\n     * Returns a negative integer, a positive integer, or zero as\n     * the {@code builder} has judged the \"left-hand\" side\n     * as less than, greater than, or equal to the \"right-hand\"\n     * side.\n     *\n     * @return final comparison result\n     * @see #build()\n     */\n    public int toComparison() {\n        return comparison;\n    }\n}\n\n",
        "simple_context": "package org.apache.commons.lang3.builder;\n\nimport java.lang.reflect.AccessibleObject;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Collection;\n\nimport java.util.Comparator;\n\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\npublic class CompareToBuilder implements Builder<Integer> {\n    static private  reflectionAppend(Object lhs, Object rhs, Class<> clazz, CompareToBuilder builder, boolean useTransients, String excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs);\n    static public int reflectionCompare(Object lhs, Object rhs, boolean compareTransients);\n    static public int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, Class<> reflectUpToClass, String excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs, Collection<String> excludeFields);\n    static public int reflectionCompare(Object lhs, Object rhs, String excludeFields);\n    private int comparison;\n    public CompareToBuilder();\n    public CompareToBuilder append(boolean lhs, boolean rhs);\n    public CompareToBuilder append(boolean[] lhs, boolean[] rhs);\n    public CompareToBuilder append(byte lhs, byte rhs);\n    public CompareToBuilder append(byte[] lhs, byte[] rhs);\n    public CompareToBuilder append(char lhs, char rhs);\n    public CompareToBuilder append(char[] lhs, char[] rhs);\n    public CompareToBuilder append(double lhs, double rhs);\n    public CompareToBuilder append(double[] lhs, double[] rhs);\n    public CompareToBuilder append(float lhs, float rhs);\n    public CompareToBuilder append(float[] lhs, float[] rhs);\n    public CompareToBuilder append(int lhs, int rhs);\n    public CompareToBuilder append(int[] lhs, int[] rhs);\n    public CompareToBuilder append(long lhs, long rhs);\n    public CompareToBuilder append(long[] lhs, long[] rhs);\n    public CompareToBuilder append(Object lhs, Object rhs);\n    public CompareToBuilder append(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder append(Object lhs, Object rhs);\n    public CompareToBuilder append(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder append(short lhs, short rhs);\n    public CompareToBuilder append(short[] lhs, short[] rhs);\n    private  appendArray(Object lhs, Object rhs, Comparator<> comparator);\n    public CompareToBuilder appendSuper(int superCompareTo);\n    public Integer build();\n    public int toComparison();\n}\n\n"
    }
]