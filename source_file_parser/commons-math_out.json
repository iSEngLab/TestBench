[
    {
        "project_name": "commons-math",
        "file_name": "AccurateMathCalc.java",
        "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
        "execute_path": "commons-math/commons-math-core",
        "package": "org.apache.commons.math4.core.jdkmath",
        "docstring": "/**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */",
        "source_code": "\nstatic double slowCos(final double x, final double[] result) {\n\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        if ((i & 1) != 0) { // skip odd entries\n            continue;\n        }\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        if ((i & 2) != 0) { // alternate terms are negative\n            facts[0] = -facts[0];\n            facts[1] = -facts[1];\n        }\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0]; ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
        "class_name": "AccurateMathCalc",
        "method_name": "slowCos",
        "argument_name": [
            "double x",
            "double[] result"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\n\n/** Class used to compute the classical functions tables.\n * @since 3.0\n */\nfinal class AccurateMathCalc {\n\n    /**\n     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n     * Equivalent to 2^30.\n     */\n    private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n\n    /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */\n    private static final double[] FACT = new double[]\n        {\n        +1.0d,                        // 0\n        +1.0d,                        // 1\n        +2.0d,                        // 2\n        +6.0d,                        // 3\n        +24.0d,                       // 4\n        +120.0d,                      // 5\n        +720.0d,                      // 6\n        +5040.0d,                     // 7\n        +40320.0d,                    // 8\n        +362880.0d,                   // 9\n        +3628800.0d,                  // 10\n        +39916800.0d,                 // 11\n        +479001600.0d,                // 12\n        +6227020800.0d,               // 13\n        +87178291200.0d,              // 14\n        +1307674368000.0d,            // 15\n        +20922789888000.0d,           // 16\n        +355687428096000.0d,          // 17\n        +6402373705728000.0d,         // 18\n        +121645100408832000.0d,       // 19\n        };\n\n    /** Coefficients for slowLog. */\n    private static final double[][] LN_SPLIT_COEF = {\n        {2.0, 0.0},\n        {0.6666666269302368, 3.9736429850260626E-8},\n        {0.3999999761581421, 2.3841857910019882E-8},\n        {0.2857142686843872, 1.7029898543501842E-8},\n        {0.2222222089767456, 1.3245471311735498E-8},\n        {0.1818181574344635, 2.4384203044354907E-8},\n        {0.1538461446762085, 9.140260083262505E-9},\n        {0.13333332538604736, 9.220590270857665E-9},\n        {0.11764700710773468, 1.2393345855018391E-8},\n        {0.10526403784751892, 8.251545029714408E-9},\n        {0.0952233225107193, 1.2675934823758863E-8},\n        {0.08713622391223907, 1.1430250008909141E-8},\n        {0.07842259109020233, 2.404307984052299E-9},\n        {0.08371849358081818, 1.176342548272881E-8},\n        {0.030589580535888672, 1.2958646899018938E-9},\n        {0.14982303977012634, 1.225743062930824E-8},\n    };\n\n    /** Table start declaration. */\n    private static final String TABLE_START_DECL = \"    {\";\n\n    /** Table end declaration. */\n    private static final String TABLE_END_DECL   = \"    };\";\n\n    /**\n     * Private Constructor.\n     */\n    private AccurateMathCalc() {\n    }\n\n    /** Build the sine and cosine tables.\n     * @param SINE_TABLE_A table of the most significant part of the sines\n     * @param SINE_TABLE_B table of the least significant part of the sines\n     * @param COSINE_TABLE_A table of the most significant part of the cosines\n     * @param COSINE_TABLE_B table of the most significant part of the cosines\n     * @param SINE_TABLE_LEN length of the tables\n     * @param TANGENT_TABLE_A table of the most significant part of the tangents\n     * @param TANGENT_TABLE_B table of the most significant part of the tangents\n     */\n    @SuppressWarnings(\"unused\")\n    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B,\n                                          double[] COSINE_TABLE_A, double[] COSINE_TABLE_B,\n                                          int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {\n        final double[] result = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n            double[] bs = new double[2];\n            double[] temps = new double[2];\n\n            if ((i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n                as[0] = SINE_TABLE_A[i / 2 + 1];\n                as[1] = SINE_TABLE_B[i / 2 + 1];\n                bs[0] = COSINE_TABLE_A[i / 2 + 1];\n                bs[1] = COSINE_TABLE_B[i / 2 + 1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n    }\n\n    /**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */\n    static double slowCos(final double x, final double[] result) {\n\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) != 0) { // skip odd entries\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /**\n     * For x between 0 and pi/4 compute sine using Taylor expansion:\n     * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return sin(x)\n     */\n    static double slowSin(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) == 0) { // Ignore even numbers\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n\n    /**\n     *  For x between 0 and 1, returns exp(x), uses extended precision.\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n     *  @return exp(x)\n     */\n    static double slowexp(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /** Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     */\n    private static void split(final double d, final double[] split) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }\n\n    /** Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     */\n    private static void resplit(final double[] a) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) { // MAGIC NUMBER\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }\n\n    /** Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     */\n    private static void splitMult(double[] a, double[] b, double[] ans) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n\n    /** Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     */\n    private static void splitAdd(final double[] a, final double[] b, final double[] ans) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n\n    /** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */\n    static void splitReciprocal(final double[] in, final double[] result) {\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n                result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err *= result[0] + result[1];\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n\n    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     */\n    private static void quadMult(final double[] a, final double[] b, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] zs = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n    }\n\n    /** Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     */\n    static double expint(int p, final double[] result) {\n        //double x = M_E;\n        final double[] xs = new double[2];\n        final double[] as = new double[2];\n        final double[] ys = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n    /** xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     */\n    static double[] slowLog(double xi) {\n        double[] x = new double[2];\n        double[] x2 = new double[2];\n        double[] y = new double[2];\n        double[] a = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n\n        for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array2d array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n        out.println(name);\n        checkLen(expectedLen, array2d.length);\n        out.println(TABLE_START_DECL + \" \");\n        int i = 0;\n        for (double[] array : array2d) { // \"double array[]\" causes PMD parsing error\n            out.print(\"        {\");\n            for (double d : array) { // assume inner array has very few entries\n                out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n            }\n            out.println(\"}, // \" + i++);\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[] array) {\n        out.println(name + \"=\");\n        checkLen(expectedLen, array.length);\n        out.println(TABLE_START_DECL);\n        for (double d : array) {\n            out.printf(\"        %s%n\", format(d)); // one entry per line\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /** Format a double.\n     * @param d double number to format\n     * @return formatted number\n     */\n    static String format(double d) {\n        if (Double.isNaN(d)) {\n            return \"Double.NaN,\";\n        } else {\n            return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n        }\n    }\n\n    /**\n     * Check two lengths are equal.\n     * @param expectedLen expected length\n     * @param actual actual length\n     * @throws IllegalStateException if the two lengths are not equal\n     */\n    private static void checkLen(int expectedLen, int actual) {\n        if (expectedLen != actual) {\n            throw new IllegalStateException(actual + \" != \" + expectedLen);\n        }\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}\n\n"
    },
    {
        "project_name": "commons-math",
        "file_name": "AccurateMathCalc.java",
        "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
        "execute_path": "commons-math/commons-math-core",
        "package": "org.apache.commons.math4.core.jdkmath",
        "docstring": "/**\n     *  For x between 0 and 1, returns exp(x), uses extended precision.\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n     *  @return exp(x)\n     */",
        "source_code": "\nstatic double slowexp(final double x, final double[] result) {\n    final double[] xs = new double[2];\n    final double[] ys = new double[2];\n    final double[] facts = new double[2];\n    final double[] as = new double[2];\n    split(x, xs);\n    ys[0] = ys[1] = 0.0;\n\n    for (int i = FACT.length - 1; i >= 0; i--) {\n        splitMult(xs, ys, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n\n        split(FACT[i], as);\n        splitReciprocal(as, facts);\n\n        splitAdd(ys, facts, as);\n        ys[0] = as[0];\n        ys[1] = as[1];\n    }\n\n    if (result != null) {\n        result[0] = ys[0];\n        result[1] = ys[1];\n    }\n\n    return ys[0] + ys[1];\n}\n",
        "class_name": "AccurateMathCalc",
        "method_name": "slowexp",
        "argument_name": [
            "double x",
            "double[] result"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\n\n/** Class used to compute the classical functions tables.\n * @since 3.0\n */\nfinal class AccurateMathCalc {\n\n    /**\n     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n     * Equivalent to 2^30.\n     */\n    private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n\n    /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */\n    private static final double[] FACT = new double[]\n        {\n        +1.0d,                        // 0\n        +1.0d,                        // 1\n        +2.0d,                        // 2\n        +6.0d,                        // 3\n        +24.0d,                       // 4\n        +120.0d,                      // 5\n        +720.0d,                      // 6\n        +5040.0d,                     // 7\n        +40320.0d,                    // 8\n        +362880.0d,                   // 9\n        +3628800.0d,                  // 10\n        +39916800.0d,                 // 11\n        +479001600.0d,                // 12\n        +6227020800.0d,               // 13\n        +87178291200.0d,              // 14\n        +1307674368000.0d,            // 15\n        +20922789888000.0d,           // 16\n        +355687428096000.0d,          // 17\n        +6402373705728000.0d,         // 18\n        +121645100408832000.0d,       // 19\n        };\n\n    /** Coefficients for slowLog. */\n    private static final double[][] LN_SPLIT_COEF = {\n        {2.0, 0.0},\n        {0.6666666269302368, 3.9736429850260626E-8},\n        {0.3999999761581421, 2.3841857910019882E-8},\n        {0.2857142686843872, 1.7029898543501842E-8},\n        {0.2222222089767456, 1.3245471311735498E-8},\n        {0.1818181574344635, 2.4384203044354907E-8},\n        {0.1538461446762085, 9.140260083262505E-9},\n        {0.13333332538604736, 9.220590270857665E-9},\n        {0.11764700710773468, 1.2393345855018391E-8},\n        {0.10526403784751892, 8.251545029714408E-9},\n        {0.0952233225107193, 1.2675934823758863E-8},\n        {0.08713622391223907, 1.1430250008909141E-8},\n        {0.07842259109020233, 2.404307984052299E-9},\n        {0.08371849358081818, 1.176342548272881E-8},\n        {0.030589580535888672, 1.2958646899018938E-9},\n        {0.14982303977012634, 1.225743062930824E-8},\n    };\n\n    /** Table start declaration. */\n    private static final String TABLE_START_DECL = \"    {\";\n\n    /** Table end declaration. */\n    private static final String TABLE_END_DECL   = \"    };\";\n\n    /**\n     * Private Constructor.\n     */\n    private AccurateMathCalc() {\n    }\n\n    /** Build the sine and cosine tables.\n     * @param SINE_TABLE_A table of the most significant part of the sines\n     * @param SINE_TABLE_B table of the least significant part of the sines\n     * @param COSINE_TABLE_A table of the most significant part of the cosines\n     * @param COSINE_TABLE_B table of the most significant part of the cosines\n     * @param SINE_TABLE_LEN length of the tables\n     * @param TANGENT_TABLE_A table of the most significant part of the tangents\n     * @param TANGENT_TABLE_B table of the most significant part of the tangents\n     */\n    @SuppressWarnings(\"unused\")\n    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B,\n                                          double[] COSINE_TABLE_A, double[] COSINE_TABLE_B,\n                                          int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {\n        final double[] result = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n            double[] bs = new double[2];\n            double[] temps = new double[2];\n\n            if ((i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n                as[0] = SINE_TABLE_A[i / 2 + 1];\n                as[1] = SINE_TABLE_B[i / 2 + 1];\n                bs[0] = COSINE_TABLE_A[i / 2 + 1];\n                bs[1] = COSINE_TABLE_B[i / 2 + 1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n    }\n\n    /**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */\n    static double slowCos(final double x, final double[] result) {\n\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) != 0) { // skip odd entries\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /**\n     * For x between 0 and pi/4 compute sine using Taylor expansion:\n     * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return sin(x)\n     */\n    static double slowSin(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) == 0) { // Ignore even numbers\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n\n    /**\n     *  For x between 0 and 1, returns exp(x), uses extended precision.\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n     *  @return exp(x)\n     */\n    static double slowexp(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /** Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     */\n    private static void split(final double d, final double[] split) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }\n\n    /** Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     */\n    private static void resplit(final double[] a) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) { // MAGIC NUMBER\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }\n\n    /** Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     */\n    private static void splitMult(double[] a, double[] b, double[] ans) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n\n    /** Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     */\n    private static void splitAdd(final double[] a, final double[] b, final double[] ans) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n\n    /** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */\n    static void splitReciprocal(final double[] in, final double[] result) {\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n                result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err *= result[0] + result[1];\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n\n    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     */\n    private static void quadMult(final double[] a, final double[] b, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] zs = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n    }\n\n    /** Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     */\n    static double expint(int p, final double[] result) {\n        //double x = M_E;\n        final double[] xs = new double[2];\n        final double[] as = new double[2];\n        final double[] ys = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n    /** xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     */\n    static double[] slowLog(double xi) {\n        double[] x = new double[2];\n        double[] x2 = new double[2];\n        double[] y = new double[2];\n        double[] a = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n\n        for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array2d array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n        out.println(name);\n        checkLen(expectedLen, array2d.length);\n        out.println(TABLE_START_DECL + \" \");\n        int i = 0;\n        for (double[] array : array2d) { // \"double array[]\" causes PMD parsing error\n            out.print(\"        {\");\n            for (double d : array) { // assume inner array has very few entries\n                out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n            }\n            out.println(\"}, // \" + i++);\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[] array) {\n        out.println(name + \"=\");\n        checkLen(expectedLen, array.length);\n        out.println(TABLE_START_DECL);\n        for (double d : array) {\n            out.printf(\"        %s%n\", format(d)); // one entry per line\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /** Format a double.\n     * @param d double number to format\n     * @return formatted number\n     */\n    static String format(double d) {\n        if (Double.isNaN(d)) {\n            return \"Double.NaN,\";\n        } else {\n            return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n        }\n    }\n\n    /**\n     * Check two lengths are equal.\n     * @param expectedLen expected length\n     * @param actual actual length\n     * @throws IllegalStateException if the two lengths are not equal\n     */\n    private static void checkLen(int expectedLen, int actual) {\n        if (expectedLen != actual) {\n            throw new IllegalStateException(actual + \" != \" + expectedLen);\n        }\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}\n\n"
    },
    {
        "project_name": "commons-math",
        "file_name": "AccurateMathCalc.java",
        "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
        "execute_path": "commons-math/commons-math-core",
        "package": "org.apache.commons.math4.core.jdkmath",
        "docstring": "/** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */",
        "source_code": "\nstatic void splitReciprocal(final double[] in, final double[] result) {\n    final double b = 1.0 / 4194304.0;\n    final double a = 1.0 - b;\n\n    if (in[0] == 0.0) {\n        in[0] = in[1];\n        in[1] = 0.0;\n    }\n\n    result[0] = a / in[0];\n    result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n    if (result[1] != result[1]) { // can happen if result[1] is NAN\n        result[1] = 0.0;\n    }\n\n    /* Resplit */\n    resplit(result);\n\n    for (int i = 0; i < 2; i++) {\n        /* this may be overkill, probably once is enough */\n        double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n        /*err = 1.0 - err; */\n        err *= result[0] + result[1];\n        /*printf(\"err = %16e\\n\", err); */\n        result[1] += err;\n    }\n}\n",
        "class_name": "AccurateMathCalc",
        "method_name": "splitReciprocal",
        "argument_name": [
            "double[] in",
            "double[] result"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\n\n/** Class used to compute the classical functions tables.\n * @since 3.0\n */\nfinal class AccurateMathCalc {\n\n    /**\n     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n     * Equivalent to 2^30.\n     */\n    private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n\n    /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */\n    private static final double[] FACT = new double[]\n        {\n        +1.0d,                        // 0\n        +1.0d,                        // 1\n        +2.0d,                        // 2\n        +6.0d,                        // 3\n        +24.0d,                       // 4\n        +120.0d,                      // 5\n        +720.0d,                      // 6\n        +5040.0d,                     // 7\n        +40320.0d,                    // 8\n        +362880.0d,                   // 9\n        +3628800.0d,                  // 10\n        +39916800.0d,                 // 11\n        +479001600.0d,                // 12\n        +6227020800.0d,               // 13\n        +87178291200.0d,              // 14\n        +1307674368000.0d,            // 15\n        +20922789888000.0d,           // 16\n        +355687428096000.0d,          // 17\n        +6402373705728000.0d,         // 18\n        +121645100408832000.0d,       // 19\n        };\n\n    /** Coefficients for slowLog. */\n    private static final double[][] LN_SPLIT_COEF = {\n        {2.0, 0.0},\n        {0.6666666269302368, 3.9736429850260626E-8},\n        {0.3999999761581421, 2.3841857910019882E-8},\n        {0.2857142686843872, 1.7029898543501842E-8},\n        {0.2222222089767456, 1.3245471311735498E-8},\n        {0.1818181574344635, 2.4384203044354907E-8},\n        {0.1538461446762085, 9.140260083262505E-9},\n        {0.13333332538604736, 9.220590270857665E-9},\n        {0.11764700710773468, 1.2393345855018391E-8},\n        {0.10526403784751892, 8.251545029714408E-9},\n        {0.0952233225107193, 1.2675934823758863E-8},\n        {0.08713622391223907, 1.1430250008909141E-8},\n        {0.07842259109020233, 2.404307984052299E-9},\n        {0.08371849358081818, 1.176342548272881E-8},\n        {0.030589580535888672, 1.2958646899018938E-9},\n        {0.14982303977012634, 1.225743062930824E-8},\n    };\n\n    /** Table start declaration. */\n    private static final String TABLE_START_DECL = \"    {\";\n\n    /** Table end declaration. */\n    private static final String TABLE_END_DECL   = \"    };\";\n\n    /**\n     * Private Constructor.\n     */\n    private AccurateMathCalc() {\n    }\n\n    /** Build the sine and cosine tables.\n     * @param SINE_TABLE_A table of the most significant part of the sines\n     * @param SINE_TABLE_B table of the least significant part of the sines\n     * @param COSINE_TABLE_A table of the most significant part of the cosines\n     * @param COSINE_TABLE_B table of the most significant part of the cosines\n     * @param SINE_TABLE_LEN length of the tables\n     * @param TANGENT_TABLE_A table of the most significant part of the tangents\n     * @param TANGENT_TABLE_B table of the most significant part of the tangents\n     */\n    @SuppressWarnings(\"unused\")\n    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B,\n                                          double[] COSINE_TABLE_A, double[] COSINE_TABLE_B,\n                                          int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {\n        final double[] result = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n            double[] bs = new double[2];\n            double[] temps = new double[2];\n\n            if ((i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n                as[0] = SINE_TABLE_A[i / 2 + 1];\n                as[1] = SINE_TABLE_B[i / 2 + 1];\n                bs[0] = COSINE_TABLE_A[i / 2 + 1];\n                bs[1] = COSINE_TABLE_B[i / 2 + 1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n    }\n\n    /**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */\n    static double slowCos(final double x, final double[] result) {\n\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) != 0) { // skip odd entries\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /**\n     * For x between 0 and pi/4 compute sine using Taylor expansion:\n     * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return sin(x)\n     */\n    static double slowSin(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) == 0) { // Ignore even numbers\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n\n    /**\n     *  For x between 0 and 1, returns exp(x), uses extended precision.\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n     *  @return exp(x)\n     */\n    static double slowexp(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /** Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     */\n    private static void split(final double d, final double[] split) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }\n\n    /** Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     */\n    private static void resplit(final double[] a) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) { // MAGIC NUMBER\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }\n\n    /** Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     */\n    private static void splitMult(double[] a, double[] b, double[] ans) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n\n    /** Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     */\n    private static void splitAdd(final double[] a, final double[] b, final double[] ans) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n\n    /** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */\n    static void splitReciprocal(final double[] in, final double[] result) {\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n                result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err *= result[0] + result[1];\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n\n    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     */\n    private static void quadMult(final double[] a, final double[] b, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] zs = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n    }\n\n    /** Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     */\n    static double expint(int p, final double[] result) {\n        //double x = M_E;\n        final double[] xs = new double[2];\n        final double[] as = new double[2];\n        final double[] ys = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n    /** xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     */\n    static double[] slowLog(double xi) {\n        double[] x = new double[2];\n        double[] x2 = new double[2];\n        double[] y = new double[2];\n        double[] a = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n\n        for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array2d array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n        out.println(name);\n        checkLen(expectedLen, array2d.length);\n        out.println(TABLE_START_DECL + \" \");\n        int i = 0;\n        for (double[] array : array2d) { // \"double array[]\" causes PMD parsing error\n            out.print(\"        {\");\n            for (double d : array) { // assume inner array has very few entries\n                out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n            }\n            out.println(\"}, // \" + i++);\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[] array) {\n        out.println(name + \"=\");\n        checkLen(expectedLen, array.length);\n        out.println(TABLE_START_DECL);\n        for (double d : array) {\n            out.printf(\"        %s%n\", format(d)); // one entry per line\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /** Format a double.\n     * @param d double number to format\n     * @return formatted number\n     */\n    static String format(double d) {\n        if (Double.isNaN(d)) {\n            return \"Double.NaN,\";\n        } else {\n            return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n        }\n    }\n\n    /**\n     * Check two lengths are equal.\n     * @param expectedLen expected length\n     * @param actual actual length\n     * @throws IllegalStateException if the two lengths are not equal\n     */\n    private static void checkLen(int expectedLen, int actual) {\n        if (expectedLen != actual) {\n            throw new IllegalStateException(actual + \" != \" + expectedLen);\n        }\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}\n\n"
    },
    {
        "project_name": "commons-math",
        "file_name": "AccurateMathCalc.java",
        "relative_path": "commons-math/commons-math-core/src/main/java/org/apache/commons/math4/core/jdkmath/AccurateMathCalc.java",
        "execute_path": "commons-math/commons-math-core",
        "package": "org.apache.commons.math4.core.jdkmath",
        "docstring": "/**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array2d array data\n     */",
        "source_code": "\nstatic void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n    out.println(name);\n    checkLen(expectedLen, array2d.length);\n    out.println(TABLE_START_DECL + \" \");\n    int i = 0;\n    for (double[] array : array2d) { // \"double array[]\" causes PMD parsing error\n        out.print(\"        {\");\n        for (double d : array) { // assume inner array has very few entries\n            out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n        }\n        out.println(\"}, // \" + i++);\n    }\n    out.println(TABLE_END_DECL);\n}\n",
        "class_name": "AccurateMathCalc",
        "method_name": "printarray",
        "argument_name": [
            "PrintStream out",
            "String name",
            "int expectedLen",
            "double[][] array2d"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\n\n/** Class used to compute the classical functions tables.\n * @since 3.0\n */\nfinal class AccurateMathCalc {\n\n    /**\n     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n     * Equivalent to 2^30.\n     */\n    private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n\n    /** Factorial table, for Taylor series expansions. 0!, 1!, 2!, ... 19! */\n    private static final double[] FACT = new double[]\n        {\n        +1.0d,                        // 0\n        +1.0d,                        // 1\n        +2.0d,                        // 2\n        +6.0d,                        // 3\n        +24.0d,                       // 4\n        +120.0d,                      // 5\n        +720.0d,                      // 6\n        +5040.0d,                     // 7\n        +40320.0d,                    // 8\n        +362880.0d,                   // 9\n        +3628800.0d,                  // 10\n        +39916800.0d,                 // 11\n        +479001600.0d,                // 12\n        +6227020800.0d,               // 13\n        +87178291200.0d,              // 14\n        +1307674368000.0d,            // 15\n        +20922789888000.0d,           // 16\n        +355687428096000.0d,          // 17\n        +6402373705728000.0d,         // 18\n        +121645100408832000.0d,       // 19\n        };\n\n    /** Coefficients for slowLog. */\n    private static final double[][] LN_SPLIT_COEF = {\n        {2.0, 0.0},\n        {0.6666666269302368, 3.9736429850260626E-8},\n        {0.3999999761581421, 2.3841857910019882E-8},\n        {0.2857142686843872, 1.7029898543501842E-8},\n        {0.2222222089767456, 1.3245471311735498E-8},\n        {0.1818181574344635, 2.4384203044354907E-8},\n        {0.1538461446762085, 9.140260083262505E-9},\n        {0.13333332538604736, 9.220590270857665E-9},\n        {0.11764700710773468, 1.2393345855018391E-8},\n        {0.10526403784751892, 8.251545029714408E-9},\n        {0.0952233225107193, 1.2675934823758863E-8},\n        {0.08713622391223907, 1.1430250008909141E-8},\n        {0.07842259109020233, 2.404307984052299E-9},\n        {0.08371849358081818, 1.176342548272881E-8},\n        {0.030589580535888672, 1.2958646899018938E-9},\n        {0.14982303977012634, 1.225743062930824E-8},\n    };\n\n    /** Table start declaration. */\n    private static final String TABLE_START_DECL = \"    {\";\n\n    /** Table end declaration. */\n    private static final String TABLE_END_DECL   = \"    };\";\n\n    /**\n     * Private Constructor.\n     */\n    private AccurateMathCalc() {\n    }\n\n    /** Build the sine and cosine tables.\n     * @param SINE_TABLE_A table of the most significant part of the sines\n     * @param SINE_TABLE_B table of the least significant part of the sines\n     * @param COSINE_TABLE_A table of the most significant part of the cosines\n     * @param COSINE_TABLE_B table of the most significant part of the cosines\n     * @param SINE_TABLE_LEN length of the tables\n     * @param TANGENT_TABLE_A table of the most significant part of the tangents\n     * @param TANGENT_TABLE_B table of the most significant part of the tangents\n     */\n    @SuppressWarnings(\"unused\")\n    private static void buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B,\n                                          double[] COSINE_TABLE_A, double[] COSINE_TABLE_B,\n                                          int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B) {\n        final double[] result = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n            double[] bs = new double[2];\n            double[] temps = new double[2];\n\n            if ((i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i / 2];\n                xs[1] = SINE_TABLE_B[i / 2];\n                ys[0] = COSINE_TABLE_A[i / 2];\n                ys[1] = COSINE_TABLE_B[i / 2];\n                as[0] = SINE_TABLE_A[i / 2 + 1];\n                as[1] = SINE_TABLE_B[i / 2 + 1];\n                bs[0] = COSINE_TABLE_A[i / 2 + 1];\n                bs[1] = COSINE_TABLE_B[i / 2 + 1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < SINE_TABLE_LEN; i++) {\n            double[] xs = new double[2];\n            double[] ys = new double[2];\n            double[] as = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n    }\n\n    /**\n     *  For x between 0 and pi/4 compute cosine using Talor series\n     *  cos(x) = 1 - x^2/2! + x^4/4! ...\n     * @param x number from which cosine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return cos(x)\n     */\n    static double slowCos(final double x, final double[] result) {\n\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) != 0) { // skip odd entries\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /**\n     * For x between 0 and pi/4 compute sine using Taylor expansion:\n     * sin(x) = x - x^3/3! + x^5/5! - x^7/7! ...\n     * @param x number from which sine is requested\n     * @param result placeholder where to put the result in extended precision\n     * (may be null)\n     * @return sin(x)\n     */\n    static double slowSin(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            if ((i & 1) == 0) { // Ignore even numbers\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ((i & 2) != 0) { // alternate terms are negative\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n\n    /**\n     *  For x between 0 and 1, returns exp(x), uses extended precision.\n     *  @param x argument of exponential\n     *  @param result placeholder where to place exp(x) split in two terms\n     *  for extra precision (i.e. exp(x) = result[0] + result[1]\n     *  @return exp(x)\n     */\n    static double slowexp(final double x, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] facts = new double[2];\n        final double[] as = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = FACT.length - 1; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }\n\n    /** Compute split[0], split[1] such that their sum is equal to d,\n     * and split[0] has its 30 least significant bits as zero.\n     * @param d number to split\n     * @param split placeholder where to place the result\n     */\n    private static void split(final double d, final double[] split) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }\n\n    /** Recompute a split.\n     * @param a input/out array containing the split, changed\n     * on output\n     */\n    private static void resplit(final double[] a) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) { // MAGIC NUMBER\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }\n\n    /** Multiply two numbers in split form.\n     * @param a first term of multiplication\n     * @param b second term of multiplication\n     * @param ans placeholder where to put the result\n     */\n    private static void splitMult(double[] a, double[] b, double[] ans) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }\n\n    /** Add two numbers in split form.\n     * @param a first term of addition\n     * @param b second term of addition\n     * @param ans placeholder where to put the result\n     */\n    private static void splitAdd(final double[] a, final double[] b, final double[] ans) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }\n\n    /** Compute the reciprocal of in.  Use the following algorithm.\n     *  in = c + d.\n     *  want to find x + y such that x+y = 1/(c+d) and x is much\n     *  larger than y and x has several zero bits on the right.\n     *\n     *  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1.\n     *  Use following identity to compute (a+b)/(c+d)\n     *\n     *  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd)\n     *  set x = a/c  and y = (bc - ad) / (c^2 + cd)\n     *  This will be close to the right answer, but there will be\n     *  some rounding in the calculation of X.  So by carefully\n     *  computing 1 - (c+d)(x+y) we can compute an error and\n     *  add that back in.   This is done carefully so that terms\n     *  of similar size are subtracted first.\n     *  @param in initial number, in split form\n     *  @param result placeholder where to put the result\n     */\n    static void splitReciprocal(final double[] in, final double[] result) {\n        final double b = 1.0 / 4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b * in[0] - a * in[1]) / (in[0] * in[0] + in[0] * in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n                result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err *= result[0] + result[1];\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }\n\n    /** Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision.\n     * @param a first term of the multiplication\n     * @param b second term of the multiplication\n     * @param result placeholder where to put the result\n     */\n    private static void quadMult(final double[] a, final double[] b, final double[] result) {\n        final double[] xs = new double[2];\n        final double[] ys = new double[2];\n        final double[] zs = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] -= tmp - result[0] - zs[0];\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] -= tmp - result[0] - zs[1];\n        result[0] = tmp;\n    }\n\n    /** Compute exp(p) for a integer p in extended precision.\n     * @param p integer whose exponential is requested\n     * @param result placeholder where to put the result in extended precision\n     * @return exp(p) in standard precision (equal to result[0] + result[1])\n     */\n    static double expint(int p, final double[] result) {\n        //double x = M_E;\n        final double[] xs = new double[2];\n        final double[] as = new double[2];\n        final double[] ys = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }\n    /** xi in the range of [1, 2].\n     *                                3        5        7\n     *      x+1           /          x        x        x          \\\n     *  ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  |\n     *      1-x           \\          3        5        7          /\n     *\n     * So, compute a Remez approximation of the following function\n     *\n     *  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x\n     *\n     * This will be an even function with only positive coefficents.\n     * x is in the range [0 - 1/3].\n     *\n     * Transform xi for input to the above function by setting\n     * x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then\n     * the result is multiplied by x.\n     * @param xi number from which log is requested\n     * @return log(xi)\n     */\n    static double[] slowLog(double xi) {\n        double[] x = new double[2];\n        double[] x2 = new double[2];\n        double[] y = new double[2];\n        double[] a = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length - 1][1];\n\n        for (int i = LN_SPLIT_COEF.length - 2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }\n\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array2d array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[][] array2d) {\n        out.println(name);\n        checkLen(expectedLen, array2d.length);\n        out.println(TABLE_START_DECL + \" \");\n        int i = 0;\n        for (double[] array : array2d) { // \"double array[]\" causes PMD parsing error\n            out.print(\"        {\");\n            for (double d : array) { // assume inner array has very few entries\n                out.printf(\"%-25.25s\", format(d)); // multiple entries per line\n            }\n            out.println(\"}, // \" + i++);\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /**\n     * Print an array.\n     * @param out text output stream where output should be printed\n     * @param name array name\n     * @param expectedLen expected length of the array\n     * @param array array data\n     */\n    static void printarray(PrintStream out, String name, int expectedLen, double[] array) {\n        out.println(name + \"=\");\n        checkLen(expectedLen, array.length);\n        out.println(TABLE_START_DECL);\n        for (double d : array) {\n            out.printf(\"        %s%n\", format(d)); // one entry per line\n        }\n        out.println(TABLE_END_DECL);\n    }\n\n    /** Format a double.\n     * @param d double number to format\n     * @return formatted number\n     */\n    static String format(double d) {\n        if (Double.isNaN(d)) {\n            return \"Double.NaN,\";\n        } else {\n            return ((d >= 0) ? \"+\" : \"\") + Double.toString(d) + \"d,\";\n        }\n    }\n\n    /**\n     * Check two lengths are equal.\n     * @param expectedLen expected length\n     * @param actual actual length\n     * @throws IllegalStateException if the two lengths are not equal\n     */\n    private static void checkLen(int expectedLen, int actual) {\n        if (expectedLen != actual) {\n            throw new IllegalStateException(actual + \" != \" + expectedLen);\n        }\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.core.jdkmath;\n\nimport java.io.PrintStream;\n\nfinal class AccurateMathCalc {\n    static final private long HEX_40000000;\n    static final private double[] FACT;\n    static final private double[][] LN_SPLIT_COEF;\n    static final private String TABLE_START_DECL;\n    static final private String TABLE_END_DECL;\n    private AccurateMathCalc();\n    static private  buildSinCosTables(double[] SINE_TABLE_A, double[] SINE_TABLE_B, double[] COSINE_TABLE_A, double[] COSINE_TABLE_B, int SINE_TABLE_LEN, double[] TANGENT_TABLE_A, double[] TANGENT_TABLE_B);\n    static double slowCos(double x, double[] result);\n    static double slowSin(double x, double[] result);\n    static double slowexp(double x, double[] result);\n    static private  split(double d, double[] split);\n    static private  resplit(double[] a);\n    static private  splitMult(double[] a, double[] b, double[] ans);\n    static private  splitAdd(double[] a, double[] b, double[] ans);\n    static  splitReciprocal(double[] in, double[] result);\n    static private  quadMult(double[] a, double[] b, double[] result);\n    static double expint(int p, double[] result);\n    static double[] slowLog(double xi);\n    static  printarray(PrintStream out, String name, int expectedLen, double[][] array2d);\n    static  printarray(PrintStream out, String name, int expectedLen, double[] array);\n    static String format(double d);\n    static private  checkLen(int expectedLen, int actual);\n}\n\n"
    },
    {
        "project_name": "commons-math",
        "file_name": "Pair.java",
        "relative_path": "commons-math/commons-math-legacy-core/src/main/java/org/apache/commons/math4/legacy/core/Pair.java",
        "execute_path": "commons-math/commons-math-legacy-core",
        "package": "org.apache.commons.math4.legacy.core",
        "docstring": "/**\n     * Compare the specified object with this entry for equality.\n     *\n     * @param o Object.\n     * @return {@code true} if the given object is also a map entry and\n     * the two entries represent the same mapping.\n     */",
        "source_code": "\n@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (!(o instanceof Pair)) {\n        return false;\n    } else {\n        Pair<?, ?> oP = (Pair<?, ?>) o;\n        return (key == null ?\n                oP.key == null :\n                key.equals(oP.key)) &&\n            (value == null ?\n             oP.value == null :\n             value.equals(oP.value));\n    }\n}\n",
        "class_name": "Pair",
        "method_name": "equals",
        "argument_name": [
            "Object o"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math4.legacy.core;\n\n/**\n * Generic pair.\n * <br>\n * Although the instances of this class are immutable, it is impossible\n * to ensure that the references passed to the constructor will not be\n * modified by the caller.\n *\n * @param <K> Key type.\n * @param <V> Value type.\n *\n * @since 3.0\n */\npublic class Pair<K, V> {\n    /** Key. */\n    private final K key;\n    /** Value. */\n    private final V value;\n\n    /**\n     * Create an entry representing a mapping from the specified key to the\n     * specified value.\n     *\n     * @param k Key (first element of the pair).\n     * @param v Value (second element of the pair).\n     */\n    public Pair(K k, V v) {\n        key = k;\n        value = v;\n    }\n\n    /**\n     * Create an entry representing the same mapping as the specified entry.\n     *\n     * @param entry Entry to copy.\n     */\n    public Pair(Pair<? extends K, ? extends V> entry) {\n        this(entry.getKey(), entry.getValue());\n    }\n\n    /**\n     * Get the key.\n     *\n     * @return the key (first element of the pair).\n     */\n    public K getKey() {\n        return getFirst();\n    }\n\n    /**\n     * Get the value.\n     *\n     * @return the value (second element of the pair).\n     */\n    public V getValue() {\n        return getSecond();\n    }\n\n    /**\n     * Get the first element of the pair.\n     *\n     * @return the first element of the pair.\n     * @since 3.1\n     */\n    public K getFirst() {\n        return key;\n    }\n\n    /**\n     * Get the second element of the pair.\n     *\n     * @return the second element of the pair.\n     * @since 3.1\n     */\n    public V getSecond() {\n        return value;\n    }\n\n    /**\n     * Compare the specified object with this entry for equality.\n     *\n     * @param o Object.\n     * @return {@code true} if the given object is also a map entry and\n     * the two entries represent the same mapping.\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Pair)) {\n            return false;\n        } else {\n            Pair<?, ?> oP = (Pair<?, ?>) o;\n            return (key == null ?\n                    oP.key == null :\n                    key.equals(oP.key)) &&\n                (value == null ?\n                 oP.value == null :\n                 value.equals(oP.value));\n        }\n    }\n\n    /**\n     * Compute a hash code.\n     *\n     * @return the hash code value.\n     */\n    @Override\n    public int hashCode() {\n        int result = key == null ? 0 : key.hashCode();\n\n        final int h = value == null ? 0 : value.hashCode();\n        result = 37 * result + h ^ (h >>> 16);\n\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return \"[\" + getKey() + \", \" + getValue() + \"]\";\n    }\n\n    /**\n     * Convenience factory method that calls the\n     * {@link #Pair(Object, Object) constructor}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param k First element of the pair.\n     * @param v Second element of the pair.\n     * @return a new {@code Pair} containing {@code k} and {@code v}.\n     * @since 3.3\n     */\n    public static <K, V> Pair<K, V> create(K k, V v) {\n        return new Pair<>(k, v);\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.legacy.core;\n\npublic class Pair {\n    final private K key;\n    final private V value;\n    public Pair(K k, V v);\n    public Pair(Pair<K, V> entry);\n    public K getKey();\n    public V getValue();\n    public K getFirst();\n    public V getSecond();\n    public boolean equals(Object o);\n    public int hashCode();\n    public String toString();\n    static public Pair<K, V> create(K k, V v);\n}\n\n"
    },
    {
        "project_name": "commons-math",
        "file_name": "Pair.java",
        "relative_path": "commons-math/commons-math-legacy-core/src/main/java/org/apache/commons/math4/legacy/core/Pair.java",
        "execute_path": "commons-math/commons-math-legacy-core",
        "package": "org.apache.commons.math4.legacy.core",
        "docstring": "/**\n     * Compute a hash code.\n     *\n     * @return the hash code value.\n     */",
        "source_code": "\n@Override\npublic int hashCode() {\n    int result = key == null ? 0 : key.hashCode();\n\n    final int h = value == null ? 0 : value.hashCode();\n    result = 37 * result + h ^ (h >>> 16);\n\n    return result;\n}\n",
        "class_name": "Pair",
        "method_name": "hashCode",
        "argument_name": [],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math4.legacy.core;\n\n/**\n * Generic pair.\n * <br>\n * Although the instances of this class are immutable, it is impossible\n * to ensure that the references passed to the constructor will not be\n * modified by the caller.\n *\n * @param <K> Key type.\n * @param <V> Value type.\n *\n * @since 3.0\n */\npublic class Pair<K, V> {\n    /** Key. */\n    private final K key;\n    /** Value. */\n    private final V value;\n\n    /**\n     * Create an entry representing a mapping from the specified key to the\n     * specified value.\n     *\n     * @param k Key (first element of the pair).\n     * @param v Value (second element of the pair).\n     */\n    public Pair(K k, V v) {\n        key = k;\n        value = v;\n    }\n\n    /**\n     * Create an entry representing the same mapping as the specified entry.\n     *\n     * @param entry Entry to copy.\n     */\n    public Pair(Pair<? extends K, ? extends V> entry) {\n        this(entry.getKey(), entry.getValue());\n    }\n\n    /**\n     * Get the key.\n     *\n     * @return the key (first element of the pair).\n     */\n    public K getKey() {\n        return getFirst();\n    }\n\n    /**\n     * Get the value.\n     *\n     * @return the value (second element of the pair).\n     */\n    public V getValue() {\n        return getSecond();\n    }\n\n    /**\n     * Get the first element of the pair.\n     *\n     * @return the first element of the pair.\n     * @since 3.1\n     */\n    public K getFirst() {\n        return key;\n    }\n\n    /**\n     * Get the second element of the pair.\n     *\n     * @return the second element of the pair.\n     * @since 3.1\n     */\n    public V getSecond() {\n        return value;\n    }\n\n    /**\n     * Compare the specified object with this entry for equality.\n     *\n     * @param o Object.\n     * @return {@code true} if the given object is also a map entry and\n     * the two entries represent the same mapping.\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Pair)) {\n            return false;\n        } else {\n            Pair<?, ?> oP = (Pair<?, ?>) o;\n            return (key == null ?\n                    oP.key == null :\n                    key.equals(oP.key)) &&\n                (value == null ?\n                 oP.value == null :\n                 value.equals(oP.value));\n        }\n    }\n\n    /**\n     * Compute a hash code.\n     *\n     * @return the hash code value.\n     */\n    @Override\n    public int hashCode() {\n        int result = key == null ? 0 : key.hashCode();\n\n        final int h = value == null ? 0 : value.hashCode();\n        result = 37 * result + h ^ (h >>> 16);\n\n        return result;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public String toString() {\n        return \"[\" + getKey() + \", \" + getValue() + \"]\";\n    }\n\n    /**\n     * Convenience factory method that calls the\n     * {@link #Pair(Object, Object) constructor}.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     * @param k First element of the pair.\n     * @param v Second element of the pair.\n     * @return a new {@code Pair} containing {@code k} and {@code v}.\n     * @since 3.3\n     */\n    public static <K, V> Pair<K, V> create(K k, V v) {\n        return new Pair<>(k, v);\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.legacy.core;\n\npublic class Pair {\n    final private K key;\n    final private V value;\n    public Pair(K k, V v);\n    public Pair(Pair<K, V> entry);\n    public K getKey();\n    public V getValue();\n    public K getFirst();\n    public V getSecond();\n    public boolean equals(Object o);\n    public int hashCode();\n    public String toString();\n    static public Pair<K, V> create(K k, V v);\n}\n\n"
    },
    {
        "project_name": "commons-math",
        "file_name": "Neuron.java",
        "relative_path": "commons-math/commons-math-neuralnet/src/main/java/org/apache/commons/math4/neuralnet/Neuron.java",
        "execute_path": "commons-math/commons-math-neuralnet",
        "package": "org.apache.commons.math4.neuralnet",
        "docstring": "/**\n     * Tries to atomically update the neuron's features.\n     * Update will be performed only if the expected values match the\n     * current values.<br>\n     * In effect, when concurrent threads call this method, the state\n     * could be modified by one, so that it does not correspond to the\n     * the state assumed by another.\n     * Typically, a caller {@link #getFeatures() retrieves the current state},\n     * and uses it to compute the new state.\n     * During this computation, another thread might have done the same\n     * thing, and updated the state: If the current thread were to proceed\n     * with its own update, it would overwrite the new state (which might\n     * already have been used by yet other threads).\n     * To prevent this, the method does not perform the update when a\n     * concurrent modification has been detected, and returns {@code false}.\n     * When this happens, the caller should fetch the new current state,\n     * redo its computation, and call this method again.\n     *\n     * @param expect Current values of the features, as assumed by the caller.\n     * Update will never succeed if the contents of this array does not match\n     * the values returned by {@link #getFeatures()}.\n     * @param update Features's new values.\n     * @return {@code true} if the update was successful, {@code false}\n     * otherwise.\n     * @throws IllegalArgumentException if the length of {@code update} is\n     * not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     */",
        "source_code": "\npublic boolean compareAndSetFeatures(double[] expect,\n                                     double[] update) {\n    if (update.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     update.length, size);\n    }\n\n    // Get the internal reference. Note that this must not be a copy;\n    // otherwise the \"compareAndSet\" below will always fail.\n    final double[] current = features.get();\n    if (!containSameValues(current, expect)) {\n        // Some other thread already modified the state.\n        return false;\n    }\n\n    // Increment attempt counter.\n    numberOfAttemptedUpdates.incrementAndGet();\n\n    if (features.compareAndSet(current, update.clone())) {\n        // The current thread could atomically update the state (attempt succeeded).\n        numberOfSuccessfulUpdates.incrementAndGet();\n        return true;\n    } else {\n        // Some other thread came first (attempt failed).\n        return false;\n    }\n}\n",
        "class_name": "Neuron",
        "method_name": "compareAndSetFeatures",
        "argument_name": [
            "double[] expect",
            "double[] update"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math4.neuralnet;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.commons.numbers.core.Precision;\nimport org.apache.commons.math4.neuralnet.internal.NeuralNetException;\n\n/**\n * Describes a neuron element of a neural network.\n *\n * This class aims to be thread-safe.\n *\n * @since 3.3\n */\npublic class Neuron {\n    /** Identifier. */\n    private final long identifier;\n    /** Length of the feature set. */\n    private final int size;\n    /** Neuron data. */\n    private final AtomicReference<double[]> features;\n    /** Number of attempts to update a neuron. */\n    private final AtomicLong numberOfAttemptedUpdates = new AtomicLong(0);\n    /** Number of successful updates  of a neuron. */\n    private final AtomicLong numberOfSuccessfulUpdates = new AtomicLong(0);\n\n    /**\n     * Creates a neuron.\n     * The size of the feature set is fixed to the length of the given\n     * argument.\n     * <br>\n     * Constructor is package-private: Neurons must be\n     * {@link Network#createNeuron(double[]) created} by the network\n     * instance to which they will belong.\n     *\n     * @param identifier Identifier (assigned by the {@link Network}).\n     * @param features Initial values of the feature set.\n     */\n    Neuron(long identifier,\n           double[] features) {\n        this.identifier = identifier;\n        this.size = features.length;\n        this.features = new AtomicReference<>(features.clone());\n    }\n\n    /**\n     * Performs a deep copy of this instance.\n     * Upon return, the copied and original instances will be independent:\n     * Updating one will not affect the other.\n     *\n     * @return a new instance with the same state as this instance.\n     * @since 3.6\n     */\n    public synchronized Neuron copy() {\n        final Neuron copy = new Neuron(getIdentifier(),\n                                       getFeatures());\n        copy.numberOfAttemptedUpdates.set(numberOfAttemptedUpdates.get());\n        copy.numberOfSuccessfulUpdates.set(numberOfSuccessfulUpdates.get());\n\n        return copy;\n    }\n\n    /**\n     * Gets the neuron's identifier.\n     *\n     * @return the identifier.\n     */\n    public long getIdentifier() {\n        return identifier;\n    }\n\n    /**\n     * Gets the length of the feature set.\n     *\n     * @return the number of features.\n     */\n    public int getSize() {\n        return size;\n    }\n\n    /**\n     * Gets the neuron's features.\n     *\n     * @return a copy of the neuron's features.\n     */\n    public double[] getFeatures() {\n        return features.get().clone();\n    }\n\n    /**\n     * Tries to atomically update the neuron's features.\n     * Update will be performed only if the expected values match the\n     * current values.<br>\n     * In effect, when concurrent threads call this method, the state\n     * could be modified by one, so that it does not correspond to the\n     * the state assumed by another.\n     * Typically, a caller {@link #getFeatures() retrieves the current state},\n     * and uses it to compute the new state.\n     * During this computation, another thread might have done the same\n     * thing, and updated the state: If the current thread were to proceed\n     * with its own update, it would overwrite the new state (which might\n     * already have been used by yet other threads).\n     * To prevent this, the method does not perform the update when a\n     * concurrent modification has been detected, and returns {@code false}.\n     * When this happens, the caller should fetch the new current state,\n     * redo its computation, and call this method again.\n     *\n     * @param expect Current values of the features, as assumed by the caller.\n     * Update will never succeed if the contents of this array does not match\n     * the values returned by {@link #getFeatures()}.\n     * @param update Features's new values.\n     * @return {@code true} if the update was successful, {@code false}\n     * otherwise.\n     * @throws IllegalArgumentException if the length of {@code update} is\n     * not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     */\n    public boolean compareAndSetFeatures(double[] expect,\n                                         double[] update) {\n        if (update.length != size) {\n            throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                         update.length, size);\n        }\n\n        // Get the internal reference. Note that this must not be a copy;\n        // otherwise the \"compareAndSet\" below will always fail.\n        final double[] current = features.get();\n        if (!containSameValues(current, expect)) {\n            // Some other thread already modified the state.\n            return false;\n        }\n\n        // Increment attempt counter.\n        numberOfAttemptedUpdates.incrementAndGet();\n\n        if (features.compareAndSet(current, update.clone())) {\n            // The current thread could atomically update the state (attempt succeeded).\n            numberOfSuccessfulUpdates.incrementAndGet();\n            return true;\n        } else {\n            // Some other thread came first (attempt failed).\n            return false;\n        }\n    }\n\n    /**\n     * Retrieves the number of calls to the\n     * {@link #compareAndSetFeatures(double[],double[]) compareAndSetFeatures}\n     * method.\n     * Note that if the caller wants to use this method in combination with\n     * {@link #getNumberOfSuccessfulUpdates()}, additional synchronization\n     * may be required to ensure consistency.\n     *\n     * @return the number of update attempts.\n     * @since 3.6\n     */\n    public long getNumberOfAttemptedUpdates() {\n        return numberOfAttemptedUpdates.get();\n    }\n\n    /**\n     * Retrieves the number of successful calls to the\n     * {@link #compareAndSetFeatures(double[],double[]) compareAndSetFeatures}\n     * method.\n     * Note that if the caller wants to use this method in combination with\n     * {@link #getNumberOfAttemptedUpdates()}, additional synchronization\n     * may be required to ensure consistency.\n     *\n     * @return the number of successful updates.\n     * @since 3.6\n     */\n    public long getNumberOfSuccessfulUpdates() {\n        return numberOfSuccessfulUpdates.get();\n    }\n\n    /**\n     * Checks whether the contents of both arrays is the same.\n     *\n     * @param current Current values.\n     * @param expect Expected values.\n     * @throws IllegalArgumentException if the length of {@code expect}\n     * is not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     * @return {@code true} if the arrays contain the same values.\n     */\n    private boolean containSameValues(double[] current,\n                                      double[] expect) {\n        if (expect.length != size) {\n            throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                         expect.length, size);\n        }\n\n        for (int i = 0; i < size; i++) {\n            if (!Precision.equals(current[i], expect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.neuralnet;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.commons.numbers.core.Precision;\n\nimport org.apache.commons.math4.neuralnet.internal.NeuralNetException;\n\npublic class Neuron {\n    final private long identifier;\n    final private int size;\n    final private AtomicReference<double[]> features;\n    final private AtomicLong numberOfAttemptedUpdates;\n    final private AtomicLong numberOfSuccessfulUpdates;\n    Neuron(long identifier, double[] features);\n    public synchronized Neuron copy();\n    public long getIdentifier();\n    public int getSize();\n    public double[] getFeatures();\n    public boolean compareAndSetFeatures(double[] expect, double[] update);\n    public long getNumberOfAttemptedUpdates();\n    public long getNumberOfSuccessfulUpdates();\n    private boolean containSameValues(double[] current, double[] expect);\n}\n\n"
    },
    {
        "project_name": "commons-math",
        "file_name": "Neuron.java",
        "relative_path": "commons-math/commons-math-neuralnet/src/main/java/org/apache/commons/math4/neuralnet/Neuron.java",
        "execute_path": "commons-math/commons-math-neuralnet",
        "package": "org.apache.commons.math4.neuralnet",
        "docstring": "/**\n     * Checks whether the contents of both arrays is the same.\n     *\n     * @param current Current values.\n     * @param expect Expected values.\n     * @throws IllegalArgumentException if the length of {@code expect}\n     * is not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     * @return {@code true} if the arrays contain the same values.\n     */",
        "source_code": "\nprivate boolean containSameValues(double[] current,\n                                  double[] expect) {\n    if (expect.length != size) {\n        throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                     expect.length, size);\n    }\n\n    for (int i = 0; i < size; i++) {\n        if (!Precision.equals(current[i], expect[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\n",
        "class_name": "Neuron",
        "method_name": "containSameValues",
        "argument_name": [
            "double[] current",
            "double[] expect"
        ],
        "full_context": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math4.neuralnet;\n\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.commons.numbers.core.Precision;\nimport org.apache.commons.math4.neuralnet.internal.NeuralNetException;\n\n/**\n * Describes a neuron element of a neural network.\n *\n * This class aims to be thread-safe.\n *\n * @since 3.3\n */\npublic class Neuron {\n    /** Identifier. */\n    private final long identifier;\n    /** Length of the feature set. */\n    private final int size;\n    /** Neuron data. */\n    private final AtomicReference<double[]> features;\n    /** Number of attempts to update a neuron. */\n    private final AtomicLong numberOfAttemptedUpdates = new AtomicLong(0);\n    /** Number of successful updates  of a neuron. */\n    private final AtomicLong numberOfSuccessfulUpdates = new AtomicLong(0);\n\n    /**\n     * Creates a neuron.\n     * The size of the feature set is fixed to the length of the given\n     * argument.\n     * <br>\n     * Constructor is package-private: Neurons must be\n     * {@link Network#createNeuron(double[]) created} by the network\n     * instance to which they will belong.\n     *\n     * @param identifier Identifier (assigned by the {@link Network}).\n     * @param features Initial values of the feature set.\n     */\n    Neuron(long identifier,\n           double[] features) {\n        this.identifier = identifier;\n        this.size = features.length;\n        this.features = new AtomicReference<>(features.clone());\n    }\n\n    /**\n     * Performs a deep copy of this instance.\n     * Upon return, the copied and original instances will be independent:\n     * Updating one will not affect the other.\n     *\n     * @return a new instance with the same state as this instance.\n     * @since 3.6\n     */\n    public synchronized Neuron copy() {\n        final Neuron copy = new Neuron(getIdentifier(),\n                                       getFeatures());\n        copy.numberOfAttemptedUpdates.set(numberOfAttemptedUpdates.get());\n        copy.numberOfSuccessfulUpdates.set(numberOfSuccessfulUpdates.get());\n\n        return copy;\n    }\n\n    /**\n     * Gets the neuron's identifier.\n     *\n     * @return the identifier.\n     */\n    public long getIdentifier() {\n        return identifier;\n    }\n\n    /**\n     * Gets the length of the feature set.\n     *\n     * @return the number of features.\n     */\n    public int getSize() {\n        return size;\n    }\n\n    /**\n     * Gets the neuron's features.\n     *\n     * @return a copy of the neuron's features.\n     */\n    public double[] getFeatures() {\n        return features.get().clone();\n    }\n\n    /**\n     * Tries to atomically update the neuron's features.\n     * Update will be performed only if the expected values match the\n     * current values.<br>\n     * In effect, when concurrent threads call this method, the state\n     * could be modified by one, so that it does not correspond to the\n     * the state assumed by another.\n     * Typically, a caller {@link #getFeatures() retrieves the current state},\n     * and uses it to compute the new state.\n     * During this computation, another thread might have done the same\n     * thing, and updated the state: If the current thread were to proceed\n     * with its own update, it would overwrite the new state (which might\n     * already have been used by yet other threads).\n     * To prevent this, the method does not perform the update when a\n     * concurrent modification has been detected, and returns {@code false}.\n     * When this happens, the caller should fetch the new current state,\n     * redo its computation, and call this method again.\n     *\n     * @param expect Current values of the features, as assumed by the caller.\n     * Update will never succeed if the contents of this array does not match\n     * the values returned by {@link #getFeatures()}.\n     * @param update Features's new values.\n     * @return {@code true} if the update was successful, {@code false}\n     * otherwise.\n     * @throws IllegalArgumentException if the length of {@code update} is\n     * not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     */\n    public boolean compareAndSetFeatures(double[] expect,\n                                         double[] update) {\n        if (update.length != size) {\n            throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                         update.length, size);\n        }\n\n        // Get the internal reference. Note that this must not be a copy;\n        // otherwise the \"compareAndSet\" below will always fail.\n        final double[] current = features.get();\n        if (!containSameValues(current, expect)) {\n            // Some other thread already modified the state.\n            return false;\n        }\n\n        // Increment attempt counter.\n        numberOfAttemptedUpdates.incrementAndGet();\n\n        if (features.compareAndSet(current, update.clone())) {\n            // The current thread could atomically update the state (attempt succeeded).\n            numberOfSuccessfulUpdates.incrementAndGet();\n            return true;\n        } else {\n            // Some other thread came first (attempt failed).\n            return false;\n        }\n    }\n\n    /**\n     * Retrieves the number of calls to the\n     * {@link #compareAndSetFeatures(double[],double[]) compareAndSetFeatures}\n     * method.\n     * Note that if the caller wants to use this method in combination with\n     * {@link #getNumberOfSuccessfulUpdates()}, additional synchronization\n     * may be required to ensure consistency.\n     *\n     * @return the number of update attempts.\n     * @since 3.6\n     */\n    public long getNumberOfAttemptedUpdates() {\n        return numberOfAttemptedUpdates.get();\n    }\n\n    /**\n     * Retrieves the number of successful calls to the\n     * {@link #compareAndSetFeatures(double[],double[]) compareAndSetFeatures}\n     * method.\n     * Note that if the caller wants to use this method in combination with\n     * {@link #getNumberOfAttemptedUpdates()}, additional synchronization\n     * may be required to ensure consistency.\n     *\n     * @return the number of successful updates.\n     * @since 3.6\n     */\n    public long getNumberOfSuccessfulUpdates() {\n        return numberOfSuccessfulUpdates.get();\n    }\n\n    /**\n     * Checks whether the contents of both arrays is the same.\n     *\n     * @param current Current values.\n     * @param expect Expected values.\n     * @throws IllegalArgumentException if the length of {@code expect}\n     * is not the same as specified in the {@link #Neuron(long,double[])\n     * constructor}.\n     * @return {@code true} if the arrays contain the same values.\n     */\n    private boolean containSameValues(double[] current,\n                                      double[] expect) {\n        if (expect.length != size) {\n            throw new NeuralNetException(NeuralNetException.SIZE_MISMATCH,\n                                         expect.length, size);\n        }\n\n        for (int i = 0; i < size; i++) {\n            if (!Precision.equals(current[i], expect[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
        "simple_context": "package org.apache.commons.math4.neuralnet;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport org.apache.commons.numbers.core.Precision;\n\nimport org.apache.commons.math4.neuralnet.internal.NeuralNetException;\n\npublic class Neuron {\n    final private long identifier;\n    final private int size;\n    final private AtomicReference<double[]> features;\n    final private AtomicLong numberOfAttemptedUpdates;\n    final private AtomicLong numberOfSuccessfulUpdates;\n    Neuron(long identifier, double[] features);\n    public synchronized Neuron copy();\n    public long getIdentifier();\n    public int getSize();\n    public double[] getFeatures();\n    public boolean compareAndSetFeatures(double[] expect, double[] update);\n    public long getNumberOfAttemptedUpdates();\n    public long getNumberOfSuccessfulUpdates();\n    private boolean containSameValues(double[] current, double[] expect);\n}\n\n"
    }
]