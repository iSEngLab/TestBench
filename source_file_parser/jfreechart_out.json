[
    {
        "project_name": "jfreechart",
        "file_name": "JSONUtils.java",
        "relative_path": "jfreechart/src/main/java/org/jfree/data/json/JSONUtils.java",
        "execute_path": "jfreechart",
        "package": "org.jfree.data.json",
        "docstring": "/**\n     * Returns a string containing the data in JSON format.  The format is\n     * an array of arrays, where each sub-array represents one data value.\n     * The sub-array should contain two items, first the item key as a string\n     * and second the item value as a number.  For example:\n     * {@code [[\"Key A\", 1.0], [\"Key B\", 2.0]]}\n     * <br><br>\n     * Note that this method can be used with instances of {@link PieDataset}.\n     * \n     * @param data  the data ({@code null} not permitted).\n     * \n     * @return A string in JSON format. \n     */",
        "source_code": "\npublic static String writeKeyedValues(KeyedValues data) {\n    Args.nullNotPermitted(data, \"data\");\n    StringWriter sw = new StringWriter();\n    try {\n        writeKeyedValues(data, sw);\n    } catch (IOException ex) {\n        throw new RuntimeException(ex);\n    }\n    return sw.toString();\n}\n",
        "class_name": "JSONUtils",
        "method_name": "writeKeyedValues",
        "argument_name": [
            "KeyedValues data"
        ],
        "full_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-present, by David Gilbert and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. \n * Other names may be trademarks of their respective owners.]\n *\n * --------------\n * JSONUtils.java\n * --------------\n * (C) Copyright 2014-present, by David Gilbert.\n *\n * Original Author:  David Gilbert;\n * Contributor(s):   -;\n *\n */\n\npackage org.jfree.data.json;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jfree.chart.util.Args;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.KeyedValues2D;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.PieDataset;\nimport org.jfree.data.json.impl.JSONValue;\n\n/**\n * A utility class that can read and write data in specific JSON formats.\n */\npublic class JSONUtils {\n\n    /**\n     * Returns a string containing the data in JSON format.  The format is\n     * an array of arrays, where each sub-array represents one data value.\n     * The sub-array should contain two items, first the item key as a string\n     * and second the item value as a number.  For example:\n     * {@code [[\"Key A\", 1.0], [\"Key B\", 2.0]]}\n     * <br><br>\n     * Note that this method can be used with instances of {@link PieDataset}.\n     * \n     * @param data  the data ({@code null} not permitted).\n     * \n     * @return A string in JSON format. \n     */\n    public static String writeKeyedValues(KeyedValues data) {\n        Args.nullNotPermitted(data, \"data\");\n        StringWriter sw = new StringWriter();\n        try {\n            writeKeyedValues(data, sw);\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n        return sw.toString();\n    }\n\n    /**\n     * Writes the data in JSON format to the supplied writer.\n     * <br><br>\n     * Note that this method can be used with instances of {@link PieDataset}.\n     * \n     * @param data  the data ({@code null} not permitted).\n     * @param writer  the writer ({@code null} not permitted).\n     * \n     * @throws IOException if there is an I/O problem.\n     */\n    public static void writeKeyedValues(KeyedValues data, Writer writer) \n            throws IOException {\n        Args.nullNotPermitted(data, \"data\");\n        Args.nullNotPermitted(writer, \"writer\");\n        writer.write(\"[\");\n        boolean first = true;\n        Iterator iterator = data.getKeys().iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            if (!first) {\n                writer.write(\", \");\n            } else {\n                first = false;\n            }\n            writer.write(\"[\");\n            writer.write(JSONValue.toJSONString(key.toString()));\n            writer.write(\", \");\n            writer.write(JSONValue.toJSONString(data.getValue(key)));\n            writer.write(\"]\");\n        }\n        writer.write(\"]\");\n    }\n    \n    /**\n     * Returns a string containing the data in JSON format.  The format is...\n     * <br><br>\n     * Note that this method can be used with instances of \n     * {@link CategoryDataset}.\n     * \n     * @param data  the data ({@code null} not permitted).\n     * \n     * @return A string in JSON format. \n     */\n    public static String writeKeyedValues2D(KeyedValues2D data) {\n        Args.nullNotPermitted(data, \"data\");\n        StringWriter sw = new StringWriter();\n        try {\n            writeKeyedValues2D(data, sw);\n        } catch (IOException ex) {\n            throw new RuntimeException(ex);\n        }\n        return sw.toString();\n    }\n\n    /**\n     * Writes the data in JSON format to the supplied writer.\n     * <br><br>\n     * Note that this method can be used with instances of \n     * {@link CategoryDataset}.\n     * \n     * @param data  the data ({@code null} not permitted).\n     * @param writer  the writer ({@code null} not permitted).\n     * \n     * @throws IOException if there is an I/O problem.\n     */\n    public static void writeKeyedValues2D(KeyedValues2D data, Writer writer) \n            throws IOException {\n        Args.nullNotPermitted(data, \"data\");\n        Args.nullNotPermitted(writer, \"writer\");\n        List<Comparable<?>> columnKeys = data.getColumnKeys();\n        List<Comparable<?>> rowKeys = data.getRowKeys();\n        writer.write(\"{\");\n        if (!columnKeys.isEmpty()) {\n            writer.write(\"\\\"columnKeys\\\": [\");\n            boolean first = true;\n            for (Comparable<?> columnKey : columnKeys) {\n                if (!first) {\n                    writer.write(\", \");\n                } else {\n                    first = false;\n                }\n                writer.write(JSONValue.toJSONString(columnKey.toString()));\n            }\n            writer.write(\"]\");\n        }\n        if (!rowKeys.isEmpty()) {\n            writer.write(\", \\\"rows\\\": [\");\n            boolean firstRow = true;\n            for (Comparable<?> rowKey : rowKeys) {   \n                if (!firstRow) {\n                    writer.write(\", [\");\n                } else {\n                    writer.write(\"[\");\n                    firstRow = false;\n                }\n                // write the row data \n                writer.write(JSONValue.toJSONString(rowKey.toString()));\n                writer.write(\", [\");\n                boolean first = true;\n                for (Comparable<?> columnKey : columnKeys) {\n                    if (!first) {\n                        writer.write(\", \");\n                    } else {\n                        first = false;\n                    }\n                    writer.write(JSONValue.toJSONString(data.getValue(rowKey, \n                            columnKey)));\n                }\n                writer.write(\"]]\");\n            }\n            writer.write(\"]\");\n        }\n        writer.write(\"}\");    \n    }\n    \n}\n",
        "simple_context": "package org.jfree.data.json;\n\nimport java.io.IOException;\n\nimport java.io.StringWriter;\n\nimport java.io.Writer;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport org.jfree.chart.util.Args;\n\nimport org.jfree.data.KeyedValues;\n\nimport org.jfree.data.KeyedValues2D;\n\nimport org.jfree.data.category.CategoryDataset;\n\nimport org.jfree.data.general.PieDataset;\n\nimport org.jfree.data.json.impl.JSONValue;\n\npublic class JSONUtils {\n    static public String writeKeyedValues(KeyedValues data);\n    static public  writeKeyedValues(KeyedValues data, Writer writer)throws IOException;\n    static public String writeKeyedValues2D(KeyedValues2D data);\n    static public  writeKeyedValues2D(KeyedValues2D data, Writer writer)throws IOException;\n}\n\n"
    },
    {
        "project_name": "jfreechart",
        "file_name": "BoxAndWhiskerCalculator.java",
        "relative_path": "jfreechart/src/main/java/org/jfree/data/statistics/BoxAndWhiskerCalculator.java",
        "execute_path": "jfreechart",
        "package": "org.jfree.data.statistics",
        "docstring": "/**\n     * Calculates the first quartile for a list of numbers in ascending order.\n     * If the items in the list are not in ascending order, the result is\n     * unspecified.  If the list contains items that are {@code null}, not\n     * an instance of {@code Number}, or equivalent to\n     * {@code Double.NaN}, the result is unspecified.\n     *\n     * @param values  the numbers in ascending order ({@code null} not\n     *     permitted).\n     *\n     * @return The first quartile.\n     */",
        "source_code": "\npublic static double calculateQ1(List values) {\n    Args.nullNotPermitted(values, \"values\");\n\n    double result = Double.NaN;\n    int count = values.size();\n    if (count > 0) {\n        if (count % 2 == 1) {\n            if (count > 1) {\n                result = Statistics.calculateMedian(values, 0, count / 2);\n            }\n            else {\n                result = Statistics.calculateMedian(values, 0, 0);\n            }\n        }\n        else {\n            result = Statistics.calculateMedian(values, 0, count / 2 - 1);\n        }\n\n    }\n    return result;\n}\n",
        "class_name": "BoxAndWhiskerCalculator",
        "method_name": "calculateQ1",
        "argument_name": [
            "List values"
        ],
        "full_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-present, by David Gilbert and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. \n * Other names may be trademarks of their respective owners.]\n *\n * ----------------------------\n * BoxAndWhiskerCalculator.java\n * ----------------------------\n * (C) Copyright 2003-present, by David Gilbert and Contributors.\n *\n * Original Author:  David Gilbert;\n * Contributor(s):   -;\n *\n */\n\npackage org.jfree.data.statistics;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jfree.chart.util.Args;\n\n/**\n * A utility class that calculates the mean, median, quartiles Q1 and Q3, plus\n * a list of outlier values...all from an arbitrary list of\n * {@code Number} objects.\n */\npublic abstract class BoxAndWhiskerCalculator {\n\n    /**\n     * Calculates the statistics required for a {@link BoxAndWhiskerItem}\n     * from a list of {@code Number} objects.  Any items in the list\n     * that are {@code null}, not an instance of {@code Number}, or\n     * equivalent to {@code Double.NaN}, will be ignored.\n     *\n     * @param values  a list of numbers (a {@code null} list is not\n     *                permitted).\n     *\n     * @return A box-and-whisker item.\n     */\n    public static BoxAndWhiskerItem calculateBoxAndWhiskerStatistics(\n                                        List values) {\n        return calculateBoxAndWhiskerStatistics(values, true);\n    }\n\n    /**\n     * Calculates the statistics required for a {@link BoxAndWhiskerItem}\n     * from a list of {@code Number} objects.  Any items in the list\n     * that are {@code null}, not an instance of {@code Number}, or\n     * equivalent to {@code Double.NaN}, will be ignored.\n     *\n     * @param values  a list of numbers (a {@code null} list is not\n     *                permitted).\n     * @param stripNullAndNaNItems  a flag that controls the handling of null\n     *     and NaN items.\n     *\n     * @return A box-and-whisker item.\n     */\n    public static BoxAndWhiskerItem calculateBoxAndWhiskerStatistics(\n            List values, boolean stripNullAndNaNItems) {\n\n        Args.nullNotPermitted(values, \"values\");\n\n        List vlist;\n        if (stripNullAndNaNItems) {\n            vlist = new ArrayList(values.size());\n            Iterator iterator = values.listIterator();\n            while (iterator.hasNext()) {\n                Object obj = iterator.next();\n                if (obj instanceof Number) {\n                    Number n = (Number) obj;\n                    double v = n.doubleValue();\n                    if (!Double.isNaN(v)) {\n                        vlist.add(n);\n                    }\n                }\n            }\n        }\n        else {\n            vlist = values;\n        }\n        Collections.sort(vlist);\n\n        double mean = Statistics.calculateMean(vlist, false);\n        double median = Statistics.calculateMedian(vlist, false);\n        double q1 = calculateQ1(vlist);\n        double q3 = calculateQ3(vlist);\n\n        double interQuartileRange = q3 - q1;\n\n        double upperOutlierThreshold = q3 + (interQuartileRange * 1.5);\n        double lowerOutlierThreshold = q1 - (interQuartileRange * 1.5);\n\n        double upperFaroutThreshold = q3 + (interQuartileRange * 2.0);\n        double lowerFaroutThreshold = q1 - (interQuartileRange * 2.0);\n\n        double minRegularValue = Double.POSITIVE_INFINITY;\n        double maxRegularValue = Double.NEGATIVE_INFINITY;\n        double minOutlier = Double.POSITIVE_INFINITY;\n        double maxOutlier = Double.NEGATIVE_INFINITY;\n        List outliers = new ArrayList();\n\n        Iterator iterator = vlist.iterator();\n        while (iterator.hasNext()) {\n            Number number = (Number) iterator.next();\n            double value = number.doubleValue();\n            if (value > upperOutlierThreshold) {\n                outliers.add(number);\n                if (value > maxOutlier && value <= upperFaroutThreshold) {\n                    maxOutlier = value;\n                }\n            }\n            else if (value < lowerOutlierThreshold) {\n                outliers.add(number);\n                if (value < minOutlier && value >= lowerFaroutThreshold) {\n                    minOutlier = value;\n                }\n            }\n            else {\n                minRegularValue = Math.min(minRegularValue, value);\n                maxRegularValue = Math.max(maxRegularValue, value);\n            }\n            minOutlier = Math.min(minOutlier, minRegularValue);\n            maxOutlier = Math.max(maxOutlier, maxRegularValue);\n        }\n\n        return new BoxAndWhiskerItem(mean, median, q1, q3, minRegularValue,\n                maxRegularValue, minOutlier, maxOutlier, outliers);\n\n    }\n\n    /**\n     * Calculates the first quartile for a list of numbers in ascending order.\n     * If the items in the list are not in ascending order, the result is\n     * unspecified.  If the list contains items that are {@code null}, not\n     * an instance of {@code Number}, or equivalent to\n     * {@code Double.NaN}, the result is unspecified.\n     *\n     * @param values  the numbers in ascending order ({@code null} not\n     *     permitted).\n     *\n     * @return The first quartile.\n     */\n    public static double calculateQ1(List values) {\n        Args.nullNotPermitted(values, \"values\");\n\n        double result = Double.NaN;\n        int count = values.size();\n        if (count > 0) {\n            if (count % 2 == 1) {\n                if (count > 1) {\n                    result = Statistics.calculateMedian(values, 0, count / 2);\n                }\n                else {\n                    result = Statistics.calculateMedian(values, 0, 0);\n                }\n            }\n            else {\n                result = Statistics.calculateMedian(values, 0, count / 2 - 1);\n            }\n\n        }\n        return result;\n    }\n\n    /**\n     * Calculates the third quartile for a list of numbers in ascending order.\n     * If the items in the list are not in ascending order, the result is\n     * unspecified.  If the list contains items that are {@code null}, not\n     * an instance of {@code Number}, or equivalent to\n     * {@code Double.NaN}, the result is unspecified.\n     *\n     * @param values  the list of values ({@code null} not permitted).\n     *\n     * @return The third quartile.\n     */\n    public static double calculateQ3(List values) {\n        Args.nullNotPermitted(values, \"values\");\n        double result = Double.NaN;\n        int count = values.size();\n        if (count > 0) {\n            if (count % 2 == 1) {\n                if (count > 1) {\n                    result = Statistics.calculateMedian(values, count / 2,\n                            count - 1);\n                }\n                else {\n                    result = Statistics.calculateMedian(values, 0, 0);\n                }\n            }\n            else {\n                result = Statistics.calculateMedian(values, count / 2,\n                        count - 1);\n            }\n        }\n        return result;\n    }\n\n}\n",
        "simple_context": "package org.jfree.data.statistics;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport org.jfree.chart.util.Args;\n\nabstract public class BoxAndWhiskerCalculator {\n    static public BoxAndWhiskerItem calculateBoxAndWhiskerStatistics(List values);\n    static public BoxAndWhiskerItem calculateBoxAndWhiskerStatistics(List values, boolean stripNullAndNaNItems);\n    static public double calculateQ1(List values);\n    static public double calculateQ3(List values);\n}\n\n"
    },
    {
        "project_name": "jfreechart",
        "file_name": "Regression.java",
        "relative_path": "jfreechart/src/main/java/org/jfree/data/statistics/Regression.java",
        "execute_path": "jfreechart",
        "package": "org.jfree.data.statistics",
        "docstring": "/**\n     * Returns the parameters 'a' and 'b' for an equation y = ax^b, fitted to\n     * the data using a power regression equation.  The result is returned as\n     * an array, where double[0] --&gt; a, and double[1] --&gt; b.\n     *\n     * @param data  the data.\n     *\n     * @return The parameters.\n     */",
        "source_code": "\npublic static double[] getPowerRegression(double[][] data) {\n\n    int n = data.length;\n    if (n < 2) {\n        throw new IllegalArgumentException(\"Not enough data.\");\n    }\n\n    double sumX = 0;\n    double sumY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        double x = Math.log(data[i][0]);\n        double y = Math.log(data[i][1]);\n        sumX += x;\n        sumY += y;\n        double xx = x * x;\n        sumXX += xx;\n        double xy = x * y;\n        sumXY += xy;\n    }\n    double sxx = sumXX - (sumX * sumX) / n;\n    double sxy = sumXY - (sumX * sumY) / n;\n    double xbar = sumX / n;\n    double ybar = sumY / n;\n\n    double[] result = new double[2];\n    result[1] = sxy / sxx;\n    result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n\n    return result;\n\n}\n",
        "class_name": "Regression",
        "method_name": "getPowerRegression",
        "argument_name": [
            "double[][] data"
        ],
        "full_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-present, by David Gilbert and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. \n * Other names may be trademarks of their respective owners.]\n *\n * ---------------\n * Regression.java\n * ---------------\n * (C) Copyright 2002-present, by David Gilbert.\n *\n * Original Author:  David Gilbert;\n * Contributor(s):   Peter Kolb (patch 2795746);\n *\n */\n\npackage org.jfree.data.statistics;\n\nimport org.jfree.chart.util.Args;\nimport org.jfree.data.xy.XYDataset;\n\n/**\n * A utility class for fitting regression curves to data.\n */\npublic abstract class Regression {\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = a + bx, fitted to\n     * the data using ordinary least squares regression.  The result is\n     * returned as a double[], where result[0] --&gt; a, and result[1] --&gt; b.\n     *\n     * @param data  the data.\n     *\n     * @return The parameters.\n     */\n    public static double[] getOLSRegression(double[][] data) {\n\n        int n = data.length;\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = data[i][0];\n            double y = data[i][1];\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = ybar - result[1] * xbar;\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = a + bx, fitted to\n     * the data using ordinary least squares regression. The result is returned\n     * as a double[], where result[0] --&gt; a, and result[1] --&gt; b.\n     *\n     * @param data  the data.\n     * @param series  the series (zero-based index).\n     *\n     * @return The parameters.\n     */\n    public static double[] getOLSRegression(XYDataset data, int series) {\n\n        int n = data.getItemCount(series);\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = data.getXValue(series, i);\n            double y = data.getYValue(series, i);\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = ybar - result[1] * xbar;\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = ax^b, fitted to\n     * the data using a power regression equation.  The result is returned as\n     * an array, where double[0] --&gt; a, and double[1] --&gt; b.\n     *\n     * @param data  the data.\n     *\n     * @return The parameters.\n     */\n    public static double[] getPowerRegression(double[][] data) {\n\n        int n = data.length;\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = Math.log(data[i][0]);\n            double y = Math.log(data[i][1]);\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = ax^b, fitted to\n     * the data using a power regression equation.  The result is returned as\n     * an array, where double[0] --&gt; a, and double[1] --&gt; b.\n     *\n     * @param data  the data.\n     * @param series  the series to fit the regression line against.\n     *\n     * @return The parameters.\n     */\n    public static double[] getPowerRegression(XYDataset data, int series) {\n\n        int n = data.getItemCount(series);\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = Math.log(data.getXValue(series, i));\n            double y = Math.log(data.getYValue(series, i));\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a0', 'a1', 'a2', ..., 'an' for a polynomial \n     * function of order n, y = a0 + a1 * x + a2 * x^2 + ... + an * x^n,\n     * fitted to the data using a polynomial regression equation.\n     * The result is returned as an array with a length of n + 2,\n     * where double[0] --&gt; a0, double[1] --&gt; a1, .., double[n] --&gt; an.\n     * and double[n + 1] is the correlation coefficient R2\n     * Reference: J. D. Faires, R. L. Burden, Numerische Methoden (german\n     * edition), pp. 243ff and 327ff.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param series  the series to fit the regression line against (the series\n     *         must have at least order + 1 non-NaN items).\n     * @param order  the order of the function (&gt; 0).\n     *\n     * @return The parameters.\n     */\n    public static double[] getPolynomialRegression(XYDataset dataset, \n            int series, int order) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        int itemCount = dataset.getItemCount(series);\n        if (itemCount < order + 1) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n        int validItems = 0;\n        double[][] data = new double[2][itemCount];\n        for(int item = 0; item < itemCount; item++){\n            double x = dataset.getXValue(series, item);\n            double y = dataset.getYValue(series, item);\n            if (!Double.isNaN(x) && !Double.isNaN(y)){\n                data[0][validItems] = x;\n                data[1][validItems] = y;\n                validItems++;\n            }\n        }\n        if (validItems < order + 1) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n        int equations = order + 1;\n        int coefficients = order + 2;\n        double[] result = new double[equations + 1];\n        double[][] matrix = new double[equations][coefficients];\n        double sumX = 0.0;\n        double sumY = 0.0;\n\n        for(int item = 0; item < validItems; item++){\n            sumX += data[0][item];\n            sumY += data[1][item];\n            for(int eq = 0; eq < equations; eq++){\n                for(int coe = 0; coe < coefficients - 1; coe++){\n                    matrix[eq][coe] += Math.pow(data[0][item],eq + coe);\n                }\n                matrix[eq][coefficients - 1] += data[1][item]\n                        * Math.pow(data[0][item],eq);\n            }\n        }\n        double[][] subMatrix = calculateSubMatrix(matrix);\n        for (int eq = 1; eq < equations; eq++) {\n            matrix[eq][0] = 0;\n            if (coefficients - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, matrix[eq], 1, coefficients - 1);\n        }\n        for (int eq = equations - 1; eq > -1; eq--) {\n            double value = matrix[eq][coefficients - 1];\n            for (int coe = eq; coe < coefficients -1; coe++) {\n                value -= matrix[eq][coe] * result[coe];\n            }\n            result[eq] = value / matrix[eq][eq];\n        }\n        double meanY = sumY / validItems;\n        double yObsSquare = 0.0;\n        double yRegSquare = 0.0;\n        for (int item = 0; item < validItems; item++) {\n            double yCalc = 0;\n            for (int eq = 0; eq < equations; eq++) {\n                yCalc += result[eq] * Math.pow(data[0][item],eq);\n            }\n            yRegSquare += Math.pow(yCalc - meanY, 2);\n            yObsSquare += Math.pow(data[1][item] - meanY, 2);\n        }\n        double rSquare = yRegSquare / yObsSquare;\n        result[equations] = rSquare;\n        return result;\n    }\n\n    /**\n     * Returns a matrix with the following features: (1) the number of rows\n     * and columns is 1 less than that of the original matrix; (2)the matrix\n     * is triangular, i.e. all elements a (row, column) with column &gt; row are\n     * zero.  This method is used for calculating a polynomial regression.\n     * \n     * @param matrix  the start matrix.\n     *\n     * @return The new matrix.\n     */\n    private static double[][] calculateSubMatrix(double[][] matrix){\n        int equations = matrix.length;\n        int coefficients = matrix[0].length;\n        double[][] result = new double[equations - 1][coefficients - 1];\n        for (int eq = 1; eq < equations; eq++) {\n            double factor = matrix[0][0] / matrix[eq][0];\n            for (int coe = 1; coe < coefficients; coe++) {\n                result[eq - 1][coe -1] = matrix[0][coe] - matrix[eq][coe]\n                        * factor;\n            }\n        }\n        if (equations == 1) {\n            return result;\n        }\n        // check for zero pivot element\n        if (result[0][0] == 0) {\n            boolean found = false;\n            for (int i = 0; i < result.length; i ++) {\n                if (result[i][0] != 0) {\n                    found = true;\n                    double[] temp = result[0];\n                    System.arraycopy(result[i], 0, result[0], 0, \n                            result[i].length);\n                    System.arraycopy(temp, 0, result[i], 0, temp.length);\n                    break;\n                }\n            }\n            if (!found) {\n                //System.out.println(\"Equation has no solution!\");\n                return new double[equations - 1][coefficients - 1];\n            }\n        }\n        double[][] subMatrix = calculateSubMatrix(result);\n        for (int eq = 1; eq < equations -  1; eq++) {\n            result[eq][0] = 0;\n            if (coefficients - 1 - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, result[eq], 1, coefficients - 1 - 1);\n        }\n        return result;\n    }\n\n}\n",
        "simple_context": "package org.jfree.data.statistics;\n\nimport org.jfree.chart.util.Args;\n\nimport org.jfree.data.xy.XYDataset;\n\nabstract public class Regression {\n    static public double[] getOLSRegression(double[][] data);\n    static public double[] getOLSRegression(XYDataset data, int series);\n    static public double[] getPowerRegression(double[][] data);\n    static public double[] getPowerRegression(XYDataset data, int series);\n    static public double[] getPolynomialRegression(XYDataset dataset, int series, int order);\n    static private double[][] calculateSubMatrix(double[][] matrix);\n}\n\n"
    },
    {
        "project_name": "jfreechart",
        "file_name": "Regression.java",
        "relative_path": "jfreechart/src/main/java/org/jfree/data/statistics/Regression.java",
        "execute_path": "jfreechart",
        "package": "org.jfree.data.statistics",
        "docstring": "/**\n     * Returns a matrix with the following features: (1) the number of rows\n     * and columns is 1 less than that of the original matrix; (2)the matrix\n     * is triangular, i.e. all elements a (row, column) with column &gt; row are\n     * zero.  This method is used for calculating a polynomial regression.\n     * \n     * @param matrix  the start matrix.\n     *\n     * @return The new matrix.\n     */",
        "source_code": "\nprivate static double[][] calculateSubMatrix(double[][] matrix){\n    int equations = matrix.length;\n    int coefficients = matrix[0].length;\n    double[][] result = new double[equations - 1][coefficients - 1];\n    for (int eq = 1; eq < equations; eq++) {\n        double factor = matrix[0][0] / matrix[eq][0];\n        for (int coe = 1; coe < coefficients; coe++) {\n            result[eq - 1][coe -1] = matrix[0][coe] - matrix[eq][coe]\n                    * factor;\n        }\n    }\n    if (equations == 1) {\n        return result;\n    }\n    // check for zero pivot element\n    if (result[0][0] == 0) {\n        boolean found = false;\n        for (int i = 0; i < result.length; i ++) {\n            if (result[i][0] != 0) {\n                found = true;\n                double[] temp = result[0];\n                System.arraycopy(result[i], 0, result[0], 0, \n                        result[i].length);\n                System.arraycopy(temp, 0, result[i], 0, temp.length);\n                break;\n            }\n        }\n        if (!found) {\n            //System.out.println(\"Equation has no solution!\");\n            return new double[equations - 1][coefficients - 1];\n        }\n    }\n    double[][] subMatrix = calculateSubMatrix(result);\n    for (int eq = 1; eq < equations -  1; eq++) {\n        result[eq][0] = 0;\n        if (coefficients - 1 - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, result[eq], 1, coefficients - 1 - 1);\n    }\n    return result;\n}\n",
        "class_name": "Regression",
        "method_name": "calculateSubMatrix",
        "argument_name": [
            "double[][] matrix"
        ],
        "full_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-present, by David Gilbert and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. \n * Other names may be trademarks of their respective owners.]\n *\n * ---------------\n * Regression.java\n * ---------------\n * (C) Copyright 2002-present, by David Gilbert.\n *\n * Original Author:  David Gilbert;\n * Contributor(s):   Peter Kolb (patch 2795746);\n *\n */\n\npackage org.jfree.data.statistics;\n\nimport org.jfree.chart.util.Args;\nimport org.jfree.data.xy.XYDataset;\n\n/**\n * A utility class for fitting regression curves to data.\n */\npublic abstract class Regression {\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = a + bx, fitted to\n     * the data using ordinary least squares regression.  The result is\n     * returned as a double[], where result[0] --&gt; a, and result[1] --&gt; b.\n     *\n     * @param data  the data.\n     *\n     * @return The parameters.\n     */\n    public static double[] getOLSRegression(double[][] data) {\n\n        int n = data.length;\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = data[i][0];\n            double y = data[i][1];\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = ybar - result[1] * xbar;\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = a + bx, fitted to\n     * the data using ordinary least squares regression. The result is returned\n     * as a double[], where result[0] --&gt; a, and result[1] --&gt; b.\n     *\n     * @param data  the data.\n     * @param series  the series (zero-based index).\n     *\n     * @return The parameters.\n     */\n    public static double[] getOLSRegression(XYDataset data, int series) {\n\n        int n = data.getItemCount(series);\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = data.getXValue(series, i);\n            double y = data.getYValue(series, i);\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = ybar - result[1] * xbar;\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = ax^b, fitted to\n     * the data using a power regression equation.  The result is returned as\n     * an array, where double[0] --&gt; a, and double[1] --&gt; b.\n     *\n     * @param data  the data.\n     *\n     * @return The parameters.\n     */\n    public static double[] getPowerRegression(double[][] data) {\n\n        int n = data.length;\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = Math.log(data[i][0]);\n            double y = Math.log(data[i][1]);\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a' and 'b' for an equation y = ax^b, fitted to\n     * the data using a power regression equation.  The result is returned as\n     * an array, where double[0] --&gt; a, and double[1] --&gt; b.\n     *\n     * @param data  the data.\n     * @param series  the series to fit the regression line against.\n     *\n     * @return The parameters.\n     */\n    public static double[] getPowerRegression(XYDataset data, int series) {\n\n        int n = data.getItemCount(series);\n        if (n < 2) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < n; i++) {\n            double x = Math.log(data.getXValue(series, i));\n            double y = Math.log(data.getYValue(series, i));\n            sumX += x;\n            sumY += y;\n            double xx = x * x;\n            sumXX += xx;\n            double xy = x * y;\n            sumXY += xy;\n        }\n        double sxx = sumXX - (sumX * sumX) / n;\n        double sxy = sumXY - (sumX * sumY) / n;\n        double xbar = sumX / n;\n        double ybar = sumY / n;\n\n        double[] result = new double[2];\n        result[1] = sxy / sxx;\n        result[0] = Math.pow(Math.exp(1.0), ybar - result[1] * xbar);\n\n        return result;\n\n    }\n\n    /**\n     * Returns the parameters 'a0', 'a1', 'a2', ..., 'an' for a polynomial \n     * function of order n, y = a0 + a1 * x + a2 * x^2 + ... + an * x^n,\n     * fitted to the data using a polynomial regression equation.\n     * The result is returned as an array with a length of n + 2,\n     * where double[0] --&gt; a0, double[1] --&gt; a1, .., double[n] --&gt; an.\n     * and double[n + 1] is the correlation coefficient R2\n     * Reference: J. D. Faires, R. L. Burden, Numerische Methoden (german\n     * edition), pp. 243ff and 327ff.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param series  the series to fit the regression line against (the series\n     *         must have at least order + 1 non-NaN items).\n     * @param order  the order of the function (&gt; 0).\n     *\n     * @return The parameters.\n     */\n    public static double[] getPolynomialRegression(XYDataset dataset, \n            int series, int order) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        int itemCount = dataset.getItemCount(series);\n        if (itemCount < order + 1) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n        int validItems = 0;\n        double[][] data = new double[2][itemCount];\n        for(int item = 0; item < itemCount; item++){\n            double x = dataset.getXValue(series, item);\n            double y = dataset.getYValue(series, item);\n            if (!Double.isNaN(x) && !Double.isNaN(y)){\n                data[0][validItems] = x;\n                data[1][validItems] = y;\n                validItems++;\n            }\n        }\n        if (validItems < order + 1) {\n            throw new IllegalArgumentException(\"Not enough data.\");\n        }\n        int equations = order + 1;\n        int coefficients = order + 2;\n        double[] result = new double[equations + 1];\n        double[][] matrix = new double[equations][coefficients];\n        double sumX = 0.0;\n        double sumY = 0.0;\n\n        for(int item = 0; item < validItems; item++){\n            sumX += data[0][item];\n            sumY += data[1][item];\n            for(int eq = 0; eq < equations; eq++){\n                for(int coe = 0; coe < coefficients - 1; coe++){\n                    matrix[eq][coe] += Math.pow(data[0][item],eq + coe);\n                }\n                matrix[eq][coefficients - 1] += data[1][item]\n                        * Math.pow(data[0][item],eq);\n            }\n        }\n        double[][] subMatrix = calculateSubMatrix(matrix);\n        for (int eq = 1; eq < equations; eq++) {\n            matrix[eq][0] = 0;\n            if (coefficients - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, matrix[eq], 1, coefficients - 1);\n        }\n        for (int eq = equations - 1; eq > -1; eq--) {\n            double value = matrix[eq][coefficients - 1];\n            for (int coe = eq; coe < coefficients -1; coe++) {\n                value -= matrix[eq][coe] * result[coe];\n            }\n            result[eq] = value / matrix[eq][eq];\n        }\n        double meanY = sumY / validItems;\n        double yObsSquare = 0.0;\n        double yRegSquare = 0.0;\n        for (int item = 0; item < validItems; item++) {\n            double yCalc = 0;\n            for (int eq = 0; eq < equations; eq++) {\n                yCalc += result[eq] * Math.pow(data[0][item],eq);\n            }\n            yRegSquare += Math.pow(yCalc - meanY, 2);\n            yObsSquare += Math.pow(data[1][item] - meanY, 2);\n        }\n        double rSquare = yRegSquare / yObsSquare;\n        result[equations] = rSquare;\n        return result;\n    }\n\n    /**\n     * Returns a matrix with the following features: (1) the number of rows\n     * and columns is 1 less than that of the original matrix; (2)the matrix\n     * is triangular, i.e. all elements a (row, column) with column &gt; row are\n     * zero.  This method is used for calculating a polynomial regression.\n     * \n     * @param matrix  the start matrix.\n     *\n     * @return The new matrix.\n     */\n    private static double[][] calculateSubMatrix(double[][] matrix){\n        int equations = matrix.length;\n        int coefficients = matrix[0].length;\n        double[][] result = new double[equations - 1][coefficients - 1];\n        for (int eq = 1; eq < equations; eq++) {\n            double factor = matrix[0][0] / matrix[eq][0];\n            for (int coe = 1; coe < coefficients; coe++) {\n                result[eq - 1][coe -1] = matrix[0][coe] - matrix[eq][coe]\n                        * factor;\n            }\n        }\n        if (equations == 1) {\n            return result;\n        }\n        // check for zero pivot element\n        if (result[0][0] == 0) {\n            boolean found = false;\n            for (int i = 0; i < result.length; i ++) {\n                if (result[i][0] != 0) {\n                    found = true;\n                    double[] temp = result[0];\n                    System.arraycopy(result[i], 0, result[0], 0, \n                            result[i].length);\n                    System.arraycopy(temp, 0, result[i], 0, temp.length);\n                    break;\n                }\n            }\n            if (!found) {\n                //System.out.println(\"Equation has no solution!\");\n                return new double[equations - 1][coefficients - 1];\n            }\n        }\n        double[][] subMatrix = calculateSubMatrix(result);\n        for (int eq = 1; eq < equations -  1; eq++) {\n            result[eq][0] = 0;\n            if (coefficients - 1 - 1 >= 0) System.arraycopy(subMatrix[eq - 1], 0, result[eq], 1, coefficients - 1 - 1);\n        }\n        return result;\n    }\n\n}\n",
        "simple_context": "package org.jfree.data.statistics;\n\nimport org.jfree.chart.util.Args;\n\nimport org.jfree.data.xy.XYDataset;\n\nabstract public class Regression {\n    static public double[] getOLSRegression(double[][] data);\n    static public double[] getOLSRegression(XYDataset data, int series);\n    static public double[] getPowerRegression(double[][] data);\n    static public double[] getPowerRegression(XYDataset data, int series);\n    static public double[] getPolynomialRegression(XYDataset dataset, int series, int order);\n    static private double[][] calculateSubMatrix(double[][] matrix);\n}\n\n"
    },
    {
        "project_name": "jfreechart",
        "file_name": "DatasetUtils.java",
        "relative_path": "jfreechart/src/main/java/org/jfree/data/general/DatasetUtils.java",
        "execute_path": "jfreechart",
        "package": "org.jfree.data.general",
        "docstring": "/**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or {@code null} values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The total.\n     */",
        "source_code": "\npublic static double calculatePieDatasetTotal(PieDataset dataset) {\n    Args.nullNotPermitted(dataset, \"dataset\");\n    List keys = dataset.getKeys();\n    double totalValue = 0;\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable current = (Comparable) iterator.next();\n        if (current != null) {\n            Number value = dataset.getValue(current);\n            double v = 0.0;\n            if (value != null) {\n                v = value.doubleValue();\n            }\n            if (v > 0) {\n                totalValue = totalValue + v;\n            }\n        }\n    }\n    return totalValue;\n}\n",
        "class_name": "DatasetUtils",
        "method_name": "calculatePieDatasetTotal",
        "argument_name": [
            "PieDataset dataset"
        ],
        "full_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-present, by David Gilbert and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. \n * Other names may be trademarks of their respective owners.]\n *\n * -----------------\n * DatasetUtils.java\n * -----------------\n * (C) Copyright 2000-present, by David Gilbert and Contributors.\n *\n * Original Author:  David Gilbert;\n * Contributor(s):   Andrzej Porebski (bug fix);\n *                   Jonathan Nash (bug fix);\n *                   Richard Atkinson;\n *                   Andreas Schroeder;\n *                   Rafal Skalny (patch 1925366);\n *                   Jerome David (patch 2131001);\n *                   Peter Kolb (patch 2791407);\n *                   Martin Hoeller (patch 2952086);\n *\n */\n\npackage org.jfree.data.general;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.jfree.chart.util.ArrayUtils;\nimport org.jfree.chart.util.Args;\n\nimport org.jfree.data.DomainInfo;\nimport org.jfree.data.DomainOrder;\nimport org.jfree.data.KeyToGroupMap;\nimport org.jfree.data.KeyedValues;\nimport org.jfree.data.Range;\nimport org.jfree.data.RangeInfo;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.category.CategoryRangeInfo;\nimport org.jfree.data.category.DefaultCategoryDataset;\nimport org.jfree.data.category.IntervalCategoryDataset;\nimport org.jfree.data.function.Function2D;\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\nimport org.jfree.data.xy.IntervalXYDataset;\nimport org.jfree.data.xy.OHLCDataset;\nimport org.jfree.data.xy.TableXYDataset;\nimport org.jfree.data.xy.XYDataset;\nimport org.jfree.data.xy.XYDomainInfo;\nimport org.jfree.data.xy.XYRangeInfo;\nimport org.jfree.data.xy.XYSeries;\nimport org.jfree.data.xy.XYSeriesCollection;\nimport org.jfree.data.xy.XYZDataset;\n\n/**\n * A collection of useful static methods relating to datasets.\n */\npublic final class DatasetUtils {\n\n    /**\n     * Private constructor for non-instanceability.\n     */\n    private DatasetUtils() {\n        // now try to instantiate this ;-)\n    }\n\n    /**\n     * Calculates the total of all the values in a {@link PieDataset}.  If\n     * the dataset contains negative or {@code null} values, they are\n     * ignored.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The total.\n     */\n    public static double calculatePieDatasetTotal(PieDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        List keys = dataset.getKeys();\n        double totalValue = 0;\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable current = (Comparable) iterator.next();\n            if (current != null) {\n                Number value = dataset.getValue(current);\n                double v = 0.0;\n                if (value != null) {\n                    v = value.doubleValue();\n                }\n                if (v > 0) {\n                    totalValue = totalValue + v;\n                }\n            }\n        }\n        return totalValue;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param rowKey  the row key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n            Comparable rowKey) {\n        int row = dataset.getRowIndex(rowKey);\n        return createPieDatasetForRow(dataset, row);\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single row.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param row  the row (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForRow(CategoryDataset dataset,\n            int row) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int columnCount = dataset.getColumnCount();\n        for (int current = 0; current < columnCount; current++) {\n            Comparable columnKey = dataset.getColumnKey(current);\n            result.setValue(columnKey, dataset.getValue(row, current));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a pie dataset from a table dataset by taking all the values\n     * for a single column.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param columnKey  the column key.\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n            Comparable columnKey) {\n        int column = dataset.getColumnIndex(columnKey);\n        return createPieDatasetForColumn(dataset, column);\n    }\n\n    /**\n     * Creates a pie dataset from a {@link CategoryDataset} by taking all the\n     * values for a single column.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param column  the column (zero-based index).\n     *\n     * @return A pie dataset.\n     */\n    public static PieDataset createPieDatasetForColumn(CategoryDataset dataset,\n            int column) {\n        DefaultPieDataset result = new DefaultPieDataset();\n        int rowCount = dataset.getRowCount();\n        for (int i = 0; i < rowCount; i++) {\n            Comparable rowKey = dataset.getRowKey(i);\n            result.setValue(rowKey, dataset.getValue(i, column));\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the {@code percentThreshold}) into a single item with the\n     * key \"Other\".\n     *\n     * @param source  the source dataset ({@code null} not permitted).\n     * @param key  a new key for the aggregated items ({@code null} not\n     *             permitted).\n     * @param minimumPercent  the percent threshold.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent) {\n        return DatasetUtils.createConsolidatedPieDataset(source, key,\n                minimumPercent, 2);\n    }\n\n    /**\n     * Creates a new pie dataset based on the supplied dataset, but modified\n     * by aggregating all the low value items (those whose value is lower\n     * than the {@code percentThreshold}) into a single item.  The\n     * aggregated items are assigned the specified key.  Aggregation only\n     * occurs if there are at least {@code minItems} items to aggregate.\n     *\n     * @param source  the source dataset ({@code null} not permitted).\n     * @param key  the key to represent the aggregated items.\n     * @param minimumPercent  the percent threshold (ten percent is 0.10).\n     * @param minItems  only aggregate low values if there are at least this\n     *                  many.\n     *\n     * @return The pie dataset with (possibly) aggregated items.\n     */\n    public static PieDataset createConsolidatedPieDataset(PieDataset source,\n            Comparable key, double minimumPercent, int minItems) {\n\n        DefaultPieDataset result = new DefaultPieDataset();\n        double total = DatasetUtils.calculatePieDatasetTotal(source);\n\n        //  Iterate and find all keys below threshold percentThreshold\n        List keys = source.getKeys();\n        ArrayList otherKeys = new ArrayList();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                double value = dataValue.doubleValue();\n                if (value / total < minimumPercent) {\n                    otherKeys.add(currentKey);\n                }\n            }\n        }\n\n        //  Create new dataset with keys above threshold percentThreshold\n        iterator = keys.iterator();\n        double otherValue = 0;\n        while (iterator.hasNext()) {\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = source.getValue(currentKey);\n            if (dataValue != null) {\n                if (otherKeys.contains(currentKey)\n                    && otherKeys.size() >= minItems) {\n                    //  Do not add key to dataset\n                    otherValue += dataValue.doubleValue();\n                }\n                else {\n                    //  Add key to dataset\n                    result.setValue(currentKey, dataValue);\n                }\n            }\n        }\n        //  Add other category if applicable\n        if (otherKeys.size() >= minItems) {\n            result.setValue(key, otherValue);\n        }\n        return result;\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in an\n     * array (instances of {@code double} are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, double[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array.\n     * <p>\n     * Row and column keys are created by appending 0, 1, 2, ... to the\n     * supplied prefixes.\n     *\n     * @param rowKeyPrefix  the row key prefix.\n     * @param columnKeyPrefix  the column key prefix.\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(String rowKeyPrefix,\n            String columnKeyPrefix, Number[][] data) {\n\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            String rowKey = rowKeyPrefix + (r + 1);\n            for (int c = 0; c < data[r].length; c++) {\n                String columnKey = columnKeyPrefix + (c + 1);\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} that contains a copy of the data in\n     * an array (instances of {@code double} are created to represent the\n     * data items).\n     * <p>\n     * Row and column keys are taken from the supplied arrays.\n     *\n     * @param rowKeys  the row keys ({@code null} not permitted).\n     * @param columnKeys  the column keys ({@code null} not permitted).\n     * @param data  the data.\n     *\n     * @return The dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable[] rowKeys,\n            Comparable[] columnKeys, double[][] data) {\n\n        Args.nullNotPermitted(rowKeys, \"rowKeys\");\n        Args.nullNotPermitted(columnKeys, \"columnKeys\");\n        if (ArrayUtils.hasDuplicateItems(rowKeys)) {\n            throw new IllegalArgumentException(\"Duplicate items in 'rowKeys'.\");\n        }\n        if (ArrayUtils.hasDuplicateItems(columnKeys)) {\n            throw new IllegalArgumentException(\n                    \"Duplicate items in 'columnKeys'.\");\n        }\n        if (rowKeys.length != data.length) {\n            throw new IllegalArgumentException(\n                \"The number of row keys does not match the number of rows in \"\n                + \"the data array.\");\n        }\n        int columnCount = 0;\n        for (int r = 0; r < data.length; r++) {\n            columnCount = Math.max(columnCount, data[r].length);\n        }\n        if (columnKeys.length != columnCount) {\n            throw new IllegalArgumentException(\n                \"The number of column keys does not match the number of \"\n                + \"columns in the data array.\");\n        }\n\n        // now do the work...\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int r = 0; r < data.length; r++) {\n            Comparable rowKey = rowKeys[r];\n            for (int c = 0; c < data[r].length; c++) {\n                Comparable columnKey = columnKeys[c];\n                result.addValue(data[r][c], rowKey, columnKey);\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates a {@link CategoryDataset} by copying the data from the supplied\n     * {@link KeyedValues} instance.\n     *\n     * @param rowKey  the row key ({@code null} not permitted).\n     * @param rowData  the row data ({@code null} not permitted).\n     *\n     * @return A dataset.\n     */\n    public static CategoryDataset createCategoryDataset(Comparable rowKey,\n            KeyedValues rowData) {\n\n        Args.nullNotPermitted(rowKey, \"rowKey\");\n        Args.nullNotPermitted(rowData, \"rowData\");\n        DefaultCategoryDataset result = new DefaultCategoryDataset();\n        for (int i = 0; i < rowData.getItemCount(); i++) {\n            result.addValue(rowData.getValue(i), rowKey, rowData.getKey(i));\n        }\n        return result;\n\n    }\n\n    /**\n     * Creates an {@link XYDataset} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function ({@code null} not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be &gt; 1).\n     * @param seriesKey  the key to give the resulting series ({@code null} not\n     *     permitted).\n     *\n     * @return A dataset.\n     */\n    public static XYDataset sampleFunction2D(Function2D f, double start,\n            double end, int samples, Comparable seriesKey) {\n\n        // defer argument checking\n        XYSeries series = sampleFunction2DToSeries(f, start, end, samples,\n                seriesKey);\n        XYSeriesCollection collection = new XYSeriesCollection(series);\n        return collection;\n    }\n\n    /**\n     * Creates an {@link XYSeries} by sampling the specified function over a\n     * fixed range.\n     *\n     * @param f  the function ({@code null} not permitted).\n     * @param start  the start value for the range.\n     * @param end  the end value for the range.\n     * @param samples  the number of sample points (must be &gt; 1).\n     * @param seriesKey  the key to give the resulting series\n     *                   ({@code null} not permitted).\n     *\n     * @return A series.\n     */\n    public static XYSeries sampleFunction2DToSeries(Function2D f,\n            double start, double end, int samples, Comparable seriesKey) {\n\n        Args.nullNotPermitted(f, \"f\");\n        Args.nullNotPermitted(seriesKey, \"seriesKey\");\n        if (start >= end) {\n            throw new IllegalArgumentException(\"Requires 'start' < 'end'.\");\n        }\n        if (samples < 2) {\n            throw new IllegalArgumentException(\"Requires 'samples' > 1\");\n        }\n\n        XYSeries series = new XYSeries(seriesKey);\n        double step = (end - start) / (samples - 1);\n        for (int i = 0; i < samples; i++) {\n            double x = start + (step * i);\n            series.add(x, f.getValue(x));\n        }\n        return series;\n    }\n\n    /**\n     * Returns {@code true} if the dataset is empty (or {@code null}),\n     * and {@code false} otherwise.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(PieDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int itemCount = dataset.getItemCount();\n        if (itemCount == 0) {\n            return true;\n        }\n\n        for (int item = 0; item < itemCount; item++) {\n            Number y = dataset.getValue(item);\n            if (y != null) {\n                double yy = y.doubleValue();\n                if (yy > 0.0) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns {@code true} if the dataset is empty (or {@code null}),\n     * and {@code false} otherwise.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (rowCount == 0 || columnCount == 0) {\n            return true;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                if (dataset.getValue(r, c) != null) {\n                    return false;\n                }\n\n            }\n        }\n\n        return true;\n\n    }\n\n    /**\n     * Returns {@code true} if the dataset is empty (or {@code null}),\n     * and {@code false} otherwise.\n     *\n     * @param dataset  the dataset ({@code null} permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean isEmptyOrNull(XYDataset dataset) {\n        if (dataset != null) {\n            for (int s = 0; s < dataset.getSeriesCount(); s++) {\n                if (dataset.getItemCount(s) > 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range of values (possibly {@code null}).\n     */\n    public static Range findDomainBounds(XYDataset dataset) {\n        return findDomainBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the domain (x-values) of a dataset.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  determines whether or not the x-interval is taken\n     *                         into account (only applies if the dataset is an\n     *                         {@link IntervalXYDataset}).\n     *\n     * @return The range of values (possibly {@code null}).\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n            boolean includeInterval) {\n\n        Args.nullNotPermitted(dataset, \"dataset\");\n\n        Range result;\n        // if the dataset implements DomainInfo, life is easier\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            result = info.getDomainBounds(includeInterval);\n        }\n        else {\n            result = iterateDomainBounds(dataset, includeInterval);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the bounds of the x-values in the specified {@code dataset}\n     * taking into account only the visible series and including any x-interval\n     * if requested.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param visibleSeriesKeys  the visible series keys ({@code null}\n     *     not permitted).\n     * @param includeInterval  include the x-interval (if any)?\n     *\n     * @return The bounds (or {@code null} if the dataset contains no values.\n     */\n    public static Range findDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        \n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result;\n        if (dataset instanceof XYDomainInfo) {\n            XYDomainInfo info = (XYDomainInfo) dataset;\n            result = info.getDomainBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindDomainBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.  If the dataset is an instance of\n     * {@link IntervalXYDataset}, the starting and ending x-values\n     * will be used for the bounds calculation.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset) {\n        return iterateDomainBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the items in an {@link XYDataset} to find\n     * the range of x-values.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the x-interval or just the\n     *          x-value is used to determine the overall range.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateDomainBounds(XYDataset dataset,\n            boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n        double lvalue, uvalue;\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = intervalXYData.getXValue(series, item);\n                    lvalue = intervalXYData.getStartXValue(series, item);\n                    uvalue = intervalXYData.getEndXValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    lvalue = dataset.getXValue(series, item);\n                    uvalue = lvalue;\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        if (minimum > maximum) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     ({@code null} not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     */\n    public static Range findRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result;\n        if (dataset instanceof CategoryRangeInfo) {\n            CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset)} method.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range findRangeBounds(XYDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the range for the dataset.  This method\n     * is the partner for the {@link #findDomainBounds(XYDataset, boolean)}\n     * method.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the y-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys, and those items\n     * whose x-values fall within the specified range.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     ({@code null} not permitted).\n     * @param xRange  the x-range ({@code null} not permitted).\n     * @param includeInterval  include the y-interval (if the dataset has a\n     *     y-interval).\n     *\n     * @return The data bounds.\n     */\n    public static Range findRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result;\n        if (dataset instanceof XYRangeInfo) {\n            XYRangeInfo info = (XYRangeInfo) dataset;\n            result = info.getRangeBounds(visibleSeriesKeys, xRange,\n                    includeInterval);\n        }\n        else {\n            result = iterateToFindRangeBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        }\n        return result;\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateRangeBounds(CategoryDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number value, lvalue, uvalue;\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    value = icd.getValue(row, column);\n                    double v;\n                    if ((value != null)\n                            && !Double.isNaN(v = value.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    lvalue = icd.getStartValue(row, column);\n                    if (lvalue != null\n                            && !Double.isNaN(v = lvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                    uvalue = icd.getEndValue(row, column);\n                    if (uvalue != null\n                            && !Double.isNaN(v = uvalue.doubleValue())) {\n                        minimum = Math.min(v, minimum);\n                        maximum = Math.max(v, maximum);\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            for (int row = 0; row < rowCount; row++) {\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(row, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the category dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         y-interval is taken into account.\n     * @param visibleSeriesKeys  the visible series keys.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateToFindRangeBounds(CategoryDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Args.nullNotPermitted(visibleSeriesKeys, \"visibleSeriesKeys\");\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int columnCount = dataset.getColumnCount();\n        if (includeInterval\n                && dataset instanceof BoxAndWhiskerCategoryDataset) {\n            // handle special case of BoxAndWhiskerDataset\n            BoxAndWhiskerCategoryDataset bx\n                    = (BoxAndWhiskerCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                int itemCount = dataset.getColumnCount();\n                for (int item = 0; item < itemCount; item++) {\n                    Number lvalue = bx.getMinRegularValue(series, item);\n                    if (lvalue == null) {\n                        lvalue = bx.getValue(series, item);\n                    }\n                    Number uvalue = bx.getMaxRegularValue(series, item);\n                    if (uvalue == null) {\n                        uvalue = bx.getValue(series, item);\n                    }\n                    if (lvalue != null) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof IntervalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            IntervalCategoryDataset icd = (IntervalCategoryDataset) dataset;\n            Number lvalue, uvalue;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    lvalue = icd.getStartValue(series, column);\n                    uvalue = icd.getEndValue(series, column);\n                    if (lvalue != null && !Double.isNaN(lvalue.doubleValue())) {\n                        minimum = Math.min(minimum, lvalue.doubleValue());\n                    }\n                    if (uvalue != null && !Double.isNaN(uvalue.doubleValue())) {\n                        maximum = Math.max(maximum, uvalue.doubleValue());\n                    }\n                }\n            }\n        }\n        else if (includeInterval\n                && dataset instanceof MultiValueCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            MultiValueCategoryDataset mvcd\n                    = (MultiValueCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    List values = mvcd.getValues(series, column);\n                    Iterator valueIterator = values.iterator();\n                    while (valueIterator.hasNext()) {\n                        Object o = valueIterator.next();\n                        if (o instanceof Number){\n                            double v = ((Number) o).doubleValue();\n                            if (!Double.isNaN(v)){\n                                minimum = Math.min(minimum, v);\n                                maximum = Math.max(maximum, v);\n                            }\n                        }\n                    }\n               }\n            }\n        }\n        else if (includeInterval \n                && dataset instanceof StatisticalCategoryDataset) {\n            // handle the special case where the dataset has y-intervals that\n            // we want to measure\n            StatisticalCategoryDataset scd\n                    = (StatisticalCategoryDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number meanN = scd.getMeanValue(series, column);\n                    if (meanN != null) {\n                        double std = 0.0;\n                        Number stdN = scd.getStdDevValue(series, column);\n                        if (stdN != null) {\n                            std = stdN.doubleValue();\n                            if (Double.isNaN(std)) {\n                                std = 0.0;\n                            }\n                        }\n                        double mean = meanN.doubleValue();\n                        if (!Double.isNaN(mean)) {\n                            minimum = Math.min(minimum, mean - std);\n                            maximum = Math.max(maximum, mean + std);\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            // handle the standard case (plain CategoryDataset)\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.getRowIndex(seriesKey);\n                for (int column = 0; column < columnCount; column++) {\n                    Number value = dataset.getValue(series, column);\n                    if (value != null) {\n                        double v = value.doubleValue();\n                        if (!Double.isNaN(v)) {\n                            minimum = Math.min(minimum, v);\n                            maximum = Math.max(maximum, v);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Iterates over the data item of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateRangeBounds(XYDataset dataset) {\n        return iterateRangeBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data items of the xy dataset to find\n     * the range bounds.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  a flag that determines, for an\n     *          {@link IntervalXYDataset}, whether the y-interval or just the\n     *          y-value is used to determine the overall range.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateRangeBounds(XYDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = ixyd.getYValue(series, item);\n                    double lvalue = ixyd.getStartYValue(series, item);\n                    double uvalue = ixyd.getEndYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                        maximum = Math.max(maximum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        minimum = Math.min(minimum, uvalue);\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double lvalue = ohlc.getLowValue(series, item);\n                    double uvalue = ohlc.getHighValue(series, item);\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        }\n        else {\n            // standard case - plain XYDataset\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value = dataset.getYValue(series, item);\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of values in the z-dimension for the dataset. This\n     * method is the partner for the {@link #findRangeBounds(XYDataset)}\n     * and {@link #findDomainBounds(XYDataset)} methods.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range findZBounds(XYZDataset dataset) {\n        return findZBounds(dataset, true);\n    }\n\n    /**\n     * Returns the range of values in the z-dimension for the dataset.  This\n     * method is the partner for the\n     * {@link #findRangeBounds(XYDataset, boolean)} and\n     * {@link #findDomainBounds(XYDataset, boolean)} methods.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *                         z-interval is taken into account.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range findZBounds(XYZDataset dataset,\n            boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result = iterateZBounds(dataset, includeInterval);\n        return result;\n    }\n\n    /**\n     * Finds the bounds of the z-values in the specified dataset, including\n     * only those series that are listed in visibleSeriesKeys, and those items\n     * whose x-values fall within the specified range.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param visibleSeriesKeys  the keys for the visible series\n     *     ({@code null} not permitted).\n     * @param xRange  the x-range ({@code null} not permitted).\n     * @param includeInterval  include the z-interval (if the dataset has a\n     *     z-interval).\n     *\n     * @return The data bounds.\n     */\n    public static Range findZBounds(XYZDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result = iterateToFindZBounds(dataset, visibleSeriesKeys,\n                    xRange, includeInterval);\n        return result;\n    }\n\n    /**\n     * Iterates over the data item of the xyz dataset to find\n     * the z-dimension bounds.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateZBounds(XYZDataset dataset) {\n        return iterateZBounds(dataset, true);\n    }\n\n    /**\n     * Iterates over the data items of the xyz dataset to find\n     * the z-dimension bounds.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param includeInterval  include the z-interval (if the dataset has a\n     *     z-interval.\n     *\n     * @return The range (possibly {@code null}).\n     */\n    public static Range iterateZBounds(XYZDataset dataset,\n            boolean includeInterval) {\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int seriesCount = dataset.getSeriesCount();\n\n        for (int series = 0; series < seriesCount; series++) {\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double value = dataset.getZValue(series, item);\n                if (!Double.isNaN(value)) {\n                    minimum = Math.min(minimum, value);\n                    maximum = Math.max(maximum, value);\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        }\n        else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of x-values in the specified dataset for the\n     * data items belonging to the visible series.\n     * \n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param visibleSeriesKeys  the visible series keys ({@code null} not\n     *     permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     * \n     * @return The x-range (possibly {@code null}).\n     */\n    public static Range iterateToFindDomainBounds(XYDataset dataset,\n            List visibleSeriesKeys, boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Args.nullNotPermitted(visibleSeriesKeys, \"visibleSeriesKeys\");\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double xvalue = ixyd.getXValue(series, item);\n                    double lvalue = ixyd.getStartXValue(series, item);\n                    double uvalue = ixyd.getEndXValue(series, item);\n                    if (!Double.isNaN(xvalue)) {\n                        minimum = Math.min(minimum, xvalue);\n                        maximum = Math.max(maximum, xvalue);\n                    }\n                    if (!Double.isNaN(lvalue)) {\n                        minimum = Math.min(minimum, lvalue);\n                    }\n                    if (!Double.isNaN(uvalue)) {\n                        maximum = Math.max(maximum, uvalue);\n                    }\n                }\n            }\n        } else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    if (!Double.isNaN(x)) {\n                        minimum = Math.min(minimum, x);\n                        maximum = Math.max(maximum, x);\n                    }\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        } else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of y-values in the specified dataset for the\n     * data items belonging to the visible series and with x-values in the\n     * given range.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param visibleSeriesKeys  the visible series keys ({@code null} not\n     *     permitted).\n     * @param xRange  the x-range ({@code null} not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     y-interval for the dataset is included (this only applies if the\n     *     dataset is an instance of IntervalXYDataset).\n     *\n     * @return The y-range (possibly {@code null}).\n     */\n    public static Range iterateToFindRangeBounds(XYDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Args.nullNotPermitted(visibleSeriesKeys, \"visibleSeriesKeys\");\n        Args.nullNotPermitted(xRange, \"xRange\");\n\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n\n        // handle three cases by dataset type\n        if (includeInterval && dataset instanceof OHLCDataset) {\n            // handle special case of OHLCDataset\n            OHLCDataset ohlc = (OHLCDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ohlc.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double lvalue = ohlc.getLowValue(series, item);\n                        double uvalue = ohlc.getHighValue(series, item);\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof BoxAndWhiskerXYDataset) {\n            // handle special case of BoxAndWhiskerXYDataset\n            BoxAndWhiskerXYDataset bx = (BoxAndWhiskerXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = bx.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        Number lvalue = bx.getMinRegularValue(series, item);\n                        Number uvalue = bx.getMaxRegularValue(series, item);\n                        if (lvalue != null) {\n                            minimum = Math.min(minimum, lvalue.doubleValue());\n                        }\n                        if (uvalue != null) {\n                            maximum = Math.max(maximum, uvalue.doubleValue());\n                        }\n                    }\n                }\n            }\n        }\n        else if (includeInterval && dataset instanceof IntervalXYDataset) {\n            // handle special case of IntervalXYDataset\n            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = ixyd.getXValue(series, item);\n                    if (xRange.contains(x)) {\n                        double yvalue = ixyd.getYValue(series, item);\n                        double lvalue = ixyd.getStartYValue(series, item);\n                        double uvalue = ixyd.getEndYValue(series, item);\n                        if (!Double.isNaN(yvalue)) {\n                            minimum = Math.min(minimum, yvalue);\n                            maximum = Math.max(maximum, yvalue);\n                        }\n                        if (!Double.isNaN(lvalue)) {\n                            minimum = Math.min(minimum, lvalue);\n                        }\n                        if (!Double.isNaN(uvalue)) {\n                            maximum = Math.max(maximum, uvalue);\n                        }\n                    }\n                }\n            }\n        } else {\n            // standard case - plain XYDataset\n            Iterator iterator = visibleSeriesKeys.iterator();\n            while (iterator.hasNext()) {\n                Comparable seriesKey = (Comparable) iterator.next();\n                int series = dataset.indexOf(seriesKey);\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double x = dataset.getXValue(series, item);\n                    double y = dataset.getYValue(series, item);\n                    if (xRange.contains(x)) {\n                        if (!Double.isNaN(y)) {\n                            minimum = Math.min(minimum, y);\n                            maximum = Math.max(maximum, y);\n                        }\n                    }\n                }\n            }\n        }\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        } else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Returns the range of z-values in the specified dataset for the\n     * data items belonging to the visible series and with x-values in the\n     * given range.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param visibleSeriesKeys  the visible series keys ({@code null} not\n     *     permitted).\n     * @param xRange  the x-range ({@code null} not permitted).\n     * @param includeInterval  a flag that determines whether or not the\n     *     z-interval for the dataset is included (this only applies if the\n     *     dataset has an interval, which is currently not supported).\n     *\n     * @return The y-range (possibly {@code null}).\n     */\n    public static Range iterateToFindZBounds(XYZDataset dataset,\n            List visibleSeriesKeys, Range xRange, boolean includeInterval) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Args.nullNotPermitted(visibleSeriesKeys, \"visibleSeriesKeys\");\n        Args.nullNotPermitted(xRange, \"xRange\");\n    \n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n    \n        Iterator iterator = visibleSeriesKeys.iterator();\n        while (iterator.hasNext()) {\n            Comparable seriesKey = (Comparable) iterator.next();\n            int series = dataset.indexOf(seriesKey);\n            int itemCount = dataset.getItemCount(series);\n            for (int item = 0; item < itemCount; item++) {\n                double x = dataset.getXValue(series, item);\n                double z = dataset.getZValue(series, item);\n                if (xRange.contains(x)) {\n                    if (!Double.isNaN(z)) {\n                        minimum = Math.min(minimum, z);\n                        maximum = Math.max(maximum, z);\n                    }\n                }\n            }\n        }\n\n        if (minimum == Double.POSITIVE_INFINITY) {\n            return null;\n        } else {\n            return new Range(minimum, maximum);\n        }\n    }\n\n    /**\n     * Finds the minimum domain (or X) value for the specified dataset.  This\n     * is easy if the dataset implements the {@link DomainInfo} interface (a\n     * good idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.\n     * <p>\n     * Returns {@code null} if all the data values in the dataset are\n     * {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The minimum value (possibly {@code null}).\n     */\n    public static Number findMinimumDomainValue(XYDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Number result;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return info.getDomainLowerBound(true);\n        }\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = minimum;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum domain value for the specified dataset.  This is\n     * easy if the dataset implements the {@link DomainInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * {@code null} if all the data values in the dataset are\n     * {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The maximum value (possibly {@code null}).\n     */\n    public static Number findMaximumDomainValue(XYDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Number result;\n        // if the dataset implements DomainInfo, life is easy\n        if (dataset instanceof DomainInfo) {\n            DomainInfo info = (DomainInfo) dataset;\n            return info.getDomainUpperBound(true);\n        }\n\n        // hasn't implemented DomainInfo, so iterate...\n        else {\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                            = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndXValue(series, item);\n                    }\n                    else {\n                        value = dataset.getXValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                result = null;\n            }\n            else {\n                result = maximum;\n            }\n\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * {@code null} if all the data values in the dataset are\n     * {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The minimum value (possibly {@code null}).\n     */\n    public static Number findMinimumRangeValue(CategoryDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return info.getRangeLowerBound(true);\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                                = (IntervalCategoryDataset) dataset;\n                        value = icd.getStartValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        minimum = Math.min(minimum, value.doubleValue());\n                    }\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return minimum;\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the minimum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * {@code null} if all the data values in the dataset are\n     * {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The minimum value (possibly {@code null}).\n     */\n    public static Number findMinimumRangeValue(XYDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return info.getRangeLowerBound(true);\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n            double minimum = Double.POSITIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                                = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getStartYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getLowValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        minimum = Math.min(minimum, value);\n                    }\n\n                }\n            }\n            if (minimum == Double.POSITIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return minimum;\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is easy\n     * if the dataset implements the {@link RangeInfo} interface (a good idea\n     * if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * {@code null} if all the data values are {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The maximum value (possibly {@code null}).\n     */\n    public static Number findMaximumRangeValue(CategoryDataset dataset) {\n\n        Args.nullNotPermitted(dataset, \"dataset\");\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return info.getRangeUpperBound(true);\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getRowCount();\n            int itemCount = dataset.getColumnCount();\n            for (int series = 0; series < seriesCount; series++) {\n                for (int item = 0; item < itemCount; item++) {\n                    Number value;\n                    if (dataset instanceof IntervalCategoryDataset) {\n                        IntervalCategoryDataset icd\n                            = (IntervalCategoryDataset) dataset;\n                        value = icd.getEndValue(series, item);\n                    }\n                    else {\n                        value = dataset.getValue(series, item);\n                    }\n                    if (value != null) {\n                        maximum = Math.max(maximum, value.doubleValue());\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return maximum;\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the maximum range value for the specified dataset.  This is\n     * easy if the dataset implements the {@link RangeInfo} interface (a good\n     * idea if there is an efficient way to determine the maximum value).\n     * Otherwise, it involves iterating over the entire data-set.  Returns\n     * {@code null} if all the data values are {@code null}.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The maximum value (possibly {@code null}).\n     */\n    public static Number findMaximumRangeValue(XYDataset dataset) {\n\n        Args.nullNotPermitted(dataset, \"dataset\");\n\n        // work out the minimum value...\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            return info.getRangeUpperBound(true);\n        }\n\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        else  {\n\n            double maximum = Double.NEGATIVE_INFINITY;\n            int seriesCount = dataset.getSeriesCount();\n            for (int series = 0; series < seriesCount; series++) {\n                int itemCount = dataset.getItemCount(series);\n                for (int item = 0; item < itemCount; item++) {\n                    double value;\n                    if (dataset instanceof IntervalXYDataset) {\n                        IntervalXYDataset intervalXYData\n                                = (IntervalXYDataset) dataset;\n                        value = intervalXYData.getEndYValue(series, item);\n                    }\n                    else if (dataset instanceof OHLCDataset) {\n                        OHLCDataset highLowData = (OHLCDataset) dataset;\n                        value = highLowData.getHighValue(series, item);\n                    }\n                    else {\n                        value = dataset.getYValue(series, item);\n                    }\n                    if (!Double.isNaN(value)) {\n                        maximum = Math.max(maximum, value);\n                    }\n                }\n            }\n            if (maximum == Double.NEGATIVE_INFINITY) {\n                return null;\n            }\n            else {\n                return maximum;\n            }\n\n        }\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range ({@code null} if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param base  the base value for the bars.\n     *\n     * @return The range ({@code null} if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range\n     * (y-values), assuming that the series in one category are stacked.\n     *\n     * @param dataset  the dataset.\n     * @param map  a structure that maps series to groups.\n     *\n     * @return The value range ({@code null} if the dataset contains no\n     *         values).\n     */\n    public static Range findStackedRangeBounds(CategoryDataset dataset,\n            KeyToGroupMap map) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        boolean hasValidData = false;\n        Range result = null;\n\n        // create an array holding the group indices for each series...\n        int[] groupIndex = new int[dataset.getRowCount()];\n        for (int i = 0; i < dataset.getRowCount(); i++) {\n            groupIndex[i] = map.getGroupIndex(map.getGroup(\n                    dataset.getRowKey(i)));\n        }\n\n        // minimum and maximum for each group...\n        int groupCount = map.getGroupCount();\n        double[] minimum = new double[groupCount];\n        double[] maximum = new double[groupCount];\n\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The minimum value.\n     *\n     * @see #findMaximumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMinimumStackedRangeValue(CategoryDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Number result = null;\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value < 0.0) {\n                        total = total + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, total);\n        }\n        if (hasValidData) {\n            result = minimum;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the maximum value in the dataset range, assuming that values in\n     * each category are \"stacked\".\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The maximum value (possibly {@code null}).\n     *\n     * @see #findMinimumStackedRangeValue(CategoryDataset)\n     */\n    public static Number findMaximumStackedRangeValue(CategoryDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        Number result = null;\n        boolean hasValidData = false;\n        double maximum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double total = 0.0;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        total = total + value;\n                    }\n                }\n            }\n            maximum = Math.max(maximum, total);\n        }\n        if (hasValidData) {\n            result = maximum;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range ([0.0, 0.0] if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset) {\n        return findStackedRangeBounds(dataset, 0.0);\n    }\n\n    /**\n     * Returns the minimum and maximum values for the dataset's range,\n     * assuming that the series are stacked, using the specified base value.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param base  the base value.\n     *\n     * @return The range ({@code null} if the dataset contains no values).\n     */\n    public static Range findStackedRangeBounds(TableXYDataset dataset,\n            double base) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        double minimum = base;\n        double maximum = base;\n        for (int itemNo = 0; itemNo < dataset.getItemCount(); itemNo++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getSeriesCount();\n            for (int seriesNo = 0; seriesNo < seriesCount; seriesNo++) {\n                double y = dataset.getYValue(seriesNo, itemNo);\n                if (!Double.isNaN(y)) {\n                    if (y > 0.0) {\n                        positive += y;\n                    }\n                    else {\n                        negative += y;\n                    }\n                }\n            }\n            if (positive > maximum) {\n                maximum = positive;\n            }\n            if (negative < minimum) {\n                minimum = negative;\n            }\n        }\n        if (minimum <= maximum) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Calculates the total for the y-values in all series for a given item\n     * index.\n     *\n     * @param dataset  the dataset.\n     * @param item  the item index.\n     *\n     * @return The total.\n     */\n    public static double calculateStackTotal(TableXYDataset dataset, int item) {\n        double total = 0.0;\n        int seriesCount = dataset.getSeriesCount();\n        for (int s = 0; s < seriesCount; s++) {\n            double value = dataset.getYValue(s, item);\n            if (!Double.isNaN(value)) {\n                total = total + value;\n            }\n        }\n        return total;\n    }\n\n    /**\n     * Calculates the range of values for a dataset where each item is the\n     * running total of the items for the current series.\n     *\n     * @param dataset  the dataset ({@code null} not permitted).\n     *\n     * @return The range.\n     *\n     * @see #findRangeBounds(CategoryDataset)\n     */\n    public static Range findCumulativeRangeBounds(CategoryDataset dataset) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        boolean allItemsNull = true; // we'll set this to false if there is at\n                                     // least one non-null data item...\n        double minimum = 0.0;\n        double maximum = 0.0;\n        for (int row = 0; row < dataset.getRowCount(); row++) {\n            double runningTotal = 0.0;\n            for (int column = 0; column <= dataset.getColumnCount() - 1;\n                 column++) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    allItemsNull = false;\n                    double value = n.doubleValue();\n                    if (!Double.isNaN(value)) {\n                        runningTotal = runningTotal + value;\n                        minimum = Math.min(minimum, runningTotal);\n                        maximum = Math.max(maximum, runningTotal);\n                    }\n                }\n            }\n        }\n        if (!allItemsNull) {\n            return new Range(minimum, maximum);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the interpolated value of y that corresponds to the specified\n     * x-value in the given series.  If the x-value falls outside the range of\n     * x-values for the dataset, this method returns {@code Double.NaN}.\n     * \n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param series  the series index.\n     * @param x  the x-value.\n     * \n     * @return The y value.\n     */\n    public static double findYValue(XYDataset dataset, int series, double x) {\n        // delegate null check on dataset\n        int[] indices = findItemIndicesForX(dataset, series, x);\n        if (indices[0] == -1) {\n            return Double.NaN;\n        }\n        if (indices[0] == indices[1]) {\n            return dataset.getYValue(series, indices[0]);\n        }\n        double x0 = dataset.getXValue(series, indices[0]);\n        double x1 = dataset.getXValue(series, indices[1]);\n        double y0 = dataset.getYValue(series, indices[0]);\n        double y1 = dataset.getYValue(series, indices[1]);\n        return y0 + (y1 - y0) * (x - x0) / (x1 - x0);\n    }\n    \n    /**\n     * Finds the indices of the the items in the dataset that span the \n     * specified x-value.  There are three cases for the return value:\n     * <ul>\n     * <li>there is an exact match for the x-value at index i \n     * (returns {@code int[] {i, i}});</li>\n     * <li>the x-value falls between two (adjacent) items at index i and i+1 \n     * (returns {@code int[] {i, i+1}});</li>\n     * <li>the x-value falls outside the domain bounds, in which case the \n     *    method returns {@code int[] {-1, -1}}.</li>\n     * </ul>\n     * @param dataset  the dataset ({@code null} not permitted).\n     * @param series  the series index.\n     * @param x  the x-value.\n     *\n     * @return The indices of the two items that span the x-value.\n     * \n     * @see #findYValue(org.jfree.data.xy.XYDataset, int, double) \n     */\n    public static int[] findItemIndicesForX(XYDataset dataset, int series,\n            double x) {\n        Args.nullNotPermitted(dataset, \"dataset\");\n        int itemCount = dataset.getItemCount(series);\n        if (itemCount == 0) {\n            return new int[] {-1, -1};\n        }\n        if (itemCount == 1) {\n            if (x == dataset.getXValue(series, 0)) {\n                return new int[] {0, 0};\n            } else {\n                return new int[] {-1, -1};\n            }\n        }\n        if (dataset.getDomainOrder() == DomainOrder.ASCENDING) {\n            int low = 0;\n            int high = itemCount - 1;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue > x) {\n                return new int[] {-1, -1};\n            }\n            if (lowValue == x) {\n                return new int[] {low, low};\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue < x) {\n                return new int[] {-1, -1};\n            }\n            if (highValue == x) {\n                return new int[] {high, high};\n            }\n            int mid = (low + high) / 2;\n            while (high - low > 1) {\n                double midV = dataset.getXValue(series, mid);\n                if (x == midV) {\n                    return new int[] {mid, mid};\n                }\n                if (midV < x) {\n                    low = mid;\n                }\n                else {\n                    high = mid;\n                }\n                mid = (low + high) / 2;\n            }\n            return new int[] {low, high};\n        }\n        else if (dataset.getDomainOrder() == DomainOrder.DESCENDING) {\n            int high = 0;\n            int low = itemCount - 1;\n            double lowValue = dataset.getXValue(series, low);\n            if (lowValue > x) {\n                return new int[] {-1, -1};\n            }\n            double highValue = dataset.getXValue(series, high);\n            if (highValue < x) {\n                return new int[] {-1, -1};\n            }\n            int mid = (low + high) / 2;\n            while (high - low > 1) {\n                double midV = dataset.getXValue(series, mid);\n                if (x == midV) {\n                    return new int[] {mid, mid};\n                }\n                if (midV < x) {\n                    low = mid;\n                }\n                else {\n                    high = mid;\n                }\n                mid = (low + high) / 2;\n            }\n            return new int[] {low, high};\n        }\n        else {\n            // we don't know anything about the ordering of the x-values,\n            // so we iterate until we find the first crossing of x (if any)\n            // we know there are at least 2 items in the series at this point\n            double prev = dataset.getXValue(series, 0);\n            if (x == prev) {\n                return new int[] {0, 0}; // exact match on first item\n            }\n            for (int i = 1; i < itemCount; i++) {\n                double next = dataset.getXValue(series, i);\n                if (x == next) {\n                    return new int[] {i, i}; // exact match\n                }\n                if ((x > prev && x < next) || (x < prev && x > next)) {\n                    return new int[] {i - 1, i}; // spanning match\n                }\n            }\n            return new int[] {-1, -1}; // no crossing of x\n        }\n    }\n\n}\n",
        "simple_context": "package org.jfree.data.general;\n\nimport java.util.ArrayList;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport org.jfree.chart.util.ArrayUtils;\n\nimport org.jfree.chart.util.Args;\n\nimport org.jfree.data.DomainInfo;\n\nimport org.jfree.data.DomainOrder;\n\nimport org.jfree.data.KeyToGroupMap;\n\nimport org.jfree.data.KeyedValues;\n\nimport org.jfree.data.Range;\n\nimport org.jfree.data.RangeInfo;\n\nimport org.jfree.data.category.CategoryDataset;\n\nimport org.jfree.data.category.CategoryRangeInfo;\n\nimport org.jfree.data.category.DefaultCategoryDataset;\n\nimport org.jfree.data.category.IntervalCategoryDataset;\n\nimport org.jfree.data.function.Function2D;\n\nimport org.jfree.data.statistics.BoxAndWhiskerCategoryDataset;\n\nimport org.jfree.data.statistics.BoxAndWhiskerXYDataset;\n\nimport org.jfree.data.statistics.MultiValueCategoryDataset;\n\nimport org.jfree.data.statistics.StatisticalCategoryDataset;\n\nimport org.jfree.data.xy.IntervalXYDataset;\n\nimport org.jfree.data.xy.OHLCDataset;\n\nimport org.jfree.data.xy.TableXYDataset;\n\nimport org.jfree.data.xy.XYDataset;\n\nimport org.jfree.data.xy.XYDomainInfo;\n\nimport org.jfree.data.xy.XYRangeInfo;\n\nimport org.jfree.data.xy.XYSeries;\n\nimport org.jfree.data.xy.XYSeriesCollection;\n\nimport org.jfree.data.xy.XYZDataset;\n\nfinal public class DatasetUtils {\n    private DatasetUtils();\n    static public double calculatePieDatasetTotal(PieDataset dataset);\n    static public PieDataset createPieDatasetForRow(CategoryDataset dataset, Comparable rowKey);\n    static public PieDataset createPieDatasetForRow(CategoryDataset dataset, int row);\n    static public PieDataset createPieDatasetForColumn(CategoryDataset dataset, Comparable columnKey);\n    static public PieDataset createPieDatasetForColumn(CategoryDataset dataset, int column);\n    static public PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent);\n    static public PieDataset createConsolidatedPieDataset(PieDataset source, Comparable key, double minimumPercent, int minItems);\n    static public CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, double[][] data);\n    static public CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, Number data);\n    static public CategoryDataset createCategoryDataset(Comparable rowKeys, Comparable columnKeys, double[][] data);\n    static public CategoryDataset createCategoryDataset(Comparable rowKey, KeyedValues rowData);\n    static public XYDataset sampleFunction2D(Function2D f, double start, double end, int samples, Comparable seriesKey);\n    static public XYSeries sampleFunction2DToSeries(Function2D f, double start, double end, int samples, Comparable seriesKey);\n    static public boolean isEmptyOrNull(PieDataset dataset);\n    static public boolean isEmptyOrNull(CategoryDataset dataset);\n    static public boolean isEmptyOrNull(XYDataset dataset);\n    static public Range findDomainBounds(XYDataset dataset);\n    static public Range findDomainBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range iterateDomainBounds(XYDataset dataset);\n    static public Range iterateDomainBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findRangeBounds(CategoryDataset dataset);\n    static public Range findRangeBounds(CategoryDataset dataset, boolean includeInterval);\n    static public Range findRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range findRangeBounds(XYDataset dataset);\n    static public Range findRangeBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Range iterateRangeBounds(CategoryDataset dataset);\n    static public Range iterateRangeBounds(CategoryDataset dataset, boolean includeInterval);\n    static public Range iterateToFindRangeBounds(CategoryDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range iterateRangeBounds(XYDataset dataset);\n    static public Range iterateRangeBounds(XYDataset dataset, boolean includeInterval);\n    static public Range findZBounds(XYZDataset dataset);\n    static public Range findZBounds(XYZDataset dataset, boolean includeInterval);\n    static public Range findZBounds(XYZDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Range iterateZBounds(XYZDataset dataset);\n    static public Range iterateZBounds(XYZDataset dataset, boolean includeInterval);\n    static public Range iterateToFindDomainBounds(XYDataset dataset, List visibleSeriesKeys, boolean includeInterval);\n    static public Range iterateToFindRangeBounds(XYDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Range iterateToFindZBounds(XYZDataset dataset, List visibleSeriesKeys, Range xRange, boolean includeInterval);\n    static public Number findMinimumDomainValue(XYDataset dataset);\n    static public Number findMaximumDomainValue(XYDataset dataset);\n    static public Number findMinimumRangeValue(CategoryDataset dataset);\n    static public Number findMinimumRangeValue(XYDataset dataset);\n    static public Number findMaximumRangeValue(CategoryDataset dataset);\n    static public Number findMaximumRangeValue(XYDataset dataset);\n    static public Range findStackedRangeBounds(CategoryDataset dataset);\n    static public Range findStackedRangeBounds(CategoryDataset dataset, double base);\n    static public Range findStackedRangeBounds(CategoryDataset dataset, KeyToGroupMap map);\n    static public Number findMinimumStackedRangeValue(CategoryDataset dataset);\n    static public Number findMaximumStackedRangeValue(CategoryDataset dataset);\n    static public Range findStackedRangeBounds(TableXYDataset dataset);\n    static public Range findStackedRangeBounds(TableXYDataset dataset, double base);\n    static public double calculateStackTotal(TableXYDataset dataset, int item);\n    static public Range findCumulativeRangeBounds(CategoryDataset dataset);\n    static public double findYValue(XYDataset dataset, int series, double x);\n    static public int[] findItemIndicesForX(XYDataset dataset, int series, double x);\n}\n\n"
    },
    {
        "project_name": "jfreechart",
        "file_name": "Series.java",
        "relative_path": "jfreechart/src/main/java/org/jfree/data/general/Series.java",
        "execute_path": "jfreechart",
        "package": "org.jfree.data.general",
        "docstring": "/**\n     * Tests the series for equality with another object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */",
        "source_code": "\n@Override\npublic boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof Series)) {\n        return false;\n    }\n    Series that = (Series) obj;\n    if (!Objects.equals(this.key, that.key)) {\n        return false;\n    }\n    if (!Objects.equals(this.description, that.description)) {\n        return false;\n    }\n    if (!that.canEqual(this)) {\n        return false;\n    }\n    return true;\n}\n",
        "class_name": "Series",
        "method_name": "equals",
        "argument_name": [
            "Object obj"
        ],
        "full_context": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-present, by David Gilbert and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. \n * Other names may be trademarks of their respective owners.]\n *\n * -----------\n * Series.java\n * -----------\n * (C) Copyright 2001-present, by David Gilbert.\n *\n * Original Author:  David Gilbert;\n * Contributor(s):   Tracy Hiltbrand (equals/hashCode comply with EqualsVerifier);\n * \n */\n\npackage org.jfree.data.general;\n\nimport org.jfree.chart.util.Args;\n\nimport javax.swing.event.EventListenerList;\nimport java.beans.*;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Objects;\n\n/**\n * Base class representing a data series.  Subclasses are left to implement the\n * actual data structures.\n * <P>\n * The series has two properties (\"Key\" and \"Description\") for which you can\n * register a {@code PropertyChangeListener}.\n * <P>\n * You can also register a {@link SeriesChangeListener} to receive notification\n * of changes to the series data.\n */\npublic abstract class Series implements Cloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -6906561437538683581L;\n\n    /** The key for the series. */\n    private Comparable key;\n\n    /** A description of the series. */\n    private String description;\n\n    /** Storage for registered change listeners. */\n    private transient EventListenerList listeners;\n\n    /** Object to support property change notification. */\n    private transient PropertyChangeSupport propertyChangeSupport;\n\n    /** Object to support property change notification. */\n    private transient VetoableChangeSupport vetoableChangeSupport;\n\n    /** A flag that controls whether changes are notified. */\n    private boolean notify;\n\n    /**\n     * Creates a new series with the specified key.\n     *\n     * @param key  the series key ({@code null} not permitted).\n     */\n    protected Series(Comparable key) {\n        this(key, null);\n    }\n\n    /**\n     * Creates a new series with the specified key and description.\n     *\n     * @param key  the series key ({@code null} NOT permitted).\n     * @param description  the series description ({@code null} permitted).\n     */\n    protected Series(Comparable key, String description) {\n        Args.nullNotPermitted(key, \"key\");\n        this.key = key;\n        this.description = description;\n        this.listeners = new EventListenerList();\n        this.propertyChangeSupport = new PropertyChangeSupport(this);\n        this.vetoableChangeSupport = new VetoableChangeSupport(this);\n        this.notify = true;\n    }\n\n    /**\n     * Returns the key for the series.\n     *\n     * @return The series key (never {@code null}).\n     *\n     * @see #setKey(Comparable)\n     */\n    public Comparable getKey() {\n        return this.key;\n    }\n\n    /**\n     * Sets the key for the series and sends a {@code VetoableChangeEvent}\n     * (with the property name \"Key\") to all registered listeners.  For \n     * backwards compatibility, this method also fires a regular \n     * {@code PropertyChangeEvent}.  If the key change is vetoed this \n     * method will throw an IllegalArgumentException.\n     *\n     * This implementation is not very robust when cloning or deserialising\n     * series collections, so you should not rely upon it for that purpose.\n     * In future releases, the series key will be made immutable.\n     *\n     * @param key  the key ({@code null} not permitted).\n     *\n     * @see #getKey()\n     * @deprecated In future releases the series key will be immutable.\n     */\n    @Deprecated\n    public void setKey(Comparable key) {\n        Args.nullNotPermitted(key, \"key\");\n        Comparable old = this.key;\n        try {\n            // if this series belongs to a dataset, the dataset might veto the\n            // change if it results in two series within the dataset having the\n            // same key\n            this.vetoableChangeSupport.fireVetoableChange(\"Key\", old, key);\n            this.key = key;\n            // prior to 1.0.14, we just fired a PropertyChange - so we need to\n            // keep doing this\n            this.propertyChangeSupport.firePropertyChange(\"Key\", old, key);\n        } catch (PropertyVetoException e) {\n            throw new IllegalArgumentException(e.getMessage());\n        }\n    }\n\n    /**\n     * Returns a description of the series.\n     *\n     * @return The series description (possibly {@code null}).\n     *\n     * @see #setDescription(String)\n     */\n    public String getDescription() {\n        return this.description;\n    }\n\n    /**\n     * Sets the description of the series and sends a\n     * {@code PropertyChangeEvent} to all registered listeners.\n     *\n     * @param description  the description ({@code null} permitted).\n     *\n     * @see #getDescription()\n     */\n    public void setDescription(String description) {\n        String old = this.description;\n        this.description = description;\n        this.propertyChangeSupport.firePropertyChange(\"Description\", old,\n                description);\n    }\n\n    /**\n     * Returns the flag that controls whether or not change events are sent to\n     * registered listeners.\n     *\n     * @return A boolean.\n     *\n     * @see #setNotify(boolean)\n     */\n    public boolean getNotify() {\n        return this.notify;\n    }\n\n    /**\n     * Sets the flag that controls whether or not change events are sent to\n     * registered listeners.\n     *\n     * @param notify  the new value of the flag.\n     *\n     * @see #getNotify()\n     */\n    public void setNotify(boolean notify) {\n        if (this.notify != notify) {\n            this.notify = notify;\n            fireSeriesChanged();\n        }\n    }\n\n    /**\n     * Returns {@code true} if the series contains no data items, and\n     * {@code false} otherwise.\n     *\n     * @return A boolean.\n     */\n    public boolean isEmpty() {\n        return (getItemCount() == 0);\n    }\n\n    /**\n     * Returns the number of data items in the series.\n     *\n     * @return The number of data items in the series.\n     */\n    public abstract int getItemCount();\n\n    /**\n     * Returns a clone of the series.\n     * <P>\n     * Notes:\n     * <ul>\n     * <li>No need to clone the name or description, since String object is\n     * immutable.</li>\n     * <li>We set the listener list to empty, since the listeners did not\n     * register with the clone.</li>\n     * <li>Same applies to the PropertyChangeSupport instance.</li>\n     * </ul>\n     *\n     * @return A clone of the series.\n     *\n     * @throws CloneNotSupportedException  not thrown by this class, but\n     *         subclasses may differ.\n     */\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        Series clone = (Series) super.clone();\n        clone.listeners = new EventListenerList();\n        clone.propertyChangeSupport = new PropertyChangeSupport(clone);\n        clone.vetoableChangeSupport = new VetoableChangeSupport(clone);\n        return clone;\n    }\n\n    /**\n     * Tests the series for equality with another object.\n     *\n     * @param obj  the object ({@code null} permitted).\n     *\n     * @return {@code true} or {@code false}.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Series)) {\n            return false;\n        }\n        Series that = (Series) obj;\n        if (!Objects.equals(this.key, that.key)) {\n            return false;\n        }\n        if (!Objects.equals(this.description, that.description)) {\n            return false;\n        }\n        if (!that.canEqual(this)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Ensures symmetry between super/subclass implementations of equals. For\n     * more detail, see http://jqno.nl/equalsverifier/manual/inheritance.\n     *\n     * @param other Object\n     * \n     * @return true ONLY if the parameter is THIS class type\n     */\n    public boolean canEqual(Object other) {\n        // fix the \"equals not symmetric\" problem\n        return (other instanceof Series);\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    @Override\n    public int hashCode() {\n        int hash = 5;\n        hash = 53 * hash + Objects.hashCode(this.key);\n        hash = 53 * hash + Objects.hashCode(this.description);\n        return hash;\n    }\n\n    /**\n     * Registers an object with this series, to receive notification whenever\n     * the series changes.\n     * <P>\n     * Objects being registered must implement the {@link SeriesChangeListener}\n     * interface.\n     *\n     * @param listener  the listener to register.\n     */\n    public void addChangeListener(SeriesChangeListener listener) {\n        this.listeners.add(SeriesChangeListener.class, listener);\n    }\n\n    /**\n     * Deregisters an object, so that it not longer receives notification\n     * whenever the series changes.\n     *\n     * @param listener  the listener to deregister.\n     */\n    public void removeChangeListener(SeriesChangeListener listener) {\n        this.listeners.remove(SeriesChangeListener.class, listener);\n    }\n\n    /**\n     * General method for signalling to registered listeners that the series\n     * has been changed.\n     */\n    public void fireSeriesChanged() {\n        if (this.notify) {\n            notifyListeners(new SeriesChangeEvent(this));\n        }\n    }\n\n    /**\n     * Sends a change event to all registered listeners.\n     *\n     * @param event  contains information about the event that triggered the\n     *               notification.\n     */\n    protected void notifyListeners(SeriesChangeEvent event) {\n\n        Object[] listenerList = this.listeners.getListenerList();\n        for (int i = listenerList.length - 2; i >= 0; i -= 2) {\n            if (listenerList[i] == SeriesChangeListener.class) {\n                ((SeriesChangeListener) listenerList[i + 1]).seriesChanged(\n                        event);\n            }\n        }\n\n    }\n\n    /**\n     * Adds a property change listener to the series.\n     *\n     * @param listener  the listener.\n     */\n    public void addPropertyChangeListener(PropertyChangeListener listener) {\n        this.propertyChangeSupport.addPropertyChangeListener(listener);\n    }\n\n    /**\n     * Removes a property change listener from the series.\n     *\n     * @param listener  the listener.\n     */\n    public void removePropertyChangeListener(PropertyChangeListener listener) {\n        this.propertyChangeSupport.removePropertyChangeListener(listener);\n    }\n\n    /**\n     * Fires a property change event.\n     *\n     * @param property  the property key.\n     * @param oldValue  the old value.\n     * @param newValue  the new value.\n     */\n    protected void firePropertyChange(String property, Object oldValue,\n            Object newValue) {\n        this.propertyChangeSupport.firePropertyChange(property, oldValue,\n                newValue);\n    }\n    \n    /**\n     * Adds a vetoable property change listener to the series.\n     *\n     * @param listener  the listener.\n     */\n    public void addVetoableChangeListener(VetoableChangeListener listener) {\n        this.vetoableChangeSupport.addVetoableChangeListener(listener);\n    }\n\n    /**\n     * Removes a vetoable property change listener from the series.\n     *\n     * @param listener  the listener.\n     */\n    public void removeVetoableChangeListener(VetoableChangeListener listener) {\n        this.vetoableChangeSupport.removeVetoableChangeListener(listener);\n    }    \n\n    /**\n     * Fires a vetoable property change event.\n     *\n     * @param property  the property key.\n     * @param oldValue  the old value.\n     * @param newValue  the new value.\n     * \n     * @throws PropertyVetoException if the change was vetoed.\n     */\n    protected void fireVetoableChange(String property, Object oldValue,\n            Object newValue) throws PropertyVetoException {\n        this.vetoableChangeSupport.fireVetoableChange(property, oldValue,\n                newValue);\n    }\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream ({@code null} not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream ({@code null} not permitted).\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n            throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.listeners = new EventListenerList();\n        this.propertyChangeSupport = new PropertyChangeSupport(this);\n        this.vetoableChangeSupport = new VetoableChangeSupport(this);\n    }\n\n}\n",
        "simple_context": "package org.jfree.data.general;\n\nimport org.jfree.chart.util.Args;\n\nimport javax.swing.event.EventListenerList;\n\nimport java.beans;\n\nimport java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.ObjectOutputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Objects;\n\nabstract public class Series implements Cloneable, Serializable {\n    static final private long serialVersionUID;\n    private Comparable key;\n    private String description;\n    transient private EventListenerList listeners;\n    transient private PropertyChangeSupport propertyChangeSupport;\n    transient private VetoableChangeSupport vetoableChangeSupport;\n    private boolean notify;\n    protected Series(Comparable key);\n    protected Series(Comparable key, String description);\n    public Comparable getKey();\n    public  setKey(Comparable key);\n    public String getDescription();\n    public  setDescription(String description);\n    public boolean getNotify();\n    public  setNotify(boolean notify);\n    public boolean isEmpty();\n    abstract public int getItemCount();\n    public Object clone()throws CloneNotSupportedException;\n    public boolean equals(Object obj);\n    public boolean canEqual(Object other);\n    public int hashCode();\n    public  addChangeListener(SeriesChangeListener listener);\n    public  removeChangeListener(SeriesChangeListener listener);\n    public  fireSeriesChanged();\n    protected  notifyListeners(SeriesChangeEvent event);\n    public  addPropertyChangeListener(PropertyChangeListener listener);\n    public  removePropertyChangeListener(PropertyChangeListener listener);\n    protected  firePropertyChange(String property, Object oldValue, Object newValue);\n    public  addVetoableChangeListener(VetoableChangeListener listener);\n    public  removeVetoableChangeListener(VetoableChangeListener listener);\n    protected  fireVetoableChange(String property, Object oldValue, Object newValue)throws PropertyVetoException;\n    private  writeObject(ObjectOutputStream stream)throws IOException;\n    private  readObject(ObjectInputStream stream)throws IOException, ClassNotFoundException;\n}\n\n"
    }
]