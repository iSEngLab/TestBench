[
    {
        "project_name": "Java",
        "code": "\npublic static int average(int[] numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    long sum = 0;\n    for (int number : numbers) {\n        sum += number;\n    }\n    return (int) (sum / numbers.length);\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "Average",
        "method_name": "average",
        "SourceCode&Full": [
            "Accept",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept"
        ]
    },
    {
        "project_name": "Java",
        "code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    int n = unsorted.length;\n    heapify(unsorted, n);\n    while (n > 1) {\n        swap(unsorted, 1, n--);\n        siftDown(unsorted, 1, n);\n    }\n    return unsorted;\n}\n",
        "package": "com.thealgorithms.sorts",
        "class_name": "HeapSort",
        "method_name": "sort",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "static int possiblePaint(ArrayList<Node> nodes, int n, int m) {\n\n    // Create a visited array of n nodes\n    ArrayList<Integer> visited = new ArrayList<Integer>();\n    for (int i = 0; i < n + 1; i++) {\n        visited.add(0);\n    }\n\n    // maxColors used till now are 1 as\n    // all nodes are painted color 1\n    int maxColors = 1;\n\n    for (int sv = 1; sv <= n; sv++) {\n        if (visited.get(sv) > 0) {\n            continue;\n        }\n\n        // If the starting point is unvisited,\n        // mark it visited and push it in queue\n        visited.set(sv, 1);\n        Queue<Integer> q = new LinkedList<>();\n        q.add(sv);\n\n        // BFS\n        while (q.size() != 0) {\n            int top = q.peek();\n            q.remove();\n\n            // Checking all adjacent nodes\n            // to \"top\" edge in our queue\n            for (int it : nodes.get(top).edges) {\n\n                // If the color of the\n                // adjacent node is same, increase it by\n                // 1\n                if (nodes.get(top).color == nodes.get(it).color) {\n                    nodes.get(it).color += 1;\n                }\n\n                // If number of colors used exceeds m,\n                // return 0\n                maxColors = Math.max(maxColors, Math.max(nodes.get(top).color, nodes.get(it).color));\n                if (maxColors > m) return 0;\n\n                // If the adjacent node is not visited,\n                // mark it visited and push it in queue\n                if (visited.get(it) == 0) {\n                    visited.set(it, 1);\n                    q.add(it);\n                }\n            }\n        }\n    }\n    return 1;\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "MColoring",
        "method_name": "possiblePaint",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic int indexOf(T element) {\n    Objects.requireNonNull(element);\n    Node<T> iterator = cursorSpace[head];\n    for (int i = 0; i < count; i++) {\n        if (iterator.element.equals(element)) {\n            return i;\n        }\n        iterator = cursorSpace[iterator.next];\n    }\n\n    return -1;\n}\n",
        "package": "com.thealgorithms.datastructures.lists",
        "class_name": "CursorLinkedList",
        "method_name": "indexOf",
        "SourceCode&Full": [
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\nNode mergeKList(Node[] a, int N) {\n    // Min Heap\n    PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n\n    // adding head of all linkedList in min heap\n    min.addAll(Arrays.asList(a).subList(0, N));\n\n    // Make new head among smallest heads in K linkedList\n    Node head = min.poll();\n    min.add(head.next);\n    Node curr = head;\n\n    // merging LinkedList\n    while (!min.isEmpty()) {\n        Node temp = min.poll();\n        curr.next = temp;\n        curr = temp;\n\n        // Add Node in min Heap only if temp.next is not null\n        if (temp.next != null) {\n            min.add(temp.next);\n        }\n    }\n\n    return head;\n}\n",
        "package": "com.thealgorithms.datastructures.lists",
        "class_name": "Merge_K_SortedLinkedlist",
        "method_name": "mergeKList",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static List<TreeSet<Integer>> combination(int n, int k) {\n    if (n <= 0) {\n        return null;\n    }\n    length = k;\n    Integer[] arr = new Integer[n];\n    for (int i = 1; i <= n; i++) {\n        arr[i - 1] = i;\n    }\n    return Combination.combination(arr, length);\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "ArrayCombination",
        "method_name": "combination",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String decimalToHex(int d) {\n    String digits = \"0123456789ABCDEF\";\n    if (d <= 0) {\n        return \"0\";\n    }\n    String hex = \"\";\n    while (d > 0) {\n        int digit = d % 16;\n        hex = digits.charAt(digit) + hex;\n        d = d / 16;\n    }\n    return hex;\n}\n",
        "package": "com.thealgorithms.conversions",
        "class_name": "OctalToHexadecimal",
        "method_name": "decimalToHex",
        "SourceCode&Full": [
            "Syntax Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String convertToAnyBase(int inp, int base) {\n    ArrayList<Character> charArr = new ArrayList<>();\n\n    while (inp > 0) {\n        charArr.add(reVal(inp % base));\n        inp /= base;\n    }\n\n    StringBuilder str = new StringBuilder(charArr.size());\n\n    for (Character ch : charArr) {\n        str.append(ch);\n    }\n\n    return str.reverse().toString();\n}\n",
        "package": "com.thealgorithms.conversions",
        "class_name": "DecimalToAnyBase",
        "method_name": "convertToAnyBase",
        "SourceCode&Full": [
            "Test Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Accept",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int getAliquotSum(int n) {\n    if (n <= 0) return -1;\n    int sum = 1;\n    double root = Math.sqrt(n);\n    /*\n     * We can get the factors after the root by dividing number by its factors\n     * before the root.\n     * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.\n     * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.\n     * Now by dividing 100 by each factor before 10 we get:\n     * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20\n     * So we get 100, 50, 25 and 20 which are factors of 100 after 10\n     */\n    for (int i = 2; i <= root; i++) {\n        if (n % i == 0) {\n            sum += i + n / i;\n        }\n    }\n    // if n is a perfect square then its root was added twice in above loop, so subtracting root\n    // from sum\n    if (root == (int) root) sum -= root;\n    return sum;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "AliquotSum",
        "method_name": "getAliquotSum",
        "SourceCode&Full": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static boolean setWay(int[][] map, int i, int j) {\n    if (map[6][5] == 2) { // means the ball find its path, ending condition\n        return true;\n    }\n    if (map[i][j] == 0) { // if the ball haven't gone through this point\n        // then the ball follows the move strategy : down -> right -> up -> left\n        map[i][j] = 2; // we assume that this path is feasible first, set the current point to 2\n                       // first\u3002\n        if (setWay(map, i + 1, j)) { // go down\n            return true;\n        } else if (setWay(map, i, j + 1)) { // go right\n            return true;\n        } else if (setWay(map, i - 1, j)) { // go up\n            return true;\n        } else if (setWay(map, i, j - 1)) { // go left\n            return true;\n        } else {\n            // means that the current point is the dead end, the ball cannot proceed, set\n            // the current point to 3 and return false, the backtracking will start, it will\n            // go to the previous step and check for feasible path again\n            map[i][j] = 3;\n            return false;\n        }\n    } else { // if the map[i][j] != 0 , it will probably be 1,2,3, return false because the\n        // ball cannot hit the wall, cannot go to the path that has gone though before,\n        // and cannot head to deadened.\n        return false;\n    }\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "MazeRecursion",
        "method_name": "setWay",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic Node find(int key) {\n    Node current = root;\n    while (current != null) {\n        if (key < current.data) {\n            if (current.left == null) {\n                return current; // The key isn't exist, returns the parent\n            }\n            current = current.left;\n        } else if (key > current.data) {\n            if (current.right == null) {\n                return current;\n            }\n            current = current.right;\n        } else { // If you find the value return it\n            return current;\n        }\n    }\n    return null;\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "BinaryTree",
        "method_name": "find",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\nArrayList<E> topSortOrder() {\n    calculateInDegree();\n    Queue<E> q = new LinkedList<E>();\n\n    for (E vertex : inDegree.keySet()) {\n        if (inDegree.get(vertex) == 0) {\n            q.add(vertex);\n        }\n    }\n\n    ArrayList<E> answer = new ArrayList<>();\n\n    while (!q.isEmpty()) {\n        E current = q.poll();\n        answer.add(current);\n        for (E adjacent : graph.getAdjacents(current)) {\n            inDegree.put(adjacent, inDegree.get(adjacent) - 1);\n            if (inDegree.get(adjacent) == 0) {\n                q.add(adjacent);\n            }\n        }\n    }\n\n    return answer;\n}\n",
        "package": "com.thealgorithms.datastructures.graphs",
        "class_name": "AdjacencyList",
        "method_name": "topSortOrder",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic String decode(String encryptedMessage, int shift) {\n    StringBuilder decoded = new StringBuilder();\n\n    shift %= 26;\n\n    final int length = encryptedMessage.length();\n    for (int i = 0; i < length; i++) {\n        char current = encryptedMessage.charAt(i);\n        if (isCapitalLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'A' ? current + 26 : current)); // 26 = number of latin letters\n        } else if (isSmallLatinLetter(current)) {\n            current -= shift;\n            decoded.append((char) (current < 'a' ? current + 26 : current)); // 26 = number of latin letters\n        } else {\n            decoded.append(current);\n        }\n    }\n    return decoded.toString();\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "Caesar",
        "method_name": "decode",
        "SourceCode&Full": [
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\nstatic int getTwinPrime(int inputNumber) {\n\n    // if inputNumber and (inputNumber + 2) are both prime\n    // then return (inputNumber + 2) as a result\n    if (PrimeCheck.isPrime(inputNumber) && PrimeCheck.isPrime(inputNumber + 2)) {\n        return inputNumber + 2;\n    }\n    // if any one from inputNumber and (inputNumber + 2) or if both of them are not prime\n    // then return -1 as a result\n    return -1;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "TwinPrime",
        "method_name": "getTwinPrime",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "// Determinant calculator\npublic static int determinant(int[][] a, int n) {\n    int det = 0, sign = 1, p = 0, q = 0;\n\n    if (n == 1) {\n        det = a[0][0];\n    } else {\n        int[][] b = new int[n - 1][n - 1];\n        for (int x = 0; x < n; x++) {\n            p = 0;\n            q = 0;\n            for (int i = 1; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (j != x) {\n                        b[p][q++] = a[i][j];\n                        if (q % (n - 1) == 0) {\n                            p++;\n                            q = 0;\n                        }\n                    }\n                }\n            }\n            det = det + a[0][x] * determinant(b, n - 1) * sign;\n            sign = -sign;\n        }\n    }\n    return det;\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "HillCipher",
        "method_name": "determinant",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp.data != value) {\n        return false;\n    }\n\n    // No children\n    if (temp.right == null && temp.left == null) {\n        if (temp == root) {\n            root = null;\n        } // This if/else assigns the new node to be either the left or right child of the\n          // parent\n        else if (temp.parent.data < temp.data) {\n            temp.parent.right = null;\n        } else {\n            temp.parent.left = null;\n        }\n        return true;\n    } // Two children\n    else if (temp.left != null && temp.right != null) {\n        Node successor = findSuccessor(temp);\n\n        // The left tree of temp is made the left tree of the successor\n        successor.left = temp.left;\n        successor.left.parent = successor;\n\n        // If the successor has a right child, the child's grandparent is it's new parent\n        if (successor.parent != temp) {\n            if (successor.right != null) {\n                successor.right.parent = successor.parent;\n                successor.parent.left = successor.right;\n            } else {\n                successor.parent.left = null;\n            }\n            successor.right = temp.right;\n            successor.right.parent = successor;\n        }\n\n        if (temp == root) {\n            successor.parent = null;\n            root = successor;\n        } // If you're not deleting the root\n        else {\n            successor.parent = temp.parent;\n\n            // This if/else assigns the new node to be either the left or right child of the\n            // parent\n            if (temp.parent.data < temp.data) {\n                temp.parent.right = successor;\n            } else {\n                temp.parent.left = successor;\n            }\n        }\n        return true;\n    } // One child\n    else {\n        // If it has a right child\n        if (temp.right != null) {\n            if (temp == root) {\n                root = temp.right;\n                return true;\n            }\n\n            temp.right.parent = temp.parent;\n\n            // Assigns temp to left or right child\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.right;\n            } else {\n                temp.parent.right = temp.right;\n            }\n        } // If it has a left child\n        else {\n            if (temp == root) {\n                root = temp.left;\n                return true;\n            }\n\n            temp.left.parent = temp.parent;\n\n            // Assigns temp to left or right side\n            if (temp.data < temp.parent.data) {\n                temp.parent.left = temp.left;\n            } else {\n                temp.parent.right = temp.left;\n            }\n        }\n        return true;\n    }\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "BinaryTree",
        "method_name": "remove",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int findMax(final int[] array) {\n    int n = array.length;\n    if (n == 0) {\n        throw new IllegalArgumentException(\"Array must be non-empty.\");\n    }\n    int max = array[0];\n    for (int i = 1; i < n; i++) {\n        if (array[i] > max) {\n            max = array[i];\n        }\n    }\n    return max;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "FindMax",
        "method_name": "findMax",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Accept"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic Node middle() {\n    if (head == null) {\n        return null;\n    }\n    Node firstCounter = head;\n    Node secondCounter = firstCounter.next;\n    while (secondCounter != null && secondCounter.next != null) {\n        firstCounter = firstCounter.next;\n        secondCounter = secondCounter.next.next;\n    }\n    return firstCounter;\n}\n",
        "package": "com.thealgorithms.datastructures.lists",
        "class_name": "SinglyLinkedList",
        "method_name": "middle",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic boolean isArmstrong(int number) {\n    long sum = 0;\n    String temp = Integer.toString(number); // Convert the given number to a string\n    int power = temp.length(); // Extract the length of the number (number of digits)\n    long originalNumber = number;\n\n    while (originalNumber > 0) {\n        long digit = originalNumber % 10;\n        sum += (long) Math.pow(digit, power); // The digit raised to the power of the number of digits and added to the sum.\n        originalNumber /= 10;\n    }\n\n    return sum == number;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "Armstrong",
        "method_name": "isArmstrong",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Accept",
            "Test Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic int peek() {\n    if (isEmpty()) {\n        throw new EmptyStackException();\n    }\n    return stack.get(stack.size() - 1);\n}\n",
        "package": "com.thealgorithms.datastructures.stacks",
        "class_name": "StackArrayList",
        "method_name": "peek",
        "SourceCode&Full": [
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "/* A function to get the sum of the elements from index l to index r. This will be called\n * internally*/\nprivate int getSumTree(int start, int end, int q_start, int q_end, int seg_index) {\n    if (q_start <= start && q_end >= end) {\n        return this.seg_t[seg_index];\n    }\n\n    if (q_start > end || q_end < start) {\n        return 0;\n    }\n\n    int mid = start + (end - start) / 2;\n    return (getSumTree(start, mid, q_start, q_end, seg_index * 2 + 1) + getSumTree(mid + 1, end, q_start, q_end, seg_index * 2 + 2));\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "SegmentTree",
        "method_name": "getSumTree",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "/*\n * @brief Swaps the bits at the position posA and posB from data\n */\npublic static int bitSwap(int data, final int posA, final int posB) {\n    if (SingleBitOperations.getBit(data, posA) != SingleBitOperations.getBit(data, posB)) {\n        data ^= (1 << posA) ^ (1 << posB);\n    }\n    return data;\n}\n",
        "package": "com.thealgorithms.bitmanipulation",
        "class_name": "BitSwap",
        "method_name": "bitSwap",
        "SourceCode&Full": [
            "Test Error",
            "Test Error",
            "Accept",
            "Accept",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int calculateHammingDistance(String s1, String s2) throws Exception {\n    if (s1.length() != s2.length()) {\n        throw new Exception(\"String lengths must be equal\");\n    }\n\n    int stringLength = s1.length();\n    int counter = 0;\n\n    for (int i = 0; i < stringLength; i++) {\n        if (s1.charAt(i) != s2.charAt(i)) {\n            counter++;\n        }\n    }\n    return counter;\n}\n",
        "package": "com.thealgorithms.strings",
        "class_name": "HammingDistance",
        "method_name": "calculateHammingDistance",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String encode(String message, String cipherSmall) {\n    StringBuilder encoded = new StringBuilder();\n\n    // This map is used to encode\n    Map<Character, Character> cipherMap = new HashMap<>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    // To handle Small and Capital letters\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n        cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n    }\n\n    for (int i = 0; i < message.length(); i++) {\n        if (Character.isAlphabetic(message.charAt(i))) {\n            encoded.append(cipherMap.get(message.charAt(i)));\n        } else {\n            encoded.append(message.charAt(i));\n        }\n    }\n\n    return encoded.toString();\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "SimpleSubstitutionCipher",
        "method_name": "encode",
        "SourceCode&Full": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic void push(Item item) {\n    NodeStack<Item> newNs = new NodeStack<Item>(item);\n\n    if (this.isEmpty()) {\n        NodeStack.setHead(new NodeStack<>(item));\n        newNs.setNext(null);\n        newNs.setPrevious(null);\n    } else {\n        newNs.setPrevious(NodeStack.head);\n        NodeStack.head.setNext(newNs);\n        NodeStack.setHead(newNs);\n    }\n\n    NodeStack.setSize(NodeStack.getSize() + 1);\n}\n",
        "package": "com.thealgorithms.datastructures.stacks",
        "class_name": "NodeStack",
        "method_name": "push",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static int getMaxValue(int... numbers) {\n    if (numbers == null || numbers.length == 0) {\n        throw new IllegalArgumentException(\"Numbers array cannot be empty or null\");\n    }\n    int absMax = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (Math.abs(numbers[i]) > Math.abs(absMax)) {\n            absMax = numbers[i];\n        }\n    }\n    return absMax;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "AbsoluteMax",
        "method_name": "getMaxValue",
        "SourceCode&Full": [
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Accept",
            "Test Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String decode(String encryptedMessage, String cipherSmall) {\n    StringBuilder decoded = new StringBuilder();\n\n    Map<Character, Character> cipherMap = new HashMap<>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    for (int i = 0; i < cipherSmall.length(); i++) {\n        cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n        cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n    }\n\n    for (int i = 0; i < encryptedMessage.length(); i++) {\n        if (Character.isAlphabetic(encryptedMessage.charAt(i))) {\n            decoded.append(cipherMap.get(encryptedMessage.charAt(i)));\n        } else {\n            decoded.append(encryptedMessage.charAt(i));\n        }\n    }\n\n    return decoded.toString();\n}\n",
        "package": "com.thealgorithms.ciphers",
        "class_name": "SimpleSubstitutionCipher",
        "method_name": "decode",
        "SourceCode&Full": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Accept",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic HeapNode insert(int key) {\n    HeapNode toInsert = new HeapNode(key); // creates the node\n    if (this.empty()) {\n        this.min = toInsert;\n    } else { // tree is not empty\n        min.setNext(toInsert);\n        this.updateMin(toInsert);\n    }\n    this.numOfHeapNodes++;\n    this.numOfTrees++;\n    return toInsert;\n}\n",
        "package": "com.thealgorithms.datastructures.heaps",
        "class_name": "FibonacciHeap",
        "method_name": "insert",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "private Node rotateLeft(Node a) {\n    Node b = a.right;\n    b.parent = a.parent;\n\n    a.right = b.left;\n\n    if (a.right != null) {\n        a.right.parent = a;\n    }\n\n    b.left = a;\n    a.parent = b;\n\n    if (b.parent != null) {\n        if (b.parent.right == a) {\n            b.parent.right = b;\n        } else {\n            b.parent.left = b;\n        }\n    }\n\n    setBalance(a, b);\n\n    return b;\n}\n",
        "package": "com.thealgorithms.datastructures.trees",
        "class_name": "AVLTree",
        "method_name": "rotateLeft",
        "SourceCode&Full": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static String toLowerCase(String s) {\n    char[] values = s.toCharArray();\n    for (int i = 0; i < values.length; ++i) {\n        if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n            values[i] = Character.toLowerCase(values[i]);\n        }\n    }\n    return new String(values);\n}\n",
        "package": "com.thealgorithms.strings",
        "class_name": "Lower",
        "method_name": "toLowerCase",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic int countGraphs() {\n    int count = 0;\n    Set<Node> markedNodes = new HashSet<Node>();\n\n    for (Node n : nodeList) {\n        if (!markedNodes.contains(n)) {\n            markedNodes.add(n);\n            markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\n            count++;\n        }\n    }\n\n    return count;\n}\n",
        "package": "com.thealgorithms.datastructures.graphs",
        "class_name": "Graph",
        "method_name": "countGraphs",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Accept",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static void floodFill(final int[][] image, final int x, final int y, final int newColor, final int oldColor) {\n    if (newColor == oldColor || x < 0 || x >= image.length || y < 0 || y >= image[x].length || getPixel(image, x, y) != oldColor) {\n        return;\n    }\n\n    putPixel(image, x, y, newColor);\n\n    /* Recursively check for horizontally & vertically adjacent coordinates */\n    floodFill(image, x + 1, y, newColor, oldColor);\n    floodFill(image, x - 1, y, newColor, oldColor);\n    floodFill(image, x, y + 1, newColor, oldColor);\n    floodFill(image, x, y - 1, newColor, oldColor);\n\n    /* Recursively check for diagonally adjacent coordinates  */\n    floodFill(image, x + 1, y - 1, newColor, oldColor);\n    floodFill(image, x - 1, y + 1, newColor, oldColor);\n    floodFill(image, x + 1, y + 1, newColor, oldColor);\n    floodFill(image, x - 1, y - 1, newColor, oldColor);\n}\n",
        "package": "com.thealgorithms.backtracking",
        "class_name": "FloodFill",
        "method_name": "floodFill",
        "SourceCode&Full": [
            "Test Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic double process(double sample) {\n    double result = 0.0;\n\n    // Process\n    for (int i = 1; i <= order; i++) {\n        result += (coeffsB[i] * historyX[i - 1] - coeffsA[i] * historyY[i - 1]);\n    }\n    result = (result + coeffsB[0] * sample) / coeffsA[0];\n\n    // Feedback\n    for (int i = order - 1; i > 0; i--) {\n        historyX[i] = historyX[i - 1];\n        historyY[i] = historyY[i - 1];\n    }\n\n    historyX[0] = sample;\n    historyY[0] = result;\n\n    return result;\n}\n",
        "package": "com.thealgorithms.audiofilters",
        "class_name": "IIRFilter",
        "method_name": "process",
        "SourceCode&Full": [
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\n@Override\npublic <T extends Comparable<T>> T[] sort(T[] array) {\n    doSort(array, 0, array.length - 1);\n    return array;\n}\n",
        "package": "com.thealgorithms.sorts",
        "class_name": "QuickSort",
        "method_name": "sort",
        "SourceCode&Full": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Accept",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error"
        ]
    },
    {
        "project_name": "Java",
        "code": "\npublic static ArrayList<Complex> fft(ArrayList<Complex> x, boolean inverse) {\n    /* Pad the signal with zeros if necessary */\n    paddingPowerOfTwo(x);\n    int N = x.size();\n    int log2N = findLog2(N);\n    x = fftBitReversal(N, log2N, x);\n    int direction = inverse ? -1 : 1;\n\n    /* Main loop of the algorithm */\n    for (int len = 2; len <= N; len *= 2) {\n        double angle = -2 * Math.PI / len * direction;\n        Complex wlen = new Complex(Math.cos(angle), Math.sin(angle));\n        for (int i = 0; i < N; i += len) {\n            Complex w = new Complex(1, 0);\n            for (int j = 0; j < len / 2; j++) {\n                Complex u = x.get(i + j);\n                Complex v = w.multiply(x.get(i + j + len / 2));\n                x.set(i + j, u.add(v));\n                x.set(i + j + len / 2, u.subtract(v));\n                w = w.multiply(wlen);\n            }\n        }\n    }\n    x = inverseFFT(N, inverse, x);\n    return x;\n}\n",
        "package": "com.thealgorithms.maths",
        "class_name": "FFT",
        "method_name": "fft",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ]
    }
]