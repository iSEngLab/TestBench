[
    {
        "project_name": "zxing",
        "code": "\npublic static int getCodeword(int symbol) {\n  int i = Arrays.binarySearch(SYMBOL_TABLE, symbol & 0x3FFFF);\n  if (i < 0) {\n    return -1;\n  }\n  return (CODEWORD_TABLE[i] - 1) % NUMBER_OF_CODEWORDS;\n}\n",
        "package": "com.google.zxing.pdf417",
        "class_name": "PDF417Common",
        "method_name": "getCodeword",
        "SourceCode&Full": [
            "Compile Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic AztecDetectorResult detect(boolean isMirror) throws NotFoundException {\n\n  // 1. Get the center of the aztec matrix\n  Point pCenter = getMatrixCenter();\n\n  // 2. Get the center points of the four diagonal points just outside the bull's eye\n  //  [topRight, bottomRight, bottomLeft, topLeft]\n  ResultPoint[] bullsEyeCorners = getBullsEyeCorners(pCenter);\n\n  if (isMirror) {\n    ResultPoint temp = bullsEyeCorners[0];\n    bullsEyeCorners[0] = bullsEyeCorners[2];\n    bullsEyeCorners[2] = temp;\n  }\n\n  // 3. Get the size of the matrix and other parameters from the bull's eye\n  int errorsCorrected = extractParameters(bullsEyeCorners);\n\n  // 4. Sample the grid\n  BitMatrix bits = sampleGrid(image,\n                              bullsEyeCorners[shift % 4],\n                              bullsEyeCorners[(shift + 1) % 4],\n                              bullsEyeCorners[(shift + 2) % 4],\n                              bullsEyeCorners[(shift + 3) % 4]);\n\n  // 5. Get the corners of the matrix.\n  ResultPoint[] corners = getMatrixCornerPoints(bullsEyeCorners);\n\n  return new AztecDetectorResult(bits, corners, compact, nbDataBlocks, nbLayers, errorsCorrected);\n}\n",
        "package": "com.google.zxing.aztec.detector",
        "class_name": "Detector",
        "method_name": "detect",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate Point getMatrixCenter() {\n\n  ResultPoint pointA;\n  ResultPoint pointB;\n  ResultPoint pointC;\n  ResultPoint pointD;\n\n  //Get a white rectangle that can be the border of the matrix in center bull's eye or\n  try {\n\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n\n  } catch (NotFoundException e) {\n\n    // This exception can be in case the initial rectangle is white\n    // In that case, surely in the bull's eye, we try to expand the rectangle.\n    int cx = image.getWidth() / 2;\n    int cy = image.getHeight() / 2;\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n\n  }\n\n  //Compute the center of the rectangle\n  int cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  int cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n\n  // Redetermine the white rectangle starting from previously computed center.\n  // This will ensure that we end up with a white rectangle in center bull's eye\n  // in order to compute a more accurate center.\n  try {\n    ResultPoint[] cornerPoints = new WhiteRectangleDetector(image, 15, cx, cy).detect();\n    pointA = cornerPoints[0];\n    pointB = cornerPoints[1];\n    pointC = cornerPoints[2];\n    pointD = cornerPoints[3];\n  } catch (NotFoundException e) {\n    // This exception can be in case the initial rectangle is white\n    // In that case we try to expand the rectangle.\n    pointA = getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();\n    pointB = getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();\n    pointC = getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();\n    pointD = getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();\n  }\n\n  // Recompute the center of the rectangle\n  cx = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0f);\n  cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0f);\n\n  return new Point(cx, cy);\n}\n",
        "package": "com.google.zxing.aztec.detector",
        "class_name": "Detector",
        "method_name": "getMatrixCenter",
        "SourceCode&Full": [
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic int getNextSet(int from) {\n  if (from >= size) {\n    return size;\n  }\n  int bitsOffset = from / 32;\n  int currentBits = bits[bitsOffset];\n  // mask off lesser bits first\n  currentBits &= -(1 << (from & 0x1F));\n  while (currentBits == 0) {\n    if (++bitsOffset == bits.length) {\n      return size;\n    }\n    currentBits = bits[bitsOffset];\n  }\n  int result = (bitsOffset * 32) + Integer.numberOfTrailingZeros(currentBits);\n  return Math.min(result, size);\n}\n",
        "package": "com.google.zxing.common",
        "class_name": "BitArray",
        "method_name": "getNextSet",
        "SourceCode&Full": [
            "Test Error",
            "Test Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Test Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Test Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Test Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "@Override\npublic boolean equals(Object o) {\n  if (!(o instanceof FinderPattern)) {\n    return false;\n  }\n  FinderPattern that = (FinderPattern) o;\n  return value == that.value;\n}\n",
        "package": "com.google.zxing.oned.rss",
        "class_name": "FinderPattern",
        "method_name": "equals",
        "SourceCode&Full": [
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Test Error",
            "Accept",
            "Accept",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Accept",
            "Test Error",
            "Accept"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "// Create a new state representing this state, but an additional character\n// output in Binary Shift mode.\nState addBinaryShiftChar(int index) {\n  Token token = this.token;\n  int mode = this.mode;\n  int bitCount = this.bitCount;\n  if (this.mode == HighLevelEncoder.MODE_PUNCT || this.mode == HighLevelEncoder.MODE_DIGIT) {\n    int latch = HighLevelEncoder.LATCH_TABLE[mode][HighLevelEncoder.MODE_UPPER];\n    token = token.add(latch & 0xFFFF, latch >> 16);\n    bitCount += latch >> 16;\n    mode = HighLevelEncoder.MODE_UPPER;\n  }\n  int deltaBitCount =\n      (binaryShiftByteCount == 0 || binaryShiftByteCount == 31) ? 18 :\n      (binaryShiftByteCount == 62) ? 9 : 8;\n  State result = new State(token, mode, binaryShiftByteCount + 1, bitCount + deltaBitCount);\n  if (result.binaryShiftByteCount == 2047 + 31) {\n    // The string is as long as it's allowed to be.  We should end it.\n    result = result.endBinaryShift(index + 1);\n  }\n  return result;\n}\n",
        "package": "com.google.zxing.aztec.encoder",
        "class_name": "State",
        "method_name": "addBinaryShiftChar",
        "SourceCode&Full": [
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Accept",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic static float distance(int aX, int aY, int bX, int bY) {\n  double xDiff = aX - bX;\n  double yDiff = aY - bY;\n  return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);\n}\n",
        "package": "com.google.zxing.common.detector",
        "class_name": "MathUtils",
        "method_name": "distance",
        "SourceCode&Full": [
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Accept",
            "Accept",
            "Test Error",
            "Accept",
            "Accept"
        ],
        "SourceCode&Simple": [
            "Accept",
            "Accept",
            "Accept",
            "Test Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate static void calculateThresholdForBlock(byte[] luminances,\n                                               int subWidth,\n                                               int subHeight,\n                                               int width,\n                                               int height,\n                                               int[][] blackPoints,\n                                               BitMatrix matrix) {\n  int maxYOffset = height - BLOCK_SIZE;\n  int maxXOffset = width - BLOCK_SIZE;\n  for (int y = 0; y < subHeight; y++) {\n    int yoffset = y << BLOCK_SIZE_POWER;\n    if (yoffset > maxYOffset) {\n      yoffset = maxYOffset;\n    }\n    int top = cap(y, subHeight - 3);\n    for (int x = 0; x < subWidth; x++) {\n      int xoffset = x << BLOCK_SIZE_POWER;\n      if (xoffset > maxXOffset) {\n        xoffset = maxXOffset;\n      }\n      int left = cap(x, subWidth - 3);\n      int sum = 0;\n      for (int z = -2; z <= 2; z++) {\n        int[] blackRow = blackPoints[top + z];\n        sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];\n      }\n      int average = sum / 25;\n      thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);\n    }\n  }\n}\n",
        "package": "com.google.zxing.common",
        "class_name": "HybridBinarizer",
        "method_name": "calculateThresholdForBlock",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Accept",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Accept"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic int decodeWithECCount(int[] received, int twoS) throws ReedSolomonException {\n  GenericGFPoly poly = new GenericGFPoly(field, received);\n  int[] syndromeCoefficients = new int[twoS];\n  boolean noError = true;\n  for (int i = 0; i < twoS; i++) {\n    int eval = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));\n    syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;\n    if (eval != 0) {\n      noError = false;\n    }\n  }\n  if (noError) {\n    return 0;\n  }\n  GenericGFPoly syndrome = new GenericGFPoly(field, syndromeCoefficients);\n  GenericGFPoly[] sigmaOmega =\n      runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);\n  GenericGFPoly sigma = sigmaOmega[0];\n  GenericGFPoly omega = sigmaOmega[1];\n  int[] errorLocations = findErrorLocations(sigma);\n  int[] errorMagnitudes = findErrorMagnitudes(omega, errorLocations);\n  for (int i = 0; i < errorLocations.length; i++) {\n    int position = received.length - 1 - field.log(errorLocations[i]);\n    if (position < 0) {\n      throw new ReedSolomonException(\"Bad error location\");\n    }\n    received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i]);\n  }\n  return errorLocations.length;\n}\n",
        "package": "com.google.zxing.common.reedsolomon",
        "class_name": "ReedSolomonDecoder",
        "method_name": "decodeWithECCount",
        "SourceCode&Full": [
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Syntax Error"
        ],
        "SourceCodeOnly": [
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Syntax Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic ResultPoint[] detect() throws NotFoundException {\n\n  int left = leftInit;\n  int right = rightInit;\n  int up = upInit;\n  int down = downInit;\n  boolean sizeExceeded = false;\n  boolean aBlackPointFoundOnBorder = true;\n\n  boolean atLeastOneBlackPointFoundOnRight = false;\n  boolean atLeastOneBlackPointFoundOnBottom = false;\n  boolean atLeastOneBlackPointFoundOnLeft = false;\n  boolean atLeastOneBlackPointFoundOnTop = false;\n\n  while (aBlackPointFoundOnBorder) {\n\n    aBlackPointFoundOnBorder = false;\n\n    // .....\n    // .   |\n    // .....\n    boolean rightBorderNotWhite = true;\n    while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {\n      rightBorderNotWhite = containsBlackPoint(up, down, right, false);\n      if (rightBorderNotWhite) {\n        right++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnRight = true;\n      } else if (!atLeastOneBlackPointFoundOnRight) {\n        right++;\n      }\n    }\n\n    if (right >= width) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .....\n    // .   .\n    // .___.\n    boolean bottomBorderNotWhite = true;\n    while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {\n      bottomBorderNotWhite = containsBlackPoint(left, right, down, true);\n      if (bottomBorderNotWhite) {\n        down++;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnBottom = true;\n      } else if (!atLeastOneBlackPointFoundOnBottom) {\n        down++;\n      }\n    }\n\n    if (down >= height) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .....\n    // |   .\n    // .....\n    boolean leftBorderNotWhite = true;\n    while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {\n      leftBorderNotWhite = containsBlackPoint(up, down, left, false);\n      if (leftBorderNotWhite) {\n        left--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnLeft = true;\n      } else if (!atLeastOneBlackPointFoundOnLeft) {\n        left--;\n      }\n    }\n\n    if (left < 0) {\n      sizeExceeded = true;\n      break;\n    }\n\n    // .___.\n    // .   .\n    // .....\n    boolean topBorderNotWhite = true;\n    while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {\n      topBorderNotWhite = containsBlackPoint(left, right, up, true);\n      if (topBorderNotWhite) {\n        up--;\n        aBlackPointFoundOnBorder = true;\n        atLeastOneBlackPointFoundOnTop = true;\n      } else if (!atLeastOneBlackPointFoundOnTop) {\n        up--;\n      }\n    }\n\n    if (up < 0) {\n      sizeExceeded = true;\n      break;\n    }\n\n  }\n\n  if (!sizeExceeded) {\n\n    int maxSize = right - left;\n\n    ResultPoint z = null;\n    for (int i = 1; z == null && i < maxSize; i++) {\n      z = getBlackPointOnSegment(left, down - i, left + i, down);\n    }\n\n    if (z == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint t = null;\n    //go down right\n    for (int i = 1; t == null && i < maxSize; i++) {\n      t = getBlackPointOnSegment(left, up + i, left + i, up);\n    }\n\n    if (t == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint x = null;\n    //go down left\n    for (int i = 1; x == null && i < maxSize; i++) {\n      x = getBlackPointOnSegment(right, up + i, right - i, up);\n    }\n\n    if (x == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    ResultPoint y = null;\n    //go up left\n    for (int i = 1; y == null && i < maxSize; i++) {\n      y = getBlackPointOnSegment(right, down - i, right - i, down);\n    }\n\n    if (y == null) {\n      throw NotFoundException.getNotFoundInstance();\n    }\n\n    return centerEdges(y, z, x, t);\n\n  } else {\n    throw NotFoundException.getNotFoundInstance();\n  }\n}\n",
        "package": "com.google.zxing.common.detector",
        "class_name": "WhiteRectangleDetector",
        "method_name": "detect",
        "SourceCode&Full": [
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Accept",
            "Test Error",
            "Test Error",
            "Test Error",
            "Test Error",
            "Compile Error",
            "Syntax Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate static String getCharacter(Table table, int code) {\n  switch (table) {\n    case UPPER:\n      return UPPER_TABLE[code];\n    case LOWER:\n      return LOWER_TABLE[code];\n    case MIXED:\n      return MIXED_TABLE[code];\n    case PUNCT:\n      return PUNCT_TABLE[code];\n    case DIGIT:\n      return DIGIT_TABLE[code];\n    default:\n      // Should not reach here.\n      throw new IllegalStateException(\"Bad table\");\n  }\n}\n",
        "package": "com.google.zxing.aztec.decoder",
        "class_name": "Decoder",
        "method_name": "getCharacter",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Test Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Test Error",
            "Syntax Error",
            "Test Error",
            "Test Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\nprivate static String getEncodedData(boolean[] correctedBits) throws FormatException {\n  int endIndex = correctedBits.length;\n  Table latchTable = Table.UPPER; // table most recently latched to\n  Table shiftTable = Table.UPPER; // table to use for the next read\n\n  // Final decoded string result\n  // (correctedBits-5) / 4 is an upper bound on the size (all-digit result)\n  StringBuilder result = new StringBuilder((correctedBits.length - 5) / 4);\n\n  // Intermediary buffer of decoded bytes, which is decoded into a string and flushed\n  // when character encoding changes (ECI) or input ends.\n  ByteArrayOutputStream decodedBytes = new ByteArrayOutputStream();\n  Charset encoding = DEFAULT_ENCODING;\n\n  int index = 0;\n  while (index < endIndex) {\n    if (shiftTable == Table.BINARY) {\n      if (endIndex - index < 5) {\n        break;\n      }\n      int length = readCode(correctedBits, index, 5);\n      index += 5;\n      if (length == 0) {\n        if (endIndex - index < 11) {\n          break;\n        }\n        length = readCode(correctedBits, index, 11) + 31;\n        index += 11;\n      }\n      for (int charCount = 0; charCount < length; charCount++) {\n        if (endIndex - index < 8) {\n          index = endIndex;  // Force outer loop to exit\n          break;\n        }\n        int code = readCode(correctedBits, index, 8);\n        decodedBytes.write((byte) code);\n        index += 8;\n      }\n      // Go back to whatever mode we had been in\n      shiftTable = latchTable;\n    } else {\n      int size = shiftTable == Table.DIGIT ? 4 : 5;\n      if (endIndex - index < size) {\n        break;\n      }\n      int code = readCode(correctedBits, index, size);\n      index += size;\n      String str = getCharacter(shiftTable, code);\n      if (\"FLG(n)\".equals(str)) {\n        if (endIndex - index < 3) {\n          break;\n        }\n        int n = readCode(correctedBits, index, 3);\n        index += 3;\n        //  flush bytes, FLG changes state\n        try {\n          result.append(decodedBytes.toString(encoding.name()));\n        } catch (UnsupportedEncodingException uee) {\n          throw new IllegalStateException(uee);\n        }\n        decodedBytes.reset();\n        switch (n) {\n          case 0:\n            result.append((char) 29);  // translate FNC1 as ASCII 29\n            break;\n          case 7:\n            throw FormatException.getFormatInstance(); // FLG(7) is reserved and illegal\n          default:\n            // ECI is decimal integer encoded as 1-6 codes in DIGIT mode\n            int eci = 0;\n            if (endIndex - index < 4 * n) {\n              break;\n            }\n            while (n-- > 0) {\n              int nextDigit = readCode(correctedBits, index, 4);\n              index += 4;\n              if (nextDigit < 2 || nextDigit > 11) {\n                throw FormatException.getFormatInstance(); // Not a decimal digit\n              }\n              eci = eci * 10 + (nextDigit - 2);\n            }\n            CharacterSetECI charsetECI = CharacterSetECI.getCharacterSetECIByValue(eci);\n            if (charsetECI == null) {\n              throw FormatException.getFormatInstance();\n            }\n            encoding = charsetECI.getCharset();\n        }\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      } else if (str.startsWith(\"CTRL_\")) {\n        // Table changes\n        // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.\n        // That's including when that mode is a shift.\n        // Our test case dlusbs.png for issue #642 exercises that.\n        latchTable = shiftTable;  // Latch the current mode, so as to return to Upper after U/S B/S\n        shiftTable = getTable(str.charAt(5));\n        if (str.charAt(6) == 'L') {\n          latchTable = shiftTable;\n        }\n      } else {\n        // Though stored as a table of strings for convenience, codes actually represent 1 or 2 *bytes*.\n        byte[] b = str.getBytes(StandardCharsets.US_ASCII);\n        decodedBytes.write(b, 0, b.length);\n        // Go back to whatever mode we had been in\n        shiftTable = latchTable;\n      }\n    }\n  }\n  try {\n    result.append(decodedBytes.toString(encoding.name()));\n  } catch (UnsupportedEncodingException uee) {\n    // can't happen\n    throw new IllegalStateException(uee);\n  }\n  return result.toString();\n}\n",
        "package": "com.google.zxing.aztec.decoder",
        "class_name": "Decoder",
        "method_name": "getEncodedData",
        "SourceCode&Full": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Syntax Error",
            "Test Error",
            "Compile Error",
            "Test Error",
            "Test Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Syntax Error",
            "Syntax Error",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Syntax Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    },
    {
        "project_name": "zxing",
        "code": "\npublic static AztecCode encode(String data, int minECCPercent, int userSpecifiedLayers, Charset charset) {\n  byte[] bytes = data.getBytes(null != charset ? charset : StandardCharsets.ISO_8859_1);\n  return encode(bytes, minECCPercent, userSpecifiedLayers, charset);\n}\n",
        "package": "com.google.zxing.aztec.encoder",
        "class_name": "Encoder",
        "method_name": "encode",
        "SourceCode&Full": [
            "Test Error",
            "Accept",
            "Test Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ],
        "SourceCode&Simple": [
            "Compile Error",
            "Accept",
            "Accept",
            "Compile Error",
            "Accept",
            "Test Error",
            "Accept",
            "Compile Error",
            "Accept",
            "Compile Error"
        ],
        "SourceCodeOnly": [
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Test Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error",
            "Compile Error"
        ]
    }
]